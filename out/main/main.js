"use strict";
const electron = require("electron");
const path$4 = require("path");
const require$$0$3 = require("tty");
const require$$1$1 = require("util");
const require$$3$1 = require("fs");
const require$$4$1 = require("net");
const require$$0$4 = require("events");
const stream = require("stream");
const zlib = require("zlib");
const require$$0$5 = require("buffer");
const require$$1$2 = require("string_decoder");
const require$$8 = require("querystring");
const require$$0$6 = require("url");
const require$$0$7 = require("http");
const require$$0$8 = require("crypto");
const require$$4$2 = require("https");
const require$$4$3 = require("assert");
const require$$0$9 = require("os");
function _interopNamespaceDefault(e) {
  const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e) {
    for (const k2 in e) {
      if (k2 !== "default") {
        const d2 = Object.getOwnPropertyDescriptor(e, k2);
        Object.defineProperty(n, k2, d2.get ? d2 : {
          enumerable: true,
          get: () => e[k2]
        });
      }
    }
  }
  n.default = e;
  return Object.freeze(n);
}
const path__namespace = /* @__PURE__ */ _interopNamespaceDefault(path$4);
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
var express$2 = { exports: {} };
var bodyParser = { exports: {} };
/*!
 * depd
 * Copyright(c) 2014-2018 Douglas Christopher Wilson
 * MIT Licensed
 */
var relative = path$4.relative;
var depd_1 = depd;
var basePath = process.cwd();
function containsNamespace(str, namespace) {
  var vals = str.split(/[ ,]+/);
  var ns = String(namespace).toLowerCase();
  for (var i = 0; i < vals.length; i++) {
    var val = vals[i];
    if (val && (val === "*" || val.toLowerCase() === ns)) {
      return true;
    }
  }
  return false;
}
function convertDataDescriptorToAccessor(obj, prop, message) {
  var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
  var value = descriptor.value;
  descriptor.get = function getter() {
    return value;
  };
  if (descriptor.writable) {
    descriptor.set = function setter(val) {
      return value = val;
    };
  }
  delete descriptor.value;
  delete descriptor.writable;
  Object.defineProperty(obj, prop, descriptor);
  return descriptor;
}
function createArgumentsString(arity) {
  var str = "";
  for (var i = 0; i < arity; i++) {
    str += ", arg" + i;
  }
  return str.substr(2);
}
function createStackString(stack) {
  var str = this.name + ": " + this.namespace;
  if (this.message) {
    str += " deprecated " + this.message;
  }
  for (var i = 0; i < stack.length; i++) {
    str += "\n    at " + stack[i].toString();
  }
  return str;
}
function depd(namespace) {
  if (!namespace) {
    throw new TypeError("argument namespace is required");
  }
  var stack = getStack();
  var site = callSiteLocation(stack[1]);
  var file = site[0];
  function deprecate2(message) {
    log.call(deprecate2, message);
  }
  deprecate2._file = file;
  deprecate2._ignored = isignored(namespace);
  deprecate2._namespace = namespace;
  deprecate2._traced = istraced(namespace);
  deprecate2._warned = /* @__PURE__ */ Object.create(null);
  deprecate2.function = wrapfunction;
  deprecate2.property = wrapproperty;
  return deprecate2;
}
function eehaslisteners(emitter, type3) {
  var count = typeof emitter.listenerCount !== "function" ? emitter.listeners(type3).length : emitter.listenerCount(type3);
  return count > 0;
}
function isignored(namespace) {
  if (process.noDeprecation) {
    return true;
  }
  var str = process.env.NO_DEPRECATION || "";
  return containsNamespace(str, namespace);
}
function istraced(namespace) {
  if (process.traceDeprecation) {
    return true;
  }
  var str = process.env.TRACE_DEPRECATION || "";
  return containsNamespace(str, namespace);
}
function log(message, site) {
  var haslisteners = eehaslisteners(process, "deprecation");
  if (!haslisteners && this._ignored) {
    return;
  }
  var caller;
  var callFile;
  var callSite;
  var depSite;
  var i = 0;
  var seen = false;
  var stack = getStack();
  var file = this._file;
  if (site) {
    depSite = site;
    callSite = callSiteLocation(stack[1]);
    callSite.name = depSite.name;
    file = callSite[0];
  } else {
    i = 2;
    depSite = callSiteLocation(stack[i]);
    callSite = depSite;
  }
  for (; i < stack.length; i++) {
    caller = callSiteLocation(stack[i]);
    callFile = caller[0];
    if (callFile === file) {
      seen = true;
    } else if (callFile === this._file) {
      file = this._file;
    } else if (seen) {
      break;
    }
  }
  var key = caller ? depSite.join(":") + "__" + caller.join(":") : void 0;
  if (key !== void 0 && key in this._warned) {
    return;
  }
  this._warned[key] = true;
  var msg = message;
  if (!msg) {
    msg = callSite === depSite || !callSite.name ? defaultMessage(depSite) : defaultMessage(callSite);
  }
  if (haslisteners) {
    var err = DeprecationError(this._namespace, msg, stack.slice(i));
    process.emit("deprecation", err);
    return;
  }
  var format2 = process.stderr.isTTY ? formatColor : formatPlain;
  var output = format2.call(this, msg, caller, stack.slice(i));
  process.stderr.write(output + "\n", "utf8");
}
function callSiteLocation(callSite) {
  var file = callSite.getFileName() || "<anonymous>";
  var line = callSite.getLineNumber();
  var colm = callSite.getColumnNumber();
  if (callSite.isEval()) {
    file = callSite.getEvalOrigin() + ", " + file;
  }
  var site = [file, line, colm];
  site.callSite = callSite;
  site.name = callSite.getFunctionName();
  return site;
}
function defaultMessage(site) {
  var callSite = site.callSite;
  var funcName = site.name;
  if (!funcName) {
    funcName = "<anonymous@" + formatLocation(site) + ">";
  }
  var context = callSite.getThis();
  var typeName = context && callSite.getTypeName();
  if (typeName === "Object") {
    typeName = void 0;
  }
  if (typeName === "Function") {
    typeName = context.name || typeName;
  }
  return typeName && callSite.getMethodName() ? typeName + "." + funcName : funcName;
}
function formatPlain(msg, caller, stack) {
  var timestamp = (/* @__PURE__ */ new Date()).toUTCString();
  var formatted = timestamp + " " + this._namespace + " deprecated " + msg;
  if (this._traced) {
    for (var i = 0; i < stack.length; i++) {
      formatted += "\n    at " + stack[i].toString();
    }
    return formatted;
  }
  if (caller) {
    formatted += " at " + formatLocation(caller);
  }
  return formatted;
}
function formatColor(msg, caller, stack) {
  var formatted = "\x1B[36;1m" + this._namespace + "\x1B[22;39m \x1B[33;1mdeprecated\x1B[22;39m \x1B[0m" + msg + "\x1B[39m";
  if (this._traced) {
    for (var i = 0; i < stack.length; i++) {
      formatted += "\n    \x1B[36mat " + stack[i].toString() + "\x1B[39m";
    }
    return formatted;
  }
  if (caller) {
    formatted += " \x1B[36m" + formatLocation(caller) + "\x1B[39m";
  }
  return formatted;
}
function formatLocation(callSite) {
  return relative(basePath, callSite[0]) + ":" + callSite[1] + ":" + callSite[2];
}
function getStack() {
  var limit = Error.stackTraceLimit;
  var obj = {};
  var prep = Error.prepareStackTrace;
  Error.prepareStackTrace = prepareObjectStackTrace;
  Error.stackTraceLimit = Math.max(10, limit);
  Error.captureStackTrace(obj);
  var stack = obj.stack.slice(1);
  Error.prepareStackTrace = prep;
  Error.stackTraceLimit = limit;
  return stack;
}
function prepareObjectStackTrace(obj, stack) {
  return stack;
}
function wrapfunction(fn, message) {
  if (typeof fn !== "function") {
    throw new TypeError("argument fn must be a function");
  }
  var args = createArgumentsString(fn.length);
  var stack = getStack();
  var site = callSiteLocation(stack[1]);
  site.name = fn.name;
  var deprecatedfn = new Function(
    "fn",
    "log",
    "deprecate",
    "message",
    "site",
    '"use strict"\nreturn function (' + args + ") {log.call(deprecate, message, site)\nreturn fn.apply(this, arguments)\n}"
  )(fn, log, this, message, site);
  return deprecatedfn;
}
function wrapproperty(obj, prop, message) {
  if (!obj || typeof obj !== "object" && typeof obj !== "function") {
    throw new TypeError("argument obj must be object");
  }
  var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
  if (!descriptor) {
    throw new TypeError("must call property on owner object");
  }
  if (!descriptor.configurable) {
    throw new TypeError("property must be configurable");
  }
  var deprecate2 = this;
  var stack = getStack();
  var site = callSiteLocation(stack[1]);
  site.name = prop;
  if ("value" in descriptor) {
    descriptor = convertDataDescriptorToAccessor(obj, prop);
  }
  var get2 = descriptor.get;
  var set2 = descriptor.set;
  if (typeof get2 === "function") {
    descriptor.get = function getter() {
      log.call(deprecate2, message, site);
      return get2.apply(this, arguments);
    };
  }
  if (typeof set2 === "function") {
    descriptor.set = function setter() {
      log.call(deprecate2, message, site);
      return set2.apply(this, arguments);
    };
  }
  Object.defineProperty(obj, prop, descriptor);
}
function DeprecationError(namespace, message, stack) {
  var error2 = new Error();
  var stackString;
  Object.defineProperty(error2, "constructor", {
    value: DeprecationError
  });
  Object.defineProperty(error2, "message", {
    configurable: true,
    enumerable: false,
    value: message,
    writable: true
  });
  Object.defineProperty(error2, "name", {
    enumerable: false,
    configurable: true,
    value: "DeprecationError",
    writable: true
  });
  Object.defineProperty(error2, "namespace", {
    configurable: true,
    enumerable: false,
    value: namespace,
    writable: true
  });
  Object.defineProperty(error2, "stack", {
    configurable: true,
    enumerable: false,
    get: function() {
      if (stackString !== void 0) {
        return stackString;
      }
      return stackString = createStackString.call(this, stack);
    },
    set: function setter(val) {
      stackString = val;
    }
  });
  return error2;
}
var bytes = { exports: {} };
/*!
 * bytes
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015 Jed Watson
 * MIT Licensed
 */
var hasRequiredBytes;
function requireBytes() {
  if (hasRequiredBytes)
    return bytes.exports;
  hasRequiredBytes = 1;
  bytes.exports = bytes$1;
  bytes.exports.format = format2;
  bytes.exports.parse = parse2;
  var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;
  var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;
  var map2 = {
    b: 1,
    kb: 1 << 10,
    mb: 1 << 20,
    gb: 1 << 30,
    tb: Math.pow(1024, 4),
    pb: Math.pow(1024, 5)
  };
  var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;
  function bytes$1(value, options) {
    if (typeof value === "string") {
      return parse2(value);
    }
    if (typeof value === "number") {
      return format2(value, options);
    }
    return null;
  }
  function format2(value, options) {
    if (!Number.isFinite(value)) {
      return null;
    }
    var mag = Math.abs(value);
    var thousandsSeparator = options && options.thousandsSeparator || "";
    var unitSeparator = options && options.unitSeparator || "";
    var decimalPlaces = options && options.decimalPlaces !== void 0 ? options.decimalPlaces : 2;
    var fixedDecimals = Boolean(options && options.fixedDecimals);
    var unit = options && options.unit || "";
    if (!unit || !map2[unit.toLowerCase()]) {
      if (mag >= map2.pb) {
        unit = "PB";
      } else if (mag >= map2.tb) {
        unit = "TB";
      } else if (mag >= map2.gb) {
        unit = "GB";
      } else if (mag >= map2.mb) {
        unit = "MB";
      } else if (mag >= map2.kb) {
        unit = "KB";
      } else {
        unit = "B";
      }
    }
    var val = value / map2[unit.toLowerCase()];
    var str = val.toFixed(decimalPlaces);
    if (!fixedDecimals) {
      str = str.replace(formatDecimalsRegExp, "$1");
    }
    if (thousandsSeparator) {
      str = str.split(".").map(function(s2, i) {
        return i === 0 ? s2.replace(formatThousandsRegExp, thousandsSeparator) : s2;
      }).join(".");
    }
    return str + unitSeparator + unit;
  }
  function parse2(val) {
    if (typeof val === "number" && !isNaN(val)) {
      return val;
    }
    if (typeof val !== "string") {
      return null;
    }
    var results = parseRegExp.exec(val);
    var floatValue;
    var unit = "b";
    if (!results) {
      floatValue = parseInt(val, 10);
      unit = "b";
    } else {
      floatValue = parseFloat(results[1]);
      unit = results[4].toLowerCase();
    }
    if (isNaN(floatValue)) {
      return null;
    }
    return Math.floor(map2[unit] * floatValue);
  }
  return bytes.exports;
}
var contentType = {};
/*!
 * content-type
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var PARAM_REGEXP$1 = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g;
var TEXT_REGEXP$1 = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/;
var TOKEN_REGEXP$1 = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
var QESC_REGEXP$1 = /\\([\u000b\u0020-\u00ff])/g;
var QUOTE_REGEXP$1 = /([\\"])/g;
var TYPE_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
contentType.format = format$2;
contentType.parse = parse$9;
function format$2(obj) {
  if (!obj || typeof obj !== "object") {
    throw new TypeError("argument obj is required");
  }
  var parameters = obj.parameters;
  var type3 = obj.type;
  if (!type3 || !TYPE_REGEXP.test(type3)) {
    throw new TypeError("invalid type");
  }
  var string = type3;
  if (parameters && typeof parameters === "object") {
    var param3;
    var params = Object.keys(parameters).sort();
    for (var i = 0; i < params.length; i++) {
      param3 = params[i];
      if (!TOKEN_REGEXP$1.test(param3)) {
        throw new TypeError("invalid parameter name");
      }
      string += "; " + param3 + "=" + qstring$2(parameters[param3]);
    }
  }
  return string;
}
function parse$9(string) {
  if (!string) {
    throw new TypeError("argument string is required");
  }
  var header3 = typeof string === "object" ? getcontenttype$1(string) : string;
  if (typeof header3 !== "string") {
    throw new TypeError("argument string is required to be a string");
  }
  var index2 = header3.indexOf(";");
  var type3 = index2 !== -1 ? header3.slice(0, index2).trim() : header3.trim();
  if (!TYPE_REGEXP.test(type3)) {
    throw new TypeError("invalid media type");
  }
  var obj = new ContentType(type3.toLowerCase());
  if (index2 !== -1) {
    var key;
    var match2;
    var value;
    PARAM_REGEXP$1.lastIndex = index2;
    while (match2 = PARAM_REGEXP$1.exec(header3)) {
      if (match2.index !== index2) {
        throw new TypeError("invalid parameter format");
      }
      index2 += match2[0].length;
      key = match2[1].toLowerCase();
      value = match2[2];
      if (value.charCodeAt(0) === 34) {
        value = value.slice(1, -1);
        if (value.indexOf("\\") !== -1) {
          value = value.replace(QESC_REGEXP$1, "$1");
        }
      }
      obj.parameters[key] = value;
    }
    if (index2 !== header3.length) {
      throw new TypeError("invalid parameter format");
    }
  }
  return obj;
}
function getcontenttype$1(obj) {
  var header3;
  if (typeof obj.getHeader === "function") {
    header3 = obj.getHeader("content-type");
  } else if (typeof obj.headers === "object") {
    header3 = obj.headers && obj.headers["content-type"];
  }
  if (typeof header3 !== "string") {
    throw new TypeError("content-type header is missing from object");
  }
  return header3;
}
function qstring$2(val) {
  var str = String(val);
  if (TOKEN_REGEXP$1.test(str)) {
    return str;
  }
  if (str.length > 0 && !TEXT_REGEXP$1.test(str)) {
    throw new TypeError("invalid parameter value");
  }
  return '"' + str.replace(QUOTE_REGEXP$1, "\\$1") + '"';
}
function ContentType(type3) {
  this.parameters = /* @__PURE__ */ Object.create(null);
  this.type = type3;
}
var httpErrors = { exports: {} };
var setprototypeof = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? setProtoOf : mixinProperties);
function setProtoOf(obj, proto2) {
  obj.__proto__ = proto2;
  return obj;
}
function mixinProperties(obj, proto2) {
  for (var prop in proto2) {
    if (!Object.prototype.hasOwnProperty.call(obj, prop)) {
      obj[prop] = proto2[prop];
    }
  }
  return obj;
}
const require$$0$2 = {
  "100": "Continue",
  "101": "Switching Protocols",
  "102": "Processing",
  "103": "Early Hints",
  "200": "OK",
  "201": "Created",
  "202": "Accepted",
  "203": "Non-Authoritative Information",
  "204": "No Content",
  "205": "Reset Content",
  "206": "Partial Content",
  "207": "Multi-Status",
  "208": "Already Reported",
  "226": "IM Used",
  "300": "Multiple Choices",
  "301": "Moved Permanently",
  "302": "Found",
  "303": "See Other",
  "304": "Not Modified",
  "305": "Use Proxy",
  "307": "Temporary Redirect",
  "308": "Permanent Redirect",
  "400": "Bad Request",
  "401": "Unauthorized",
  "402": "Payment Required",
  "403": "Forbidden",
  "404": "Not Found",
  "405": "Method Not Allowed",
  "406": "Not Acceptable",
  "407": "Proxy Authentication Required",
  "408": "Request Timeout",
  "409": "Conflict",
  "410": "Gone",
  "411": "Length Required",
  "412": "Precondition Failed",
  "413": "Payload Too Large",
  "414": "URI Too Long",
  "415": "Unsupported Media Type",
  "416": "Range Not Satisfiable",
  "417": "Expectation Failed",
  "418": "I'm a Teapot",
  "421": "Misdirected Request",
  "422": "Unprocessable Entity",
  "423": "Locked",
  "424": "Failed Dependency",
  "425": "Too Early",
  "426": "Upgrade Required",
  "428": "Precondition Required",
  "429": "Too Many Requests",
  "431": "Request Header Fields Too Large",
  "451": "Unavailable For Legal Reasons",
  "500": "Internal Server Error",
  "501": "Not Implemented",
  "502": "Bad Gateway",
  "503": "Service Unavailable",
  "504": "Gateway Timeout",
  "505": "HTTP Version Not Supported",
  "506": "Variant Also Negotiates",
  "507": "Insufficient Storage",
  "508": "Loop Detected",
  "509": "Bandwidth Limit Exceeded",
  "510": "Not Extended",
  "511": "Network Authentication Required"
};
/*!
 * statuses
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var codes = require$$0$2;
var statuses$3 = status;
status.message = codes;
status.code = createMessageToStatusCodeMap(codes);
status.codes = createStatusCodeList(codes);
status.redirect = {
  300: true,
  301: true,
  302: true,
  303: true,
  305: true,
  307: true,
  308: true
};
status.empty = {
  204: true,
  205: true,
  304: true
};
status.retry = {
  502: true,
  503: true,
  504: true
};
function createMessageToStatusCodeMap(codes2) {
  var map2 = {};
  Object.keys(codes2).forEach(function forEachCode(code) {
    var message = codes2[code];
    var status3 = Number(code);
    map2[message.toLowerCase()] = status3;
  });
  return map2;
}
function createStatusCodeList(codes2) {
  return Object.keys(codes2).map(function mapCode(code) {
    return Number(code);
  });
}
function getStatusCode(message) {
  var msg = message.toLowerCase();
  if (!Object.prototype.hasOwnProperty.call(status.code, msg)) {
    throw new Error('invalid status message: "' + message + '"');
  }
  return status.code[msg];
}
function getStatusMessage(code) {
  if (!Object.prototype.hasOwnProperty.call(status.message, code)) {
    throw new Error("invalid status code: " + code);
  }
  return status.message[code];
}
function status(code) {
  if (typeof code === "number") {
    return getStatusMessage(code);
  }
  if (typeof code !== "string") {
    throw new TypeError("code must be a number or string");
  }
  var n = parseInt(code, 10);
  if (!isNaN(n)) {
    return getStatusMessage(n);
  }
  return getStatusCode(code);
}
var inherits$1 = { exports: {} };
var inherits_browser = { exports: {} };
var hasRequiredInherits_browser;
function requireInherits_browser() {
  if (hasRequiredInherits_browser)
    return inherits_browser.exports;
  hasRequiredInherits_browser = 1;
  if (typeof Object.create === "function") {
    inherits_browser.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    inherits_browser.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
  return inherits_browser.exports;
}
try {
  var util$4 = require("util");
  if (typeof util$4.inherits !== "function")
    throw "";
  inherits$1.exports = util$4.inherits;
} catch (e) {
  inherits$1.exports = requireInherits_browser();
}
var inheritsExports = inherits$1.exports;
/*!
 * toidentifier
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var toidentifier = toIdentifier;
function toIdentifier(str) {
  return str.split(" ").map(function(token) {
    return token.slice(0, 1).toUpperCase() + token.slice(1);
  }).join("").replace(/[^ _0-9a-z]/gi, "");
}
/*!
 * http-errors
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
(function(module) {
  var deprecate2 = depd_1("http-errors");
  var setPrototypeOf2 = setprototypeof;
  var statuses2 = statuses$3;
  var inherits2 = inheritsExports;
  var toIdentifier2 = toidentifier;
  module.exports = createError2;
  module.exports.HttpError = createHttpErrorConstructor();
  module.exports.isHttpError = createIsHttpErrorFunction(module.exports.HttpError);
  populateConstructorExports(module.exports, statuses2.codes, module.exports.HttpError);
  function codeClass(status3) {
    return Number(String(status3).charAt(0) + "00");
  }
  function createError2() {
    var err;
    var msg;
    var status3 = 500;
    var props = {};
    for (var i = 0; i < arguments.length; i++) {
      var arg = arguments[i];
      var type3 = typeof arg;
      if (type3 === "object" && arg instanceof Error) {
        err = arg;
        status3 = err.status || err.statusCode || status3;
      } else if (type3 === "number" && i === 0) {
        status3 = arg;
      } else if (type3 === "string") {
        msg = arg;
      } else if (type3 === "object") {
        props = arg;
      } else {
        throw new TypeError("argument #" + (i + 1) + " unsupported type " + type3);
      }
    }
    if (typeof status3 === "number" && (status3 < 400 || status3 >= 600)) {
      deprecate2("non-error status code; use only 4xx or 5xx status codes");
    }
    if (typeof status3 !== "number" || !statuses2.message[status3] && (status3 < 400 || status3 >= 600)) {
      status3 = 500;
    }
    var HttpError = createError2[status3] || createError2[codeClass(status3)];
    if (!err) {
      err = HttpError ? new HttpError(msg) : new Error(msg || statuses2.message[status3]);
      Error.captureStackTrace(err, createError2);
    }
    if (!HttpError || !(err instanceof HttpError) || err.status !== status3) {
      err.expose = status3 < 500;
      err.status = err.statusCode = status3;
    }
    for (var key in props) {
      if (key !== "status" && key !== "statusCode") {
        err[key] = props[key];
      }
    }
    return err;
  }
  function createHttpErrorConstructor() {
    function HttpError() {
      throw new TypeError("cannot construct abstract class");
    }
    inherits2(HttpError, Error);
    return HttpError;
  }
  function createClientErrorConstructor(HttpError, name, code) {
    var className = toClassName(name);
    function ClientError(message) {
      var msg = message != null ? message : statuses2.message[code];
      var err = new Error(msg);
      Error.captureStackTrace(err, ClientError);
      setPrototypeOf2(err, ClientError.prototype);
      Object.defineProperty(err, "message", {
        enumerable: true,
        configurable: true,
        value: msg,
        writable: true
      });
      Object.defineProperty(err, "name", {
        enumerable: false,
        configurable: true,
        value: className,
        writable: true
      });
      return err;
    }
    inherits2(ClientError, HttpError);
    nameFunc(ClientError, className);
    ClientError.prototype.status = code;
    ClientError.prototype.statusCode = code;
    ClientError.prototype.expose = true;
    return ClientError;
  }
  function createIsHttpErrorFunction(HttpError) {
    return function isHttpError(val) {
      if (!val || typeof val !== "object") {
        return false;
      }
      if (val instanceof HttpError) {
        return true;
      }
      return val instanceof Error && typeof val.expose === "boolean" && typeof val.statusCode === "number" && val.status === val.statusCode;
    };
  }
  function createServerErrorConstructor(HttpError, name, code) {
    var className = toClassName(name);
    function ServerError(message) {
      var msg = message != null ? message : statuses2.message[code];
      var err = new Error(msg);
      Error.captureStackTrace(err, ServerError);
      setPrototypeOf2(err, ServerError.prototype);
      Object.defineProperty(err, "message", {
        enumerable: true,
        configurable: true,
        value: msg,
        writable: true
      });
      Object.defineProperty(err, "name", {
        enumerable: false,
        configurable: true,
        value: className,
        writable: true
      });
      return err;
    }
    inherits2(ServerError, HttpError);
    nameFunc(ServerError, className);
    ServerError.prototype.status = code;
    ServerError.prototype.statusCode = code;
    ServerError.prototype.expose = false;
    return ServerError;
  }
  function nameFunc(func, name) {
    var desc = Object.getOwnPropertyDescriptor(func, "name");
    if (desc && desc.configurable) {
      desc.value = name;
      Object.defineProperty(func, "name", desc);
    }
  }
  function populateConstructorExports(exports, codes2, HttpError) {
    codes2.forEach(function forEachCode(code) {
      var CodeError;
      var name = toIdentifier2(statuses2.message[code]);
      switch (codeClass(code)) {
        case 400:
          CodeError = createClientErrorConstructor(HttpError, name, code);
          break;
        case 500:
          CodeError = createServerErrorConstructor(HttpError, name, code);
          break;
      }
      if (CodeError) {
        exports[code] = CodeError;
        exports[name] = CodeError;
      }
    });
  }
  function toClassName(name) {
    return name.substr(-5) !== "Error" ? name + "Error" : name;
  }
})(httpErrors);
var httpErrorsExports = httpErrors.exports;
var src$4 = { exports: {} };
var browser$4 = { exports: {} };
var debug$b = { exports: {} };
var ms$6;
var hasRequiredMs$4;
function requireMs$4() {
  if (hasRequiredMs$4)
    return ms$6;
  hasRequiredMs$4 = 1;
  var s2 = 1e3;
  var m2 = s2 * 60;
  var h2 = m2 * 60;
  var d2 = h2 * 24;
  var y2 = d2 * 365.25;
  ms$6 = function(val, options) {
    options = options || {};
    var type3 = typeof val;
    if (type3 === "string" && val.length > 0) {
      return parse2(val);
    } else if (type3 === "number" && isNaN(val) === false) {
      return options.long ? fmtLong2(val) : fmtShort2(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse2(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match2 = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
      str
    );
    if (!match2) {
      return;
    }
    var n = parseFloat(match2[1]);
    var type3 = (match2[2] || "ms").toLowerCase();
    switch (type3) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y2;
      case "days":
      case "day":
      case "d":
        return n * d2;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h2;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m2;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s2;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort2(ms2) {
    if (ms2 >= d2) {
      return Math.round(ms2 / d2) + "d";
    }
    if (ms2 >= h2) {
      return Math.round(ms2 / h2) + "h";
    }
    if (ms2 >= m2) {
      return Math.round(ms2 / m2) + "m";
    }
    if (ms2 >= s2) {
      return Math.round(ms2 / s2) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong2(ms2) {
    return plural2(ms2, d2, "day") || plural2(ms2, h2, "hour") || plural2(ms2, m2, "minute") || plural2(ms2, s2, "second") || ms2 + " ms";
  }
  function plural2(ms2, n, name) {
    if (ms2 < n) {
      return;
    }
    if (ms2 < n * 1.5) {
      return Math.floor(ms2 / n) + " " + name;
    }
    return Math.ceil(ms2 / n) + " " + name + "s";
  }
  return ms$6;
}
var hasRequiredDebug$3;
function requireDebug$3() {
  if (hasRequiredDebug$3)
    return debug$b.exports;
  hasRequiredDebug$3 = 1;
  (function(module, exports) {
    exports = module.exports = createDebug.debug = createDebug["default"] = createDebug;
    exports.coerce = coerce;
    exports.disable = disable;
    exports.enable = enable;
    exports.enabled = enabled;
    exports.humanize = requireMs$4();
    exports.names = [];
    exports.skips = [];
    exports.formatters = {};
    var prevTime;
    function selectColor(namespace) {
      var hash = 0, i;
      for (i in namespace) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return exports.colors[Math.abs(hash) % exports.colors.length];
    }
    function createDebug(namespace) {
      function debug2() {
        if (!debug2.enabled)
          return;
        var self2 = debug2;
        var curr = +/* @__PURE__ */ new Date();
        var ms2 = curr - (prevTime || curr);
        self2.diff = ms2;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        args[0] = exports.coerce(args[0]);
        if ("string" !== typeof args[0]) {
          args.unshift("%O");
        }
        var index2 = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match2, format2) {
          if (match2 === "%%")
            return match2;
          index2++;
          var formatter = exports.formatters[format2];
          if ("function" === typeof formatter) {
            var val = args[index2];
            match2 = formatter.call(self2, val);
            args.splice(index2, 1);
            index2--;
          }
          return match2;
        });
        exports.formatArgs.call(self2, args);
        var logFn = debug2.log || exports.log || console.log.bind(console);
        logFn.apply(self2, args);
      }
      debug2.namespace = namespace;
      debug2.enabled = exports.enabled(namespace);
      debug2.useColors = exports.useColors();
      debug2.color = selectColor(namespace);
      if ("function" === typeof exports.init) {
        exports.init(debug2);
      }
      return debug2;
    }
    function enable(namespaces) {
      exports.save(namespaces);
      exports.names = [];
      exports.skips = [];
      var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      var len = split.length;
      for (var i = 0; i < len; i++) {
        if (!split[i])
          continue;
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          exports.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          exports.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      exports.enable("");
    }
    function enabled(name) {
      var i, len;
      for (i = 0, len = exports.skips.length; i < len; i++) {
        if (exports.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = exports.names.length; i < len; i++) {
        if (exports.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error)
        return val.stack || val.message;
      return val;
    }
  })(debug$b, debug$b.exports);
  return debug$b.exports;
}
var hasRequiredBrowser$4;
function requireBrowser$4() {
  if (hasRequiredBrowser$4)
    return browser$4.exports;
  hasRequiredBrowser$4 = 1;
  (function(module, exports) {
    exports = module.exports = requireDebug$3();
    exports.log = log2;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = "undefined" != typeof chrome && "undefined" != typeof chrome.storage ? chrome.storage.local : localstorage();
    exports.colors = [
      "lightseagreen",
      "forestgreen",
      "goldenrod",
      "dodgerblue",
      "darkorchid",
      "crimson"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
        return true;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    exports.formatters.j = function(v2) {
      try {
        return JSON.stringify(v2);
      } catch (err) {
        return "[UnexpectedJSONParseError]: " + err.message;
      }
    };
    function formatArgs(args) {
      var useColors2 = this.useColors;
      args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports.humanize(this.diff);
      if (!useColors2)
        return;
      var c2 = "color: " + this.color;
      args.splice(1, 0, c2, "color: inherit");
      var index2 = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function(match2) {
        if ("%%" === match2)
          return;
        index2++;
        if ("%c" === match2) {
          lastC = index2;
        }
      });
      args.splice(lastC, 0, c2);
    }
    function log2() {
      return "object" === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
    }
    function save(namespaces) {
      try {
        if (null == namespaces) {
          exports.storage.removeItem("debug");
        } else {
          exports.storage.debug = namespaces;
        }
      } catch (e) {
      }
    }
    function load() {
      var r;
      try {
        r = exports.storage.debug;
      } catch (e) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    exports.enable(load());
    function localstorage() {
      try {
        return window.localStorage;
      } catch (e) {
      }
    }
  })(browser$4, browser$4.exports);
  return browser$4.exports;
}
var node$4 = { exports: {} };
var hasRequiredNode$4;
function requireNode$4() {
  if (hasRequiredNode$4)
    return node$4.exports;
  hasRequiredNode$4 = 1;
  (function(module, exports) {
    var tty = require$$0$3;
    var util2 = require$$1$1;
    exports = module.exports = requireDebug$3();
    exports.init = init2;
    exports.log = log2;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.colors = [6, 2, 3, 4, 5, 1];
    exports.inspectOpts = Object.keys(process.env).filter(function(key) {
      return /^debug_/i.test(key);
    }).reduce(function(obj, key) {
      var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_2, k2) {
        return k2.toUpperCase();
      });
      var val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val))
        val = true;
      else if (/^(no|off|false|disabled)$/i.test(val))
        val = false;
      else if (val === "null")
        val = null;
      else
        val = Number(val);
      obj[prop] = val;
      return obj;
    }, {});
    var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
    if (1 !== fd && 2 !== fd) {
      util2.deprecate(function() {
      }, "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)")();
    }
    var stream3 = 1 === fd ? process.stdout : 2 === fd ? process.stderr : createWritableStdioStream(fd);
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(fd);
    }
    exports.formatters.o = function(v2) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v2, this.inspectOpts).split("\n").map(function(str) {
        return str.trim();
      }).join(" ");
    };
    exports.formatters.O = function(v2) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v2, this.inspectOpts);
    };
    function formatArgs(args) {
      var name = this.namespace;
      var useColors2 = this.useColors;
      if (useColors2) {
        var c2 = this.color;
        var prefix = "  \x1B[3" + c2 + ";1m" + name + " \x1B[0m";
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push("\x1B[3" + c2 + "m+" + exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = (/* @__PURE__ */ new Date()).toUTCString() + " " + name + " " + args[0];
      }
    }
    function log2() {
      return stream3.write(util2.format.apply(util2, arguments) + "\n");
    }
    function save(namespaces) {
      if (null == namespaces) {
        delete process.env.DEBUG;
      } else {
        process.env.DEBUG = namespaces;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function createWritableStdioStream(fd2) {
      var stream22;
      var tty_wrap = process.binding("tty_wrap");
      switch (tty_wrap.guessHandleType(fd2)) {
        case "TTY":
          stream22 = new tty.WriteStream(fd2);
          stream22._type = "tty";
          if (stream22._handle && stream22._handle.unref) {
            stream22._handle.unref();
          }
          break;
        case "FILE":
          var fs2 = require$$3$1;
          stream22 = new fs2.SyncWriteStream(fd2, { autoClose: false });
          stream22._type = "fs";
          break;
        case "PIPE":
        case "TCP":
          var net = require$$4$1;
          stream22 = new net.Socket({
            fd: fd2,
            readable: false,
            writable: true
          });
          stream22.readable = false;
          stream22.read = null;
          stream22._type = "pipe";
          if (stream22._handle && stream22._handle.unref) {
            stream22._handle.unref();
          }
          break;
        default:
          throw new Error("Implement me. Unknown stream file type!");
      }
      stream22.fd = fd2;
      stream22._isStdio = true;
      return stream22;
    }
    function init2(debug2) {
      debug2.inspectOpts = {};
      var keys2 = Object.keys(exports.inspectOpts);
      for (var i = 0; i < keys2.length; i++) {
        debug2.inspectOpts[keys2[i]] = exports.inspectOpts[keys2[i]];
      }
    }
    exports.enable(load());
  })(node$4, node$4.exports);
  return node$4.exports;
}
var hasRequiredSrc$1;
function requireSrc$1() {
  if (hasRequiredSrc$1)
    return src$4.exports;
  hasRequiredSrc$1 = 1;
  if (typeof process !== "undefined" && process.type === "renderer") {
    src$4.exports = requireBrowser$4();
  } else {
    src$4.exports = requireNode$4();
  }
  return src$4.exports;
}
/*!
 * destroy
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var EventEmitter = require$$0$4.EventEmitter;
var ReadStream = require$$3$1.ReadStream;
var Stream$4 = stream;
var Zlib = zlib;
var destroy_1 = destroy$2;
function destroy$2(stream3, suppress) {
  if (isFsReadStream(stream3)) {
    destroyReadStream(stream3);
  } else if (isZlibStream(stream3)) {
    destroyZlibStream(stream3);
  } else if (hasDestroy(stream3)) {
    stream3.destroy();
  }
  if (isEventEmitter(stream3) && suppress) {
    stream3.removeAllListeners("error");
    stream3.addListener("error", noop$2);
  }
  return stream3;
}
function destroyReadStream(stream3) {
  stream3.destroy();
  if (typeof stream3.close === "function") {
    stream3.on("open", onOpenClose);
  }
}
function closeZlibStream(stream3) {
  if (stream3._hadError === true) {
    var prop = stream3._binding === null ? "_binding" : "_handle";
    stream3[prop] = {
      close: function() {
        this[prop] = null;
      }
    };
  }
  stream3.close();
}
function destroyZlibStream(stream3) {
  if (typeof stream3.destroy === "function") {
    if (stream3._binding) {
      stream3.destroy();
      if (stream3._processing) {
        stream3._needDrain = true;
        stream3.once("drain", onDrainClearBinding);
      } else {
        stream3._binding.clear();
      }
    } else if (stream3._destroy && stream3._destroy !== Stream$4.Transform.prototype._destroy) {
      stream3.destroy();
    } else if (stream3._destroy && typeof stream3.close === "function") {
      stream3.destroyed = true;
      stream3.close();
    } else {
      stream3.destroy();
    }
  } else if (typeof stream3.close === "function") {
    closeZlibStream(stream3);
  }
}
function hasDestroy(stream3) {
  return stream3 instanceof Stream$4 && typeof stream3.destroy === "function";
}
function isEventEmitter(val) {
  return val instanceof EventEmitter;
}
function isFsReadStream(stream3) {
  return stream3 instanceof ReadStream;
}
function isZlibStream(stream3) {
  return stream3 instanceof Zlib.Gzip || stream3 instanceof Zlib.Gunzip || stream3 instanceof Zlib.Deflate || stream3 instanceof Zlib.DeflateRaw || stream3 instanceof Zlib.Inflate || stream3 instanceof Zlib.InflateRaw || stream3 instanceof Zlib.Unzip;
}
function noop$2() {
}
function onDrainClearBinding() {
  this._binding.clear();
}
function onOpenClose() {
  if (typeof this.fd === "number") {
    this.close();
  }
}
var lib$1 = { exports: {} };
var safer_1;
var hasRequiredSafer;
function requireSafer() {
  if (hasRequiredSafer)
    return safer_1;
  hasRequiredSafer = 1;
  var buffer = require$$0$5;
  var Buffer2 = buffer.Buffer;
  var safer = {};
  var key;
  for (key in buffer) {
    if (!buffer.hasOwnProperty(key))
      continue;
    if (key === "SlowBuffer" || key === "Buffer")
      continue;
    safer[key] = buffer[key];
  }
  var Safer = safer.Buffer = {};
  for (key in Buffer2) {
    if (!Buffer2.hasOwnProperty(key))
      continue;
    if (key === "allocUnsafe" || key === "allocUnsafeSlow")
      continue;
    Safer[key] = Buffer2[key];
  }
  safer.Buffer.prototype = Buffer2.prototype;
  if (!Safer.from || Safer.from === Uint8Array.from) {
    Safer.from = function(value, encodingOrOffset, length) {
      if (typeof value === "number") {
        throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
      }
      if (value && typeof value.length === "undefined") {
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
      }
      return Buffer2(value, encodingOrOffset, length);
    };
  }
  if (!Safer.alloc) {
    Safer.alloc = function(size, fill, encoding3) {
      if (typeof size !== "number") {
        throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
      }
      if (size < 0 || size >= 2 * (1 << 30)) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
      var buf = Buffer2(size);
      if (!fill || fill.length === 0) {
        buf.fill(0);
      } else if (typeof encoding3 === "string") {
        buf.fill(fill, encoding3);
      } else {
        buf.fill(fill);
      }
      return buf;
    };
  }
  if (!safer.kStringMaxLength) {
    try {
      safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
    } catch (e) {
    }
  }
  if (!safer.constants) {
    safer.constants = {
      MAX_LENGTH: safer.kMaxLength
    };
    if (safer.kStringMaxLength) {
      safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
    }
  }
  safer_1 = safer;
  return safer_1;
}
var bomHandling = {};
var hasRequiredBomHandling;
function requireBomHandling() {
  if (hasRequiredBomHandling)
    return bomHandling;
  hasRequiredBomHandling = 1;
  var BOMChar = "\uFEFF";
  bomHandling.PrependBOM = PrependBOMWrapper;
  function PrependBOMWrapper(encoder, options) {
    this.encoder = encoder;
    this.addBOM = true;
  }
  PrependBOMWrapper.prototype.write = function(str) {
    if (this.addBOM) {
      str = BOMChar + str;
      this.addBOM = false;
    }
    return this.encoder.write(str);
  };
  PrependBOMWrapper.prototype.end = function() {
    return this.encoder.end();
  };
  bomHandling.StripBOM = StripBOMWrapper;
  function StripBOMWrapper(decoder, options) {
    this.decoder = decoder;
    this.pass = false;
    this.options = options || {};
  }
  StripBOMWrapper.prototype.write = function(buf) {
    var res2 = this.decoder.write(buf);
    if (this.pass || !res2)
      return res2;
    if (res2[0] === BOMChar) {
      res2 = res2.slice(1);
      if (typeof this.options.stripBOM === "function")
        this.options.stripBOM();
    }
    this.pass = true;
    return res2;
  };
  StripBOMWrapper.prototype.end = function() {
    return this.decoder.end();
  };
  return bomHandling;
}
var encodings = {};
var internal;
var hasRequiredInternal;
function requireInternal() {
  if (hasRequiredInternal)
    return internal;
  hasRequiredInternal = 1;
  var Buffer2 = requireSafer().Buffer;
  internal = {
    // Encodings
    utf8: { type: "_internal", bomAware: true },
    cesu8: { type: "_internal", bomAware: true },
    unicode11utf8: "utf8",
    ucs2: { type: "_internal", bomAware: true },
    utf16le: "ucs2",
    binary: { type: "_internal" },
    base64: { type: "_internal" },
    hex: { type: "_internal" },
    // Codec.
    _internal: InternalCodec
  };
  function InternalCodec(codecOptions, iconv) {
    this.enc = codecOptions.encodingName;
    this.bomAware = codecOptions.bomAware;
    if (this.enc === "base64")
      this.encoder = InternalEncoderBase64;
    else if (this.enc === "cesu8") {
      this.enc = "utf8";
      this.encoder = InternalEncoderCesu8;
      if (Buffer2.from("eda0bdedb2a9", "hex").toString() !== "ðŸ’©") {
        this.decoder = InternalDecoderCesu8;
        this.defaultCharUnicode = iconv.defaultCharUnicode;
      }
    }
  }
  InternalCodec.prototype.encoder = InternalEncoder;
  InternalCodec.prototype.decoder = InternalDecoder;
  var StringDecoder = require$$1$2.StringDecoder;
  if (!StringDecoder.prototype.end)
    StringDecoder.prototype.end = function() {
    };
  function InternalDecoder(options, codec) {
    StringDecoder.call(this, codec.enc);
  }
  InternalDecoder.prototype = StringDecoder.prototype;
  function InternalEncoder(options, codec) {
    this.enc = codec.enc;
  }
  InternalEncoder.prototype.write = function(str) {
    return Buffer2.from(str, this.enc);
  };
  InternalEncoder.prototype.end = function() {
  };
  function InternalEncoderBase64(options, codec) {
    this.prevStr = "";
  }
  InternalEncoderBase64.prototype.write = function(str) {
    str = this.prevStr + str;
    var completeQuads = str.length - str.length % 4;
    this.prevStr = str.slice(completeQuads);
    str = str.slice(0, completeQuads);
    return Buffer2.from(str, "base64");
  };
  InternalEncoderBase64.prototype.end = function() {
    return Buffer2.from(this.prevStr, "base64");
  };
  function InternalEncoderCesu8(options, codec) {
  }
  InternalEncoderCesu8.prototype.write = function(str) {
    var buf = Buffer2.alloc(str.length * 3), bufIdx = 0;
    for (var i = 0; i < str.length; i++) {
      var charCode = str.charCodeAt(i);
      if (charCode < 128)
        buf[bufIdx++] = charCode;
      else if (charCode < 2048) {
        buf[bufIdx++] = 192 + (charCode >>> 6);
        buf[bufIdx++] = 128 + (charCode & 63);
      } else {
        buf[bufIdx++] = 224 + (charCode >>> 12);
        buf[bufIdx++] = 128 + (charCode >>> 6 & 63);
        buf[bufIdx++] = 128 + (charCode & 63);
      }
    }
    return buf.slice(0, bufIdx);
  };
  InternalEncoderCesu8.prototype.end = function() {
  };
  function InternalDecoderCesu8(options, codec) {
    this.acc = 0;
    this.contBytes = 0;
    this.accBytes = 0;
    this.defaultCharUnicode = codec.defaultCharUnicode;
  }
  InternalDecoderCesu8.prototype.write = function(buf) {
    var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, res2 = "";
    for (var i = 0; i < buf.length; i++) {
      var curByte = buf[i];
      if ((curByte & 192) !== 128) {
        if (contBytes > 0) {
          res2 += this.defaultCharUnicode;
          contBytes = 0;
        }
        if (curByte < 128) {
          res2 += String.fromCharCode(curByte);
        } else if (curByte < 224) {
          acc = curByte & 31;
          contBytes = 1;
          accBytes = 1;
        } else if (curByte < 240) {
          acc = curByte & 15;
          contBytes = 2;
          accBytes = 1;
        } else {
          res2 += this.defaultCharUnicode;
        }
      } else {
        if (contBytes > 0) {
          acc = acc << 6 | curByte & 63;
          contBytes--;
          accBytes++;
          if (contBytes === 0) {
            if (accBytes === 2 && acc < 128 && acc > 0)
              res2 += this.defaultCharUnicode;
            else if (accBytes === 3 && acc < 2048)
              res2 += this.defaultCharUnicode;
            else
              res2 += String.fromCharCode(acc);
          }
        } else {
          res2 += this.defaultCharUnicode;
        }
      }
    }
    this.acc = acc;
    this.contBytes = contBytes;
    this.accBytes = accBytes;
    return res2;
  };
  InternalDecoderCesu8.prototype.end = function() {
    var res2 = 0;
    if (this.contBytes > 0)
      res2 += this.defaultCharUnicode;
    return res2;
  };
  return internal;
}
var utf16 = {};
var hasRequiredUtf16;
function requireUtf16() {
  if (hasRequiredUtf16)
    return utf16;
  hasRequiredUtf16 = 1;
  var Buffer2 = requireSafer().Buffer;
  utf16.utf16be = Utf16BECodec;
  function Utf16BECodec() {
  }
  Utf16BECodec.prototype.encoder = Utf16BEEncoder;
  Utf16BECodec.prototype.decoder = Utf16BEDecoder;
  Utf16BECodec.prototype.bomAware = true;
  function Utf16BEEncoder() {
  }
  Utf16BEEncoder.prototype.write = function(str) {
    var buf = Buffer2.from(str, "ucs2");
    for (var i = 0; i < buf.length; i += 2) {
      var tmp = buf[i];
      buf[i] = buf[i + 1];
      buf[i + 1] = tmp;
    }
    return buf;
  };
  Utf16BEEncoder.prototype.end = function() {
  };
  function Utf16BEDecoder() {
    this.overflowByte = -1;
  }
  Utf16BEDecoder.prototype.write = function(buf) {
    if (buf.length == 0)
      return "";
    var buf2 = Buffer2.alloc(buf.length + 1), i = 0, j2 = 0;
    if (this.overflowByte !== -1) {
      buf2[0] = buf[0];
      buf2[1] = this.overflowByte;
      i = 1;
      j2 = 2;
    }
    for (; i < buf.length - 1; i += 2, j2 += 2) {
      buf2[j2] = buf[i + 1];
      buf2[j2 + 1] = buf[i];
    }
    this.overflowByte = i == buf.length - 1 ? buf[buf.length - 1] : -1;
    return buf2.slice(0, j2).toString("ucs2");
  };
  Utf16BEDecoder.prototype.end = function() {
  };
  utf16.utf16 = Utf16Codec;
  function Utf16Codec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf16Codec.prototype.encoder = Utf16Encoder;
  Utf16Codec.prototype.decoder = Utf16Decoder;
  function Utf16Encoder(options, codec) {
    options = options || {};
    if (options.addBOM === void 0)
      options.addBOM = true;
    this.encoder = codec.iconv.getEncoder("utf-16le", options);
  }
  Utf16Encoder.prototype.write = function(str) {
    return this.encoder.write(str);
  };
  Utf16Encoder.prototype.end = function() {
    return this.encoder.end();
  };
  function Utf16Decoder(options, codec) {
    this.decoder = null;
    this.initialBytes = [];
    this.initialBytesLen = 0;
    this.options = options || {};
    this.iconv = codec.iconv;
  }
  Utf16Decoder.prototype.write = function(buf) {
    if (!this.decoder) {
      this.initialBytes.push(buf);
      this.initialBytesLen += buf.length;
      if (this.initialBytesLen < 16)
        return "";
      var buf = Buffer2.concat(this.initialBytes), encoding3 = detectEncoding(buf, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding3, this.options);
      this.initialBytes.length = this.initialBytesLen = 0;
    }
    return this.decoder.write(buf);
  };
  Utf16Decoder.prototype.end = function() {
    if (!this.decoder) {
      var buf = Buffer2.concat(this.initialBytes), encoding3 = detectEncoding(buf, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding3, this.options);
      var res2 = this.decoder.write(buf), trail = this.decoder.end();
      return trail ? res2 + trail : res2;
    }
    return this.decoder.end();
  };
  function detectEncoding(buf, defaultEncoding) {
    var enc = defaultEncoding || "utf-16le";
    if (buf.length >= 2) {
      if (buf[0] == 254 && buf[1] == 255)
        enc = "utf-16be";
      else if (buf[0] == 255 && buf[1] == 254)
        enc = "utf-16le";
      else {
        var asciiCharsLE = 0, asciiCharsBE = 0, _len = Math.min(buf.length - buf.length % 2, 64);
        for (var i = 0; i < _len; i += 2) {
          if (buf[i] === 0 && buf[i + 1] !== 0)
            asciiCharsBE++;
          if (buf[i] !== 0 && buf[i + 1] === 0)
            asciiCharsLE++;
        }
        if (asciiCharsBE > asciiCharsLE)
          enc = "utf-16be";
        else if (asciiCharsBE < asciiCharsLE)
          enc = "utf-16le";
      }
    }
    return enc;
  }
  return utf16;
}
var utf7 = {};
var hasRequiredUtf7;
function requireUtf7() {
  if (hasRequiredUtf7)
    return utf7;
  hasRequiredUtf7 = 1;
  var Buffer2 = requireSafer().Buffer;
  utf7.utf7 = Utf7Codec;
  utf7.unicode11utf7 = "utf7";
  function Utf7Codec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf7Codec.prototype.encoder = Utf7Encoder;
  Utf7Codec.prototype.decoder = Utf7Decoder;
  Utf7Codec.prototype.bomAware = true;
  var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
  function Utf7Encoder(options, codec) {
    this.iconv = codec.iconv;
  }
  Utf7Encoder.prototype.write = function(str) {
    return Buffer2.from(str.replace(nonDirectChars, function(chunk) {
      return "+" + (chunk === "+" ? "" : this.iconv.encode(chunk, "utf16-be").toString("base64").replace(/=+$/, "")) + "-";
    }.bind(this)));
  };
  Utf7Encoder.prototype.end = function() {
  };
  function Utf7Decoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = "";
  }
  var base64Regex = /[A-Za-z0-9\/+]/;
  var base64Chars = [];
  for (var i = 0; i < 256; i++)
    base64Chars[i] = base64Regex.test(String.fromCharCode(i));
  var plusChar = "+".charCodeAt(0), minusChar = "-".charCodeAt(0), andChar = "&".charCodeAt(0);
  Utf7Decoder.prototype.write = function(buf) {
    var res2 = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
    for (var i2 = 0; i2 < buf.length; i2++) {
      if (!inBase64) {
        if (buf[i2] == plusChar) {
          res2 += this.iconv.decode(buf.slice(lastI, i2), "ascii");
          lastI = i2 + 1;
          inBase64 = true;
        }
      } else {
        if (!base64Chars[buf[i2]]) {
          if (i2 == lastI && buf[i2] == minusChar) {
            res2 += "+";
          } else {
            var b64str = base64Accum + buf.slice(lastI, i2).toString();
            res2 += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
          }
          if (buf[i2] != minusChar)
            i2--;
          lastI = i2 + 1;
          inBase64 = false;
          base64Accum = "";
        }
      }
    }
    if (!inBase64) {
      res2 += this.iconv.decode(buf.slice(lastI), "ascii");
    } else {
      var b64str = base64Accum + buf.slice(lastI).toString();
      var canBeDecoded = b64str.length - b64str.length % 8;
      base64Accum = b64str.slice(canBeDecoded);
      b64str = b64str.slice(0, canBeDecoded);
      res2 += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
    }
    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;
    return res2;
  };
  Utf7Decoder.prototype.end = function() {
    var res2 = "";
    if (this.inBase64 && this.base64Accum.length > 0)
      res2 = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
    this.inBase64 = false;
    this.base64Accum = "";
    return res2;
  };
  utf7.utf7imap = Utf7IMAPCodec;
  function Utf7IMAPCodec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
  Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
  Utf7IMAPCodec.prototype.bomAware = true;
  function Utf7IMAPEncoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = Buffer2.alloc(6);
    this.base64AccumIdx = 0;
  }
  Utf7IMAPEncoder.prototype.write = function(str) {
    var inBase64 = this.inBase64, base64Accum = this.base64Accum, base64AccumIdx = this.base64AccumIdx, buf = Buffer2.alloc(str.length * 5 + 10), bufIdx = 0;
    for (var i2 = 0; i2 < str.length; i2++) {
      var uChar = str.charCodeAt(i2);
      if (32 <= uChar && uChar <= 126) {
        if (inBase64) {
          if (base64AccumIdx > 0) {
            bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
            base64AccumIdx = 0;
          }
          buf[bufIdx++] = minusChar;
          inBase64 = false;
        }
        if (!inBase64) {
          buf[bufIdx++] = uChar;
          if (uChar === andChar)
            buf[bufIdx++] = minusChar;
        }
      } else {
        if (!inBase64) {
          buf[bufIdx++] = andChar;
          inBase64 = true;
        }
        if (inBase64) {
          base64Accum[base64AccumIdx++] = uChar >> 8;
          base64Accum[base64AccumIdx++] = uChar & 255;
          if (base64AccumIdx == base64Accum.length) {
            bufIdx += buf.write(base64Accum.toString("base64").replace(/\//g, ","), bufIdx);
            base64AccumIdx = 0;
          }
        }
      }
    }
    this.inBase64 = inBase64;
    this.base64AccumIdx = base64AccumIdx;
    return buf.slice(0, bufIdx);
  };
  Utf7IMAPEncoder.prototype.end = function() {
    var buf = Buffer2.alloc(10), bufIdx = 0;
    if (this.inBase64) {
      if (this.base64AccumIdx > 0) {
        bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
        this.base64AccumIdx = 0;
      }
      buf[bufIdx++] = minusChar;
      this.inBase64 = false;
    }
    return buf.slice(0, bufIdx);
  };
  function Utf7IMAPDecoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = "";
  }
  var base64IMAPChars = base64Chars.slice();
  base64IMAPChars[",".charCodeAt(0)] = true;
  Utf7IMAPDecoder.prototype.write = function(buf) {
    var res2 = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
    for (var i2 = 0; i2 < buf.length; i2++) {
      if (!inBase64) {
        if (buf[i2] == andChar) {
          res2 += this.iconv.decode(buf.slice(lastI, i2), "ascii");
          lastI = i2 + 1;
          inBase64 = true;
        }
      } else {
        if (!base64IMAPChars[buf[i2]]) {
          if (i2 == lastI && buf[i2] == minusChar) {
            res2 += "&";
          } else {
            var b64str = base64Accum + buf.slice(lastI, i2).toString().replace(/,/g, "/");
            res2 += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
          }
          if (buf[i2] != minusChar)
            i2--;
          lastI = i2 + 1;
          inBase64 = false;
          base64Accum = "";
        }
      }
    }
    if (!inBase64) {
      res2 += this.iconv.decode(buf.slice(lastI), "ascii");
    } else {
      var b64str = base64Accum + buf.slice(lastI).toString().replace(/,/g, "/");
      var canBeDecoded = b64str.length - b64str.length % 8;
      base64Accum = b64str.slice(canBeDecoded);
      b64str = b64str.slice(0, canBeDecoded);
      res2 += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
    }
    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;
    return res2;
  };
  Utf7IMAPDecoder.prototype.end = function() {
    var res2 = "";
    if (this.inBase64 && this.base64Accum.length > 0)
      res2 = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
    this.inBase64 = false;
    this.base64Accum = "";
    return res2;
  };
  return utf7;
}
var sbcsCodec = {};
var hasRequiredSbcsCodec;
function requireSbcsCodec() {
  if (hasRequiredSbcsCodec)
    return sbcsCodec;
  hasRequiredSbcsCodec = 1;
  var Buffer2 = requireSafer().Buffer;
  sbcsCodec._sbcs = SBCSCodec;
  function SBCSCodec(codecOptions, iconv) {
    if (!codecOptions)
      throw new Error("SBCS codec is called without the data.");
    if (!codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256)
      throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)");
    if (codecOptions.chars.length === 128) {
      var asciiString = "";
      for (var i = 0; i < 128; i++)
        asciiString += String.fromCharCode(i);
      codecOptions.chars = asciiString + codecOptions.chars;
    }
    this.decodeBuf = Buffer2.from(codecOptions.chars, "ucs2");
    var encodeBuf = Buffer2.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));
    for (var i = 0; i < codecOptions.chars.length; i++)
      encodeBuf[codecOptions.chars.charCodeAt(i)] = i;
    this.encodeBuf = encodeBuf;
  }
  SBCSCodec.prototype.encoder = SBCSEncoder;
  SBCSCodec.prototype.decoder = SBCSDecoder;
  function SBCSEncoder(options, codec) {
    this.encodeBuf = codec.encodeBuf;
  }
  SBCSEncoder.prototype.write = function(str) {
    var buf = Buffer2.alloc(str.length);
    for (var i = 0; i < str.length; i++)
      buf[i] = this.encodeBuf[str.charCodeAt(i)];
    return buf;
  };
  SBCSEncoder.prototype.end = function() {
  };
  function SBCSDecoder(options, codec) {
    this.decodeBuf = codec.decodeBuf;
  }
  SBCSDecoder.prototype.write = function(buf) {
    var decodeBuf = this.decodeBuf;
    var newBuf = Buffer2.alloc(buf.length * 2);
    var idx1 = 0, idx2 = 0;
    for (var i = 0; i < buf.length; i++) {
      idx1 = buf[i] * 2;
      idx2 = i * 2;
      newBuf[idx2] = decodeBuf[idx1];
      newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
    }
    return newBuf.toString("ucs2");
  };
  SBCSDecoder.prototype.end = function() {
  };
  return sbcsCodec;
}
var sbcsData;
var hasRequiredSbcsData;
function requireSbcsData() {
  if (hasRequiredSbcsData)
    return sbcsData;
  hasRequiredSbcsData = 1;
  sbcsData = {
    // Not supported by iconv, not sure why.
    "10029": "maccenteuro",
    "maccenteuro": {
      "type": "_sbcs",
      "chars": "Ã„Ä€ÄÃ‰Ä„Ã–ÃœÃ¡Ä…ÄŒÃ¤ÄÄ†Ä‡Ã©Å¹ÅºÄŽÃ­ÄÄ’Ä“Ä–Ã³Ä—Ã´Ã¶ÃµÃºÄšÄ›Ã¼â€ Â°Ä˜Â£Â§â€¢Â¶ÃŸÂ®Â©â„¢Ä™Â¨â‰ Ä£Ä®Ä¯Äªâ‰¤â‰¥Ä«Ä¶âˆ‚âˆ‘Å‚Ä»Ä¼Ä½Ä¾Ä¹ÄºÅ…Å†ÅƒÂ¬âˆšÅ„Å‡âˆ†Â«Â»â€¦Â ÅˆÅÃ•Å‘ÅŒâ€“â€”â€œâ€â€˜â€™Ã·â—ŠÅÅ”Å•Å˜â€¹â€ºÅ™Å–Å—Å â€šâ€žÅ¡ÅšÅ›ÃÅ¤Å¥ÃÅ½Å¾ÅªÃ“Ã”Å«Å®ÃšÅ¯Å°Å±Å²Å³ÃÃ½Ä·Å»ÅÅ¼Ä¢Ë‡"
    },
    "808": "cp808",
    "ibm808": "cp808",
    "cp808": {
      "type": "_sbcs",
      "chars": "ÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÑÐÑ‘Ð„Ñ”Ð‡Ñ—ÐŽÑžÂ°âˆ™Â·âˆšâ„–â‚¬â– Â "
    },
    "mik": {
      "type": "_sbcs",
      "chars": "ÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÑâ””â”´â”¬â”œâ”€â”¼â•£â•‘â•šâ•”â•©â•¦â• â•â•¬â”â–‘â–’â–“â”‚â”¤â„–Â§â•—â•â”˜â”Œâ–ˆâ–„â–Œâ–â–€Î±ÃŸÎ“Ï€Î£ÏƒÂµÏ„Î¦Î˜Î©Î´âˆžÏ†Îµâˆ©â‰¡Â±â‰¥â‰¤âŒ âŒ¡Ã·â‰ˆÂ°âˆ™Â·âˆšâ¿Â²â– Â "
    },
    // Aliases of generated encodings.
    "ascii8bit": "ascii",
    "usascii": "ascii",
    "ansix34": "ascii",
    "ansix341968": "ascii",
    "ansix341986": "ascii",
    "csascii": "ascii",
    "cp367": "ascii",
    "ibm367": "ascii",
    "isoir6": "ascii",
    "iso646us": "ascii",
    "iso646irv": "ascii",
    "us": "ascii",
    "latin1": "iso88591",
    "latin2": "iso88592",
    "latin3": "iso88593",
    "latin4": "iso88594",
    "latin5": "iso88599",
    "latin6": "iso885910",
    "latin7": "iso885913",
    "latin8": "iso885914",
    "latin9": "iso885915",
    "latin10": "iso885916",
    "csisolatin1": "iso88591",
    "csisolatin2": "iso88592",
    "csisolatin3": "iso88593",
    "csisolatin4": "iso88594",
    "csisolatincyrillic": "iso88595",
    "csisolatinarabic": "iso88596",
    "csisolatingreek": "iso88597",
    "csisolatinhebrew": "iso88598",
    "csisolatin5": "iso88599",
    "csisolatin6": "iso885910",
    "l1": "iso88591",
    "l2": "iso88592",
    "l3": "iso88593",
    "l4": "iso88594",
    "l5": "iso88599",
    "l6": "iso885910",
    "l7": "iso885913",
    "l8": "iso885914",
    "l9": "iso885915",
    "l10": "iso885916",
    "isoir14": "iso646jp",
    "isoir57": "iso646cn",
    "isoir100": "iso88591",
    "isoir101": "iso88592",
    "isoir109": "iso88593",
    "isoir110": "iso88594",
    "isoir144": "iso88595",
    "isoir127": "iso88596",
    "isoir126": "iso88597",
    "isoir138": "iso88598",
    "isoir148": "iso88599",
    "isoir157": "iso885910",
    "isoir166": "tis620",
    "isoir179": "iso885913",
    "isoir199": "iso885914",
    "isoir203": "iso885915",
    "isoir226": "iso885916",
    "cp819": "iso88591",
    "ibm819": "iso88591",
    "cyrillic": "iso88595",
    "arabic": "iso88596",
    "arabic8": "iso88596",
    "ecma114": "iso88596",
    "asmo708": "iso88596",
    "greek": "iso88597",
    "greek8": "iso88597",
    "ecma118": "iso88597",
    "elot928": "iso88597",
    "hebrew": "iso88598",
    "hebrew8": "iso88598",
    "turkish": "iso88599",
    "turkish8": "iso88599",
    "thai": "iso885911",
    "thai8": "iso885911",
    "celtic": "iso885914",
    "celtic8": "iso885914",
    "isoceltic": "iso885914",
    "tis6200": "tis620",
    "tis62025291": "tis620",
    "tis62025330": "tis620",
    "10000": "macroman",
    "10006": "macgreek",
    "10007": "maccyrillic",
    "10079": "maciceland",
    "10081": "macturkish",
    "cspc8codepage437": "cp437",
    "cspc775baltic": "cp775",
    "cspc850multilingual": "cp850",
    "cspcp852": "cp852",
    "cspc862latinhebrew": "cp862",
    "cpgr": "cp869",
    "msee": "cp1250",
    "mscyrl": "cp1251",
    "msansi": "cp1252",
    "msgreek": "cp1253",
    "msturk": "cp1254",
    "mshebr": "cp1255",
    "msarab": "cp1256",
    "winbaltrim": "cp1257",
    "cp20866": "koi8r",
    "20866": "koi8r",
    "ibm878": "koi8r",
    "cskoi8r": "koi8r",
    "cp21866": "koi8u",
    "21866": "koi8u",
    "ibm1168": "koi8u",
    "strk10482002": "rk1048",
    "tcvn5712": "tcvn",
    "tcvn57121": "tcvn",
    "gb198880": "iso646cn",
    "cn": "iso646cn",
    "csiso14jisc6220ro": "iso646jp",
    "jisc62201969ro": "iso646jp",
    "jp": "iso646jp",
    "cshproman8": "hproman8",
    "r8": "hproman8",
    "roman8": "hproman8",
    "xroman8": "hproman8",
    "ibm1051": "hproman8",
    "mac": "macintosh",
    "csmacintosh": "macintosh"
  };
  return sbcsData;
}
var sbcsDataGenerated;
var hasRequiredSbcsDataGenerated;
function requireSbcsDataGenerated() {
  if (hasRequiredSbcsDataGenerated)
    return sbcsDataGenerated;
  hasRequiredSbcsDataGenerated = 1;
  sbcsDataGenerated = {
    "437": "cp437",
    "737": "cp737",
    "775": "cp775",
    "850": "cp850",
    "852": "cp852",
    "855": "cp855",
    "856": "cp856",
    "857": "cp857",
    "858": "cp858",
    "860": "cp860",
    "861": "cp861",
    "862": "cp862",
    "863": "cp863",
    "864": "cp864",
    "865": "cp865",
    "866": "cp866",
    "869": "cp869",
    "874": "windows874",
    "922": "cp922",
    "1046": "cp1046",
    "1124": "cp1124",
    "1125": "cp1125",
    "1129": "cp1129",
    "1133": "cp1133",
    "1161": "cp1161",
    "1162": "cp1162",
    "1163": "cp1163",
    "1250": "windows1250",
    "1251": "windows1251",
    "1252": "windows1252",
    "1253": "windows1253",
    "1254": "windows1254",
    "1255": "windows1255",
    "1256": "windows1256",
    "1257": "windows1257",
    "1258": "windows1258",
    "28591": "iso88591",
    "28592": "iso88592",
    "28593": "iso88593",
    "28594": "iso88594",
    "28595": "iso88595",
    "28596": "iso88596",
    "28597": "iso88597",
    "28598": "iso88598",
    "28599": "iso88599",
    "28600": "iso885910",
    "28601": "iso885911",
    "28603": "iso885913",
    "28604": "iso885914",
    "28605": "iso885915",
    "28606": "iso885916",
    "windows874": {
      "type": "_sbcs",
      "chars": "â‚¬ï¿½ï¿½ï¿½ï¿½â€¦ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½â€˜â€™â€œâ€â€¢â€“â€”ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Â à¸à¸‚à¸ƒà¸„à¸…à¸†à¸‡à¸ˆà¸‰à¸Šà¸‹à¸Œà¸à¸Žà¸à¸à¸‘à¸’à¸“à¸”à¸•à¸–à¸—à¸˜à¸™à¸šà¸›à¸œà¸à¸žà¸Ÿà¸ à¸¡à¸¢à¸£à¸¤à¸¥à¸¦à¸§à¸¨à¸©à¸ªà¸«à¸¬à¸­à¸®à¸¯à¸°à¸±à¸²à¸³à¸´à¸µà¸¶à¸·à¸¸à¸¹à¸ºï¿½ï¿½ï¿½ï¿½à¸¿à¹€à¹à¹‚à¹ƒà¹„à¹…à¹†à¹‡à¹ˆà¹‰à¹Šà¹‹à¹Œà¹à¹Žà¹à¹à¹‘à¹’à¹“à¹”à¹•à¹–à¹—à¹˜à¹™à¹šà¹›ï¿½ï¿½ï¿½ï¿½"
    },
    "win874": "windows874",
    "cp874": "windows874",
    "windows1250": {
      "type": "_sbcs",
      "chars": "â‚¬ï¿½â€šï¿½â€žâ€¦â€ â€¡ï¿½â€°Å â€¹ÅšÅ¤Å½Å¹ï¿½â€˜â€™â€œâ€â€¢â€“â€”ï¿½â„¢Å¡â€ºÅ›Å¥Å¾ÅºÂ Ë‡Ë˜ÅÂ¤Ä„Â¦Â§Â¨Â©ÅžÂ«Â¬Â­Â®Å»Â°Â±Ë›Å‚Â´ÂµÂ¶Â·Â¸Ä…ÅŸÂ»Ä½ËÄ¾Å¼Å”ÃÃ‚Ä‚Ã„Ä¹Ä†Ã‡ÄŒÃ‰Ä˜Ã‹ÄšÃÃŽÄŽÄÅƒÅ‡Ã“Ã”ÅÃ–Ã—Å˜Å®ÃšÅ°ÃœÃÅ¢ÃŸÅ•Ã¡Ã¢ÄƒÃ¤ÄºÄ‡Ã§ÄÃ©Ä™Ã«Ä›Ã­Ã®ÄÄ‘Å„ÅˆÃ³Ã´Å‘Ã¶Ã·Å™Å¯ÃºÅ±Ã¼Ã½Å£Ë™"
    },
    "win1250": "windows1250",
    "cp1250": "windows1250",
    "windows1251": {
      "type": "_sbcs",
      "chars": "Ð‚Ðƒâ€šÑ“â€žâ€¦â€ â€¡â‚¬â€°Ð‰â€¹ÐŠÐŒÐ‹ÐÑ’â€˜â€™â€œâ€â€¢â€“â€”ï¿½â„¢Ñ™â€ºÑšÑœÑ›ÑŸÂ ÐŽÑžÐˆÂ¤ÒÂ¦Â§ÐÂ©Ð„Â«Â¬Â­Â®Ð‡Â°Â±Ð†Ñ–Ò‘ÂµÂ¶Â·Ñ‘â„–Ñ”Â»Ñ˜Ð…Ñ•Ñ—ÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÑ"
    },
    "win1251": "windows1251",
    "cp1251": "windows1251",
    "windows1252": {
      "type": "_sbcs",
      "chars": "â‚¬ï¿½â€šÆ’â€žâ€¦â€ â€¡Ë†â€°Å â€¹Å’ï¿½Å½ï¿½ï¿½â€˜â€™â€œâ€â€¢â€“â€”Ëœâ„¢Å¡â€ºÅ“ï¿½Å¾Å¸Â Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿Ã€ÃÃ‚ÃƒÃ„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃŽÃÃÃ‘Ã’Ã“Ã”Ã•Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÃÃžÃŸÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Ã°Ã±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ã½Ã¾Ã¿"
    },
    "win1252": "windows1252",
    "cp1252": "windows1252",
    "windows1253": {
      "type": "_sbcs",
      "chars": "â‚¬ï¿½â€šÆ’â€žâ€¦â€ â€¡ï¿½â€°ï¿½â€¹ï¿½ï¿½ï¿½ï¿½ï¿½â€˜â€™â€œâ€â€¢â€“â€”ï¿½â„¢ï¿½â€ºï¿½ï¿½ï¿½ï¿½Â Î…Î†Â£Â¤Â¥Â¦Â§Â¨Â©ï¿½Â«Â¬Â­Â®â€•Â°Â±Â²Â³Î„ÂµÂ¶Â·ÎˆÎ‰ÎŠÂ»ÎŒÂ½ÎŽÎÎÎ‘Î’Î“Î”Î•Î–Î—Î˜Î™ÎšÎ›ÎœÎÎžÎŸÎ Î¡ï¿½Î£Î¤Î¥Î¦Î§Î¨Î©ÎªÎ«Î¬Î­Î®Î¯Î°Î±Î²Î³Î´ÎµÎ¶Î·Î¸Î¹ÎºÎ»Î¼Î½Î¾Î¿Ï€ÏÏ‚ÏƒÏ„Ï…Ï†Ï‡ÏˆÏ‰ÏŠÏ‹ÏŒÏÏŽï¿½"
    },
    "win1253": "windows1253",
    "cp1253": "windows1253",
    "windows1254": {
      "type": "_sbcs",
      "chars": "â‚¬ï¿½â€šÆ’â€žâ€¦â€ â€¡Ë†â€°Å â€¹Å’ï¿½ï¿½ï¿½ï¿½â€˜â€™â€œâ€â€¢â€“â€”Ëœâ„¢Å¡â€ºÅ“ï¿½ï¿½Å¸Â Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿Ã€ÃÃ‚ÃƒÃ„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃŽÃÄžÃ‘Ã’Ã“Ã”Ã•Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÄ°ÅžÃŸÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯ÄŸÃ±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ä±ÅŸÃ¿"
    },
    "win1254": "windows1254",
    "cp1254": "windows1254",
    "windows1255": {
      "type": "_sbcs",
      "chars": "â‚¬ï¿½â€šÆ’â€žâ€¦â€ â€¡Ë†â€°ï¿½â€¹ï¿½ï¿½ï¿½ï¿½ï¿½â€˜â€™â€œâ€â€¢â€“â€”Ëœâ„¢ï¿½â€ºï¿½ï¿½ï¿½ï¿½Â Â¡Â¢Â£â‚ªÂ¥Â¦Â§Â¨Â©Ã—Â«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹Ã·Â»Â¼Â½Â¾Â¿Ö°Ö±Ö²Ö³Ö´ÖµÖ¶Ö·Ö¸Ö¹ÖºÖ»Ö¼Ö½Ö¾Ö¿×€××‚×ƒ×°×±×²×³×´ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½××‘×’×“×”×•×–×—×˜×™×š×›×œ××ž×Ÿ× ×¡×¢×£×¤×¥×¦×§×¨×©×ªï¿½ï¿½â€Žâ€ï¿½"
    },
    "win1255": "windows1255",
    "cp1255": "windows1255",
    "windows1256": {
      "type": "_sbcs",
      "chars": "â‚¬Ù¾â€šÆ’â€žâ€¦â€ â€¡Ë†â€°Ù¹â€¹Å’Ú†Ú˜ÚˆÚ¯â€˜â€™â€œâ€â€¢â€“â€”Ú©â„¢Ú‘â€ºÅ“â€Œâ€ÚºÂ ØŒÂ¢Â£Â¤Â¥Â¦Â§Â¨Â©Ú¾Â«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹Ø›Â»Â¼Â½Â¾ØŸÛØ¡Ø¢Ø£Ø¤Ø¥Ø¦Ø§Ø¨Ø©ØªØ«Ø¬Ø­Ø®Ø¯Ø°Ø±Ø²Ø³Ø´ØµØ¶Ã—Ø·Ø¸Ø¹ØºÙ€ÙÙ‚ÙƒÃ Ù„Ã¢Ù…Ù†Ù‡ÙˆÃ§Ã¨Ã©ÃªÃ«Ù‰ÙŠÃ®Ã¯Ù‹ÙŒÙÙŽÃ´ÙÙÃ·Ù‘Ã¹Ù’Ã»Ã¼â€Žâ€Û’"
    },
    "win1256": "windows1256",
    "cp1256": "windows1256",
    "windows1257": {
      "type": "_sbcs",
      "chars": "â‚¬ï¿½â€šï¿½â€žâ€¦â€ â€¡ï¿½â€°ï¿½â€¹ï¿½Â¨Ë‡Â¸ï¿½â€˜â€™â€œâ€â€¢â€“â€”ï¿½â„¢ï¿½â€ºï¿½Â¯Ë›ï¿½Â ï¿½Â¢Â£Â¤ï¿½Â¦Â§Ã˜Â©Å–Â«Â¬Â­Â®Ã†Â°Â±Â²Â³Â´ÂµÂ¶Â·Ã¸Â¹Å—Â»Â¼Â½Â¾Ã¦Ä„Ä®Ä€Ä†Ã„Ã…Ä˜Ä’ÄŒÃ‰Å¹Ä–Ä¢Ä¶ÄªÄ»Å ÅƒÅ…Ã“ÅŒÃ•Ã–Ã—Å²ÅÅšÅªÃœÅ»Å½ÃŸÄ…Ä¯ÄÄ‡Ã¤Ã¥Ä™Ä“ÄÃ©ÅºÄ—Ä£Ä·Ä«Ä¼Å¡Å„Å†Ã³ÅÃµÃ¶Ã·Å³Å‚Å›Å«Ã¼Å¼Å¾Ë™"
    },
    "win1257": "windows1257",
    "cp1257": "windows1257",
    "windows1258": {
      "type": "_sbcs",
      "chars": "â‚¬ï¿½â€šÆ’â€žâ€¦â€ â€¡Ë†â€°ï¿½â€¹Å’ï¿½ï¿½ï¿½ï¿½â€˜â€™â€œâ€â€¢â€“â€”Ëœâ„¢ï¿½â€ºÅ“ï¿½ï¿½Å¸Â Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿Ã€ÃÃ‚Ä‚Ã„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹Ì€ÃÃŽÃÄÃ‘Ì‰Ã“Ã”Æ Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÆ¯ÌƒÃŸÃ Ã¡Ã¢ÄƒÃ¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«ÌÃ­Ã®Ã¯Ä‘Ã±Ì£Ã³Ã´Æ¡Ã¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Æ°â‚«Ã¿"
    },
    "win1258": "windows1258",
    "cp1258": "windows1258",
    "iso88591": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿Ã€ÃÃ‚ÃƒÃ„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃŽÃÃÃ‘Ã’Ã“Ã”Ã•Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÃÃžÃŸÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Ã°Ã±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ã½Ã¾Ã¿"
    },
    "cp28591": "iso88591",
    "iso88592": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ Ä„Ë˜ÅÂ¤Ä½ÅšÂ§Â¨Å ÅžÅ¤Å¹Â­Å½Å»Â°Ä…Ë›Å‚Â´Ä¾Å›Ë‡Â¸Å¡ÅŸÅ¥ÅºËÅ¾Å¼Å”ÃÃ‚Ä‚Ã„Ä¹Ä†Ã‡ÄŒÃ‰Ä˜Ã‹ÄšÃÃŽÄŽÄÅƒÅ‡Ã“Ã”ÅÃ–Ã—Å˜Å®ÃšÅ°ÃœÃÅ¢ÃŸÅ•Ã¡Ã¢ÄƒÃ¤ÄºÄ‡Ã§ÄÃ©Ä™Ã«Ä›Ã­Ã®ÄÄ‘Å„ÅˆÃ³Ã´Å‘Ã¶Ã·Å™Å¯ÃºÅ±Ã¼Ã½Å£Ë™"
    },
    "cp28592": "iso88592",
    "iso88593": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ Ä¦Ë˜Â£Â¤ï¿½Ä¤Â§Â¨Ä°ÅžÄžÄ´Â­ï¿½Å»Â°Ä§Â²Â³Â´ÂµÄ¥Â·Â¸Ä±ÅŸÄŸÄµÂ½ï¿½Å¼Ã€ÃÃ‚ï¿½Ã„ÄŠÄˆÃ‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃŽÃï¿½Ã‘Ã’Ã“Ã”Ä Ã–Ã—ÄœÃ™ÃšÃ›ÃœÅ¬ÅœÃŸÃ Ã¡Ã¢ï¿½Ã¤Ä‹Ä‰Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯ï¿½Ã±Ã²Ã³Ã´Ä¡Ã¶Ã·ÄÃ¹ÃºÃ»Ã¼Å­ÅË™"
    },
    "cp28593": "iso88593",
    "iso88594": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ Ä„Ä¸Å–Â¤Ä¨Ä»Â§Â¨Å Ä’Ä¢Å¦Â­Å½Â¯Â°Ä…Ë›Å—Â´Ä©Ä¼Ë‡Â¸Å¡Ä“Ä£Å§ÅŠÅ¾Å‹Ä€ÃÃ‚ÃƒÃ„Ã…Ã†Ä®ÄŒÃ‰Ä˜Ã‹Ä–ÃÃŽÄªÄÅ…ÅŒÄ¶Ã”Ã•Ã–Ã—Ã˜Å²ÃšÃ›ÃœÅ¨ÅªÃŸÄÃ¡Ã¢Ã£Ã¤Ã¥Ã¦Ä¯ÄÃ©Ä™Ã«Ä—Ã­Ã®Ä«Ä‘Å†ÅÄ·Ã´ÃµÃ¶Ã·Ã¸Å³ÃºÃ»Ã¼Å©Å«Ë™"
    },
    "cp28594": "iso88594",
    "iso88595": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ ÐÐ‚ÐƒÐ„Ð…Ð†Ð‡ÐˆÐ‰ÐŠÐ‹ÐŒÂ­ÐŽÐÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÑâ„–Ñ‘Ñ’Ñ“Ñ”Ñ•Ñ–Ñ—Ñ˜Ñ™ÑšÑ›ÑœÂ§ÑžÑŸ"
    },
    "cp28595": "iso88595",
    "iso88596": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ ï¿½ï¿½ï¿½Â¤ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ØŒÂ­ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ø›ï¿½ï¿½ï¿½ØŸï¿½Ø¡Ø¢Ø£Ø¤Ø¥Ø¦Ø§Ø¨Ø©ØªØ«Ø¬Ø­Ø®Ø¯Ø°Ø±Ø²Ø³Ø´ØµØ¶Ø·Ø¸Ø¹Øºï¿½ï¿½ï¿½ï¿½ï¿½Ù€ÙÙ‚ÙƒÙ„Ù…Ù†Ù‡ÙˆÙ‰ÙŠÙ‹ÙŒÙÙŽÙÙÙ‘Ù’ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½"
    },
    "cp28596": "iso88596",
    "iso88597": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ â€˜â€™Â£â‚¬â‚¯Â¦Â§Â¨Â©ÍºÂ«Â¬Â­ï¿½â€•Â°Â±Â²Â³Î„Î…Î†Â·ÎˆÎ‰ÎŠÂ»ÎŒÂ½ÎŽÎÎÎ‘Î’Î“Î”Î•Î–Î—Î˜Î™ÎšÎ›ÎœÎÎžÎŸÎ Î¡ï¿½Î£Î¤Î¥Î¦Î§Î¨Î©ÎªÎ«Î¬Î­Î®Î¯Î°Î±Î²Î³Î´ÎµÎ¶Î·Î¸Î¹ÎºÎ»Î¼Î½Î¾Î¿Ï€ÏÏ‚ÏƒÏ„Ï…Ï†Ï‡ÏˆÏ‰ÏŠÏ‹ÏŒÏÏŽï¿½"
    },
    "cp28597": "iso88597",
    "iso88598": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ ï¿½Â¢Â£Â¤Â¥Â¦Â§Â¨Â©Ã—Â«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹Ã·Â»Â¼Â½Â¾ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½â€—××‘×’×“×”×•×–×—×˜×™×š×›×œ××ž×Ÿ× ×¡×¢×£×¤×¥×¦×§×¨×©×ªï¿½ï¿½â€Žâ€ï¿½"
    },
    "cp28598": "iso88598",
    "iso88599": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿Ã€ÃÃ‚ÃƒÃ„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃŽÃÄžÃ‘Ã’Ã“Ã”Ã•Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÄ°ÅžÃŸÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯ÄŸÃ±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ä±ÅŸÃ¿"
    },
    "cp28599": "iso88599",
    "iso885910": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ Ä„Ä’Ä¢ÄªÄ¨Ä¶Â§Ä»ÄÅ Å¦Å½Â­ÅªÅŠÂ°Ä…Ä“Ä£Ä«Ä©Ä·Â·Ä¼Ä‘Å¡Å§Å¾â€•Å«Å‹Ä€ÃÃ‚ÃƒÃ„Ã…Ã†Ä®ÄŒÃ‰Ä˜Ã‹Ä–ÃÃŽÃÃÅ…ÅŒÃ“Ã”Ã•Ã–Å¨Ã˜Å²ÃšÃ›ÃœÃÃžÃŸÄÃ¡Ã¢Ã£Ã¤Ã¥Ã¦Ä¯ÄÃ©Ä™Ã«Ä—Ã­Ã®Ã¯Ã°Å†ÅÃ³Ã´ÃµÃ¶Å©Ã¸Å³ÃºÃ»Ã¼Ã½Ã¾Ä¸"
    },
    "cp28600": "iso885910",
    "iso885911": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ à¸à¸‚à¸ƒà¸„à¸…à¸†à¸‡à¸ˆà¸‰à¸Šà¸‹à¸Œà¸à¸Žà¸à¸à¸‘à¸’à¸“à¸”à¸•à¸–à¸—à¸˜à¸™à¸šà¸›à¸œà¸à¸žà¸Ÿà¸ à¸¡à¸¢à¸£à¸¤à¸¥à¸¦à¸§à¸¨à¸©à¸ªà¸«à¸¬à¸­à¸®à¸¯à¸°à¸±à¸²à¸³à¸´à¸µà¸¶à¸·à¸¸à¸¹à¸ºï¿½ï¿½ï¿½ï¿½à¸¿à¹€à¹à¹‚à¹ƒà¹„à¹…à¹†à¹‡à¹ˆà¹‰à¹Šà¹‹à¹Œà¹à¹Žà¹à¹à¹‘à¹’à¹“à¹”à¹•à¹–à¹—à¹˜à¹™à¹šà¹›ï¿½ï¿½ï¿½ï¿½"
    },
    "cp28601": "iso885911",
    "iso885913": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ â€Â¢Â£Â¤â€žÂ¦Â§Ã˜Â©Å–Â«Â¬Â­Â®Ã†Â°Â±Â²Â³â€œÂµÂ¶Â·Ã¸Â¹Å—Â»Â¼Â½Â¾Ã¦Ä„Ä®Ä€Ä†Ã„Ã…Ä˜Ä’ÄŒÃ‰Å¹Ä–Ä¢Ä¶ÄªÄ»Å ÅƒÅ…Ã“ÅŒÃ•Ã–Ã—Å²ÅÅšÅªÃœÅ»Å½ÃŸÄ…Ä¯ÄÄ‡Ã¤Ã¥Ä™Ä“ÄÃ©ÅºÄ—Ä£Ä·Ä«Ä¼Å¡Å„Å†Ã³ÅÃµÃ¶Ã·Å³Å‚Å›Å«Ã¼Å¼Å¾â€™"
    },
    "cp28603": "iso885913",
    "iso885914": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ á¸‚á¸ƒÂ£ÄŠÄ‹á¸ŠÂ§áº€Â©áº‚á¸‹á»²Â­Â®Å¸á¸žá¸ŸÄ Ä¡á¹€á¹Â¶á¹–áºá¹—áºƒá¹ á»³áº„áº…á¹¡Ã€ÃÃ‚ÃƒÃ„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃŽÃÅ´Ã‘Ã’Ã“Ã”Ã•Ã–á¹ªÃ˜Ã™ÃšÃ›ÃœÃÅ¶ÃŸÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯ÅµÃ±Ã²Ã³Ã´ÃµÃ¶á¹«Ã¸Ã¹ÃºÃ»Ã¼Ã½Å·Ã¿"
    },
    "cp28604": "iso885914",
    "iso885915": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ Â¡Â¢Â£â‚¬Â¥Å Â§Å¡Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Å½ÂµÂ¶Â·Å¾Â¹ÂºÂ»Å’Å“Å¸Â¿Ã€ÃÃ‚ÃƒÃ„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃŽÃÃÃ‘Ã’Ã“Ã”Ã•Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÃÃžÃŸÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Ã°Ã±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ã½Ã¾Ã¿"
    },
    "cp28605": "iso885915",
    "iso885916": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ Ä„Ä…Åâ‚¬â€žÅ Â§Å¡Â©È˜Â«Å¹Â­ÅºÅ»Â°Â±ÄŒÅ‚Å½â€Â¶Â·Å¾ÄÈ™Â»Å’Å“Å¸Å¼Ã€ÃÃ‚Ä‚Ã„Ä†Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃŽÃÄÅƒÃ’Ã“Ã”ÅÃ–ÅšÅ°Ã™ÃšÃ›ÃœÄ˜ÈšÃŸÃ Ã¡Ã¢ÄƒÃ¤Ä‡Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Ä‘Å„Ã²Ã³Ã´Å‘Ã¶Å›Å±Ã¹ÃºÃ»Ã¼Ä™È›Ã¿"
    },
    "cp28606": "iso885916",
    "cp437": {
      "type": "_sbcs",
      "chars": "Ã‡Ã¼Ã©Ã¢Ã¤Ã Ã¥Ã§ÃªÃ«Ã¨Ã¯Ã®Ã¬Ã„Ã…Ã‰Ã¦Ã†Ã´Ã¶Ã²Ã»Ã¹Ã¿Ã–ÃœÂ¢Â£Â¥â‚§Æ’Ã¡Ã­Ã³ÃºÃ±Ã‘ÂªÂºÂ¿âŒÂ¬Â½Â¼Â¡Â«Â»â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Î±ÃŸÎ“Ï€Î£ÏƒÂµÏ„Î¦Î˜Î©Î´âˆžÏ†Îµâˆ©â‰¡Â±â‰¥â‰¤âŒ âŒ¡Ã·â‰ˆÂ°âˆ™Â·âˆšâ¿Â²â– Â "
    },
    "ibm437": "cp437",
    "csibm437": "cp437",
    "cp737": {
      "type": "_sbcs",
      "chars": "Î‘Î’Î“Î”Î•Î–Î—Î˜Î™ÎšÎ›ÎœÎÎžÎŸÎ Î¡Î£Î¤Î¥Î¦Î§Î¨Î©Î±Î²Î³Î´ÎµÎ¶Î·Î¸Î¹ÎºÎ»Î¼Î½Î¾Î¿Ï€ÏÏƒÏ‚Ï„Ï…Ï†Ï‡Ïˆâ–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Ï‰Î¬Î­Î®ÏŠÎ¯ÏŒÏÏ‹ÏŽÎ†ÎˆÎ‰ÎŠÎŒÎŽÎÂ±â‰¥â‰¤ÎªÎ«Ã·â‰ˆÂ°âˆ™Â·âˆšâ¿Â²â– Â "
    },
    "ibm737": "cp737",
    "csibm737": "cp737",
    "cp775": {
      "type": "_sbcs",
      "chars": "Ä†Ã¼Ã©ÄÃ¤Ä£Ã¥Ä‡Å‚Ä“Å–Å—Ä«Å¹Ã„Ã…Ã‰Ã¦Ã†ÅÃ¶Ä¢Â¢ÅšÅ›Ã–ÃœÃ¸Â£Ã˜Ã—Â¤Ä€ÄªÃ³Å»Å¼Åºâ€Â¦Â©Â®Â¬Â½Â¼ÅÂ«Â»â–‘â–’â–“â”‚â”¤Ä„ÄŒÄ˜Ä–â•£â•‘â•—â•Ä®Å â”â””â”´â”¬â”œâ”€â”¼Å²Åªâ•šâ•”â•©â•¦â• â•â•¬Å½Ä…ÄÄ™Ä—Ä¯Å¡Å³Å«Å¾â”˜â”Œâ–ˆâ–„â–Œâ–â–€Ã“ÃŸÅŒÅƒÃµÃ•ÂµÅ„Ä¶Ä·Ä»Ä¼Å†Ä’Å…â€™Â­Â±â€œÂ¾Â¶Â§Ã·â€žÂ°âˆ™Â·Â¹Â³Â²â– Â "
    },
    "ibm775": "cp775",
    "csibm775": "cp775",
    "cp850": {
      "type": "_sbcs",
      "chars": "Ã‡Ã¼Ã©Ã¢Ã¤Ã Ã¥Ã§ÃªÃ«Ã¨Ã¯Ã®Ã¬Ã„Ã…Ã‰Ã¦Ã†Ã´Ã¶Ã²Ã»Ã¹Ã¿Ã–ÃœÃ¸Â£Ã˜Ã—Æ’Ã¡Ã­Ã³ÃºÃ±Ã‘ÂªÂºÂ¿Â®Â¬Â½Â¼Â¡Â«Â»â–‘â–’â–“â”‚â”¤ÃÃ‚Ã€Â©â•£â•‘â•—â•Â¢Â¥â”â””â”´â”¬â”œâ”€â”¼Ã£Ãƒâ•šâ•”â•©â•¦â• â•â•¬Â¤Ã°ÃÃŠÃ‹ÃˆÄ±ÃÃŽÃâ”˜â”Œâ–ˆâ–„Â¦ÃŒâ–€Ã“ÃŸÃ”Ã’ÃµÃ•ÂµÃ¾ÃžÃšÃ›Ã™Ã½ÃÂ¯Â´Â­Â±â€—Â¾Â¶Â§Ã·Â¸Â°Â¨Â·Â¹Â³Â²â– Â "
    },
    "ibm850": "cp850",
    "csibm850": "cp850",
    "cp852": {
      "type": "_sbcs",
      "chars": "Ã‡Ã¼Ã©Ã¢Ã¤Å¯Ä‡Ã§Å‚Ã«ÅÅ‘Ã®Å¹Ã„Ä†Ã‰Ä¹ÄºÃ´Ã¶Ä½Ä¾ÅšÅ›Ã–ÃœÅ¤Å¥ÅÃ—ÄÃ¡Ã­Ã³ÃºÄ„Ä…Å½Å¾Ä˜Ä™Â¬ÅºÄŒÅŸÂ«Â»â–‘â–’â–“â”‚â”¤ÃÃ‚ÄšÅžâ•£â•‘â•—â•Å»Å¼â”â””â”´â”¬â”œâ”€â”¼Ä‚Äƒâ•šâ•”â•©â•¦â• â•â•¬Â¤Ä‘ÄÄŽÃ‹ÄÅ‡ÃÃŽÄ›â”˜â”Œâ–ˆâ–„Å¢Å®â–€Ã“ÃŸÃ”ÅƒÅ„ÅˆÅ Å¡Å”ÃšÅ•Å°Ã½ÃÅ£Â´Â­ËË›Ë‡Ë˜Â§Ã·Â¸Â°Â¨Ë™Å±Å˜Å™â– Â "
    },
    "ibm852": "cp852",
    "csibm852": "cp852",
    "cp855": {
      "type": "_sbcs",
      "chars": "Ñ’Ð‚Ñ“ÐƒÑ‘ÐÑ”Ð„Ñ•Ð…Ñ–Ð†Ñ—Ð‡Ñ˜ÐˆÑ™Ð‰ÑšÐŠÑ›Ð‹ÑœÐŒÑžÐŽÑŸÐÑŽÐ®ÑŠÐªÐ°ÐÐ±Ð‘Ñ†Ð¦Ð´Ð”ÐµÐ•Ñ„Ð¤Ð³Ð“Â«Â»â–‘â–’â–“â”‚â”¤Ñ…Ð¥Ð¸Ð˜â•£â•‘â•—â•Ð¹Ð™â”â””â”´â”¬â”œâ”€â”¼ÐºÐšâ•šâ•”â•©â•¦â• â•â•¬Â¤Ð»Ð›Ð¼ÐœÐ½ÐÐ¾ÐžÐ¿â”˜â”Œâ–ˆâ–„ÐŸÑâ–€Ð¯Ñ€Ð ÑÐ¡Ñ‚Ð¢ÑƒÐ£Ð¶Ð–Ð²Ð’ÑŒÐ¬â„–Â­Ñ‹Ð«Ð·Ð—ÑˆÐ¨ÑÐ­Ñ‰Ð©Ñ‡Ð§Â§â– Â "
    },
    "ibm855": "cp855",
    "csibm855": "cp855",
    "cp856": {
      "type": "_sbcs",
      "chars": "××‘×’×“×”×•×–×—×˜×™×š×›×œ××ž×Ÿ× ×¡×¢×£×¤×¥×¦×§×¨×©×ªï¿½Â£ï¿½Ã—ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Â®Â¬Â½Â¼ï¿½Â«Â»â–‘â–’â–“â”‚â”¤ï¿½ï¿½ï¿½Â©â•£â•‘â•—â•Â¢Â¥â”â””â”´â”¬â”œâ”€â”¼ï¿½ï¿½â•šâ•”â•©â•¦â• â•â•¬Â¤ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½â”˜â”Œâ–ˆâ–„Â¦ï¿½â–€ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Âµï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Â¯Â´Â­Â±â€—Â¾Â¶Â§Ã·Â¸Â°Â¨Â·Â¹Â³Â²â– Â "
    },
    "ibm856": "cp856",
    "csibm856": "cp856",
    "cp857": {
      "type": "_sbcs",
      "chars": "Ã‡Ã¼Ã©Ã¢Ã¤Ã Ã¥Ã§ÃªÃ«Ã¨Ã¯Ã®Ä±Ã„Ã…Ã‰Ã¦Ã†Ã´Ã¶Ã²Ã»Ã¹Ä°Ã–ÃœÃ¸Â£Ã˜ÅžÅŸÃ¡Ã­Ã³ÃºÃ±Ã‘ÄžÄŸÂ¿Â®Â¬Â½Â¼Â¡Â«Â»â–‘â–’â–“â”‚â”¤ÃÃ‚Ã€Â©â•£â•‘â•—â•Â¢Â¥â”â””â”´â”¬â”œâ”€â”¼Ã£Ãƒâ•šâ•”â•©â•¦â• â•â•¬Â¤ÂºÂªÃŠÃ‹Ãˆï¿½ÃÃŽÃâ”˜â”Œâ–ˆâ–„Â¦ÃŒâ–€Ã“ÃŸÃ”Ã’ÃµÃ•Âµï¿½Ã—ÃšÃ›Ã™Ã¬Ã¿Â¯Â´Â­Â±ï¿½Â¾Â¶Â§Ã·Â¸Â°Â¨Â·Â¹Â³Â²â– Â "
    },
    "ibm857": "cp857",
    "csibm857": "cp857",
    "cp858": {
      "type": "_sbcs",
      "chars": "Ã‡Ã¼Ã©Ã¢Ã¤Ã Ã¥Ã§ÃªÃ«Ã¨Ã¯Ã®Ã¬Ã„Ã…Ã‰Ã¦Ã†Ã´Ã¶Ã²Ã»Ã¹Ã¿Ã–ÃœÃ¸Â£Ã˜Ã—Æ’Ã¡Ã­Ã³ÃºÃ±Ã‘ÂªÂºÂ¿Â®Â¬Â½Â¼Â¡Â«Â»â–‘â–’â–“â”‚â”¤ÃÃ‚Ã€Â©â•£â•‘â•—â•Â¢Â¥â”â””â”´â”¬â”œâ”€â”¼Ã£Ãƒâ•šâ•”â•©â•¦â• â•â•¬Â¤Ã°ÃÃŠÃ‹Ãˆâ‚¬ÃÃŽÃâ”˜â”Œâ–ˆâ–„Â¦ÃŒâ–€Ã“ÃŸÃ”Ã’ÃµÃ•ÂµÃ¾ÃžÃšÃ›Ã™Ã½ÃÂ¯Â´Â­Â±â€—Â¾Â¶Â§Ã·Â¸Â°Â¨Â·Â¹Â³Â²â– Â "
    },
    "ibm858": "cp858",
    "csibm858": "cp858",
    "cp860": {
      "type": "_sbcs",
      "chars": "Ã‡Ã¼Ã©Ã¢Ã£Ã ÃÃ§ÃªÃŠÃ¨ÃÃ”Ã¬ÃƒÃ‚Ã‰Ã€ÃˆÃ´ÃµÃ²ÃšÃ¹ÃŒÃ•ÃœÂ¢Â£Ã™â‚§Ã“Ã¡Ã­Ã³ÃºÃ±Ã‘ÂªÂºÂ¿Ã’Â¬Â½Â¼Â¡Â«Â»â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Î±ÃŸÎ“Ï€Î£ÏƒÂµÏ„Î¦Î˜Î©Î´âˆžÏ†Îµâˆ©â‰¡Â±â‰¥â‰¤âŒ âŒ¡Ã·â‰ˆÂ°âˆ™Â·âˆšâ¿Â²â– Â "
    },
    "ibm860": "cp860",
    "csibm860": "cp860",
    "cp861": {
      "type": "_sbcs",
      "chars": "Ã‡Ã¼Ã©Ã¢Ã¤Ã Ã¥Ã§ÃªÃ«Ã¨ÃÃ°ÃžÃ„Ã…Ã‰Ã¦Ã†Ã´Ã¶Ã¾Ã»ÃÃ½Ã–ÃœÃ¸Â£Ã˜â‚§Æ’Ã¡Ã­Ã³ÃºÃÃÃ“ÃšÂ¿âŒÂ¬Â½Â¼Â¡Â«Â»â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Î±ÃŸÎ“Ï€Î£ÏƒÂµÏ„Î¦Î˜Î©Î´âˆžÏ†Îµâˆ©â‰¡Â±â‰¥â‰¤âŒ âŒ¡Ã·â‰ˆÂ°âˆ™Â·âˆšâ¿Â²â– Â "
    },
    "ibm861": "cp861",
    "csibm861": "cp861",
    "cp862": {
      "type": "_sbcs",
      "chars": "××‘×’×“×”×•×–×—×˜×™×š×›×œ××ž×Ÿ× ×¡×¢×£×¤×¥×¦×§×¨×©×ªÂ¢Â£Â¥â‚§Æ’Ã¡Ã­Ã³ÃºÃ±Ã‘ÂªÂºÂ¿âŒÂ¬Â½Â¼Â¡Â«Â»â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Î±ÃŸÎ“Ï€Î£ÏƒÂµÏ„Î¦Î˜Î©Î´âˆžÏ†Îµâˆ©â‰¡Â±â‰¥â‰¤âŒ âŒ¡Ã·â‰ˆÂ°âˆ™Â·âˆšâ¿Â²â– Â "
    },
    "ibm862": "cp862",
    "csibm862": "cp862",
    "cp863": {
      "type": "_sbcs",
      "chars": "Ã‡Ã¼Ã©Ã¢Ã‚Ã Â¶Ã§ÃªÃ«Ã¨Ã¯Ã®â€—Ã€Â§Ã‰ÃˆÃŠÃ´Ã‹ÃÃ»Ã¹Â¤Ã”ÃœÂ¢Â£Ã™Ã›Æ’Â¦Â´Ã³ÃºÂ¨Â¸Â³Â¯ÃŽâŒÂ¬Â½Â¼Â¾Â«Â»â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Î±ÃŸÎ“Ï€Î£ÏƒÂµÏ„Î¦Î˜Î©Î´âˆžÏ†Îµâˆ©â‰¡Â±â‰¥â‰¤âŒ âŒ¡Ã·â‰ˆÂ°âˆ™Â·âˆšâ¿Â²â– Â "
    },
    "ibm863": "cp863",
    "csibm863": "cp863",
    "cp864": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$Ùª&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~Â°Â·âˆ™âˆšâ–’â”€â”‚â”¼â”¤â”¬â”œâ”´â”â”Œâ””â”˜Î²âˆžÏ†Â±Â½Â¼â‰ˆÂ«Â»ï»·ï»¸ï¿½ï¿½ï»»ï»¼ï¿½Â Â­ïº‚Â£Â¤ïº„ï¿½ï¿½ïºŽïºïº•ïº™ØŒïºïº¡ïº¥Ù Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©ï»‘Ø›ïº±ïºµïº¹ØŸÂ¢ïº€ïºïºƒïº…ï»Šïº‹ïºïº‘ïº“ïº—ïº›ïºŸïº£ïº§ïº©ïº«ïº­ïº¯ïº³ïº·ïº»ïº¿ï»ï»…ï»‹ï»Â¦Â¬Ã·Ã—ï»‰Ù€ï»“ï»—ï»›ï»Ÿï»£ï»§ï»«ï»­ï»¯ï»³ïº½ï»Œï»Žï»ï»¡ï¹½Ù‘ï»¥ï»©ï»¬ï»°ï»²ï»ï»•ï»µï»¶ï»ï»™ï»±â– ï¿½"
    },
    "ibm864": "cp864",
    "csibm864": "cp864",
    "cp865": {
      "type": "_sbcs",
      "chars": "Ã‡Ã¼Ã©Ã¢Ã¤Ã Ã¥Ã§ÃªÃ«Ã¨Ã¯Ã®Ã¬Ã„Ã…Ã‰Ã¦Ã†Ã´Ã¶Ã²Ã»Ã¹Ã¿Ã–ÃœÃ¸Â£Ã˜â‚§Æ’Ã¡Ã­Ã³ÃºÃ±Ã‘ÂªÂºÂ¿âŒÂ¬Â½Â¼Â¡Â«Â¤â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Î±ÃŸÎ“Ï€Î£ÏƒÂµÏ„Î¦Î˜Î©Î´âˆžÏ†Îµâˆ©â‰¡Â±â‰¥â‰¤âŒ âŒ¡Ã·â‰ˆÂ°âˆ™Â·âˆšâ¿Â²â– Â "
    },
    "ibm865": "cp865",
    "csibm865": "cp865",
    "cp866": {
      "type": "_sbcs",
      "chars": "ÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÑÐÑ‘Ð„Ñ”Ð‡Ñ—ÐŽÑžÂ°âˆ™Â·âˆšâ„–Â¤â– Â "
    },
    "ibm866": "cp866",
    "csibm866": "cp866",
    "cp869": {
      "type": "_sbcs",
      "chars": "ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Î†ï¿½Â·Â¬Â¦â€˜â€™Îˆâ€•Î‰ÎŠÎªÎŒï¿½ï¿½ÎŽÎ«Â©ÎÂ²Â³Î¬Â£Î­Î®Î¯ÏŠÎÏŒÏÎ‘Î’Î“Î”Î•Î–Î—Â½Î˜Î™Â«Â»â–‘â–’â–“â”‚â”¤ÎšÎ›ÎœÎâ•£â•‘â•—â•ÎžÎŸâ”â””â”´â”¬â”œâ”€â”¼Î Î¡â•šâ•”â•©â•¦â• â•â•¬Î£Î¤Î¥Î¦Î§Î¨Î©Î±Î²Î³â”˜â”Œâ–ˆâ–„Î´Îµâ–€Î¶Î·Î¸Î¹ÎºÎ»Î¼Î½Î¾Î¿Ï€ÏÏƒÏ‚Ï„Î„Â­Â±Ï…Ï†Ï‡Â§ÏˆÎ…Â°Â¨Ï‰Ï‹Î°ÏŽâ– Â "
    },
    "ibm869": "cp869",
    "csibm869": "cp869",
    "cp922": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®â€¾Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿Ã€ÃÃ‚ÃƒÃ„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃŽÃÅ Ã‘Ã’Ã“Ã”Ã•Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÃÅ½ÃŸÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Å¡Ã±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ã½Å¾Ã¿"
    },
    "ibm922": "cp922",
    "csibm922": "cp922",
    "cp1046": {
      "type": "_sbcs",
      "chars": "ïºˆÃ—Ã·ï£¶ï£µï£´ï£·ï¹±Âˆâ– â”‚â”€â”â”Œâ””â”˜ï¹¹ï¹»ï¹½ï¹¿ï¹·ïºŠï»°ï»³ï»²ï»Žï»ï»ï»¶ï»¸ï»ºï»¼Â ï£ºï£¹ï£¸Â¤ï£»ïº‹ïº‘ïº—ïº›ïºŸïº£ØŒÂ­ïº§ïº³Ù Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©ïº·Ø›ïº»ïº¿ï»ŠØŸï»‹Ø¡Ø¢Ø£Ø¤Ø¥Ø¦Ø§Ø¨Ø©ØªØ«Ø¬Ø­Ø®Ø¯Ø°Ø±Ø²Ø³Ø´ØµØ¶Ø·ï»‡Ø¹Øºï»Œïº‚ïº„ïºŽï»“Ù€ÙÙ‚ÙƒÙ„Ù…Ù†Ù‡ÙˆÙ‰ÙŠÙ‹ÙŒÙÙŽÙÙÙ‘Ù’ï»—ï»›ï»Ÿï£¼ï»µï»·ï»¹ï»»ï»£ï»§ï»¬ï»©ï¿½"
    },
    "ibm1046": "cp1046",
    "csibm1046": "cp1046",
    "cp1124": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ ÐÐ‚ÒÐ„Ð…Ð†Ð‡ÐˆÐ‰ÐŠÐ‹ÐŒÂ­ÐŽÐÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÑâ„–Ñ‘Ñ’Ò‘Ñ”Ñ•Ñ–Ñ—Ñ˜Ñ™ÑšÑ›ÑœÂ§ÑžÑŸ"
    },
    "ibm1124": "cp1124",
    "csibm1124": "cp1124",
    "cp1125": {
      "type": "_sbcs",
      "chars": "ÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÑÐÑ‘ÒÒ‘Ð„Ñ”Ð†Ñ–Ð‡Ñ—Â·âˆšâ„–Â¤â– Â "
    },
    "ibm1125": "cp1125",
    "csibm1125": "cp1125",
    "cp1129": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ Â¡Â¢Â£Â¤Â¥Â¦Â§Å“Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Å¸ÂµÂ¶Â·Å’Â¹ÂºÂ»Â¼Â½Â¾Â¿Ã€ÃÃ‚Ä‚Ã„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹Ì€ÃÃŽÃÄÃ‘Ì‰Ã“Ã”Æ Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÆ¯ÌƒÃŸÃ Ã¡Ã¢ÄƒÃ¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«ÌÃ­Ã®Ã¯Ä‘Ã±Ì£Ã³Ã´Æ¡Ã¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Æ°â‚«Ã¿"
    },
    "ibm1129": "cp1129",
    "csibm1129": "cp1129",
    "cp1133": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ àºàº‚àº„àº‡àºˆàºªàºŠàºàº”àº•àº–àº—àº™àºšàº›àºœàºàºžàºŸàº¡àº¢àº£àº¥àº§àº«àº­àº®ï¿½ï¿½ï¿½àº¯àº°àº²àº³àº´àºµàº¶àº·àº¸àº¹àº¼àº±àº»àº½ï¿½ï¿½ï¿½à»€à»à»‚à»ƒà»„à»ˆà»‰à»Šà»‹à»Œà»à»†ï¿½à»œà»â‚­ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½à»à»‘à»’à»“à»”à»•à»–à»—à»˜à»™ï¿½ï¿½Â¢Â¬Â¦ï¿½"
    },
    "ibm1133": "cp1133",
    "csibm1133": "cp1133",
    "cp1161": {
      "type": "_sbcs",
      "chars": "ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½à¹ˆà¸à¸‚à¸ƒà¸„à¸…à¸†à¸‡à¸ˆà¸‰à¸Šà¸‹à¸Œà¸à¸Žà¸à¸à¸‘à¸’à¸“à¸”à¸•à¸–à¸—à¸˜à¸™à¸šà¸›à¸œà¸à¸žà¸Ÿà¸ à¸¡à¸¢à¸£à¸¤à¸¥à¸¦à¸§à¸¨à¸©à¸ªà¸«à¸¬à¸­à¸®à¸¯à¸°à¸±à¸²à¸³à¸´à¸µà¸¶à¸·à¸¸à¸¹à¸ºà¹‰à¹Šà¹‹â‚¬à¸¿à¹€à¹à¹‚à¹ƒà¹„à¹…à¹†à¹‡à¹ˆà¹‰à¹Šà¹‹à¹Œà¹à¹Žà¹à¹à¹‘à¹’à¹“à¹”à¹•à¹–à¹—à¹˜à¹™à¹šà¹›Â¢Â¬Â¦Â "
    },
    "ibm1161": "cp1161",
    "csibm1161": "cp1161",
    "cp1162": {
      "type": "_sbcs",
      "chars": "â‚¬ÂÂ‚ÂƒÂ„â€¦Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂâ€˜â€™â€œâ€â€¢â€“â€”Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ à¸à¸‚à¸ƒà¸„à¸…à¸†à¸‡à¸ˆà¸‰à¸Šà¸‹à¸Œà¸à¸Žà¸à¸à¸‘à¸’à¸“à¸”à¸•à¸–à¸—à¸˜à¸™à¸šà¸›à¸œà¸à¸žà¸Ÿà¸ à¸¡à¸¢à¸£à¸¤à¸¥à¸¦à¸§à¸¨à¸©à¸ªà¸«à¸¬à¸­à¸®à¸¯à¸°à¸±à¸²à¸³à¸´à¸µà¸¶à¸·à¸¸à¸¹à¸ºï¿½ï¿½ï¿½ï¿½à¸¿à¹€à¹à¹‚à¹ƒà¹„à¹…à¹†à¹‡à¹ˆà¹‰à¹Šà¹‹à¹Œà¹à¹Žà¹à¹à¹‘à¹’à¹“à¹”à¹•à¹–à¹—à¹˜à¹™à¹šà¹›ï¿½ï¿½ï¿½ï¿½"
    },
    "ibm1162": "cp1162",
    "csibm1162": "cp1162",
    "cp1163": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ Â¡Â¢Â£â‚¬Â¥Â¦Â§Å“Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Å¸ÂµÂ¶Â·Å’Â¹ÂºÂ»Â¼Â½Â¾Â¿Ã€ÃÃ‚Ä‚Ã„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹Ì€ÃÃŽÃÄÃ‘Ì‰Ã“Ã”Æ Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÆ¯ÌƒÃŸÃ Ã¡Ã¢ÄƒÃ¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«ÌÃ­Ã®Ã¯Ä‘Ã±Ì£Ã³Ã´Æ¡Ã¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Æ°â‚«Ã¿"
    },
    "ibm1163": "cp1163",
    "csibm1163": "cp1163",
    "maccroatian": {
      "type": "_sbcs",
      "chars": "Ã„Ã…Ã‡Ã‰Ã‘Ã–ÃœÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼â€ Â°Â¢Â£Â§â€¢Â¶ÃŸÂ®Å â„¢Â´Â¨â‰ Å½Ã˜âˆžÂ±â‰¤â‰¥âˆ†Âµâˆ‚âˆ‘âˆÅ¡âˆ«ÂªÂºâ„¦Å¾Ã¸Â¿Â¡Â¬âˆšÆ’â‰ˆÄ†Â«ÄŒâ€¦Â Ã€ÃƒÃ•Å’Å“Äâ€”â€œâ€â€˜â€™Ã·â—Šï¿½Â©â„Â¤â€¹â€ºÃ†Â»â€“Â·â€šâ€žâ€°Ã‚Ä‡ÃÄÃˆÃÃŽÃÃŒÃ“Ã”Ä‘Ã’ÃšÃ›Ã™Ä±Ë†ËœÂ¯Ï€Ã‹ËšÂ¸ÃŠÃ¦Ë‡"
    },
    "maccyrillic": {
      "type": "_sbcs",
      "chars": "ÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯â€ Â°Â¢Â£Â§â€¢Â¶Ð†Â®Â©â„¢Ð‚Ñ’â‰ ÐƒÑ“âˆžÂ±â‰¤â‰¥Ñ–Âµâˆ‚ÐˆÐ„Ñ”Ð‡Ñ—Ð‰Ñ™ÐŠÑšÑ˜Ð…Â¬âˆšÆ’â‰ˆâˆ†Â«Â»â€¦Â Ð‹Ñ›ÐŒÑœÑ•â€“â€”â€œâ€â€˜â€™Ã·â€žÐŽÑžÐÑŸâ„–ÐÑ‘ÑÐ°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÂ¤"
    },
    "macgreek": {
      "type": "_sbcs",
      "chars": "Ã„Â¹Â²Ã‰Â³Ã–ÃœÎ…Ã Ã¢Ã¤Î„Â¨Ã§Ã©Ã¨ÃªÃ«Â£â„¢Ã®Ã¯â€¢Â½â€°Ã´Ã¶Â¦Â­Ã¹Ã»Ã¼â€ Î“Î”Î˜Î›ÎžÎ ÃŸÂ®Â©Î£ÎªÂ§â‰ Â°Î‡Î‘Â±â‰¤â‰¥Â¥Î’Î•Î–Î—Î™ÎšÎœÎ¦Î«Î¨Î©Î¬ÎÂ¬ÎŸÎ¡â‰ˆÎ¤Â«Â»â€¦Â Î¥Î§Î†ÎˆÅ“â€“â€•â€œâ€â€˜â€™Ã·Î‰ÎŠÎŒÎŽÎ­Î®Î¯ÏŒÎÏÎ±Î²ÏˆÎ´ÎµÏ†Î³Î·Î¹Î¾ÎºÎ»Î¼Î½Î¿Ï€ÏŽÏÏƒÏ„Î¸Ï‰Ï‚Ï‡Ï…Î¶ÏŠÏ‹ÎÎ°ï¿½"
    },
    "maciceland": {
      "type": "_sbcs",
      "chars": "Ã„Ã…Ã‡Ã‰Ã‘Ã–ÃœÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼ÃÂ°Â¢Â£Â§â€¢Â¶ÃŸÂ®Â©â„¢Â´Â¨â‰ Ã†Ã˜âˆžÂ±â‰¤â‰¥Â¥Âµâˆ‚âˆ‘âˆÏ€âˆ«ÂªÂºâ„¦Ã¦Ã¸Â¿Â¡Â¬âˆšÆ’â‰ˆâˆ†Â«Â»â€¦Â Ã€ÃƒÃ•Å’Å“â€“â€”â€œâ€â€˜â€™Ã·â—ŠÃ¿Å¸â„Â¤ÃÃ°ÃžÃ¾Ã½Â·â€šâ€žâ€°Ã‚ÃŠÃÃ‹ÃˆÃÃŽÃÃŒÃ“Ã”ï¿½Ã’ÃšÃ›Ã™Ä±Ë†ËœÂ¯Ë˜Ë™ËšÂ¸ËË›Ë‡"
    },
    "macroman": {
      "type": "_sbcs",
      "chars": "Ã„Ã…Ã‡Ã‰Ã‘Ã–ÃœÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼â€ Â°Â¢Â£Â§â€¢Â¶ÃŸÂ®Â©â„¢Â´Â¨â‰ Ã†Ã˜âˆžÂ±â‰¤â‰¥Â¥Âµâˆ‚âˆ‘âˆÏ€âˆ«ÂªÂºâ„¦Ã¦Ã¸Â¿Â¡Â¬âˆšÆ’â‰ˆâˆ†Â«Â»â€¦Â Ã€ÃƒÃ•Å’Å“â€“â€”â€œâ€â€˜â€™Ã·â—ŠÃ¿Å¸â„Â¤â€¹â€ºï¬ï¬‚â€¡Â·â€šâ€žâ€°Ã‚ÃŠÃÃ‹ÃˆÃÃŽÃÃŒÃ“Ã”ï¿½Ã’ÃšÃ›Ã™Ä±Ë†ËœÂ¯Ë˜Ë™ËšÂ¸ËË›Ë‡"
    },
    "macromania": {
      "type": "_sbcs",
      "chars": "Ã„Ã…Ã‡Ã‰Ã‘Ã–ÃœÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼â€ Â°Â¢Â£Â§â€¢Â¶ÃŸÂ®Â©â„¢Â´Â¨â‰ Ä‚ÅžâˆžÂ±â‰¤â‰¥Â¥Âµâˆ‚âˆ‘âˆÏ€âˆ«ÂªÂºâ„¦ÄƒÅŸÂ¿Â¡Â¬âˆšÆ’â‰ˆâˆ†Â«Â»â€¦Â Ã€ÃƒÃ•Å’Å“â€“â€”â€œâ€â€˜â€™Ã·â—ŠÃ¿Å¸â„Â¤â€¹â€ºÅ¢Å£â€¡Â·â€šâ€žâ€°Ã‚ÃŠÃÃ‹ÃˆÃÃŽÃÃŒÃ“Ã”ï¿½Ã’ÃšÃ›Ã™Ä±Ë†ËœÂ¯Ë˜Ë™ËšÂ¸ËË›Ë‡"
    },
    "macthai": {
      "type": "_sbcs",
      "chars": "Â«Â»â€¦ï¢Œï¢ï¢’ï¢•ï¢˜ï¢‹ï¢Žï¢‘ï¢”ï¢—â€œâ€ï¢™ï¿½â€¢ï¢„ï¢‰ï¢…ï¢†ï¢‡ï¢ˆï¢Šï¢ï¢ï¢“ï¢–â€˜â€™ï¿½Â à¸à¸‚à¸ƒà¸„à¸…à¸†à¸‡à¸ˆà¸‰à¸Šà¸‹à¸Œà¸à¸Žà¸à¸à¸‘à¸’à¸“à¸”à¸•à¸–à¸—à¸˜à¸™à¸šà¸›à¸œà¸à¸žà¸Ÿà¸ à¸¡à¸¢à¸£à¸¤à¸¥à¸¦à¸§à¸¨à¸©à¸ªà¸«à¸¬à¸­à¸®à¸¯à¸°à¸±à¸²à¸³à¸´à¸µà¸¶à¸·à¸¸à¸¹à¸º\uFEFFâ€‹â€“â€”à¸¿à¹€à¹à¹‚à¹ƒà¹„à¹…à¹†à¹‡à¹ˆà¹‰à¹Šà¹‹à¹Œà¹â„¢à¹à¹à¹‘à¹’à¹“à¹”à¹•à¹–à¹—à¹˜à¹™Â®Â©ï¿½ï¿½ï¿½ï¿½"
    },
    "macturkish": {
      "type": "_sbcs",
      "chars": "Ã„Ã…Ã‡Ã‰Ã‘Ã–ÃœÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼â€ Â°Â¢Â£Â§â€¢Â¶ÃŸÂ®Â©â„¢Â´Â¨â‰ Ã†Ã˜âˆžÂ±â‰¤â‰¥Â¥Âµâˆ‚âˆ‘âˆÏ€âˆ«ÂªÂºâ„¦Ã¦Ã¸Â¿Â¡Â¬âˆšÆ’â‰ˆâˆ†Â«Â»â€¦Â Ã€ÃƒÃ•Å’Å“â€“â€”â€œâ€â€˜â€™Ã·â—ŠÃ¿Å¸ÄžÄŸÄ°Ä±ÅžÅŸâ€¡Â·â€šâ€žâ€°Ã‚ÃŠÃÃ‹ÃˆÃÃŽÃÃŒÃ“Ã”ï¿½Ã’ÃšÃ›Ã™ï¿½Ë†ËœÂ¯Ë˜Ë™ËšÂ¸ËË›Ë‡"
    },
    "macukraine": {
      "type": "_sbcs",
      "chars": "ÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯â€ Â°ÒÂ£Â§â€¢Â¶Ð†Â®Â©â„¢Ð‚Ñ’â‰ ÐƒÑ“âˆžÂ±â‰¤â‰¥Ñ–ÂµÒ‘ÐˆÐ„Ñ”Ð‡Ñ—Ð‰Ñ™ÐŠÑšÑ˜Ð…Â¬âˆšÆ’â‰ˆâˆ†Â«Â»â€¦Â Ð‹Ñ›ÐŒÑœÑ•â€“â€”â€œâ€â€˜â€™Ã·â€žÐŽÑžÐÑŸâ„–ÐÑ‘ÑÐ°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÂ¤"
    },
    "koi8r": {
      "type": "_sbcs",
      "chars": "â”€â”‚â”Œâ”â””â”˜â”œâ”¤â”¬â”´â”¼â–€â–„â–ˆâ–Œâ–â–‘â–’â–“âŒ â– âˆ™âˆšâ‰ˆâ‰¤â‰¥Â âŒ¡Â°Â²Â·Ã·â•â•‘â•’Ñ‘â•“â•”â••â•–â•—â•˜â•™â•šâ•›â•œâ•â•žâ•Ÿâ• â•¡Ðâ•¢â•£â•¤â•¥â•¦â•§â•¨â•©â•ªâ•«â•¬Â©ÑŽÐ°Ð±Ñ†Ð´ÐµÑ„Ð³Ñ…Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿ÑÑ€ÑÑ‚ÑƒÐ¶Ð²ÑŒÑ‹Ð·ÑˆÑÑ‰Ñ‡ÑŠÐ®ÐÐ‘Ð¦Ð”Ð•Ð¤Ð“Ð¥Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ¯Ð Ð¡Ð¢Ð£Ð–Ð’Ð¬Ð«Ð—Ð¨Ð­Ð©Ð§Ðª"
    },
    "koi8u": {
      "type": "_sbcs",
      "chars": "â”€â”‚â”Œâ”â””â”˜â”œâ”¤â”¬â”´â”¼â–€â–„â–ˆâ–Œâ–â–‘â–’â–“âŒ â– âˆ™âˆšâ‰ˆâ‰¤â‰¥Â âŒ¡Â°Â²Â·Ã·â•â•‘â•’Ñ‘Ñ”â•”Ñ–Ñ—â•—â•˜â•™â•šâ•›Ò‘â•â•žâ•Ÿâ• â•¡ÐÐ„â•£Ð†Ð‡â•¦â•§â•¨â•©â•ªÒâ•¬Â©ÑŽÐ°Ð±Ñ†Ð´ÐµÑ„Ð³Ñ…Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿ÑÑ€ÑÑ‚ÑƒÐ¶Ð²ÑŒÑ‹Ð·ÑˆÑÑ‰Ñ‡ÑŠÐ®ÐÐ‘Ð¦Ð”Ð•Ð¤Ð“Ð¥Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ¯Ð Ð¡Ð¢Ð£Ð–Ð’Ð¬Ð«Ð—Ð¨Ð­Ð©Ð§Ðª"
    },
    "koi8ru": {
      "type": "_sbcs",
      "chars": "â”€â”‚â”Œâ”â””â”˜â”œâ”¤â”¬â”´â”¼â–€â–„â–ˆâ–Œâ–â–‘â–’â–“âŒ â– âˆ™âˆšâ‰ˆâ‰¤â‰¥Â âŒ¡Â°Â²Â·Ã·â•â•‘â•’Ñ‘Ñ”â•”Ñ–Ñ—â•—â•˜â•™â•šâ•›Ò‘Ñžâ•žâ•Ÿâ• â•¡ÐÐ„â•£Ð†Ð‡â•¦â•§â•¨â•©â•ªÒÐŽÂ©ÑŽÐ°Ð±Ñ†Ð´ÐµÑ„Ð³Ñ…Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿ÑÑ€ÑÑ‚ÑƒÐ¶Ð²ÑŒÑ‹Ð·ÑˆÑÑ‰Ñ‡ÑŠÐ®ÐÐ‘Ð¦Ð”Ð•Ð¤Ð“Ð¥Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ¯Ð Ð¡Ð¢Ð£Ð–Ð’Ð¬Ð«Ð—Ð¨Ð­Ð©Ð§Ðª"
    },
    "koi8t": {
      "type": "_sbcs",
      "chars": "Ò›Ò“â€šÒ’â€žâ€¦â€ â€¡ï¿½â€°Ò³â€¹Ò²Ò·Ò¶ï¿½Òšâ€˜â€™â€œâ€â€¢â€“â€”ï¿½â„¢ï¿½â€ºï¿½ï¿½ï¿½ï¿½ï¿½Ó¯Ó®Ñ‘Â¤Ó£Â¦Â§ï¿½ï¿½ï¿½Â«Â¬Â­Â®ï¿½Â°Â±Â²Ðï¿½Ó¢Â¶Â·ï¿½â„–ï¿½Â»ï¿½ï¿½ï¿½Â©ÑŽÐ°Ð±Ñ†Ð´ÐµÑ„Ð³Ñ…Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿ÑÑ€ÑÑ‚ÑƒÐ¶Ð²ÑŒÑ‹Ð·ÑˆÑÑ‰Ñ‡ÑŠÐ®ÐÐ‘Ð¦Ð”Ð•Ð¤Ð“Ð¥Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ¯Ð Ð¡Ð¢Ð£Ð–Ð’Ð¬Ð«Ð—Ð¨Ð­Ð©Ð§Ðª"
    },
    "armscii8": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ ï¿½Ö‡Ö‰)(Â»Â«â€”.Õ,-ÖŠâ€¦ÕœÕ›ÕžÔ±Õ¡Ô²Õ¢Ô³Õ£Ô´Õ¤ÔµÕ¥Ô¶Õ¦Ô·Õ§Ô¸Õ¨Ô¹Õ©ÔºÕªÔ»Õ«Ô¼Õ¬Ô½Õ­Ô¾Õ®Ô¿Õ¯Õ€Õ°ÕÕ±Õ‚Õ²ÕƒÕ³Õ„Õ´Õ…ÕµÕ†Õ¶Õ‡Õ·ÕˆÕ¸Õ‰Õ¹ÕŠÕºÕ‹Õ»ÕŒÕ¼ÕÕ½ÕŽÕ¾ÕÕ¿ÕÖ€Õ‘ÖÕ’Ö‚Õ“ÖƒÕ”Ö„Õ•Ö…Õ–Ö†Õšï¿½"
    },
    "rk1048": {
      "type": "_sbcs",
      "chars": "Ð‚Ðƒâ€šÑ“â€žâ€¦â€ â€¡â‚¬â€°Ð‰â€¹ÐŠÒšÒºÐÑ’â€˜â€™â€œâ€â€¢â€“â€”ï¿½â„¢Ñ™â€ºÑšÒ›Ò»ÑŸÂ Ò°Ò±Ó˜Â¤Ó¨Â¦Â§ÐÂ©Ò’Â«Â¬Â­Â®Ò®Â°Â±Ð†Ñ–Ó©ÂµÂ¶Â·Ñ‘â„–Ò“Â»Ó™Ò¢Ò£Ò¯ÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÑ"
    },
    "tcvn": {
      "type": "_sbcs",
      "chars": "\0Ãšá»¤á»ªá»¬á»®\x07\b	\n\v\f\rá»¨á»°á»²á»¶á»¸Ãá»´\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~Ã€áº¢ÃƒÃáº áº¶áº¬Ãˆáººáº¼Ã‰áº¸á»†ÃŒá»ˆÄ¨Ãá»ŠÃ’á»ŽÃ•Ã“á»Œá»˜á»œá»žá» á»šá»¢Ã™á»¦Å¨Â Ä‚Ã‚ÃŠÃ”Æ Æ¯ÄÄƒÃ¢ÃªÃ´Æ¡Æ°Ä‘áº°Ì€Ì‰ÌƒÌÌ£Ã áº£Ã£Ã¡áº¡áº²áº±áº³áºµáº¯áº´áº®áº¦áº¨áºªáº¤á»€áº·áº§áº©áº«áº¥áº­Ã¨á»‚áº»áº½Ã©áº¹á»á»ƒá»…áº¿á»‡Ã¬á»‰á»„áº¾á»’Ä©Ã­á»‹Ã²á»”á»ÃµÃ³á»á»“á»•á»—á»‘á»™á»á»Ÿá»¡á»›á»£Ã¹á»–á»§Å©Ãºá»¥á»«á»­á»¯á»©á»±á»³á»·á»¹Ã½á»µá»"
    },
    "georgianacademy": {
      "type": "_sbcs",
      "chars": "Â€Ââ€šÆ’â€žâ€¦â€ â€¡Ë†â€°Å â€¹Å’ÂÂŽÂÂâ€˜â€™â€œâ€â€¢â€“â€”Ëœâ„¢Å¡â€ºÅ“ÂÂžÅ¸Â Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿áƒáƒ‘áƒ’áƒ“áƒ”áƒ•áƒ–áƒ—áƒ˜áƒ™áƒšáƒ›áƒœáƒáƒžáƒŸáƒ áƒ¡áƒ¢áƒ£áƒ¤áƒ¥áƒ¦áƒ§áƒ¨áƒ©áƒªáƒ«áƒ¬áƒ­áƒ®áƒ¯áƒ°áƒ±áƒ²áƒ³áƒ´áƒµáƒ¶Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Ã°Ã±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ã½Ã¾Ã¿"
    },
    "georgianps": {
      "type": "_sbcs",
      "chars": "Â€Ââ€šÆ’â€žâ€¦â€ â€¡Ë†â€°Å â€¹Å’ÂÂŽÂÂâ€˜â€™â€œâ€â€¢â€“â€”Ëœâ„¢Å¡â€ºÅ“ÂÂžÅ¸Â Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿áƒáƒ‘áƒ’áƒ“áƒ”áƒ•áƒ–áƒ±áƒ—áƒ˜áƒ™áƒšáƒ›áƒœáƒ²áƒáƒžáƒŸáƒ áƒ¡áƒ¢áƒ³áƒ£áƒ¤áƒ¥áƒ¦áƒ§áƒ¨áƒ©áƒªáƒ«áƒ¬áƒ­áƒ®áƒ´áƒ¯áƒ°áƒµÃ¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Ã°Ã±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ã½Ã¾Ã¿"
    },
    "pt154": {
      "type": "_sbcs",
      "chars": "Ò–Ò’Ó®Ò“â€žâ€¦Ò¶Ò®Ò²Ò¯Ò Ó¢Ò¢ÒšÒºÒ¸Ò—â€˜â€™â€œâ€â€¢â€“â€”Ò³Ò·Ò¡Ó£Ò£Ò›Ò»Ò¹Â ÐŽÑžÐˆÓ¨Ò˜Ò°Â§ÐÂ©Ó˜Â«Â¬Ó¯Â®ÒœÂ°Ò±Ð†Ñ–Ò™Ó©Â¶Â·Ñ‘â„–Ó™Â»Ñ˜ÒªÒ«ÒÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÑ"
    },
    "viscii": {
      "type": "_sbcs",
      "chars": "\0áº²áº´áºª\x07\b	\n\v\f\rá»¶á»¸\x1Bá»´ !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~áº áº®áº°áº¶áº¤áº¦áº¨áº¬áº¼áº¸áº¾á»€á»‚á»„á»†á»á»’á»”á»–á»˜á»¢á»šá»œá»žá»Šá»Žá»Œá»ˆá»¦Å¨á»¤á»²Ã•áº¯áº±áº·áº¥áº§áº©áº­áº½áº¹áº¿á»á»ƒá»…á»‡á»‘á»“á»•á»—á» Æ á»™á»á»Ÿá»‹á»°á»¨á»ªá»¬Æ¡á»›Æ¯Ã€ÃÃ‚Ãƒáº¢Ä‚áº³áºµÃˆÃ‰ÃŠáººÃŒÃÄ¨á»³Äá»©Ã’Ã“Ã”áº¡á»·á»«á»­Ã™Ãšá»¹á»µÃá»¡Æ°Ã Ã¡Ã¢Ã£áº£Äƒá»¯áº«Ã¨Ã©Ãªáº»Ã¬Ã­Ä©á»‰Ä‘á»±Ã²Ã³Ã´Ãµá»á»á»¥Ã¹ÃºÅ©á»§Ã½á»£á»®"
    },
    "iso646cn": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#Â¥%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}â€¾ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½"
    },
    "iso646jp": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[Â¥]^_`abcdefghijklmnopqrstuvwxyz{|}â€¾ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½"
    },
    "hproman8": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ Ã€Ã‚ÃˆÃŠÃ‹ÃŽÃÂ´Ë‹Ë†Â¨ËœÃ™Ã›â‚¤Â¯ÃÃ½Â°Ã‡Ã§Ã‘Ã±Â¡Â¿Â¤Â£Â¥Â§Æ’Â¢Ã¢ÃªÃ´Ã»Ã¡Ã©Ã³ÃºÃ Ã¨Ã²Ã¹Ã¤Ã«Ã¶Ã¼Ã…Ã®Ã˜Ã†Ã¥Ã­Ã¸Ã¦Ã„Ã¬Ã–ÃœÃ‰Ã¯ÃŸÃ”ÃÃƒÃ£ÃÃ°ÃÃŒÃ“Ã’Ã•ÃµÅ Å¡ÃšÅ¸Ã¿ÃžÃ¾Â·ÂµÂ¶Â¾â€”Â¼Â½ÂªÂºÂ«â– Â»Â±ï¿½"
    },
    "macintosh": {
      "type": "_sbcs",
      "chars": "Ã„Ã…Ã‡Ã‰Ã‘Ã–ÃœÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼â€ Â°Â¢Â£Â§â€¢Â¶ÃŸÂ®Â©â„¢Â´Â¨â‰ Ã†Ã˜âˆžÂ±â‰¤â‰¥Â¥Âµâˆ‚âˆ‘âˆÏ€âˆ«ÂªÂºâ„¦Ã¦Ã¸Â¿Â¡Â¬âˆšÆ’â‰ˆâˆ†Â«Â»â€¦Â Ã€ÃƒÃ•Å’Å“â€“â€”â€œâ€â€˜â€™Ã·â—ŠÃ¿Å¸â„Â¤â€¹â€ºï¬ï¬‚â€¡Â·â€šâ€žâ€°Ã‚ÃŠÃÃ‹ÃˆÃÃŽÃÃŒÃ“Ã”ï¿½Ã’ÃšÃ›Ã™Ä±Ë†ËœÂ¯Ë˜Ë™ËšÂ¸ËË›Ë‡"
    },
    "ascii": {
      "type": "_sbcs",
      "chars": "ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½"
    },
    "tis620": {
      "type": "_sbcs",
      "chars": "ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½à¸à¸‚à¸ƒà¸„à¸…à¸†à¸‡à¸ˆà¸‰à¸Šà¸‹à¸Œà¸à¸Žà¸à¸à¸‘à¸’à¸“à¸”à¸•à¸–à¸—à¸˜à¸™à¸šà¸›à¸œà¸à¸žà¸Ÿà¸ à¸¡à¸¢à¸£à¸¤à¸¥à¸¦à¸§à¸¨à¸©à¸ªà¸«à¸¬à¸­à¸®à¸¯à¸°à¸±à¸²à¸³à¸´à¸µà¸¶à¸·à¸¸à¸¹à¸ºï¿½ï¿½ï¿½ï¿½à¸¿à¹€à¹à¹‚à¹ƒà¹„à¹…à¹†à¹‡à¹ˆà¹‰à¹Šà¹‹à¹Œà¹à¹Žà¹à¹à¹‘à¹’à¹“à¹”à¹•à¹–à¹—à¹˜à¹™à¹šà¹›ï¿½ï¿½ï¿½ï¿½"
    }
  };
  return sbcsDataGenerated;
}
var dbcsCodec = {};
var hasRequiredDbcsCodec;
function requireDbcsCodec() {
  if (hasRequiredDbcsCodec)
    return dbcsCodec;
  hasRequiredDbcsCodec = 1;
  var Buffer2 = requireSafer().Buffer;
  dbcsCodec._dbcs = DBCSCodec;
  var UNASSIGNED = -1, GB18030_CODE = -2, SEQ_START = -10, NODE_START = -1e3, UNASSIGNED_NODE = new Array(256), DEF_CHAR = -1;
  for (var i = 0; i < 256; i++)
    UNASSIGNED_NODE[i] = UNASSIGNED;
  function DBCSCodec(codecOptions, iconv) {
    this.encodingName = codecOptions.encodingName;
    if (!codecOptions)
      throw new Error("DBCS codec is called without the data.");
    if (!codecOptions.table)
      throw new Error("Encoding '" + this.encodingName + "' has no data.");
    var mappingTable = codecOptions.table();
    this.decodeTables = [];
    this.decodeTables[0] = UNASSIGNED_NODE.slice(0);
    this.decodeTableSeq = [];
    for (var i2 = 0; i2 < mappingTable.length; i2++)
      this._addDecodeChunk(mappingTable[i2]);
    this.defaultCharUnicode = iconv.defaultCharUnicode;
    this.encodeTable = [];
    this.encodeTableSeq = [];
    var skipEncodeChars = {};
    if (codecOptions.encodeSkipVals)
      for (var i2 = 0; i2 < codecOptions.encodeSkipVals.length; i2++) {
        var val = codecOptions.encodeSkipVals[i2];
        if (typeof val === "number")
          skipEncodeChars[val] = true;
        else
          for (var j2 = val.from; j2 <= val.to; j2++)
            skipEncodeChars[j2] = true;
      }
    this._fillEncodeTable(0, 0, skipEncodeChars);
    if (codecOptions.encodeAdd) {
      for (var uChar in codecOptions.encodeAdd)
        if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar))
          this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
    }
    this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
    if (this.defCharSB === UNASSIGNED)
      this.defCharSB = this.encodeTable[0]["?"];
    if (this.defCharSB === UNASSIGNED)
      this.defCharSB = "?".charCodeAt(0);
    if (typeof codecOptions.gb18030 === "function") {
      this.gb18030 = codecOptions.gb18030();
      var thirdByteNodeIdx = this.decodeTables.length;
      var thirdByteNode = this.decodeTables[thirdByteNodeIdx] = UNASSIGNED_NODE.slice(0);
      var fourthByteNodeIdx = this.decodeTables.length;
      var fourthByteNode = this.decodeTables[fourthByteNodeIdx] = UNASSIGNED_NODE.slice(0);
      for (var i2 = 129; i2 <= 254; i2++) {
        var secondByteNodeIdx = NODE_START - this.decodeTables[0][i2];
        var secondByteNode = this.decodeTables[secondByteNodeIdx];
        for (var j2 = 48; j2 <= 57; j2++)
          secondByteNode[j2] = NODE_START - thirdByteNodeIdx;
      }
      for (var i2 = 129; i2 <= 254; i2++)
        thirdByteNode[i2] = NODE_START - fourthByteNodeIdx;
      for (var i2 = 48; i2 <= 57; i2++)
        fourthByteNode[i2] = GB18030_CODE;
    }
  }
  DBCSCodec.prototype.encoder = DBCSEncoder;
  DBCSCodec.prototype.decoder = DBCSDecoder;
  DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
    var bytes2 = [];
    for (; addr > 0; addr >>= 8)
      bytes2.push(addr & 255);
    if (bytes2.length == 0)
      bytes2.push(0);
    var node2 = this.decodeTables[0];
    for (var i2 = bytes2.length - 1; i2 > 0; i2--) {
      var val = node2[bytes2[i2]];
      if (val == UNASSIGNED) {
        node2[bytes2[i2]] = NODE_START - this.decodeTables.length;
        this.decodeTables.push(node2 = UNASSIGNED_NODE.slice(0));
      } else if (val <= NODE_START) {
        node2 = this.decodeTables[NODE_START - val];
      } else
        throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
    }
    return node2;
  };
  DBCSCodec.prototype._addDecodeChunk = function(chunk) {
    var curAddr = parseInt(chunk[0], 16);
    var writeTable = this._getDecodeTrieNode(curAddr);
    curAddr = curAddr & 255;
    for (var k2 = 1; k2 < chunk.length; k2++) {
      var part = chunk[k2];
      if (typeof part === "string") {
        for (var l = 0; l < part.length; ) {
          var code = part.charCodeAt(l++);
          if (55296 <= code && code < 56320) {
            var codeTrail = part.charCodeAt(l++);
            if (56320 <= codeTrail && codeTrail < 57344)
              writeTable[curAddr++] = 65536 + (code - 55296) * 1024 + (codeTrail - 56320);
            else
              throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]);
          } else if (4080 < code && code <= 4095) {
            var len = 4095 - code + 2;
            var seq = [];
            for (var m2 = 0; m2 < len; m2++)
              seq.push(part.charCodeAt(l++));
            writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
            this.decodeTableSeq.push(seq);
          } else
            writeTable[curAddr++] = code;
        }
      } else if (typeof part === "number") {
        var charCode = writeTable[curAddr - 1] + 1;
        for (var l = 0; l < part; l++)
          writeTable[curAddr++] = charCode++;
      } else
        throw new Error("Incorrect type '" + typeof part + "' given in " + this.encodingName + " at chunk " + chunk[0]);
    }
    if (curAddr > 255)
      throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
  };
  DBCSCodec.prototype._getEncodeBucket = function(uCode) {
    var high = uCode >> 8;
    if (this.encodeTable[high] === void 0)
      this.encodeTable[high] = UNASSIGNED_NODE.slice(0);
    return this.encodeTable[high];
  };
  DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 255;
    if (bucket[low] <= SEQ_START)
      this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode;
    else if (bucket[low] == UNASSIGNED)
      bucket[low] = dbcsCode;
  };
  DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
    var uCode = seq[0];
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 255;
    var node2;
    if (bucket[low] <= SEQ_START) {
      node2 = this.encodeTableSeq[SEQ_START - bucket[low]];
    } else {
      node2 = {};
      if (bucket[low] !== UNASSIGNED)
        node2[DEF_CHAR] = bucket[low];
      bucket[low] = SEQ_START - this.encodeTableSeq.length;
      this.encodeTableSeq.push(node2);
    }
    for (var j2 = 1; j2 < seq.length - 1; j2++) {
      var oldVal = node2[uCode];
      if (typeof oldVal === "object")
        node2 = oldVal;
      else {
        node2 = node2[uCode] = {};
        if (oldVal !== void 0)
          node2[DEF_CHAR] = oldVal;
      }
    }
    uCode = seq[seq.length - 1];
    node2[uCode] = dbcsCode;
  };
  DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
    var node2 = this.decodeTables[nodeIdx];
    for (var i2 = 0; i2 < 256; i2++) {
      var uCode = node2[i2];
      var mbCode = prefix + i2;
      if (skipEncodeChars[mbCode])
        continue;
      if (uCode >= 0)
        this._setEncodeChar(uCode, mbCode);
      else if (uCode <= NODE_START)
        this._fillEncodeTable(NODE_START - uCode, mbCode << 8, skipEncodeChars);
      else if (uCode <= SEQ_START)
        this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
    }
  };
  function DBCSEncoder(options, codec) {
    this.leadSurrogate = -1;
    this.seqObj = void 0;
    this.encodeTable = codec.encodeTable;
    this.encodeTableSeq = codec.encodeTableSeq;
    this.defaultCharSingleByte = codec.defCharSB;
    this.gb18030 = codec.gb18030;
  }
  DBCSEncoder.prototype.write = function(str) {
    var newBuf = Buffer2.alloc(str.length * (this.gb18030 ? 4 : 3)), leadSurrogate = this.leadSurrogate, seqObj = this.seqObj, nextChar = -1, i2 = 0, j2 = 0;
    while (true) {
      if (nextChar === -1) {
        if (i2 == str.length)
          break;
        var uCode = str.charCodeAt(i2++);
      } else {
        var uCode = nextChar;
        nextChar = -1;
      }
      if (55296 <= uCode && uCode < 57344) {
        if (uCode < 56320) {
          if (leadSurrogate === -1) {
            leadSurrogate = uCode;
            continue;
          } else {
            leadSurrogate = uCode;
            uCode = UNASSIGNED;
          }
        } else {
          if (leadSurrogate !== -1) {
            uCode = 65536 + (leadSurrogate - 55296) * 1024 + (uCode - 56320);
            leadSurrogate = -1;
          } else {
            uCode = UNASSIGNED;
          }
        }
      } else if (leadSurrogate !== -1) {
        nextChar = uCode;
        uCode = UNASSIGNED;
        leadSurrogate = -1;
      }
      var dbcsCode = UNASSIGNED;
      if (seqObj !== void 0 && uCode != UNASSIGNED) {
        var resCode = seqObj[uCode];
        if (typeof resCode === "object") {
          seqObj = resCode;
          continue;
        } else if (typeof resCode == "number") {
          dbcsCode = resCode;
        } else if (resCode == void 0) {
          resCode = seqObj[DEF_CHAR];
          if (resCode !== void 0) {
            dbcsCode = resCode;
            nextChar = uCode;
          }
        }
        seqObj = void 0;
      } else if (uCode >= 0) {
        var subtable = this.encodeTable[uCode >> 8];
        if (subtable !== void 0)
          dbcsCode = subtable[uCode & 255];
        if (dbcsCode <= SEQ_START) {
          seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
          continue;
        }
        if (dbcsCode == UNASSIGNED && this.gb18030) {
          var idx = findIdx(this.gb18030.uChars, uCode);
          if (idx != -1) {
            var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
            newBuf[j2++] = 129 + Math.floor(dbcsCode / 12600);
            dbcsCode = dbcsCode % 12600;
            newBuf[j2++] = 48 + Math.floor(dbcsCode / 1260);
            dbcsCode = dbcsCode % 1260;
            newBuf[j2++] = 129 + Math.floor(dbcsCode / 10);
            dbcsCode = dbcsCode % 10;
            newBuf[j2++] = 48 + dbcsCode;
            continue;
          }
        }
      }
      if (dbcsCode === UNASSIGNED)
        dbcsCode = this.defaultCharSingleByte;
      if (dbcsCode < 256) {
        newBuf[j2++] = dbcsCode;
      } else if (dbcsCode < 65536) {
        newBuf[j2++] = dbcsCode >> 8;
        newBuf[j2++] = dbcsCode & 255;
      } else {
        newBuf[j2++] = dbcsCode >> 16;
        newBuf[j2++] = dbcsCode >> 8 & 255;
        newBuf[j2++] = dbcsCode & 255;
      }
    }
    this.seqObj = seqObj;
    this.leadSurrogate = leadSurrogate;
    return newBuf.slice(0, j2);
  };
  DBCSEncoder.prototype.end = function() {
    if (this.leadSurrogate === -1 && this.seqObj === void 0)
      return;
    var newBuf = Buffer2.alloc(10), j2 = 0;
    if (this.seqObj) {
      var dbcsCode = this.seqObj[DEF_CHAR];
      if (dbcsCode !== void 0) {
        if (dbcsCode < 256) {
          newBuf[j2++] = dbcsCode;
        } else {
          newBuf[j2++] = dbcsCode >> 8;
          newBuf[j2++] = dbcsCode & 255;
        }
      }
      this.seqObj = void 0;
    }
    if (this.leadSurrogate !== -1) {
      newBuf[j2++] = this.defaultCharSingleByte;
      this.leadSurrogate = -1;
    }
    return newBuf.slice(0, j2);
  };
  DBCSEncoder.prototype.findIdx = findIdx;
  function DBCSDecoder(options, codec) {
    this.nodeIdx = 0;
    this.prevBuf = Buffer2.alloc(0);
    this.decodeTables = codec.decodeTables;
    this.decodeTableSeq = codec.decodeTableSeq;
    this.defaultCharUnicode = codec.defaultCharUnicode;
    this.gb18030 = codec.gb18030;
  }
  DBCSDecoder.prototype.write = function(buf) {
    var newBuf = Buffer2.alloc(buf.length * 2), nodeIdx = this.nodeIdx, prevBuf = this.prevBuf, prevBufOffset = this.prevBuf.length, seqStart = -this.prevBuf.length, uCode;
    if (prevBufOffset > 0)
      prevBuf = Buffer2.concat([prevBuf, buf.slice(0, 10)]);
    for (var i2 = 0, j2 = 0; i2 < buf.length; i2++) {
      var curByte = i2 >= 0 ? buf[i2] : prevBuf[i2 + prevBufOffset];
      var uCode = this.decodeTables[nodeIdx][curByte];
      if (uCode >= 0)
        ;
      else if (uCode === UNASSIGNED) {
        i2 = seqStart;
        uCode = this.defaultCharUnicode.charCodeAt(0);
      } else if (uCode === GB18030_CODE) {
        var curSeq = seqStart >= 0 ? buf.slice(seqStart, i2 + 1) : prevBuf.slice(seqStart + prevBufOffset, i2 + 1 + prevBufOffset);
        var ptr = (curSeq[0] - 129) * 12600 + (curSeq[1] - 48) * 1260 + (curSeq[2] - 129) * 10 + (curSeq[3] - 48);
        var idx = findIdx(this.gb18030.gbChars, ptr);
        uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
      } else if (uCode <= NODE_START) {
        nodeIdx = NODE_START - uCode;
        continue;
      } else if (uCode <= SEQ_START) {
        var seq = this.decodeTableSeq[SEQ_START - uCode];
        for (var k2 = 0; k2 < seq.length - 1; k2++) {
          uCode = seq[k2];
          newBuf[j2++] = uCode & 255;
          newBuf[j2++] = uCode >> 8;
        }
        uCode = seq[seq.length - 1];
      } else
        throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);
      if (uCode > 65535) {
        uCode -= 65536;
        var uCodeLead = 55296 + Math.floor(uCode / 1024);
        newBuf[j2++] = uCodeLead & 255;
        newBuf[j2++] = uCodeLead >> 8;
        uCode = 56320 + uCode % 1024;
      }
      newBuf[j2++] = uCode & 255;
      newBuf[j2++] = uCode >> 8;
      nodeIdx = 0;
      seqStart = i2 + 1;
    }
    this.nodeIdx = nodeIdx;
    this.prevBuf = seqStart >= 0 ? buf.slice(seqStart) : prevBuf.slice(seqStart + prevBufOffset);
    return newBuf.slice(0, j2).toString("ucs2");
  };
  DBCSDecoder.prototype.end = function() {
    var ret = "";
    while (this.prevBuf.length > 0) {
      ret += this.defaultCharUnicode;
      var buf = this.prevBuf.slice(1);
      this.prevBuf = Buffer2.alloc(0);
      this.nodeIdx = 0;
      if (buf.length > 0)
        ret += this.write(buf);
    }
    this.nodeIdx = 0;
    return ret;
  };
  function findIdx(table, val) {
    if (table[0] > val)
      return -1;
    var l = 0, r = table.length;
    while (l < r - 1) {
      var mid = l + Math.floor((r - l + 1) / 2);
      if (table[mid] <= val)
        l = mid;
      else
        r = mid;
    }
    return l;
  }
  return dbcsCodec;
}
const require$$0$1 = [
  [
    "0",
    "\0",
    128
  ],
  [
    "a1",
    "ï½¡",
    62
  ],
  [
    "8140",
    "ã€€ã€ã€‚ï¼Œï¼Žãƒ»ï¼šï¼›ï¼Ÿï¼ã‚›ã‚œÂ´ï½€Â¨ï¼¾ï¿£ï¼¿ãƒ½ãƒ¾ã‚ã‚žã€ƒä»ã€…ã€†ã€‡ãƒ¼â€•â€ï¼ï¼¼ï½žâˆ¥ï½œâ€¦â€¥â€˜â€™â€œâ€ï¼ˆï¼‰ã€”ã€•ï¼»ï¼½ï½›ï½ã€ˆ",
    9,
    "ï¼‹ï¼Â±Ã—"
  ],
  [
    "8180",
    "Ã·ï¼â‰ ï¼œï¼žâ‰¦â‰§âˆžâˆ´â™‚â™€Â°â€²â€³â„ƒï¿¥ï¼„ï¿ ï¿¡ï¼…ï¼ƒï¼†ï¼Šï¼ Â§â˜†â˜…â—‹â—â—Žâ—‡â—†â–¡â– â–³â–²â–½â–¼â€»ã€’â†’â†â†‘â†“ã€“"
  ],
  [
    "81b8",
    "âˆˆâˆ‹âŠ†âŠ‡âŠ‚âŠƒâˆªâˆ©"
  ],
  [
    "81c8",
    "âˆ§âˆ¨ï¿¢â‡’â‡”âˆ€âˆƒ"
  ],
  [
    "81da",
    "âˆ âŠ¥âŒ’âˆ‚âˆ‡â‰¡â‰’â‰ªâ‰«âˆšâˆ½âˆâˆµâˆ«âˆ¬"
  ],
  [
    "81f0",
    "â„«â€°â™¯â™­â™ªâ€ â€¡Â¶"
  ],
  [
    "81fc",
    "â—¯"
  ],
  [
    "824f",
    "ï¼",
    9
  ],
  [
    "8260",
    "ï¼¡",
    25
  ],
  [
    "8281",
    "ï½",
    25
  ],
  [
    "829f",
    "ã",
    82
  ],
  [
    "8340",
    "ã‚¡",
    62
  ],
  [
    "8380",
    "ãƒ ",
    22
  ],
  [
    "839f",
    "Î‘",
    16,
    "Î£",
    6
  ],
  [
    "83bf",
    "Î±",
    16,
    "Ïƒ",
    6
  ],
  [
    "8440",
    "Ð",
    5,
    "ÐÐ–",
    25
  ],
  [
    "8470",
    "Ð°",
    5,
    "Ñ‘Ð¶",
    7
  ],
  [
    "8480",
    "Ð¾",
    17
  ],
  [
    "849f",
    "â”€â”‚â”Œâ”â”˜â””â”œâ”¬â”¤â”´â”¼â”â”ƒâ”â”“â”›â”—â”£â”³â”«â”»â•‹â” â”¯â”¨â”·â”¿â”â”°â”¥â”¸â•‚"
  ],
  [
    "8740",
    "â‘ ",
    19,
    "â… ",
    9
  ],
  [
    "875f",
    "ã‰ãŒ”ãŒ¢ããŒ˜ãŒ§ãŒƒãŒ¶ã‘ã—ãŒãŒ¦ãŒ£ãŒ«ãŠãŒ»ãŽœãŽãŽžãŽŽãŽã„ãŽ¡"
  ],
  [
    "877e",
    "ã»"
  ],
  [
    "8780",
    "ã€ã€Ÿâ„–ãâ„¡ãŠ¤",
    4,
    "ãˆ±ãˆ²ãˆ¹ã¾ã½ã¼â‰’â‰¡âˆ«âˆ®âˆ‘âˆšâŠ¥âˆ âˆŸâŠ¿âˆµâˆ©âˆª"
  ],
  [
    "889f",
    "äºœå”–å¨ƒé˜¿å“€æ„›æŒ¨å§¶é€¢è‘µèŒœç©æ‚ªæ¡æ¸¥æ—­è‘¦èŠ¦é¯µæ¢“åœ§æ–¡æ‰±å®›å§è™»é£´çµ¢ç¶¾é®Žæˆ–ç²Ÿè¢·å®‰åºµæŒ‰æš—æ¡ˆé—‡éžæä»¥ä¼Šä½ä¾å‰å›²å¤·å§”å¨å°‰æƒŸæ„æ…°æ˜“æ¤…ç‚ºç•ç•°ç§»ç¶­ç·¯èƒƒèŽè¡£è¬‚é•éºåŒ»äº•äº¥åŸŸè‚²éƒç£¯ä¸€å£±æº¢é€¸ç¨²èŒ¨èŠ‹é°¯å…å°å’½å“¡å› å§»å¼•é£²æ·«èƒ¤è”­"
  ],
  [
    "8940",
    "é™¢é™°éš éŸ»å‹å³å®‡çƒç¾½è¿‚é›¨å¯éµœçªºä¸‘ç¢“è‡¼æ¸¦å˜˜å”„æ¬è”šé°»å§¥åŽ©æµ¦ç“œé–å™‚äº‘é‹é›²èé¤Œå¡å–¶å¬°å½±æ˜ æ›³æ „æ°¸æ³³æ´©ç‘›ç›ˆç©Žé ´è‹±è¡›è© é‹­æ¶²ç–«ç›Šé§…æ‚¦è¬è¶Šé–²æ¦ŽåŽ­å††"
  ],
  [
    "8980",
    "åœ’å °å¥„å®´å»¶æ€¨æŽ©æ´æ²¿æ¼”ç‚Žç„”ç…™ç‡•çŒ¿ç¸è‰¶è‹‘è–—é é‰›é´›å¡©æ–¼æ±šç”¥å‡¹å¤®å¥¥å¾€å¿œæŠ¼æ—ºæ¨ªæ¬§æ®´çŽ‹ç¿è¥–é´¬é´Žé»„å²¡æ²–è»å„„å±‹æ†¶è‡†æ¡¶ç‰¡ä¹™ä¿ºå¸æ©æ¸©ç©éŸ³ä¸‹åŒ–ä»®ä½•ä¼½ä¾¡ä½³åŠ å¯å˜‰å¤å«å®¶å¯¡ç§‘æš‡æžœæž¶æ­Œæ²³ç«ç‚ç¦ç¦¾ç¨¼ç®‡èŠ±è‹›èŒ„è·è¯è“è¦èª²å˜©è²¨è¿¦éŽéœžèšŠä¿„å³¨æˆ‘ç‰™ç”»è‡¥èŠ½è›¾è³€é›…é¤“é§•ä»‹ä¼šè§£å›žå¡Šå£Šå»»å¿«æ€ªæ‚”æ¢æ‡æˆ’æ‹æ”¹"
  ],
  [
    "8a40",
    "é­æ™¦æ¢°æµ·ç°ç•Œçš†çµµèŠ¥èŸ¹é–‹éšŽè²å‡±åŠ¾å¤–å’³å®³å´–æ…¨æ¦‚æ¶¯ç¢è“‹è¡—è©²éŽ§éª¸æµ¬é¦¨è›™åž£æŸ¿è›ŽéˆŽåŠƒåš‡å„å»“æ‹¡æ’¹æ ¼æ ¸æ®»ç²ç¢ºç©«è¦šè§’èµ«è¼ƒéƒ­é–£éš”é©å­¦å²³æ¥½é¡é¡ŽæŽ›ç¬ æ¨«"
  ],
  [
    "8a80",
    "æ©¿æ¢¶é°æ½Ÿå‰²å–æ°æ‹¬æ´»æ¸‡æ»‘è‘›è¤è½„ä¸”é°¹å¶æ¤›æ¨ºéž„æ ªå…œç«ƒè’²é‡œéŽŒå™›é´¨æ ¢èŒ…è±ç²¥åˆˆè‹…ç“¦ä¹¾ä¾ƒå† å¯’åˆŠå‹˜å‹§å·»å–šå ªå§¦å®Œå®˜å¯›å¹²å¹¹æ‚£æ„Ÿæ…£æ†¾æ›æ•¢æŸ‘æ¡“æ£ºæ¬¾æ­“æ±—æ¼¢æ¾—æ½…ç’°ç”˜ç›£çœ‹ç«¿ç®¡ç°¡ç·©ç¼¶ç¿°è‚è‰¦èŽžè¦³è«Œè²«é‚„é‘‘é–“é–‘é–¢é™¥éŸ“é¤¨èˆ˜ä¸¸å«å²¸å·ŒçŽ©ç™Œçœ¼å²©ç¿«è´‹é›é ‘é¡”é¡˜ä¼ä¼Žå±å–œå™¨åŸºå¥‡å¬‰å¯„å²å¸Œå¹¾å¿Œæ®æœºæ——æ—¢æœŸæ£‹æ£„"
  ],
  [
    "8b40",
    "æ©Ÿå¸°æ¯…æ°—æ±½ç•¿ç¥ˆå­£ç¨€ç´€å¾½è¦è¨˜è²´èµ·è»Œè¼é£¢é¨Žé¬¼äº€å½å„€å¦“å®œæˆ¯æŠ€æ“¬æ¬ºçŠ ç–‘ç¥‡ç¾©èŸ»èª¼è­°æŽ¬èŠéž å‰åƒå–«æ¡”æ©˜è©°ç §æµé»å´å®¢è„šè™é€†ä¸˜ä¹…ä»‡ä¼‘åŠå¸å®®å¼“æ€¥æ•‘"
  ],
  [
    "8b80",
    "æœ½æ±‚æ±²æ³£ç¸çƒç©¶çª®ç¬ˆç´šç³¾çµ¦æ—§ç‰›åŽ»å±…å·¨æ‹’æ‹ æŒ™æ¸ è™šè¨±è·é‹¸æ¼ç¦¦é­šäº¨äº«äº¬ä¾›ä¾ åƒ‘å…‡ç«¶å…±å‡¶å”åŒ¡å¿å«å–¬å¢ƒå³¡å¼·å½Šæ€¯ææ­æŒŸæ•™æ©‹æ³ç‹‚ç‹­çŸ¯èƒ¸è„…èˆˆè•Žéƒ·é¡éŸ¿é¥—é©šä»°å‡å°­æšæ¥­å±€æ›²æ¥µçŽ‰æ¡ç²åƒ…å‹¤å‡å·¾éŒ¦æ–¤æ¬£æ¬½ç´ç¦ç¦½ç­‹ç·ŠèŠ¹èŒè¡¿è¥Ÿè¬¹è¿‘é‡‘åŸéŠ€ä¹å€¶å¥åŒºç‹—çŽ–çŸ©è‹¦èº¯é§†é§ˆé§’å…·æ„šè™žå–°ç©ºå¶å¯“é‡éš…ä¸²æ«›é‡§å±‘å±ˆ"
  ],
  [
    "8c40",
    "æŽ˜çªŸæ²“é´è½¡çªªç†Šéšˆç²‚æ —ç¹°æ¡‘é¬å‹²å›è–«è¨“ç¾¤è»éƒ¡å¦è¢ˆç¥ä¿‚å‚¾åˆ‘å…„å•“åœ­çªåž‹å¥‘å½¢å¾„æµæ…¶æ…§æ†©æŽ²æºæ•¬æ™¯æ¡‚æ¸“ç•¦ç¨½ç³»çµŒç¶™ç¹‹ç½«èŒŽèŠè›è¨ˆè©£è­¦è»½é šé¶èŠ¸è¿Žé¯¨"
  ],
  [
    "8c80",
    "åŠ‡æˆŸæ’ƒæ¿€éš™æ¡å‚‘æ¬ æ±ºæ½”ç©´çµè¡€è¨£æœˆä»¶å€¹å€¦å¥å…¼åˆ¸å‰£å–§åœå …å«Œå»ºæ†²æ‡¸æ‹³æ²æ¤œæ¨©ç‰½çŠ¬çŒ®ç ”ç¡¯çµ¹çœŒè‚©è¦‹è¬™è³¢è»’é£éµé™ºé¡•é¨“é¹¸å…ƒåŽŸåŽ³å¹»å¼¦æ¸›æºçŽ„ç¾çµƒèˆ·è¨€è«ºé™ä¹Žå€‹å¤å‘¼å›ºå§‘å­¤å·±åº«å¼§æˆ¸æ•…æž¯æ¹–ç‹ç³Šè¢´è‚¡èƒ¡è°è™Žèª‡è·¨éˆ·é›‡é¡§é¼“äº”äº’ä¼åˆå‘‰å¾å¨¯å¾Œå¾¡æ‚Ÿæ¢§æªŽç‘šç¢èªžèª¤è­·é†ä¹žé¯‰äº¤ä½¼ä¾¯å€™å€–å…‰å…¬åŠŸåŠ¹å‹¾åŽšå£å‘"
  ],
  [
    "8d40",
    "åŽå–‰å‘åž¢å¥½å­”å­å®å·¥å·§å··å¹¸åºƒåºšåº·å¼˜æ’æ…ŒæŠ—æ‹˜æŽ§æ”»æ˜‚æ™ƒæ›´æ­æ ¡æ¢—æ§‹æ±Ÿæ´ªæµ©æ¸¯æºç”²çš‡ç¡¬ç¨¿ç³ ç´…ç´˜çµžç¶±è€•è€ƒè‚¯è‚±è…”è†èˆªè’è¡Œè¡¡è¬›è²¢è³¼éƒŠé…µé‰±ç ¿é‹¼é–¤é™"
  ],
  [
    "8d80",
    "é …é¦™é«˜é´»å‰›åŠ«å·åˆå£•æ‹·æ¿ è±ªè½Ÿéº¹å…‹åˆ»å‘Šå›½ç©€é…·éµ é»’ç„æ¼‰è…°ç”‘å¿½æƒšéª¨ç‹›è¾¼æ­¤é ƒä»Šå›°å¤å¢¾å©šæ¨æ‡‡æ˜æ˜†æ ¹æ¢±æ··ç—•ç´ºè‰®é­‚äº›ä½å‰å”†åµ¯å·¦å·®æŸ»æ²™ç‘³ç ‚è©éŽ–è£Ÿååº§æŒ«å‚µå‚¬å†æœ€å“‰å¡žå¦»å®°å½©æ‰æŽ¡æ ½æ­³æ¸ˆç½é‡‡çŠ€ç •ç ¦ç¥­æ–Žç´°èœè£è¼‰éš›å‰¤åœ¨æç½ªè²¡å†´å‚é˜ªå ºæ¦Šè‚´å’²å´ŽåŸ¼ç¢•é·ºä½œå‰Šå’‹æ¾æ˜¨æœ”æŸµçª„ç­–ç´¢éŒ¯æ¡œé®­ç¬¹åŒ™å†Šåˆ·"
  ],
  [
    "8e40",
    "å¯Ÿæ‹¶æ’®æ“¦æœ­æ®ºè–©é›‘çšé¯–æŒéŒ†é®«çš¿æ™’ä¸‰å‚˜å‚å±±æƒ¨æ’’æ•£æ¡Ÿç‡¦çŠç”£ç®—çº‚èš•è®ƒè³›é…¸é¤æ–¬æš«æ®‹ä»•ä»”ä¼ºä½¿åˆºå¸å²å—£å››å£«å§‹å§‰å§¿å­å±å¸‚å¸«å¿—æ€æŒ‡æ”¯å­œæ–¯æ–½æ—¨æžæ­¢"
  ],
  [
    "8e80",
    "æ­»æ°ç…ç¥‰ç§ç³¸ç´™ç´«è‚¢è„‚è‡³è¦–è©žè©©è©¦èªŒè«®è³‡è³œé›Œé£¼æ­¯äº‹ä¼¼ä¾å…å­—å¯ºæ…ˆæŒæ™‚æ¬¡æ»‹æ²»çˆ¾ç’½ç—”ç£ç¤ºè€Œè€³è‡ªè’”è¾žæ±é¹¿å¼è­˜é´«ç«ºè»¸å®é›«ä¸ƒå±åŸ·å¤±å«‰å®¤æ‚‰æ¹¿æ¼†ç–¾è³ªå®Ÿè”€ç¯ å²æŸ´èŠå±¡è•Šç¸žèˆŽå†™å°„æ¨èµ¦æ–œç…®ç¤¾ç´—è€…è¬è»Šé®è›‡é‚ªå€Ÿå‹ºå°ºæ“ç¼çˆµé…Œé‡ˆéŒ«è‹¥å¯‚å¼±æƒ¹ä¸»å–å®ˆæ‰‹æœ±æ®Šç‹©ç ç¨®è…«è¶£é…’é¦–å„’å—å‘ªå¯¿æŽˆæ¨¹ç¶¬éœ€å›šåŽå‘¨"
  ],
  [
    "8f40",
    "å®—å°±å·žä¿®æ„æ‹¾æ´²ç§€ç§‹çµ‚ç¹ç¿’è‡­èˆŸè’è¡†è¥²è®è¹´è¼¯é€±é…‹é…¬é›†é†œä»€ä½å……åå¾“æˆŽæŸ”æ±æ¸‹ç£ç¸¦é‡éŠƒå”å¤™å®¿æ·‘ç¥ç¸®ç²›å¡¾ç†Ÿå‡ºè¡“è¿°ä¿Šå³»æ˜¥çž¬ç«£èˆœé§¿å‡†å¾ªæ—¬æ¥¯æ®‰æ·³"
  ],
  [
    "8f80",
    "æº–æ½¤ç›¾ç´”å·¡éµé†‡é †å‡¦åˆæ‰€æš‘æ›™æ¸šåº¶ç·’ç½²æ›¸è–¯è—·è«¸åŠ©å™å¥³åºå¾æ•é‹¤é™¤å‚·å„Ÿå‹åŒ å‡å¬å“¨å•†å”±å˜—å¥¨å¦¾å¨¼å®µå°†å°å°‘å°šåº„åºŠå» å½°æ‰¿æŠ„æ‹›æŽŒæ·æ˜‡æ˜Œæ˜­æ™¶æ¾æ¢¢æ¨Ÿæ¨µæ²¼æ¶ˆæ¸‰æ¹˜ç„¼ç„¦ç…§ç—‡çœç¡ç¤ç¥¥ç§°ç« ç¬‘ç²§ç´¹è‚–è–è’‹è•‰è¡è£³è¨Ÿè¨¼è©”è©³è±¡è³žé†¤é‰¦é¾é˜éšœéž˜ä¸Šä¸ˆä¸žä¹—å†—å‰°åŸŽå ´å£Œå¬¢å¸¸æƒ…æ“¾æ¡æ–æµ„çŠ¶ç•³ç©£è’¸è­²é†¸éŒ å˜±åŸ´é£¾"
  ],
  [
    "9040",
    "æ‹­æ¤æ®–ç‡­ç¹”è·è‰²è§¦é£Ÿè•è¾±å°»ä¼¸ä¿¡ä¾µå”‡å¨ å¯å¯©å¿ƒæ…ŽæŒ¯æ–°æ™‹æ£®æ¦›æµ¸æ·±ç”³ç–¹çœŸç¥žç§¦ç´³è‡£èŠ¯è–ªè¦ªè¨ºèº«è¾›é€²é‡éœ‡äººä»åˆƒå¡µå£¬å°‹ç”šå°½è…Žè¨Šè¿…é™£é­ç¬¥è«é ˆé…¢å›³åŽ¨"
  ],
  [
    "9080",
    "é€—å¹åž‚å¸¥æŽ¨æ°´ç‚Šç¡ç²‹ç¿ è¡°é‚é…”éŒéŒ˜éšç‘žé«„å´‡åµ©æ•°æž¢è¶¨é››æ®æ‰æ¤™è…é —é›€è£¾æ¾„æ‘ºå¯¸ä¸–ç€¬ç•æ˜¯å‡„åˆ¶å‹¢å§“å¾æ€§æˆæ”¿æ•´æ˜Ÿæ™´æ£²æ –æ­£æ¸…ç‰²ç”Ÿç››ç²¾è–å£°è£½è¥¿èª èª“è«‹é€é†’é’é™æ–‰ç¨Žè„†éš»å¸­æƒœæˆšæ–¥æ˜”æžçŸ³ç©ç±ç¸¾è„Šè²¬èµ¤è·¡è¹Ÿç¢©åˆ‡æ‹™æŽ¥æ‘‚æŠ˜è¨­çªƒç¯€èª¬é›ªçµ¶èˆŒè‰ä»™å…ˆåƒå å®£å°‚å°–å·æˆ¦æ‰‡æ’°æ “æ ´æ³‰æµ…æ´—æŸ“æ½œç…Žç…½æ—‹ç©¿ç®­ç·š"
  ],
  [
    "9140",
    "ç¹Šç¾¨è…ºèˆ›èˆ¹è–¦è©®è³Žè·µé¸é·éŠ­éŠ‘é–ƒé®®å‰å–„æ¼¸ç„¶å…¨ç¦…ç¹•è†³ç³Žå™Œå¡‘å²¨æŽªæ›¾æ›½æ¥šç‹™ç–ç–Žç¤Žç¥–ç§Ÿç²—ç´ çµ„è˜‡è¨´é˜»é¡é¼ åƒ§å‰µåŒå¢å€‰å–ªå£®å¥çˆ½å®‹å±¤åŒæƒ£æƒ³æœæŽƒæŒ¿æŽ»"
  ],
  [
    "9180",
    "æ“æ—©æ›¹å·£æ§æ§½æ¼•ç‡¥äº‰ç—©ç›¸çª“ç³Ÿç·ç¶œè¡è‰è˜è‘¬è’¼è—»è£…èµ°é€é­éŽ—éœœé¨’åƒå¢—æ†Žè‡“è”µè´ˆé€ ä¿ƒå´å‰‡å³æ¯æ‰æŸæ¸¬è¶³é€Ÿä¿—å±žè³Šæ—ç¶šå’è¢–å…¶æƒå­˜å­«å°Šææ‘éœä»–å¤šå¤ªæ±°è©‘å”¾å •å¦¥æƒ°æ‰“æŸèˆµæ¥•é™€é§„é¨¨ä½“å †å¯¾è€å²±å¸¯å¾…æ€ æ…‹æˆ´æ›¿æ³°æ»žèƒŽè…¿è‹”è¢‹è²¸é€€é€®éšŠé»›é¯›ä»£å°å¤§ç¬¬é†é¡Œé·¹æ»ç€§å“å•„å®…æ‰˜æŠžæ‹“æ²¢æ¿¯ç¢è¨—é¸æ¿è«¾èŒ¸å‡§è›¸åª"
  ],
  [
    "9240",
    "å©ä½†é”è¾°å¥ªè„±å·½ç«ªè¾¿æ£šè°·ç‹¸é±ˆæ¨½èª°ä¸¹å˜å˜†å¦æ‹…æŽ¢æ—¦æ­Žæ·¡æ¹›ç‚­çŸ­ç«¯ç®ªç¶»è€½èƒ†è›‹èª•é›å›£å£‡å¼¾æ–­æš–æª€æ®µç”·è«‡å€¤çŸ¥åœ°å¼›æ¥æ™ºæ± ç—´ç¨šç½®è‡´èœ˜é…é¦³ç¯‰ç•œç«¹ç­‘è“„"
  ],
  [
    "9280",
    "é€ç§©çª’èŒ¶å«¡ç€ä¸­ä»²å®™å¿ æŠ½æ˜¼æŸ±æ³¨è™«è¡·è¨»é…Žé‹³é§æ¨—ç€¦çŒªè‹§è‘—è²¯ä¸å…†å‡‹å–‹å¯µå¸–å¸³åºå¼”å¼µå½«å¾´æ‡²æŒ‘æš¢æœæ½®ç‰’ç”ºçœºè´è„¹è…¸è¶èª¿è«œè¶…è·³éŠšé•·é ‚é³¥å‹…æ—ç›´æœ•æ²ˆçè³ƒéŽ®é™³æ´¥å¢œæ¤Žæ§Œè¿½éŽšç—›é€šå¡šæ ‚æŽ´æ§»ä½ƒæ¼¬æŸ˜è¾»è”¦ç¶´é”æ¤¿æ½°åªå£·å¬¬ç´¬çˆªåŠé‡£é¶´äº­ä½Žåœåµå‰ƒè²žå‘ˆå ¤å®šå¸åº•åº­å»·å¼Ÿæ‚ŒæŠµæŒºææ¢¯æ±€ç¢‡ç¦Žç¨‹ç· è‰‡è¨‚è«¦è¹„é€“"
  ],
  [
    "9340",
    "é‚¸é„­é‡˜é¼Žæ³¥æ‘˜æ“¢æ•µæ»´çš„ç¬›é©é‘æººå“²å¾¹æ’¤è½è¿­é‰„å…¸å¡«å¤©å±•åº—æ·»çºç”œè²¼è»¢é¡›ç‚¹ä¼æ®¿æ¾±ç”°é›»å…Žåå µå¡—å¦¬å± å¾’æ–—æœæ¸¡ç™»èŸè³­é€”éƒ½éç ¥ç ºåŠªåº¦åœŸå¥´æ€’å€’å…šå†¬"
  ],
  [
    "9380",
    "å‡åˆ€å”å¡”å¡˜å¥—å®•å³¶å¶‹æ‚¼æŠ•æ­æ±æ¡ƒæ¢¼æ£Ÿç›—æ·˜æ¹¯æ¶›ç¯ç‡ˆå½“ç—˜ç¥·ç­‰ç­”ç­’ç³–çµ±åˆ°è‘£è•©è—¤è¨Žè¬„è±†è¸é€ƒé€é™é™¶é ­é¨°é—˜åƒå‹•åŒå ‚å°Žæ†§æ’žæ´žçž³ç«¥èƒ´è„é“éŠ…å³ é´‡åŒ¿å¾—å¾³æ¶œç‰¹ç£ç¦¿ç¯¤æ¯’ç‹¬èª­æ ƒæ©¡å‡¸çªæ¤´å±Šé³¶è‹«å¯…é…‰ç€žå™¸å±¯æƒ‡æ•¦æ²Œè±šéé “å‘‘æ›‡éˆå¥ˆé‚£å†…ä¹å‡ªè–™è¬Žç˜æºé‹æ¥¢é¦´ç¸„ç•·å—æ¥ è»Ÿé›£æ±äºŒå°¼å¼è¿©åŒ‚è³‘è‚‰è™¹å»¿æ—¥ä¹³å…¥"
  ],
  [
    "9440",
    "å¦‚å°¿éŸ®ä»»å¦Šå¿èªæ¿¡ç¦°ç¥¢å¯§è‘±çŒ«ç†±å¹´å¿µæ»æ’šç‡ƒç²˜ä¹ƒå»¼ä¹‹åŸœåš¢æ‚©æ¿ƒç´èƒ½è„³è†¿è¾²è¦—èš¤å·´æŠŠæ’­è¦‡æ·æ³¢æ´¾ç¶ç ´å©†ç½µèŠ­é¦¬ä¿³å»ƒæ‹æŽ’æ•—æ¯ç›ƒç‰ŒèƒŒè‚ºè¼©é…å€åŸ¹åª’æ¢…"
  ],
  [
    "9480",
    "æ¥³ç…¤ç‹½è²·å£²è³ é™ªé€™è¿ç§¤çŸ§è©ä¼¯å‰¥åšæ‹æŸæ³Šç™½ç®”ç²•èˆ¶è–„è¿«æ›æ¼ çˆ†ç¸›èŽ«é§éº¦å‡½ç®±ç¡²ç®¸è‚‡ç­ˆæ«¨å¹¡è‚Œç•‘ç• å…«é‰¢æºŒç™ºé†—é«ªä¼ç½°æŠœç­é–¥é³©å™ºå¡™è›¤éš¼ä¼´åˆ¤åŠåå›å¸†æ¬æ–‘æ¿æ°¾æ±Žç‰ˆçŠ¯ç­ç•”ç¹èˆ¬è—©è²©ç¯„é‡†ç…©é ’é£¯æŒ½æ™©ç•ªç›¤ç£è•ƒè›®åŒªå‘å¦å¦ƒåº‡å½¼æ‚²æ‰‰æ‰¹æŠ«æ–æ¯”æ³Œç–²çš®ç¢‘ç§˜ç·‹ç½·è‚¥è¢«èª¹è²»é¿éžé£›æ¨‹ç°¸å‚™å°¾å¾®æž‡æ¯˜çµçœ‰ç¾Ž"
  ],
  [
    "9540",
    "é¼»æŸŠç¨—åŒ¹ç–‹é«­å½¦è†è±è‚˜å¼¼å¿…ç•¢ç­†é€¼æ¡§å§«åª›ç´ç™¾è¬¬ä¿µå½ªæ¨™æ°·æ¼‚ç“¢ç¥¨è¡¨è©•è±¹å»Ÿæç—…ç§’è‹—éŒ¨é‹²è’œè›­é°­å“å½¬æ–Œæµœç€•è²§è³“é »æ•ç“¶ä¸ä»˜åŸ å¤«å©¦å¯Œå†¨å¸ƒåºœæ€–æ‰¶æ•·"
  ],
  [
    "9580",
    "æ–§æ™®æµ®çˆ¶ç¬¦è…è†šèŠ™è­œè² è³¦èµ´é˜œé™„ä¾®æ’«æ­¦èˆžè‘¡è•ªéƒ¨å°æ¥“é¢¨è‘ºè•—ä¼å‰¯å¾©å¹…æœç¦è…¹è¤‡è¦†æ·µå¼—æ‰•æ²¸ä»ç‰©é®’åˆ†å»å™´å¢³æ†¤æ‰®ç„šå¥®ç²‰ç³žç´›é›°æ–‡èžä¸™ä½µå…µå¡€å¹£å¹³å¼ŠæŸ„ä¸¦è”½é–‰é™›ç±³é åƒ»å£ç™–ç¢§åˆ¥çž¥è”‘ç®†åå¤‰ç‰‡ç¯‡ç·¨è¾ºè¿”éä¾¿å‹‰å¨©å¼éž­ä¿èˆ—é‹ªåœƒæ•æ­©ç”«è£œè¼”ç©‚å‹Ÿå¢“æ…•æˆŠæš®æ¯ç°¿è©å€£ä¿¸åŒ…å‘†å ±å¥‰å®å³°å³¯å´©åº–æŠ±æ§æ”¾æ–¹æœ‹"
  ],
  [
    "9640",
    "æ³•æ³¡çƒ¹ç ²ç¸«èƒžèŠ³èŒè“¬èœ‚è¤’è¨ªè±Šé‚¦é‹’é£½é³³éµ¬ä¹äº¡å‚å‰–åŠå¦¨å¸½å¿˜å¿™æˆ¿æš´æœ›æŸæ£’å†’ç´¡è‚ªè†¨è¬€è²Œè²¿é‰¾é˜²å é ¬åŒ—åƒ•åœå¢¨æ’²æœ´ç‰§ç¦ç©†é‡¦å‹ƒæ²¡æ®†å €å¹Œå¥”æœ¬ç¿»å‡¡ç›†"
  ],
  [
    "9680",
    "æ‘©ç£¨é­”éº»åŸ‹å¦¹æ˜§æžšæ¯Žå“©æ§™å¹•è†œæž•é®ªæŸ¾é±’æ¡äº¦ä¿£åˆæŠ¹æœ«æ²«è¿„ä¾­ç¹­éº¿ä¸‡æ…¢æº€æ¼«è”“å‘³æœªé­…å·³ç®•å²¬å¯†èœœæ¹Šè“‘ç¨”è„ˆå¦™ç²æ°‘çœ å‹™å¤¢ç„¡ç‰ŸçŸ›éœ§éµ¡æ¤‹å©¿å¨˜å†¥åå‘½æ˜Žç›Ÿè¿·éŠ˜é³´å§ªç‰æ»…å…æ£‰ç¶¿ç·¬é¢éººæ‘¸æ¨¡èŒ‚å¦„å­Ÿæ¯›çŒ›ç›²ç¶²è€—è’™å„²æœ¨é»™ç›®æ¢å‹¿é¤…å°¤æˆ»ç±¾è²°å•æ‚¶ç´‹é–€åŒä¹Ÿå†¶å¤œçˆºè€¶é‡Žå¼¥çŸ¢åŽ„å½¹ç´„è–¬è¨³èºé–æŸ³è–®é‘“æ„‰æ„ˆæ²¹ç™’"
  ],
  [
    "9740",
    "è«­è¼¸å”¯ä½‘å„ªå‹‡å‹å®¥å¹½æ‚ æ†‚æ–æœ‰æŸšæ¹§æ¶ŒçŒ¶çŒ·ç”±ç¥è£•èª˜éŠé‚‘éƒµé›„èžå¤•äºˆä½™ä¸Žèª‰è¼¿é å‚­å¹¼å¦–å®¹åº¸æšæºæ“æ›œæ¥Šæ§˜æ´‹æº¶ç†”ç”¨çª¯ç¾Šè€€è‘‰è“‰è¦è¬¡è¸Šé¥é™½é¤Šæ…¾æŠ‘æ¬²"
  ],
  [
    "9780",
    "æ²ƒæµ´ç¿Œç¿¼æ·€ç¾…èžºè£¸æ¥èŽ±é ¼é›·æ´›çµ¡è½é…ªä¹±åµåµæ¬„æ¿«è—è˜­è¦§åˆ©åå±¥æŽæ¢¨ç†ç’ƒç—¢è£è£¡é‡Œé›¢é™¸å¾‹çŽ‡ç«‹è‘ŽæŽ ç•¥åŠ‰æµæºœç‰ç•™ç¡«ç²’éš†ç«œé¾ä¾¶æ…®æ—…è™œäº†äº®åƒšä¸¡å‡Œå¯®æ–™æ¢æ¶¼çŒŸç™‚çž­ç¨œç³§è‰¯è«’é¼é‡é™µé ˜åŠ›ç·‘å€«åŽ˜æž—æ·‹ç‡ç³è‡¨è¼ªéš£é±—éºŸç‘ å¡æ¶™ç´¯é¡žä»¤ä¼¶ä¾‹å†·åŠ±å¶ºæ€œçŽ²ç¤¼è‹“éˆ´éš·é›¶éœŠéº—é½¢æš¦æ­´åˆ—åŠ£çƒˆè£‚å»‰æ‹æ†æ¼£ç…‰ç°¾ç·´è¯"
  ],
  [
    "9840",
    "è“®é€£éŒ¬å‘‚é­¯æ«“ç‚‰è³‚è·¯éœ²åŠ´å©å»Šå¼„æœ—æ¥¼æ¦”æµªæ¼ç‰¢ç‹¼ç¯­è€è¾è‹éƒŽå…­éº“ç¦„è‚‹éŒ²è«–å€­å’Œè©±æ­ªè³„è„‡æƒ‘æž é·²äº™äº˜é°è©«è—è•¨æ¤€æ¹¾ç¢—è…•"
  ],
  [
    "989f",
    "å¼Œä¸ä¸•ä¸ªä¸±ä¸¶ä¸¼ä¸¿ä¹‚ä¹–ä¹˜äº‚äº…è±«äºŠèˆ’å¼äºŽäºžäºŸäº äº¢äº°äº³äº¶ä»Žä»ä»„ä»†ä»‚ä»—ä»žä»­ä»Ÿä»·ä¼‰ä½šä¼°ä½›ä½ä½—ä½‡ä½¶ä¾ˆä¾ä¾˜ä½»ä½©ä½°ä¾‘ä½¯ä¾†ä¾–å„˜ä¿”ä¿Ÿä¿Žä¿˜ä¿›ä¿‘ä¿šä¿ä¿¤ä¿¥å€šå€¨å€”å€ªå€¥å€…ä¼œä¿¶å€¡å€©å€¬ä¿¾ä¿¯å€‘å€†åƒå‡æœƒå•ååˆåšå–å¬å¸å‚€å‚šå‚…å‚´å‚²"
  ],
  [
    "9940",
    "åƒ‰åƒŠå‚³åƒ‚åƒ–åƒžåƒ¥åƒ­åƒ£åƒ®åƒ¹åƒµå„‰å„å„‚å„–å„•å„”å„šå„¡å„ºå„·å„¼å„»å„¿å…€å…’å…Œå…”å…¢ç«¸å…©å…ªå…®å†€å†‚å›˜å†Œå†‰å†å†‘å†“å†•å†–å†¤å†¦å†¢å†©å†ªå†«å†³å†±å†²å†°å†µå†½å‡…å‡‰å‡›å‡ è™•å‡©å‡­"
  ],
  [
    "9980",
    "å‡°å‡µå‡¾åˆ„åˆ‹åˆ”åˆŽåˆ§åˆªåˆ®åˆ³åˆ¹å‰å‰„å‰‹å‰Œå‰žå‰”å‰ªå‰´å‰©å‰³å‰¿å‰½åŠåŠ”åŠ’å‰±åŠˆåŠ‘è¾¨è¾§åŠ¬åŠ­åŠ¼åŠµå‹å‹å‹—å‹žå‹£å‹¦é£­å‹ å‹³å‹µå‹¸å‹¹åŒ†åŒˆç”¸åŒåŒåŒåŒ•åŒšåŒ£åŒ¯åŒ±åŒ³åŒ¸å€å†å…ä¸—å‰åå‡–åžå©å®å¤˜å»å·åŽ‚åŽ–åŽ åŽ¦åŽ¥åŽ®åŽ°åŽ¶åƒç°’é›™åŸæ›¼ç‡®å®å¨å­åºåå½å‘€å¬å­å¼å®å¶å©åå‘Žå’å‘µå’Žå‘Ÿå‘±å‘·å‘°å’’å‘»å’€å‘¶å’„å’å’†å“‡å’¢å’¸å’¥å’¬å“„å“ˆå’¨"
  ],
  [
    "9a40",
    "å’«å“‚å’¤å’¾å’¼å“˜å“¥å“¦å”å””å“½å“®å“­å“ºå“¢å”¹å•€å•£å•Œå”®å•œå•…å•–å•—å”¸å”³å•å–™å–€å’¯å–Šå–Ÿå•»å•¾å–˜å–žå–®å•¼å–ƒå–©å–‡å–¨å—šå—…å—Ÿå—„å—œå—¤å—”å˜”å—·å˜–å—¾å—½å˜›å—¹å™Žå™ç‡Ÿå˜´å˜¶å˜²å˜¸"
  ],
  [
    "9a80",
    "å™«å™¤å˜¯å™¬å™ªåš†åš€åšŠåš åš”åšåš¥åš®åš¶åš´å›‚åš¼å›å›ƒå›€å›ˆå›Žå›‘å›“å›—å›®å›¹åœ€å›¿åœ„åœ‰åœˆåœ‹åœåœ“åœ˜åœ–å—‡åœœåœ¦åœ·åœ¸åŽåœ»å€åå©åŸ€åžˆå¡å¿åž‰åž“åž åž³åž¤åžªåž°åŸƒåŸ†åŸ”åŸ’åŸ“å ŠåŸ–åŸ£å ‹å ™å å¡²å ¡å¡¢å¡‹å¡°æ¯€å¡’å ½å¡¹å¢…å¢¹å¢Ÿå¢«å¢ºå£žå¢»å¢¸å¢®å£…å£“å£‘å£—å£™å£˜å£¥å£œå£¤å£Ÿå£¯å£ºå£¹å£»å£¼å£½å¤‚å¤Šå¤å¤›æ¢¦å¤¥å¤¬å¤­å¤²å¤¸å¤¾ç«’å¥•å¥å¥Žå¥šå¥˜å¥¢å¥ å¥§å¥¬å¥©"
  ],
  [
    "9b40",
    "å¥¸å¦å¦ä½žä¾«å¦£å¦²å§†å§¨å§œå¦å§™å§šå¨¥å¨Ÿå¨‘å¨œå¨‰å¨šå©€å©¬å©‰å¨µå¨¶å©¢å©ªåªšåª¼åª¾å«‹å«‚åª½å«£å«—å«¦å«©å«–å«ºå«»å¬Œå¬‹å¬–å¬²å«å¬ªå¬¶å¬¾å­ƒå­…å­€å­‘å­•å­šå­›å­¥å­©å­°å­³å­µå­¸æ–ˆå­ºå®€"
  ],
  [
    "9b80",
    "å®ƒå®¦å®¸å¯ƒå¯‡å¯‰å¯”å¯å¯¤å¯¦å¯¢å¯žå¯¥å¯«å¯°å¯¶å¯³å°…å°‡å°ˆå°å°“å° å°¢å°¨å°¸å°¹å±å±†å±Žå±“å±å±å­±å±¬å±®ä¹¢å±¶å±¹å²Œå²‘å²”å¦›å²«å²»å²¶å²¼å²·å³…å²¾å³‡å³™å³©å³½å³ºå³­å¶Œå³ªå´‹å´•å´—åµœå´Ÿå´›å´‘å´”å´¢å´šå´™å´˜åµŒåµ’åµŽåµ‹åµ¬åµ³åµ¶å¶‡å¶„å¶‚å¶¢å¶å¶¬å¶®å¶½å¶å¶·å¶¼å·‰å·å·“å·’å·–å·›å·«å·²å·µå¸‹å¸šå¸™å¸‘å¸›å¸¶å¸·å¹„å¹ƒå¹€å¹Žå¹—å¹”å¹Ÿå¹¢å¹¤å¹‡å¹µå¹¶å¹ºéº¼å¹¿åº å»å»‚å»ˆå»å»"
  ],
  [
    "9c40",
    "å»–å»£å»å»šå»›å»¢å»¡å»¨å»©å»¬å»±å»³å»°å»´å»¸å»¾å¼ƒå¼‰å½å½œå¼‹å¼‘å¼–å¼©å¼­å¼¸å½å½ˆå½Œå½Žå¼¯å½‘å½–å½—å½™å½¡å½­å½³å½·å¾ƒå¾‚å½¿å¾Šå¾ˆå¾‘å¾‡å¾žå¾™å¾˜å¾ å¾¨å¾­å¾¼å¿–å¿»å¿¤å¿¸å¿±å¿æ‚³å¿¿æ€¡æ "
  ],
  [
    "9c80",
    "æ€™æ€æ€©æ€Žæ€±æ€›æ€•æ€«æ€¦æ€æ€ºæšææªæ·æŸæŠæ†ææ£æƒæ¤æ‚æ¬æ«æ™æ‚æ‚æƒ§æ‚ƒæ‚šæ‚„æ‚›æ‚–æ‚—æ‚’æ‚§æ‚‹æƒ¡æ‚¸æƒ æƒ“æ‚´å¿°æ‚½æƒ†æ‚µæƒ˜æ…æ„•æ„†æƒ¶æƒ·æ„€æƒ´æƒºæ„ƒæ„¡æƒ»æƒ±æ„æ„Žæ…‡æ„¾æ„¨æ„§æ…Šæ„¿æ„¼æ„¬æ„´æ„½æ…‚æ…„æ…³æ…·æ…˜æ…™æ…šæ…«æ…´æ…¯æ…¥æ…±æ…Ÿæ…æ…“æ…µæ†™æ†–æ†‡æ†¬æ†”æ†šæ†Šæ†‘æ†«æ†®æ‡Œæ‡Šæ‡‰æ‡·æ‡ˆæ‡ƒæ‡†æ†ºæ‡‹ç½¹æ‡æ‡¦æ‡£æ‡¶æ‡ºæ‡´æ‡¿æ‡½æ‡¼æ‡¾æˆ€æˆˆæˆ‰æˆæˆŒæˆ”æˆ›"
  ],
  [
    "9d40",
    "æˆžæˆ¡æˆªæˆ®æˆ°æˆ²æˆ³æ‰æ‰Žæ‰žæ‰£æ‰›æ‰ æ‰¨æ‰¼æŠ‚æŠ‰æ‰¾æŠ’æŠ“æŠ–æ‹”æŠƒæŠ”æ‹—æ‹‘æŠ»æ‹æ‹¿æ‹†æ“”æ‹ˆæ‹œæ‹Œæ‹Šæ‹‚æ‹‡æŠ›æ‹‰æŒŒæ‹®æ‹±æŒ§æŒ‚æŒˆæ‹¯æ‹µææŒ¾ææœææŽ–æŽŽæŽ€æŽ«æ¶æŽ£æŽæŽ‰æŽŸæŽµæ«"
  ],
  [
    "9d80",
    "æ©æŽ¾æ©æ€æ†æ£æ‰æ’æ¶æ„æ–æ´æ†æ“æ¦æ¶æ”æ—æ¨ææ‘§æ‘¯æ‘¶æ‘Žæ”ªæ’•æ’“æ’¥æ’©æ’ˆæ’¼æ“šæ“’æ“…æ“‡æ’»æ“˜æ“‚æ“±æ“§èˆ‰æ“ æ“¡æŠ¬æ“£æ“¯æ”¬æ“¶æ“´æ“²æ“ºæ”€æ“½æ”˜æ”œæ”…æ”¤æ”£æ”«æ”´æ”µæ”·æ”¶æ”¸ç•‹æ•ˆæ•–æ••æ•æ•˜æ•žæ•æ•²æ•¸æ–‚æ–ƒè®Šæ–›æ–Ÿæ–«æ–·æ—ƒæ—†æ—æ—„æ—Œæ—’æ—›æ—™æ— æ—¡æ—±æ²æ˜Šæ˜ƒæ—»æ³æ˜µæ˜¶æ˜´æ˜œæ™æ™„æ™‰æ™æ™žæ™æ™¤æ™§æ™¨æ™Ÿæ™¢æ™°æšƒæšˆæšŽæš‰æš„æš˜æšæ›æš¹æ›‰æš¾æš¼"
  ],
  [
    "9e40",
    "æ›„æš¸æ›–æ›šæ› æ˜¿æ›¦æ›©æ›°æ›µæ›·æœæœ–æœžæœ¦æœ§éœ¸æœ®æœ¿æœ¶ææœ¸æœ·æ†æžæ æ™æ£æ¤æž‰æ°æž©æ¼æªæžŒæž‹æž¦æž¡æž…æž·æŸ¯æž´æŸ¬æž³æŸ©æž¸æŸ¤æŸžæŸæŸ¢æŸ®æž¹æŸŽæŸ†æŸ§æªœæ žæ¡†æ ©æ¡€æ¡æ ²æ¡Ž"
  ],
  [
    "9e80",
    "æ¢³æ «æ¡™æ¡£æ¡·æ¡¿æ¢Ÿæ¢æ¢­æ¢”æ¢æ¢›æ¢ƒæª®æ¢¹æ¡´æ¢µæ¢ æ¢ºæ¤æ¢æ¡¾æ¤æ£Šæ¤ˆæ£˜æ¤¢æ¤¦æ£¡æ¤Œæ£æ£”æ£§æ£•æ¤¶æ¤’æ¤„æ£—æ££æ¤¥æ£¹æ£ æ£¯æ¤¨æ¤ªæ¤šæ¤£æ¤¡æ£†æ¥¹æ¥·æ¥œæ¥¸æ¥«æ¥”æ¥¾æ¥®æ¤¹æ¥´æ¤½æ¥™æ¤°æ¥¡æ¥žæ¥æ¦æ¥ªæ¦²æ¦®æ§æ¦¿æ§æ§“æ¦¾æ§Žå¯¨æ§Šæ§æ¦»æ§ƒæ¦§æ¨®æ¦‘æ¦ æ¦œæ¦•æ¦´æ§žæ§¨æ¨‚æ¨›æ§¿æ¬Šæ§¹æ§²æ§§æ¨…æ¦±æ¨žæ§­æ¨”æ§«æ¨Šæ¨’æ«æ¨£æ¨“æ©„æ¨Œæ©²æ¨¶æ©¸æ©‡æ©¢æ©™æ©¦æ©ˆæ¨¸æ¨¢æªæªæª æª„æª¢æª£"
  ],
  [
    "9f40",
    "æª—è˜—æª»æ«ƒæ«‚æª¸æª³æª¬æ«žæ«‘æ«Ÿæªªæ«šæ«ªæ«»æ¬…è˜–æ«ºæ¬’æ¬–é¬±æ¬Ÿæ¬¸æ¬·ç›œæ¬¹é£®æ­‡æ­ƒæ­‰æ­æ­™æ­”æ­›æ­Ÿæ­¡æ­¸æ­¹æ­¿æ®€æ®„æ®ƒæ®æ®˜æ®•æ®žæ®¤æ®ªæ®«æ®¯æ®²æ®±æ®³æ®·æ®¼æ¯†æ¯‹æ¯“æ¯Ÿæ¯¬æ¯«æ¯³æ¯¯"
  ],
  [
    "9f80",
    "éº¾æ°ˆæ°“æ°”æ°›æ°¤æ°£æ±žæ±•æ±¢æ±ªæ²‚æ²æ²šæ²æ²›æ±¾æ±¨æ±³æ²’æ²æ³„æ³±æ³“æ²½æ³—æ³…æ³æ²®æ²±æ²¾æ²ºæ³›æ³¯æ³™æ³ªæ´Ÿè¡æ´¶æ´«æ´½æ´¸æ´™æ´µæ´³æ´’æ´Œæµ£æ¶“æµ¤æµšæµ¹æµ™æ¶Žæ¶•æ¿¤æ¶…æ·¹æ¸•æ¸Šæ¶µæ·‡æ·¦æ¶¸æ·†æ·¬æ·žæ·Œæ·¨æ·’æ·…æ·ºæ·™æ·¤æ·•æ·ªæ·®æ¸­æ¹®æ¸®æ¸™æ¹²æ¹Ÿæ¸¾æ¸£æ¹«æ¸«æ¹¶æ¹æ¸Ÿæ¹ƒæ¸ºæ¹Žæ¸¤æ»¿æ¸æ¸¸æº‚æºªæº˜æ»‰æº·æ»“æº½æº¯æ»„æº²æ»”æ»•æºæº¥æ»‚æºŸæ½æ¼‘çŒæ»¬æ»¸æ»¾æ¼¿æ»²æ¼±æ»¯æ¼²æ»Œ"
  ],
  [
    "e040",
    "æ¼¾æ¼“æ»·æ¾†æ½ºæ½¸æ¾æ¾€æ½¯æ½›æ¿³æ½­æ¾‚æ½¼æ½˜æ¾Žæ¾‘æ¿‚æ½¦æ¾³æ¾£æ¾¡æ¾¤æ¾¹æ¿†æ¾ªæ¿Ÿæ¿•æ¿¬æ¿”æ¿˜æ¿±æ¿®æ¿›ç€‰ç€‹æ¿ºç€‘ç€ç€æ¿¾ç€›ç€šæ½´ç€ç€˜ç€Ÿç€°ç€¾ç€²ç‘ç£ç‚™ç‚’ç‚¯çƒ±ç‚¬ç‚¸ç‚³ç‚®çƒŸçƒ‹çƒ"
  ],
  [
    "e080",
    "çƒ™ç„‰çƒ½ç„œç„™ç…¥ç…•ç†ˆç…¦ç…¢ç…Œç…–ç…¬ç†ç‡»ç†„ç†•ç†¨ç†¬ç‡—ç†¹ç†¾ç‡’ç‡‰ç‡”ç‡Žç‡ ç‡¬ç‡§ç‡µç‡¼ç‡¹ç‡¿çˆçˆçˆ›çˆ¨çˆ­çˆ¬çˆ°çˆ²çˆ»çˆ¼çˆ¿ç‰€ç‰†ç‰‹ç‰˜ç‰´ç‰¾çŠ‚çŠçŠ‡çŠ’çŠ–çŠ¢çŠ§çŠ¹çŠ²ç‹ƒç‹†ç‹„ç‹Žç‹’ç‹¢ç‹ ç‹¡ç‹¹ç‹·å€çŒ—çŒŠçŒœçŒ–çŒçŒ´çŒ¯çŒ©çŒ¥çŒ¾çŽçé»˜ç—çªç¨ç°ç¸çµç»çºçˆçŽ³çŽçŽ»ç€ç¥ç®çžç’¢ç…ç‘¯ç¥ç¸ç²çºç‘•ç¿ç‘Ÿç‘™ç‘ç‘œç‘©ç‘°ç‘£ç‘ªç‘¶ç‘¾ç’‹ç’žç’§ç“Šç“ç“”ç±"
  ],
  [
    "e140",
    "ç“ ç“£ç“§ç“©ç“®ç“²ç“°ç“±ç“¸ç“·ç”„ç”ƒç”…ç”Œç”Žç”ç”•ç”“ç”žç”¦ç”¬ç”¼ç•„ç•ç•Šç•‰ç•›ç•†ç•šç•©ç•¤ç•§ç•«ç•­ç•¸ç•¶ç–†ç–‡ç•´ç–Šç–‰ç–‚ç–”ç–šç–ç–¥ç–£ç—‚ç–³ç—ƒç–µç–½ç–¸ç–¼ç–±ç—ç—Šç—’ç—™ç—£ç—žç—¾ç—¿"
  ],
  [
    "e180",
    "ç—¼ç˜ç—°ç—ºç—²ç—³ç˜‹ç˜ç˜‰ç˜Ÿç˜§ç˜ ç˜¡ç˜¢ç˜¤ç˜´ç˜°ç˜»ç™‡ç™ˆç™†ç™œç™˜ç™¡ç™¢ç™¨ç™©ç™ªç™§ç™¬ç™°ç™²ç™¶ç™¸ç™¼çš€çšƒçšˆçš‹çšŽçš–çš“çš™çššçš°çš´çš¸çš¹çšºç›‚ç›ç›–ç›’ç›žç›¡ç›¥ç›§ç›ªè˜¯ç›»çœˆçœ‡çœ„çœ©çœ¤çœžçœ¥çœ¦çœ›çœ·çœ¸ç‡çšç¨ç«ç›ç¥ç¿ç¾ç¹çžŽçž‹çž‘çž çžžçž°çž¶çž¹çž¿çž¼çž½çž»çŸ‡çŸçŸ—çŸšçŸœçŸ£çŸ®çŸ¼ç Œç ’ç¤¦ç  ç¤ªç¡…ç¢Žç¡´ç¢†ç¡¼ç¢šç¢Œç¢£ç¢µç¢ªç¢¯ç£‘ç£†ç£‹ç£”ç¢¾ç¢¼ç£…ç£Šç£¬"
  ],
  [
    "e240",
    "ç£§ç£šç£½ç£´ç¤‡ç¤’ç¤‘ç¤™ç¤¬ç¤«ç¥€ç¥ ç¥—ç¥Ÿç¥šç¥•ç¥“ç¥ºç¥¿ç¦Šç¦ç¦§é½‹ç¦ªç¦®ç¦³ç¦¹ç¦ºç§‰ç§•ç§§ç§¬ç§¡ç§£ç¨ˆç¨ç¨˜ç¨™ç¨ ç¨Ÿç¦€ç¨±ç¨»ç¨¾ç¨·ç©ƒç©—ç©‰ç©¡ç©¢ç©©é¾ç©°ç©¹ç©½çªˆçª—çª•çª˜çª–çª©ç«ˆçª°"
  ],
  [
    "e280",
    "çª¶ç«…ç«„çª¿é‚ƒç«‡ç«Šç«ç«ç«•ç«“ç«™ç«šç«ç«¡ç«¢ç«¦ç«­ç«°ç¬‚ç¬ç¬Šç¬†ç¬³ç¬˜ç¬™ç¬žç¬µç¬¨ç¬¶ç­ç­ºç¬„ç­ç¬‹ç­Œç­…ç­µç­¥ç­´ç­§ç­°ç­±ç­¬ç­®ç®ç®˜ç®Ÿç®ç®œç®šç®‹ç®’ç®ç­ç®™ç¯‹ç¯ç¯Œç¯ç®´ç¯†ç¯ç¯©ç°‘ç°”ç¯¦ç¯¥ç± ç°€ç°‡ç°“ç¯³ç¯·ç°—ç°ç¯¶ç°£ç°§ç°ªç°Ÿç°·ç°«ç°½ç±Œç±ƒç±”ç±ç±€ç±ç±˜ç±Ÿç±¤ç±–ç±¥ç±¬ç±µç²ƒç²ç²¤ç²­ç²¢ç²«ç²¡ç²¨ç²³ç²²ç²±ç²®ç²¹ç²½ç³€ç³…ç³‚ç³˜ç³’ç³œç³¢é¬»ç³¯ç³²ç³´ç³¶ç³ºç´†"
  ],
  [
    "e340",
    "ç´‚ç´œç´•ç´Šçµ…çµ‹ç´®ç´²ç´¿ç´µçµ†çµ³çµ–çµŽçµ²çµ¨çµ®çµçµ£ç¶“ç¶‰çµ›ç¶çµ½ç¶›ç¶ºç¶®ç¶£ç¶µç·‡ç¶½ç¶«ç¸½ç¶¢ç¶¯ç·œç¶¸ç¶Ÿç¶°ç·˜ç·ç·¤ç·žç·»ç·²ç·¡ç¸…ç¸Šç¸£ç¸¡ç¸’ç¸±ç¸Ÿç¸‰ç¸‹ç¸¢ç¹†ç¹¦ç¸»ç¸µç¸¹ç¹ƒç¸·"
  ],
  [
    "e380",
    "ç¸²ç¸ºç¹§ç¹ç¹–ç¹žç¹™ç¹šç¹¹ç¹ªç¹©ç¹¼ç¹»çºƒç·•ç¹½è¾®ç¹¿çºˆçº‰çºŒçº’çºçº“çº”çº–çºŽçº›çºœç¼¸ç¼ºç½…ç½Œç½ç½Žç½ç½‘ç½•ç½”ç½˜ç½Ÿç½ ç½¨ç½©ç½§ç½¸ç¾‚ç¾†ç¾ƒç¾ˆç¾‡ç¾Œç¾”ç¾žç¾ç¾šç¾£ç¾¯ç¾²ç¾¹ç¾®ç¾¶ç¾¸è­±ç¿…ç¿†ç¿Šç¿•ç¿”ç¿¡ç¿¦ç¿©ç¿³ç¿¹é£œè€†è€„è€‹è€’è€˜è€™è€œè€¡è€¨è€¿è€»èŠè†è’è˜èšèŸè¢è¨è³è²è°è¶è¹è½è¿è‚„è‚†è‚…è‚›è‚“è‚šè‚­å†è‚¬èƒ›èƒ¥èƒ™èƒèƒ„èƒšèƒ–è„‰èƒ¯èƒ±è„›è„©è„£è„¯è…‹"
  ],
  [
    "e440",
    "éš‹è…†è„¾è…“è…‘èƒ¼è…±è…®è…¥è…¦è…´è†ƒè†ˆè†Šè†€è†‚è† è†•è†¤è†£è…Ÿè†“è†©è†°è†µè†¾è†¸è†½è‡€è‡‚è†ºè‡‰è‡è‡‘è‡™è‡˜è‡ˆè‡šè‡Ÿè‡ è‡§è‡ºè‡»è‡¾èˆèˆ‚èˆ…èˆ‡èˆŠèˆèˆèˆ–èˆ©èˆ«èˆ¸èˆ³è‰€è‰™è‰˜è‰è‰šè‰Ÿè‰¤"
  ],
  [
    "e480",
    "è‰¢è‰¨è‰ªè‰«èˆ®è‰±è‰·è‰¸è‰¾èŠèŠ’èŠ«èŠŸèŠ»èŠ¬è‹¡è‹£è‹Ÿè‹’è‹´è‹³è‹ºèŽ“èŒƒè‹»è‹¹è‹žèŒ†è‹œèŒ‰è‹™èŒµèŒ´èŒ–èŒ²èŒ±è€èŒ¹èè…èŒ¯èŒ«èŒ—èŒ˜èŽ…èŽšèŽªèŽŸèŽ¢èŽ–èŒ£èŽŽèŽ‡èŽŠè¼èŽµè³èµèŽ èŽ‰èŽ¨è´è“è«èŽè½èƒè˜è‹èè·è‡è è²èè¢è èŽ½è¸è”†è»è‘­èªè¼è•šè’„è‘·è‘«è’­è‘®è’‚è‘©è‘†è¬è‘¯è‘¹èµè“Šè‘¢è’¹è’¿è’Ÿè“™è“è’»è“šè“è“è“†è“–è’¡è”¡è“¿è“´è”—è”˜è”¬è”Ÿè”•è””è“¼è•€è•£è•˜è•ˆ"
  ],
  [
    "e540",
    "è•è˜‚è•‹è••è–€è–¤è–ˆè–‘è–Šè–¨è•­è–”è–›è—ªè–‡è–œè•·è•¾è–è—‰è–ºè—è–¹è—è—•è—è—¥è—œè—¹è˜Šè˜“è˜‹è—¾è—ºè˜†è˜¢è˜šè˜°è˜¿è™ä¹•è™”è™Ÿè™§è™±èš“èš£èš©èšªèš‹èšŒèš¶èš¯è›„è›†èš°è›‰è £èš«è›”è›žè›©è›¬"
  ],
  [
    "e580",
    "è›Ÿè››è›¯èœ’èœ†èœˆèœ€èœƒè›»èœ‘èœ‰èœè›¹èœŠèœ´èœ¿èœ·èœ»èœ¥èœ©èœšè èŸè¸èŒèŽè´è—è¨è®è™è“è£èªè …èž¢èžŸèž‚èž¯èŸ‹èž½èŸ€èŸé›–èž«èŸ„èž³èŸ‡èŸ†èž»èŸ¯èŸ²èŸ è è èŸ¾èŸ¶èŸ·è ŽèŸ’è ‘è –è •è ¢è ¡è ±è ¶è ¹è §è »è¡„è¡‚è¡’è¡™è¡žè¡¢è¡«è¢è¡¾è¢žè¡µè¡½è¢µè¡²è¢‚è¢—è¢’è¢®è¢™è¢¢è¢è¢¤è¢°è¢¿è¢±è£ƒè£„è£”è£˜è£™è£è£¹è¤‚è£¼è£´è£¨è£²è¤„è¤Œè¤Šè¤“è¥ƒè¤žè¤¥è¤ªè¤«è¥è¥„è¤»è¤¶è¤¸è¥Œè¤è¥ è¥ž"
  ],
  [
    "e640",
    "è¥¦è¥¤è¥­è¥ªè¥¯è¥´è¥·è¥¾è¦ƒè¦ˆè¦Šè¦“è¦˜è¦¡è¦©è¦¦è¦¬è¦¯è¦²è¦ºè¦½è¦¿è§€è§šè§œè§è§§è§´è§¸è¨ƒè¨–è¨è¨Œè¨›è¨è¨¥è¨¶è©è©›è©’è©†è©ˆè©¼è©­è©¬è©¢èª…èª‚èª„èª¨èª¡èª‘èª¥èª¦èªšèª£è«„è«è«‚è«šè««è«³è«§"
  ],
  [
    "e680",
    "è«¤è«±è¬”è« è«¢è«·è«žè«›è¬Œè¬‡è¬šè«¡è¬–è¬è¬—è¬ è¬³éž«è¬¦è¬«è¬¾è¬¨è­è­Œè­è­Žè­‰è­–è­›è­šè­«è­Ÿè­¬è­¯è­´è­½è®€è®Œè®Žè®’è®“è®–è®™è®šè°ºè±è°¿è±ˆè±Œè±Žè±è±•è±¢è±¬è±¸è±ºè²‚è²‰è²…è²Šè²è²Žè²”è±¼è²˜æˆè²­è²ªè²½è²²è²³è²®è²¶è³ˆè³è³¤è³£è³šè³½è³ºè³»è´„è´…è´Šè´‡è´è´è´é½Žè´“è³è´”è´–èµ§èµ­èµ±èµ³è¶è¶™è·‚è¶¾è¶ºè·è·šè·–è·Œè·›è·‹è·ªè·«è·Ÿè·£è·¼è¸ˆè¸‰è·¿è¸è¸žè¸è¸Ÿè¹‚è¸µè¸°è¸´è¹Š"
  ],
  [
    "e740",
    "è¹‡è¹‰è¹Œè¹è¹ˆè¹™è¹¤è¹ è¸ªè¹£è¹•è¹¶è¹²è¹¼èºèº‡èº…èº„èº‹èºŠèº“èº‘èº”èº™èºªèº¡èº¬èº°è»†èº±èº¾è»…è»ˆè»‹è»›è»£è»¼è»»è»«è»¾è¼Šè¼…è¼•è¼’è¼™è¼“è¼œè¼Ÿè¼›è¼Œè¼¦è¼³è¼»è¼¹è½…è½‚è¼¾è½Œè½‰è½†è½Žè½—è½œ"
  ],
  [
    "e780",
    "è½¢è½£è½¤è¾œè¾Ÿè¾£è¾­è¾¯è¾·è¿šè¿¥è¿¢è¿ªè¿¯é‚‡è¿´é€…è¿¹è¿ºé€‘é€•é€¡é€é€žé€–é€‹é€§é€¶é€µé€¹è¿¸ééé‘é’é€Žé‰é€¾é–é˜éžé¨é¯é¶éš¨é²é‚‚é½é‚é‚€é‚Šé‚‰é‚é‚¨é‚¯é‚±é‚µéƒ¢éƒ¤æ‰ˆéƒ›é„‚é„’é„™é„²é„°é…Šé…–é…˜é…£é…¥é…©é…³é…²é†‹é†‰é†‚é†¢é†«é†¯é†ªé†µé†´é†ºé‡€é‡é‡‰é‡‹é‡é‡–é‡Ÿé‡¡é‡›é‡¼é‡µé‡¶éˆžé‡¿éˆ”éˆ¬éˆ•éˆ‘é‰žé‰—é‰…é‰‰é‰¤é‰ˆéŠ•éˆ¿é‰‹é‰éŠœéŠ–éŠ“éŠ›é‰šé‹éŠ¹éŠ·é‹©éŒé‹ºé„éŒ®"
  ],
  [
    "e840",
    "éŒ™éŒ¢éŒšéŒ£éŒºéŒµéŒ»éœé é¼é®é–éŽ°éŽ¬éŽ­éŽ”éŽ¹é–é—é¨é¥é˜éƒéééˆé¤éšé”é“éƒé‡éé¶é«éµé¡éºé‘é‘’é‘„é‘›é‘ é‘¢é‘žé‘ªéˆ©é‘°é‘µé‘·é‘½é‘šé‘¼é‘¾é’é‘¿é–‚é–‡é–Šé–”é––é–˜é–™"
  ],
  [
    "e880",
    "é– é–¨é–§é–­é–¼é–»é–¹é–¾é—Šæ¿¶é—ƒé—é—Œé—•é—”é—–é—œé—¡é—¥é—¢é˜¡é˜¨é˜®é˜¯é™‚é™Œé™é™‹é™·é™œé™žé™é™Ÿé™¦é™²é™¬éšéš˜éš•éš—éšªéš§éš±éš²éš°éš´éš¶éš¸éš¹é›Žé›‹é›‰é›è¥é›œéœé›•é›¹éœ„éœ†éœˆéœ“éœŽéœ‘éœéœ–éœ™éœ¤éœªéœ°éœ¹éœ½éœ¾é„é†éˆé‚é‰éœé é¤é¦é¨å‹’é«é±é¹éž…é¼éžéºéž†éž‹éžéžéžœéž¨éž¦éž£éž³éž´éŸƒéŸ†éŸˆéŸ‹éŸœéŸ­é½éŸ²ç«ŸéŸ¶éŸµé é Œé ¸é ¤é ¡é ·é ½é¡†é¡é¡‹é¡«é¡¯é¡°"
  ],
  [
    "e940",
    "é¡±é¡´é¡³é¢ªé¢¯é¢±é¢¶é£„é£ƒé£†é£©é£«é¤ƒé¤‰é¤’é¤”é¤˜é¤¡é¤é¤žé¤¤é¤ é¤¬é¤®é¤½é¤¾é¥‚é¥‰é¥…é¥é¥‹é¥‘é¥’é¥Œé¥•é¦—é¦˜é¦¥é¦­é¦®é¦¼é§Ÿé§›é§é§˜é§‘é§­é§®é§±é§²é§»é§¸é¨é¨é¨…é§¢é¨™é¨«é¨·é©…é©‚é©€é©ƒ"
  ],
  [
    "e980",
    "é¨¾é©•é©é©›é©—é©Ÿé©¢é©¥é©¤é©©é©«é©ªéª­éª°éª¼é«€é«é«‘é«“é«”é«žé«Ÿé«¢é«£é«¦é«¯é««é«®é«´é«±é«·é«»é¬†é¬˜é¬šé¬Ÿé¬¢é¬£é¬¥é¬§é¬¨é¬©é¬ªé¬®é¬¯é¬²é­„é­ƒé­é­é­Žé­‘é­˜é­´é®“é®ƒé®‘é®–é®—é®Ÿé® é®¨é®´é¯€é¯Šé®¹é¯†é¯é¯‘é¯’é¯£é¯¢é¯¤é¯”é¯¡é°ºé¯²é¯±é¯°é°•é°”é°‰é°“é°Œé°†é°ˆé°’é°Šé°„é°®é°›é°¥é°¤é°¡é°°é±‡é°²é±†é°¾é±šé± é±§é±¶é±¸é³§é³¬é³°é´‰é´ˆé³«é´ƒé´†é´ªé´¦é¶¯é´£é´Ÿéµ„é´•é´’éµé´¿é´¾éµ†éµˆ"
  ],
  [
    "ea40",
    "éµéµžéµ¤éµ‘éµéµ™éµ²é¶‰é¶‡é¶«éµ¯éµºé¶šé¶¤é¶©é¶²é·„é·é¶»é¶¸é¶ºé·†é·é·‚é·™é·“é·¸é·¦é·­é·¯é·½é¸šé¸›é¸žé¹µé¹¹é¹½éºéºˆéº‹éºŒéº’éº•éº‘éºéº¥éº©éº¸éºªéº­é¡é»Œé»Žé»é»é»”é»œé»žé»é» é»¥é»¨é»¯"
  ],
  [
    "ea80",
    "é»´é»¶é»·é»¹é»»é»¼é»½é¼‡é¼ˆçš·é¼•é¼¡é¼¬é¼¾é½Šé½’é½”é½£é½Ÿé½ é½¡é½¦é½§é½¬é½ªé½·é½²é½¶é¾•é¾œé¾ å ¯æ§‡é™ç‘¤å‡œç†™"
  ],
  [
    "ed40",
    "çºŠè¤œéˆéŠˆè“œä¿‰ç‚»æ˜±æ£ˆé‹¹æ›»å½…ä¸¨ä»¡ä»¼ä¼€ä¼ƒä¼¹ä½–ä¾’ä¾Šä¾šä¾”ä¿å€å€¢ä¿¿å€žå†å°å‚å‚”åƒ´åƒ˜å…Šå…¤å†å†¾å‡¬åˆ•åŠœåŠ¦å‹€å‹›åŒ€åŒ‡åŒ¤å²åŽ“åŽ²åï¨Žå’œå’Šå’©å“¿å–†å™å¥åž¬åŸˆåŸ‡ï¨"
  ],
  [
    "ed80",
    "ï¨å¢žå¢²å¤‹å¥“å¥›å¥å¥£å¦¤å¦ºå­–å¯€ç”¯å¯˜å¯¬å°žå²¦å²ºå³µå´§åµ“ï¨‘åµ‚åµ­å¶¸å¶¹å·å¼¡å¼´å½§å¾·å¿žææ‚…æ‚Šæƒžæƒ•æ„ æƒ²æ„‘æ„·æ„°æ†˜æˆ“æŠ¦æµæ‘ æ’æ“Žæ•Žæ˜€æ˜•æ˜»æ˜‰æ˜®æ˜žæ˜¤æ™¥æ™—æ™™ï¨’æ™³æš™æš æš²æš¿æ›ºæœŽï¤©æ¦æž»æ¡’æŸ€æ æ¡„æ£ï¨“æ¥¨ï¨”æ¦˜æ§¢æ¨°æ©«æ©†æ©³æ©¾æ«¢æ«¤æ¯–æ°¿æ±œæ²†æ±¯æ³šæ´„æ¶‡æµ¯æ¶–æ¶¬æ·æ·¸æ·²æ·¼æ¸¹æ¹œæ¸§æ¸¼æº¿æ¾ˆæ¾µæ¿µç€…ç€‡ç€¨ç‚…ç‚«ç„ç„„ç…œç…†ç…‡ï¨•ç‡ç‡¾çŠ±"
  ],
  [
    "ee40",
    "çŠ¾çŒ¤ï¨–ç·çŽ½ç‰ç–ç£ç’ç‡çµç¦çªç©ç®ç‘¢ç’‰ç’Ÿç”ç•¯çš‚çšœçšžçš›çš¦ï¨—ç†åŠ¯ç ¡ç¡Žç¡¤ç¡ºç¤°ï¨˜ï¨™ï¨šç¦”ï¨›ç¦›ç«‘ç«§ï¨œç««ç®žï¨çµˆçµœç¶·ç¶ ç·–ç¹’ç½‡ç¾¡ï¨žèŒè¢è¿è‡è¶è‘ˆè’´è•“è•™"
  ],
  [
    "ee80",
    "è•«ï¨Ÿè–°ï¨ ï¨¡è ‡è£µè¨’è¨·è©¹èª§èª¾è«Ÿï¨¢è«¶è­“è­¿è³°è³´è´’èµ¶ï¨£è»ï¨¤ï¨¥é§éƒžï¨¦é„•é„§é‡šé‡—é‡žé‡­é‡®é‡¤é‡¥éˆ†éˆéˆŠéˆºé‰€éˆ¼é‰Žé‰™é‰‘éˆ¹é‰§éŠ§é‰·é‰¸é‹§é‹—é‹™é‹ï¨§é‹•é‹ é‹“éŒ¥éŒ¡é‹»ï¨¨éŒžé‹¿éŒéŒ‚é°é—éŽ¤é†éžé¸é±é‘…é‘ˆé–’ï§œï¨©éšéš¯éœ³éœ»éƒééé‘é•é¡—é¡¥ï¨ªï¨«é¤§ï¨¬é¦žé©Žé«™é«œé­µé­²é®é®±é®»é°€éµ°éµ«ï¨­é¸™é»‘"
  ],
  [
    "eeef",
    "â…°",
    9,
    "ï¿¢ï¿¤ï¼‡ï¼‚"
  ],
  [
    "f040",
    "î€€",
    62
  ],
  [
    "f080",
    "î€¿",
    124
  ],
  [
    "f140",
    "î‚¼",
    62
  ],
  [
    "f180",
    "îƒ»",
    124
  ],
  [
    "f240",
    "î…¸",
    62
  ],
  [
    "f280",
    "î†·",
    124
  ],
  [
    "f340",
    "îˆ´",
    62
  ],
  [
    "f380",
    "î‰³",
    124
  ],
  [
    "f440",
    "î‹°",
    62
  ],
  [
    "f480",
    "îŒ¯",
    124
  ],
  [
    "f540",
    "îŽ¬",
    62
  ],
  [
    "f580",
    "î«",
    124
  ],
  [
    "f640",
    "î‘¨",
    62
  ],
  [
    "f680",
    "î’§",
    124
  ],
  [
    "f740",
    "î”¤",
    62
  ],
  [
    "f780",
    "î•£",
    124
  ],
  [
    "f840",
    "î— ",
    62
  ],
  [
    "f880",
    "î˜Ÿ",
    124
  ],
  [
    "f940",
    "îšœ"
  ],
  [
    "fa40",
    "â…°",
    9,
    "â… ",
    9,
    "ï¿¢ï¿¤ï¼‡ï¼‚ãˆ±â„–â„¡âˆµçºŠè¤œéˆéŠˆè“œä¿‰ç‚»æ˜±æ£ˆé‹¹æ›»å½…ä¸¨ä»¡ä»¼ä¼€ä¼ƒä¼¹ä½–ä¾’ä¾Šä¾šä¾”ä¿å€å€¢ä¿¿å€žå†å°å‚å‚”åƒ´åƒ˜å…Š"
  ],
  [
    "fa80",
    "å…¤å†å†¾å‡¬åˆ•åŠœåŠ¦å‹€å‹›åŒ€åŒ‡åŒ¤å²åŽ“åŽ²åï¨Žå’œå’Šå’©å“¿å–†å™å¥åž¬åŸˆåŸ‡ï¨ï¨å¢žå¢²å¤‹å¥“å¥›å¥å¥£å¦¤å¦ºå­–å¯€ç”¯å¯˜å¯¬å°žå²¦å²ºå³µå´§åµ“ï¨‘åµ‚åµ­å¶¸å¶¹å·å¼¡å¼´å½§å¾·å¿žææ‚…æ‚Šæƒžæƒ•æ„ æƒ²æ„‘æ„·æ„°æ†˜æˆ“æŠ¦æµæ‘ æ’æ“Žæ•Žæ˜€æ˜•æ˜»æ˜‰æ˜®æ˜žæ˜¤æ™¥æ™—æ™™ï¨’æ™³æš™æš æš²æš¿æ›ºæœŽï¤©æ¦æž»æ¡’æŸ€æ æ¡„æ£ï¨“æ¥¨ï¨”æ¦˜æ§¢æ¨°æ©«æ©†æ©³æ©¾æ«¢æ«¤æ¯–æ°¿æ±œæ²†æ±¯æ³šæ´„æ¶‡æµ¯"
  ],
  [
    "fb40",
    "æ¶–æ¶¬æ·æ·¸æ·²æ·¼æ¸¹æ¹œæ¸§æ¸¼æº¿æ¾ˆæ¾µæ¿µç€…ç€‡ç€¨ç‚…ç‚«ç„ç„„ç…œç…†ç…‡ï¨•ç‡ç‡¾çŠ±çŠ¾çŒ¤ï¨–ç·çŽ½ç‰ç–ç£ç’ç‡çµç¦çªç©ç®ç‘¢ç’‰ç’Ÿç”ç•¯çš‚çšœçšžçš›çš¦ï¨—ç†åŠ¯ç ¡ç¡Žç¡¤ç¡ºç¤°ï¨˜ï¨™"
  ],
  [
    "fb80",
    "ï¨šç¦”ï¨›ç¦›ç«‘ç«§ï¨œç««ç®žï¨çµˆçµœç¶·ç¶ ç·–ç¹’ç½‡ç¾¡ï¨žèŒè¢è¿è‡è¶è‘ˆè’´è•“è•™è•«ï¨Ÿè–°ï¨ ï¨¡è ‡è£µè¨’è¨·è©¹èª§èª¾è«Ÿï¨¢è«¶è­“è­¿è³°è³´è´’èµ¶ï¨£è»ï¨¤ï¨¥é§éƒžï¨¦é„•é„§é‡šé‡—é‡žé‡­é‡®é‡¤é‡¥éˆ†éˆéˆŠéˆºé‰€éˆ¼é‰Žé‰™é‰‘éˆ¹é‰§éŠ§é‰·é‰¸é‹§é‹—é‹™é‹ï¨§é‹•é‹ é‹“éŒ¥éŒ¡é‹»ï¨¨éŒžé‹¿éŒéŒ‚é°é—éŽ¤é†éžé¸é±é‘…é‘ˆé–’ï§œï¨©éšéš¯éœ³éœ»éƒééé‘é•é¡—é¡¥ï¨ªï¨«é¤§ï¨¬é¦žé©Žé«™"
  ],
  [
    "fc40",
    "é«œé­µé­²é®é®±é®»é°€éµ°éµ«ï¨­é¸™é»‘"
  ]
];
const require$$1 = [
  [
    "0",
    "\0",
    127
  ],
  [
    "8ea1",
    "ï½¡",
    62
  ],
  [
    "a1a1",
    "ã€€ã€ã€‚ï¼Œï¼Žãƒ»ï¼šï¼›ï¼Ÿï¼ã‚›ã‚œÂ´ï½€Â¨ï¼¾ï¿£ï¼¿ãƒ½ãƒ¾ã‚ã‚žã€ƒä»ã€…ã€†ã€‡ãƒ¼â€•â€ï¼ï¼¼ï½žâˆ¥ï½œâ€¦â€¥â€˜â€™â€œâ€ï¼ˆï¼‰ã€”ã€•ï¼»ï¼½ï½›ï½ã€ˆ",
    9,
    "ï¼‹ï¼Â±Ã—Ã·ï¼â‰ ï¼œï¼žâ‰¦â‰§âˆžâˆ´â™‚â™€Â°â€²â€³â„ƒï¿¥ï¼„ï¿ ï¿¡ï¼…ï¼ƒï¼†ï¼Šï¼ Â§â˜†â˜…â—‹â—â—Žâ—‡"
  ],
  [
    "a2a1",
    "â—†â–¡â– â–³â–²â–½â–¼â€»ã€’â†’â†â†‘â†“ã€“"
  ],
  [
    "a2ba",
    "âˆˆâˆ‹âŠ†âŠ‡âŠ‚âŠƒâˆªâˆ©"
  ],
  [
    "a2ca",
    "âˆ§âˆ¨ï¿¢â‡’â‡”âˆ€âˆƒ"
  ],
  [
    "a2dc",
    "âˆ âŠ¥âŒ’âˆ‚âˆ‡â‰¡â‰’â‰ªâ‰«âˆšâˆ½âˆâˆµâˆ«âˆ¬"
  ],
  [
    "a2f2",
    "â„«â€°â™¯â™­â™ªâ€ â€¡Â¶"
  ],
  [
    "a2fe",
    "â—¯"
  ],
  [
    "a3b0",
    "ï¼",
    9
  ],
  [
    "a3c1",
    "ï¼¡",
    25
  ],
  [
    "a3e1",
    "ï½",
    25
  ],
  [
    "a4a1",
    "ã",
    82
  ],
  [
    "a5a1",
    "ã‚¡",
    85
  ],
  [
    "a6a1",
    "Î‘",
    16,
    "Î£",
    6
  ],
  [
    "a6c1",
    "Î±",
    16,
    "Ïƒ",
    6
  ],
  [
    "a7a1",
    "Ð",
    5,
    "ÐÐ–",
    25
  ],
  [
    "a7d1",
    "Ð°",
    5,
    "Ñ‘Ð¶",
    25
  ],
  [
    "a8a1",
    "â”€â”‚â”Œâ”â”˜â””â”œâ”¬â”¤â”´â”¼â”â”ƒâ”â”“â”›â”—â”£â”³â”«â”»â•‹â” â”¯â”¨â”·â”¿â”â”°â”¥â”¸â•‚"
  ],
  [
    "ada1",
    "â‘ ",
    19,
    "â… ",
    9
  ],
  [
    "adc0",
    "ã‰ãŒ”ãŒ¢ããŒ˜ãŒ§ãŒƒãŒ¶ã‘ã—ãŒãŒ¦ãŒ£ãŒ«ãŠãŒ»ãŽœãŽãŽžãŽŽãŽã„ãŽ¡"
  ],
  [
    "addf",
    "ã»ã€ã€Ÿâ„–ãâ„¡ãŠ¤",
    4,
    "ãˆ±ãˆ²ãˆ¹ã¾ã½ã¼â‰’â‰¡âˆ«âˆ®âˆ‘âˆšâŠ¥âˆ âˆŸâŠ¿âˆµâˆ©âˆª"
  ],
  [
    "b0a1",
    "äºœå”–å¨ƒé˜¿å“€æ„›æŒ¨å§¶é€¢è‘µèŒœç©æ‚ªæ¡æ¸¥æ—­è‘¦èŠ¦é¯µæ¢“åœ§æ–¡æ‰±å®›å§è™»é£´çµ¢ç¶¾é®Žæˆ–ç²Ÿè¢·å®‰åºµæŒ‰æš—æ¡ˆé—‡éžæä»¥ä¼Šä½ä¾å‰å›²å¤·å§”å¨å°‰æƒŸæ„æ…°æ˜“æ¤…ç‚ºç•ç•°ç§»ç¶­ç·¯èƒƒèŽè¡£è¬‚é•éºåŒ»äº•äº¥åŸŸè‚²éƒç£¯ä¸€å£±æº¢é€¸ç¨²èŒ¨èŠ‹é°¯å…å°å’½å“¡å› å§»å¼•é£²æ·«èƒ¤è”­"
  ],
  [
    "b1a1",
    "é™¢é™°éš éŸ»å‹å³å®‡çƒç¾½è¿‚é›¨å¯éµœçªºä¸‘ç¢“è‡¼æ¸¦å˜˜å”„æ¬è”šé°»å§¥åŽ©æµ¦ç“œé–å™‚äº‘é‹é›²èé¤Œå¡å–¶å¬°å½±æ˜ æ›³æ „æ°¸æ³³æ´©ç‘›ç›ˆç©Žé ´è‹±è¡›è© é‹­æ¶²ç–«ç›Šé§…æ‚¦è¬è¶Šé–²æ¦ŽåŽ­å††åœ’å °å¥„å®´å»¶æ€¨æŽ©æ´æ²¿æ¼”ç‚Žç„”ç…™ç‡•çŒ¿ç¸è‰¶è‹‘è–—é é‰›é´›å¡©æ–¼æ±šç”¥å‡¹å¤®å¥¥å¾€å¿œ"
  ],
  [
    "b2a1",
    "æŠ¼æ—ºæ¨ªæ¬§æ®´çŽ‹ç¿è¥–é´¬é´Žé»„å²¡æ²–è»å„„å±‹æ†¶è‡†æ¡¶ç‰¡ä¹™ä¿ºå¸æ©æ¸©ç©éŸ³ä¸‹åŒ–ä»®ä½•ä¼½ä¾¡ä½³åŠ å¯å˜‰å¤å«å®¶å¯¡ç§‘æš‡æžœæž¶æ­Œæ²³ç«ç‚ç¦ç¦¾ç¨¼ç®‡èŠ±è‹›èŒ„è·è¯è“è¦èª²å˜©è²¨è¿¦éŽéœžèšŠä¿„å³¨æˆ‘ç‰™ç”»è‡¥èŠ½è›¾è³€é›…é¤“é§•ä»‹ä¼šè§£å›žå¡Šå£Šå»»å¿«æ€ªæ‚”æ¢æ‡æˆ’æ‹æ”¹"
  ],
  [
    "b3a1",
    "é­æ™¦æ¢°æµ·ç°ç•Œçš†çµµèŠ¥èŸ¹é–‹éšŽè²å‡±åŠ¾å¤–å’³å®³å´–æ…¨æ¦‚æ¶¯ç¢è“‹è¡—è©²éŽ§éª¸æµ¬é¦¨è›™åž£æŸ¿è›ŽéˆŽåŠƒåš‡å„å»“æ‹¡æ’¹æ ¼æ ¸æ®»ç²ç¢ºç©«è¦šè§’èµ«è¼ƒéƒ­é–£éš”é©å­¦å²³æ¥½é¡é¡ŽæŽ›ç¬ æ¨«æ©¿æ¢¶é°æ½Ÿå‰²å–æ°æ‹¬æ´»æ¸‡æ»‘è‘›è¤è½„ä¸”é°¹å¶æ¤›æ¨ºéž„æ ªå…œç«ƒè’²é‡œéŽŒå™›é´¨æ ¢èŒ…è±"
  ],
  [
    "b4a1",
    "ç²¥åˆˆè‹…ç“¦ä¹¾ä¾ƒå† å¯’åˆŠå‹˜å‹§å·»å–šå ªå§¦å®Œå®˜å¯›å¹²å¹¹æ‚£æ„Ÿæ…£æ†¾æ›æ•¢æŸ‘æ¡“æ£ºæ¬¾æ­“æ±—æ¼¢æ¾—æ½…ç’°ç”˜ç›£çœ‹ç«¿ç®¡ç°¡ç·©ç¼¶ç¿°è‚è‰¦èŽžè¦³è«Œè²«é‚„é‘‘é–“é–‘é–¢é™¥éŸ“é¤¨èˆ˜ä¸¸å«å²¸å·ŒçŽ©ç™Œçœ¼å²©ç¿«è´‹é›é ‘é¡”é¡˜ä¼ä¼Žå±å–œå™¨åŸºå¥‡å¬‰å¯„å²å¸Œå¹¾å¿Œæ®æœºæ——æ—¢æœŸæ£‹æ£„"
  ],
  [
    "b5a1",
    "æ©Ÿå¸°æ¯…æ°—æ±½ç•¿ç¥ˆå­£ç¨€ç´€å¾½è¦è¨˜è²´èµ·è»Œè¼é£¢é¨Žé¬¼äº€å½å„€å¦“å®œæˆ¯æŠ€æ“¬æ¬ºçŠ ç–‘ç¥‡ç¾©èŸ»èª¼è­°æŽ¬èŠéž å‰åƒå–«æ¡”æ©˜è©°ç §æµé»å´å®¢è„šè™é€†ä¸˜ä¹…ä»‡ä¼‘åŠå¸å®®å¼“æ€¥æ•‘æœ½æ±‚æ±²æ³£ç¸çƒç©¶çª®ç¬ˆç´šç³¾çµ¦æ—§ç‰›åŽ»å±…å·¨æ‹’æ‹ æŒ™æ¸ è™šè¨±è·é‹¸æ¼ç¦¦é­šäº¨äº«äº¬"
  ],
  [
    "b6a1",
    "ä¾›ä¾ åƒ‘å…‡ç«¶å…±å‡¶å”åŒ¡å¿å«å–¬å¢ƒå³¡å¼·å½Šæ€¯ææ­æŒŸæ•™æ©‹æ³ç‹‚ç‹­çŸ¯èƒ¸è„…èˆˆè•Žéƒ·é¡éŸ¿é¥—é©šä»°å‡å°­æšæ¥­å±€æ›²æ¥µçŽ‰æ¡ç²åƒ…å‹¤å‡å·¾éŒ¦æ–¤æ¬£æ¬½ç´ç¦ç¦½ç­‹ç·ŠèŠ¹èŒè¡¿è¥Ÿè¬¹è¿‘é‡‘åŸéŠ€ä¹å€¶å¥åŒºç‹—çŽ–çŸ©è‹¦èº¯é§†é§ˆé§’å…·æ„šè™žå–°ç©ºå¶å¯“é‡éš…ä¸²æ«›é‡§å±‘å±ˆ"
  ],
  [
    "b7a1",
    "æŽ˜çªŸæ²“é´è½¡çªªç†Šéšˆç²‚æ —ç¹°æ¡‘é¬å‹²å›è–«è¨“ç¾¤è»éƒ¡å¦è¢ˆç¥ä¿‚å‚¾åˆ‘å…„å•“åœ­çªåž‹å¥‘å½¢å¾„æµæ…¶æ…§æ†©æŽ²æºæ•¬æ™¯æ¡‚æ¸“ç•¦ç¨½ç³»çµŒç¶™ç¹‹ç½«èŒŽèŠè›è¨ˆè©£è­¦è»½é šé¶èŠ¸è¿Žé¯¨åŠ‡æˆŸæ’ƒæ¿€éš™æ¡å‚‘æ¬ æ±ºæ½”ç©´çµè¡€è¨£æœˆä»¶å€¹å€¦å¥å…¼åˆ¸å‰£å–§åœå …å«Œå»ºæ†²æ‡¸æ‹³æ²"
  ],
  [
    "b8a1",
    "æ¤œæ¨©ç‰½çŠ¬çŒ®ç ”ç¡¯çµ¹çœŒè‚©è¦‹è¬™è³¢è»’é£éµé™ºé¡•é¨“é¹¸å…ƒåŽŸåŽ³å¹»å¼¦æ¸›æºçŽ„ç¾çµƒèˆ·è¨€è«ºé™ä¹Žå€‹å¤å‘¼å›ºå§‘å­¤å·±åº«å¼§æˆ¸æ•…æž¯æ¹–ç‹ç³Šè¢´è‚¡èƒ¡è°è™Žèª‡è·¨éˆ·é›‡é¡§é¼“äº”äº’ä¼åˆå‘‰å¾å¨¯å¾Œå¾¡æ‚Ÿæ¢§æªŽç‘šç¢èªžèª¤è­·é†ä¹žé¯‰äº¤ä½¼ä¾¯å€™å€–å…‰å…¬åŠŸåŠ¹å‹¾åŽšå£å‘"
  ],
  [
    "b9a1",
    "åŽå–‰å‘åž¢å¥½å­”å­å®å·¥å·§å··å¹¸åºƒåºšåº·å¼˜æ’æ…ŒæŠ—æ‹˜æŽ§æ”»æ˜‚æ™ƒæ›´æ­æ ¡æ¢—æ§‹æ±Ÿæ´ªæµ©æ¸¯æºç”²çš‡ç¡¬ç¨¿ç³ ç´…ç´˜çµžç¶±è€•è€ƒè‚¯è‚±è…”è†èˆªè’è¡Œè¡¡è¬›è²¢è³¼éƒŠé…µé‰±ç ¿é‹¼é–¤é™é …é¦™é«˜é´»å‰›åŠ«å·åˆå£•æ‹·æ¿ è±ªè½Ÿéº¹å…‹åˆ»å‘Šå›½ç©€é…·éµ é»’ç„æ¼‰è…°ç”‘å¿½æƒšéª¨ç‹›è¾¼"
  ],
  [
    "baa1",
    "æ­¤é ƒä»Šå›°å¤å¢¾å©šæ¨æ‡‡æ˜æ˜†æ ¹æ¢±æ··ç—•ç´ºè‰®é­‚äº›ä½å‰å”†åµ¯å·¦å·®æŸ»æ²™ç‘³ç ‚è©éŽ–è£Ÿååº§æŒ«å‚µå‚¬å†æœ€å“‰å¡žå¦»å®°å½©æ‰æŽ¡æ ½æ­³æ¸ˆç½é‡‡çŠ€ç •ç ¦ç¥­æ–Žç´°èœè£è¼‰éš›å‰¤åœ¨æç½ªè²¡å†´å‚é˜ªå ºæ¦Šè‚´å’²å´ŽåŸ¼ç¢•é·ºä½œå‰Šå’‹æ¾æ˜¨æœ”æŸµçª„ç­–ç´¢éŒ¯æ¡œé®­ç¬¹åŒ™å†Šåˆ·"
  ],
  [
    "bba1",
    "å¯Ÿæ‹¶æ’®æ“¦æœ­æ®ºè–©é›‘çšé¯–æŒéŒ†é®«çš¿æ™’ä¸‰å‚˜å‚å±±æƒ¨æ’’æ•£æ¡Ÿç‡¦çŠç”£ç®—çº‚èš•è®ƒè³›é…¸é¤æ–¬æš«æ®‹ä»•ä»”ä¼ºä½¿åˆºå¸å²å—£å››å£«å§‹å§‰å§¿å­å±å¸‚å¸«å¿—æ€æŒ‡æ”¯å­œæ–¯æ–½æ—¨æžæ­¢æ­»æ°ç…ç¥‰ç§ç³¸ç´™ç´«è‚¢è„‚è‡³è¦–è©žè©©è©¦èªŒè«®è³‡è³œé›Œé£¼æ­¯äº‹ä¼¼ä¾å…å­—å¯ºæ…ˆæŒæ™‚"
  ],
  [
    "bca1",
    "æ¬¡æ»‹æ²»çˆ¾ç’½ç—”ç£ç¤ºè€Œè€³è‡ªè’”è¾žæ±é¹¿å¼è­˜é´«ç«ºè»¸å®é›«ä¸ƒå±åŸ·å¤±å«‰å®¤æ‚‰æ¹¿æ¼†ç–¾è³ªå®Ÿè”€ç¯ å²æŸ´èŠå±¡è•Šç¸žèˆŽå†™å°„æ¨èµ¦æ–œç…®ç¤¾ç´—è€…è¬è»Šé®è›‡é‚ªå€Ÿå‹ºå°ºæ“ç¼çˆµé…Œé‡ˆéŒ«è‹¥å¯‚å¼±æƒ¹ä¸»å–å®ˆæ‰‹æœ±æ®Šç‹©ç ç¨®è…«è¶£é…’é¦–å„’å—å‘ªå¯¿æŽˆæ¨¹ç¶¬éœ€å›šåŽå‘¨"
  ],
  [
    "bda1",
    "å®—å°±å·žä¿®æ„æ‹¾æ´²ç§€ç§‹çµ‚ç¹ç¿’è‡­èˆŸè’è¡†è¥²è®è¹´è¼¯é€±é…‹é…¬é›†é†œä»€ä½å……åå¾“æˆŽæŸ”æ±æ¸‹ç£ç¸¦é‡éŠƒå”å¤™å®¿æ·‘ç¥ç¸®ç²›å¡¾ç†Ÿå‡ºè¡“è¿°ä¿Šå³»æ˜¥çž¬ç«£èˆœé§¿å‡†å¾ªæ—¬æ¥¯æ®‰æ·³æº–æ½¤ç›¾ç´”å·¡éµé†‡é †å‡¦åˆæ‰€æš‘æ›™æ¸šåº¶ç·’ç½²æ›¸è–¯è—·è«¸åŠ©å™å¥³åºå¾æ•é‹¤é™¤å‚·å„Ÿ"
  ],
  [
    "bea1",
    "å‹åŒ å‡å¬å“¨å•†å”±å˜—å¥¨å¦¾å¨¼å®µå°†å°å°‘å°šåº„åºŠå» å½°æ‰¿æŠ„æ‹›æŽŒæ·æ˜‡æ˜Œæ˜­æ™¶æ¾æ¢¢æ¨Ÿæ¨µæ²¼æ¶ˆæ¸‰æ¹˜ç„¼ç„¦ç…§ç—‡çœç¡ç¤ç¥¥ç§°ç« ç¬‘ç²§ç´¹è‚–è–è’‹è•‰è¡è£³è¨Ÿè¨¼è©”è©³è±¡è³žé†¤é‰¦é¾é˜éšœéž˜ä¸Šä¸ˆä¸žä¹—å†—å‰°åŸŽå ´å£Œå¬¢å¸¸æƒ…æ“¾æ¡æ–æµ„çŠ¶ç•³ç©£è’¸è­²é†¸éŒ å˜±åŸ´é£¾"
  ],
  [
    "bfa1",
    "æ‹­æ¤æ®–ç‡­ç¹”è·è‰²è§¦é£Ÿè•è¾±å°»ä¼¸ä¿¡ä¾µå”‡å¨ å¯å¯©å¿ƒæ…ŽæŒ¯æ–°æ™‹æ£®æ¦›æµ¸æ·±ç”³ç–¹çœŸç¥žç§¦ç´³è‡£èŠ¯è–ªè¦ªè¨ºèº«è¾›é€²é‡éœ‡äººä»åˆƒå¡µå£¬å°‹ç”šå°½è…Žè¨Šè¿…é™£é­ç¬¥è«é ˆé…¢å›³åŽ¨é€—å¹åž‚å¸¥æŽ¨æ°´ç‚Šç¡ç²‹ç¿ è¡°é‚é…”éŒéŒ˜éšç‘žé«„å´‡åµ©æ•°æž¢è¶¨é››æ®æ‰æ¤™è…é —é›€è£¾"
  ],
  [
    "c0a1",
    "æ¾„æ‘ºå¯¸ä¸–ç€¬ç•æ˜¯å‡„åˆ¶å‹¢å§“å¾æ€§æˆæ”¿æ•´æ˜Ÿæ™´æ£²æ –æ­£æ¸…ç‰²ç”Ÿç››ç²¾è–å£°è£½è¥¿èª èª“è«‹é€é†’é’é™æ–‰ç¨Žè„†éš»å¸­æƒœæˆšæ–¥æ˜”æžçŸ³ç©ç±ç¸¾è„Šè²¬èµ¤è·¡è¹Ÿç¢©åˆ‡æ‹™æŽ¥æ‘‚æŠ˜è¨­çªƒç¯€èª¬é›ªçµ¶èˆŒè‰ä»™å…ˆåƒå å®£å°‚å°–å·æˆ¦æ‰‡æ’°æ “æ ´æ³‰æµ…æ´—æŸ“æ½œç…Žç…½æ—‹ç©¿ç®­ç·š"
  ],
  [
    "c1a1",
    "ç¹Šç¾¨è…ºèˆ›èˆ¹è–¦è©®è³Žè·µé¸é·éŠ­éŠ‘é–ƒé®®å‰å–„æ¼¸ç„¶å…¨ç¦…ç¹•è†³ç³Žå™Œå¡‘å²¨æŽªæ›¾æ›½æ¥šç‹™ç–ç–Žç¤Žç¥–ç§Ÿç²—ç´ çµ„è˜‡è¨´é˜»é¡é¼ åƒ§å‰µåŒå¢å€‰å–ªå£®å¥çˆ½å®‹å±¤åŒæƒ£æƒ³æœæŽƒæŒ¿æŽ»æ“æ—©æ›¹å·£æ§æ§½æ¼•ç‡¥äº‰ç—©ç›¸çª“ç³Ÿç·ç¶œè¡è‰è˜è‘¬è’¼è—»è£…èµ°é€é­éŽ—éœœé¨’åƒå¢—æ†Ž"
  ],
  [
    "c2a1",
    "è‡“è”µè´ˆé€ ä¿ƒå´å‰‡å³æ¯æ‰æŸæ¸¬è¶³é€Ÿä¿—å±žè³Šæ—ç¶šå’è¢–å…¶æƒå­˜å­«å°Šææ‘éœä»–å¤šå¤ªæ±°è©‘å”¾å •å¦¥æƒ°æ‰“æŸèˆµæ¥•é™€é§„é¨¨ä½“å †å¯¾è€å²±å¸¯å¾…æ€ æ…‹æˆ´æ›¿æ³°æ»žèƒŽè…¿è‹”è¢‹è²¸é€€é€®éšŠé»›é¯›ä»£å°å¤§ç¬¬é†é¡Œé·¹æ»ç€§å“å•„å®…æ‰˜æŠžæ‹“æ²¢æ¿¯ç¢è¨—é¸æ¿è«¾èŒ¸å‡§è›¸åª"
  ],
  [
    "c3a1",
    "å©ä½†é”è¾°å¥ªè„±å·½ç«ªè¾¿æ£šè°·ç‹¸é±ˆæ¨½èª°ä¸¹å˜å˜†å¦æ‹…æŽ¢æ—¦æ­Žæ·¡æ¹›ç‚­çŸ­ç«¯ç®ªç¶»è€½èƒ†è›‹èª•é›å›£å£‡å¼¾æ–­æš–æª€æ®µç”·è«‡å€¤çŸ¥åœ°å¼›æ¥æ™ºæ± ç—´ç¨šç½®è‡´èœ˜é…é¦³ç¯‰ç•œç«¹ç­‘è“„é€ç§©çª’èŒ¶å«¡ç€ä¸­ä»²å®™å¿ æŠ½æ˜¼æŸ±æ³¨è™«è¡·è¨»é…Žé‹³é§æ¨—ç€¦çŒªè‹§è‘—è²¯ä¸å…†å‡‹å–‹å¯µ"
  ],
  [
    "c4a1",
    "å¸–å¸³åºå¼”å¼µå½«å¾´æ‡²æŒ‘æš¢æœæ½®ç‰’ç”ºçœºè´è„¹è…¸è¶èª¿è«œè¶…è·³éŠšé•·é ‚é³¥å‹…æ—ç›´æœ•æ²ˆçè³ƒéŽ®é™³æ´¥å¢œæ¤Žæ§Œè¿½éŽšç—›é€šå¡šæ ‚æŽ´æ§»ä½ƒæ¼¬æŸ˜è¾»è”¦ç¶´é”æ¤¿æ½°åªå£·å¬¬ç´¬çˆªåŠé‡£é¶´äº­ä½Žåœåµå‰ƒè²žå‘ˆå ¤å®šå¸åº•åº­å»·å¼Ÿæ‚ŒæŠµæŒºææ¢¯æ±€ç¢‡ç¦Žç¨‹ç· è‰‡è¨‚è«¦è¹„é€“"
  ],
  [
    "c5a1",
    "é‚¸é„­é‡˜é¼Žæ³¥æ‘˜æ“¢æ•µæ»´çš„ç¬›é©é‘æººå“²å¾¹æ’¤è½è¿­é‰„å…¸å¡«å¤©å±•åº—æ·»çºç”œè²¼è»¢é¡›ç‚¹ä¼æ®¿æ¾±ç”°é›»å…Žåå µå¡—å¦¬å± å¾’æ–—æœæ¸¡ç™»èŸè³­é€”éƒ½éç ¥ç ºåŠªåº¦åœŸå¥´æ€’å€’å…šå†¬å‡åˆ€å”å¡”å¡˜å¥—å®•å³¶å¶‹æ‚¼æŠ•æ­æ±æ¡ƒæ¢¼æ£Ÿç›—æ·˜æ¹¯æ¶›ç¯ç‡ˆå½“ç—˜ç¥·ç­‰ç­”ç­’ç³–çµ±åˆ°"
  ],
  [
    "c6a1",
    "è‘£è•©è—¤è¨Žè¬„è±†è¸é€ƒé€é™é™¶é ­é¨°é—˜åƒå‹•åŒå ‚å°Žæ†§æ’žæ´žçž³ç«¥èƒ´è„é“éŠ…å³ é´‡åŒ¿å¾—å¾³æ¶œç‰¹ç£ç¦¿ç¯¤æ¯’ç‹¬èª­æ ƒæ©¡å‡¸çªæ¤´å±Šé³¶è‹«å¯…é…‰ç€žå™¸å±¯æƒ‡æ•¦æ²Œè±šéé “å‘‘æ›‡éˆå¥ˆé‚£å†…ä¹å‡ªè–™è¬Žç˜æºé‹æ¥¢é¦´ç¸„ç•·å—æ¥ è»Ÿé›£æ±äºŒå°¼å¼è¿©åŒ‚è³‘è‚‰è™¹å»¿æ—¥ä¹³å…¥"
  ],
  [
    "c7a1",
    "å¦‚å°¿éŸ®ä»»å¦Šå¿èªæ¿¡ç¦°ç¥¢å¯§è‘±çŒ«ç†±å¹´å¿µæ»æ’šç‡ƒç²˜ä¹ƒå»¼ä¹‹åŸœåš¢æ‚©æ¿ƒç´èƒ½è„³è†¿è¾²è¦—èš¤å·´æŠŠæ’­è¦‡æ·æ³¢æ´¾ç¶ç ´å©†ç½µèŠ­é¦¬ä¿³å»ƒæ‹æŽ’æ•—æ¯ç›ƒç‰ŒèƒŒè‚ºè¼©é…å€åŸ¹åª’æ¢…æ¥³ç…¤ç‹½è²·å£²è³ é™ªé€™è¿ç§¤çŸ§è©ä¼¯å‰¥åšæ‹æŸæ³Šç™½ç®”ç²•èˆ¶è–„è¿«æ›æ¼ çˆ†ç¸›èŽ«é§éº¦"
  ],
  [
    "c8a1",
    "å‡½ç®±ç¡²ç®¸è‚‡ç­ˆæ«¨å¹¡è‚Œç•‘ç• å…«é‰¢æºŒç™ºé†—é«ªä¼ç½°æŠœç­é–¥é³©å™ºå¡™è›¤éš¼ä¼´åˆ¤åŠåå›å¸†æ¬æ–‘æ¿æ°¾æ±Žç‰ˆçŠ¯ç­ç•”ç¹èˆ¬è—©è²©ç¯„é‡†ç…©é ’é£¯æŒ½æ™©ç•ªç›¤ç£è•ƒè›®åŒªå‘å¦å¦ƒåº‡å½¼æ‚²æ‰‰æ‰¹æŠ«æ–æ¯”æ³Œç–²çš®ç¢‘ç§˜ç·‹ç½·è‚¥è¢«èª¹è²»é¿éžé£›æ¨‹ç°¸å‚™å°¾å¾®æž‡æ¯˜çµçœ‰ç¾Ž"
  ],
  [
    "c9a1",
    "é¼»æŸŠç¨—åŒ¹ç–‹é«­å½¦è†è±è‚˜å¼¼å¿…ç•¢ç­†é€¼æ¡§å§«åª›ç´ç™¾è¬¬ä¿µå½ªæ¨™æ°·æ¼‚ç“¢ç¥¨è¡¨è©•è±¹å»Ÿæç—…ç§’è‹—éŒ¨é‹²è’œè›­é°­å“å½¬æ–Œæµœç€•è²§è³“é »æ•ç“¶ä¸ä»˜åŸ å¤«å©¦å¯Œå†¨å¸ƒåºœæ€–æ‰¶æ•·æ–§æ™®æµ®çˆ¶ç¬¦è…è†šèŠ™è­œè² è³¦èµ´é˜œé™„ä¾®æ’«æ­¦èˆžè‘¡è•ªéƒ¨å°æ¥“é¢¨è‘ºè•—ä¼å‰¯å¾©å¹…æœ"
  ],
  [
    "caa1",
    "ç¦è…¹è¤‡è¦†æ·µå¼—æ‰•æ²¸ä»ç‰©é®’åˆ†å»å™´å¢³æ†¤æ‰®ç„šå¥®ç²‰ç³žç´›é›°æ–‡èžä¸™ä½µå…µå¡€å¹£å¹³å¼ŠæŸ„ä¸¦è”½é–‰é™›ç±³é åƒ»å£ç™–ç¢§åˆ¥çž¥è”‘ç®†åå¤‰ç‰‡ç¯‡ç·¨è¾ºè¿”éä¾¿å‹‰å¨©å¼éž­ä¿èˆ—é‹ªåœƒæ•æ­©ç”«è£œè¼”ç©‚å‹Ÿå¢“æ…•æˆŠæš®æ¯ç°¿è©å€£ä¿¸åŒ…å‘†å ±å¥‰å®å³°å³¯å´©åº–æŠ±æ§æ”¾æ–¹æœ‹"
  ],
  [
    "cba1",
    "æ³•æ³¡çƒ¹ç ²ç¸«èƒžèŠ³èŒè“¬èœ‚è¤’è¨ªè±Šé‚¦é‹’é£½é³³éµ¬ä¹äº¡å‚å‰–åŠå¦¨å¸½å¿˜å¿™æˆ¿æš´æœ›æŸæ£’å†’ç´¡è‚ªè†¨è¬€è²Œè²¿é‰¾é˜²å é ¬åŒ—åƒ•åœå¢¨æ’²æœ´ç‰§ç¦ç©†é‡¦å‹ƒæ²¡æ®†å €å¹Œå¥”æœ¬ç¿»å‡¡ç›†æ‘©ç£¨é­”éº»åŸ‹å¦¹æ˜§æžšæ¯Žå“©æ§™å¹•è†œæž•é®ªæŸ¾é±’æ¡äº¦ä¿£åˆæŠ¹æœ«æ²«è¿„ä¾­ç¹­éº¿ä¸‡æ…¢æº€"
  ],
  [
    "cca1",
    "æ¼«è”“å‘³æœªé­…å·³ç®•å²¬å¯†èœœæ¹Šè“‘ç¨”è„ˆå¦™ç²æ°‘çœ å‹™å¤¢ç„¡ç‰ŸçŸ›éœ§éµ¡æ¤‹å©¿å¨˜å†¥åå‘½æ˜Žç›Ÿè¿·éŠ˜é³´å§ªç‰æ»…å…æ£‰ç¶¿ç·¬é¢éººæ‘¸æ¨¡èŒ‚å¦„å­Ÿæ¯›çŒ›ç›²ç¶²è€—è’™å„²æœ¨é»™ç›®æ¢å‹¿é¤…å°¤æˆ»ç±¾è²°å•æ‚¶ç´‹é–€åŒä¹Ÿå†¶å¤œçˆºè€¶é‡Žå¼¥çŸ¢åŽ„å½¹ç´„è–¬è¨³èºé–æŸ³è–®é‘“æ„‰æ„ˆæ²¹ç™’"
  ],
  [
    "cda1",
    "è«­è¼¸å”¯ä½‘å„ªå‹‡å‹å®¥å¹½æ‚ æ†‚æ–æœ‰æŸšæ¹§æ¶ŒçŒ¶çŒ·ç”±ç¥è£•èª˜éŠé‚‘éƒµé›„èžå¤•äºˆä½™ä¸Žèª‰è¼¿é å‚­å¹¼å¦–å®¹åº¸æšæºæ“æ›œæ¥Šæ§˜æ´‹æº¶ç†”ç”¨çª¯ç¾Šè€€è‘‰è“‰è¦è¬¡è¸Šé¥é™½é¤Šæ…¾æŠ‘æ¬²æ²ƒæµ´ç¿Œç¿¼æ·€ç¾…èžºè£¸æ¥èŽ±é ¼é›·æ´›çµ¡è½é…ªä¹±åµåµæ¬„æ¿«è—è˜­è¦§åˆ©åå±¥æŽæ¢¨ç†ç’ƒ"
  ],
  [
    "cea1",
    "ç—¢è£è£¡é‡Œé›¢é™¸å¾‹çŽ‡ç«‹è‘ŽæŽ ç•¥åŠ‰æµæºœç‰ç•™ç¡«ç²’éš†ç«œé¾ä¾¶æ…®æ—…è™œäº†äº®åƒšä¸¡å‡Œå¯®æ–™æ¢æ¶¼çŒŸç™‚çž­ç¨œç³§è‰¯è«’é¼é‡é™µé ˜åŠ›ç·‘å€«åŽ˜æž—æ·‹ç‡ç³è‡¨è¼ªéš£é±—éºŸç‘ å¡æ¶™ç´¯é¡žä»¤ä¼¶ä¾‹å†·åŠ±å¶ºæ€œçŽ²ç¤¼è‹“éˆ´éš·é›¶éœŠéº—é½¢æš¦æ­´åˆ—åŠ£çƒˆè£‚å»‰æ‹æ†æ¼£ç…‰ç°¾ç·´è¯"
  ],
  [
    "cfa1",
    "è“®é€£éŒ¬å‘‚é­¯æ«“ç‚‰è³‚è·¯éœ²åŠ´å©å»Šå¼„æœ—æ¥¼æ¦”æµªæ¼ç‰¢ç‹¼ç¯­è€è¾è‹éƒŽå…­éº“ç¦„è‚‹éŒ²è«–å€­å’Œè©±æ­ªè³„è„‡æƒ‘æž é·²äº™äº˜é°è©«è—è•¨æ¤€æ¹¾ç¢—è…•"
  ],
  [
    "d0a1",
    "å¼Œä¸ä¸•ä¸ªä¸±ä¸¶ä¸¼ä¸¿ä¹‚ä¹–ä¹˜äº‚äº…è±«äºŠèˆ’å¼äºŽäºžäºŸäº äº¢äº°äº³äº¶ä»Žä»ä»„ä»†ä»‚ä»—ä»žä»­ä»Ÿä»·ä¼‰ä½šä¼°ä½›ä½ä½—ä½‡ä½¶ä¾ˆä¾ä¾˜ä½»ä½©ä½°ä¾‘ä½¯ä¾†ä¾–å„˜ä¿”ä¿Ÿä¿Žä¿˜ä¿›ä¿‘ä¿šä¿ä¿¤ä¿¥å€šå€¨å€”å€ªå€¥å€…ä¼œä¿¶å€¡å€©å€¬ä¿¾ä¿¯å€‘å€†åƒå‡æœƒå•ååˆåšå–å¬å¸å‚€å‚šå‚…å‚´å‚²"
  ],
  [
    "d1a1",
    "åƒ‰åƒŠå‚³åƒ‚åƒ–åƒžåƒ¥åƒ­åƒ£åƒ®åƒ¹åƒµå„‰å„å„‚å„–å„•å„”å„šå„¡å„ºå„·å„¼å„»å„¿å…€å…’å…Œå…”å…¢ç«¸å…©å…ªå…®å†€å†‚å›˜å†Œå†‰å†å†‘å†“å†•å†–å†¤å†¦å†¢å†©å†ªå†«å†³å†±å†²å†°å†µå†½å‡…å‡‰å‡›å‡ è™•å‡©å‡­å‡°å‡µå‡¾åˆ„åˆ‹åˆ”åˆŽåˆ§åˆªåˆ®åˆ³åˆ¹å‰å‰„å‰‹å‰Œå‰žå‰”å‰ªå‰´å‰©å‰³å‰¿å‰½åŠåŠ”åŠ’å‰±åŠˆåŠ‘è¾¨"
  ],
  [
    "d2a1",
    "è¾§åŠ¬åŠ­åŠ¼åŠµå‹å‹å‹—å‹žå‹£å‹¦é£­å‹ å‹³å‹µå‹¸å‹¹åŒ†åŒˆç”¸åŒåŒåŒåŒ•åŒšåŒ£åŒ¯åŒ±åŒ³åŒ¸å€å†å…ä¸—å‰åå‡–åžå©å®å¤˜å»å·åŽ‚åŽ–åŽ åŽ¦åŽ¥åŽ®åŽ°åŽ¶åƒç°’é›™åŸæ›¼ç‡®å®å¨å­åºåå½å‘€å¬å­å¼å®å¶å©åå‘Žå’å‘µå’Žå‘Ÿå‘±å‘·å‘°å’’å‘»å’€å‘¶å’„å’å’†å“‡å’¢å’¸å’¥å’¬å“„å“ˆå’¨"
  ],
  [
    "d3a1",
    "å’«å“‚å’¤å’¾å’¼å“˜å“¥å“¦å”å””å“½å“®å“­å“ºå“¢å”¹å•€å•£å•Œå”®å•œå•…å•–å•—å”¸å”³å•å–™å–€å’¯å–Šå–Ÿå•»å•¾å–˜å–žå–®å•¼å–ƒå–©å–‡å–¨å—šå—…å—Ÿå—„å—œå—¤å—”å˜”å—·å˜–å—¾å—½å˜›å—¹å™Žå™ç‡Ÿå˜´å˜¶å˜²å˜¸å™«å™¤å˜¯å™¬å™ªåš†åš€åšŠåš åš”åšåš¥åš®åš¶åš´å›‚åš¼å›å›ƒå›€å›ˆå›Žå›‘å›“å›—å›®å›¹åœ€å›¿åœ„åœ‰"
  ],
  [
    "d4a1",
    "åœˆåœ‹åœåœ“åœ˜åœ–å—‡åœœåœ¦åœ·åœ¸åŽåœ»å€åå©åŸ€åžˆå¡å¿åž‰åž“åž åž³åž¤åžªåž°åŸƒåŸ†åŸ”åŸ’åŸ“å ŠåŸ–åŸ£å ‹å ™å å¡²å ¡å¡¢å¡‹å¡°æ¯€å¡’å ½å¡¹å¢…å¢¹å¢Ÿå¢«å¢ºå£žå¢»å¢¸å¢®å£…å£“å£‘å£—å£™å£˜å£¥å£œå£¤å£Ÿå£¯å£ºå£¹å£»å£¼å£½å¤‚å¤Šå¤å¤›æ¢¦å¤¥å¤¬å¤­å¤²å¤¸å¤¾ç«’å¥•å¥å¥Žå¥šå¥˜å¥¢å¥ å¥§å¥¬å¥©"
  ],
  [
    "d5a1",
    "å¥¸å¦å¦ä½žä¾«å¦£å¦²å§†å§¨å§œå¦å§™å§šå¨¥å¨Ÿå¨‘å¨œå¨‰å¨šå©€å©¬å©‰å¨µå¨¶å©¢å©ªåªšåª¼åª¾å«‹å«‚åª½å«£å«—å«¦å«©å«–å«ºå«»å¬Œå¬‹å¬–å¬²å«å¬ªå¬¶å¬¾å­ƒå­…å­€å­‘å­•å­šå­›å­¥å­©å­°å­³å­µå­¸æ–ˆå­ºå®€å®ƒå®¦å®¸å¯ƒå¯‡å¯‰å¯”å¯å¯¤å¯¦å¯¢å¯žå¯¥å¯«å¯°å¯¶å¯³å°…å°‡å°ˆå°å°“å° å°¢å°¨å°¸å°¹å±å±†å±Žå±“"
  ],
  [
    "d6a1",
    "å±å±å­±å±¬å±®ä¹¢å±¶å±¹å²Œå²‘å²”å¦›å²«å²»å²¶å²¼å²·å³…å²¾å³‡å³™å³©å³½å³ºå³­å¶Œå³ªå´‹å´•å´—åµœå´Ÿå´›å´‘å´”å´¢å´šå´™å´˜åµŒåµ’åµŽåµ‹åµ¬åµ³åµ¶å¶‡å¶„å¶‚å¶¢å¶å¶¬å¶®å¶½å¶å¶·å¶¼å·‰å·å·“å·’å·–å·›å·«å·²å·µå¸‹å¸šå¸™å¸‘å¸›å¸¶å¸·å¹„å¹ƒå¹€å¹Žå¹—å¹”å¹Ÿå¹¢å¹¤å¹‡å¹µå¹¶å¹ºéº¼å¹¿åº å»å»‚å»ˆå»å»"
  ],
  [
    "d7a1",
    "å»–å»£å»å»šå»›å»¢å»¡å»¨å»©å»¬å»±å»³å»°å»´å»¸å»¾å¼ƒå¼‰å½å½œå¼‹å¼‘å¼–å¼©å¼­å¼¸å½å½ˆå½Œå½Žå¼¯å½‘å½–å½—å½™å½¡å½­å½³å½·å¾ƒå¾‚å½¿å¾Šå¾ˆå¾‘å¾‡å¾žå¾™å¾˜å¾ å¾¨å¾­å¾¼å¿–å¿»å¿¤å¿¸å¿±å¿æ‚³å¿¿æ€¡æ æ€™æ€æ€©æ€Žæ€±æ€›æ€•æ€«æ€¦æ€æ€ºæšææªæ·æŸæŠæ†ææ£æƒæ¤æ‚æ¬æ«æ™æ‚æ‚æƒ§æ‚ƒæ‚š"
  ],
  [
    "d8a1",
    "æ‚„æ‚›æ‚–æ‚—æ‚’æ‚§æ‚‹æƒ¡æ‚¸æƒ æƒ“æ‚´å¿°æ‚½æƒ†æ‚µæƒ˜æ…æ„•æ„†æƒ¶æƒ·æ„€æƒ´æƒºæ„ƒæ„¡æƒ»æƒ±æ„æ„Žæ…‡æ„¾æ„¨æ„§æ…Šæ„¿æ„¼æ„¬æ„´æ„½æ…‚æ…„æ…³æ…·æ…˜æ…™æ…šæ…«æ…´æ…¯æ…¥æ…±æ…Ÿæ…æ…“æ…µæ†™æ†–æ†‡æ†¬æ†”æ†šæ†Šæ†‘æ†«æ†®æ‡Œæ‡Šæ‡‰æ‡·æ‡ˆæ‡ƒæ‡†æ†ºæ‡‹ç½¹æ‡æ‡¦æ‡£æ‡¶æ‡ºæ‡´æ‡¿æ‡½æ‡¼æ‡¾æˆ€æˆˆæˆ‰æˆæˆŒæˆ”æˆ›"
  ],
  [
    "d9a1",
    "æˆžæˆ¡æˆªæˆ®æˆ°æˆ²æˆ³æ‰æ‰Žæ‰žæ‰£æ‰›æ‰ æ‰¨æ‰¼æŠ‚æŠ‰æ‰¾æŠ’æŠ“æŠ–æ‹”æŠƒæŠ”æ‹—æ‹‘æŠ»æ‹æ‹¿æ‹†æ“”æ‹ˆæ‹œæ‹Œæ‹Šæ‹‚æ‹‡æŠ›æ‹‰æŒŒæ‹®æ‹±æŒ§æŒ‚æŒˆæ‹¯æ‹µææŒ¾ææœææŽ–æŽŽæŽ€æŽ«æ¶æŽ£æŽæŽ‰æŽŸæŽµæ«æ©æŽ¾æ©æ€æ†æ£æ‰æ’æ¶æ„æ–æ´æ†æ“æ¦æ¶æ”æ—æ¨ææ‘§æ‘¯æ‘¶æ‘Žæ”ªæ’•æ’“æ’¥æ’©æ’ˆæ’¼"
  ],
  [
    "daa1",
    "æ“šæ“’æ“…æ“‡æ’»æ“˜æ“‚æ“±æ“§èˆ‰æ“ æ“¡æŠ¬æ“£æ“¯æ”¬æ“¶æ“´æ“²æ“ºæ”€æ“½æ”˜æ”œæ”…æ”¤æ”£æ”«æ”´æ”µæ”·æ”¶æ”¸ç•‹æ•ˆæ•–æ••æ•æ•˜æ•žæ•æ•²æ•¸æ–‚æ–ƒè®Šæ–›æ–Ÿæ–«æ–·æ—ƒæ—†æ—æ—„æ—Œæ—’æ—›æ—™æ— æ—¡æ—±æ²æ˜Šæ˜ƒæ—»æ³æ˜µæ˜¶æ˜´æ˜œæ™æ™„æ™‰æ™æ™žæ™æ™¤æ™§æ™¨æ™Ÿæ™¢æ™°æšƒæšˆæšŽæš‰æš„æš˜æšæ›æš¹æ›‰æš¾æš¼"
  ],
  [
    "dba1",
    "æ›„æš¸æ›–æ›šæ› æ˜¿æ›¦æ›©æ›°æ›µæ›·æœæœ–æœžæœ¦æœ§éœ¸æœ®æœ¿æœ¶ææœ¸æœ·æ†æžæ æ™æ£æ¤æž‰æ°æž©æ¼æªæžŒæž‹æž¦æž¡æž…æž·æŸ¯æž´æŸ¬æž³æŸ©æž¸æŸ¤æŸžæŸæŸ¢æŸ®æž¹æŸŽæŸ†æŸ§æªœæ žæ¡†æ ©æ¡€æ¡æ ²æ¡Žæ¢³æ «æ¡™æ¡£æ¡·æ¡¿æ¢Ÿæ¢æ¢­æ¢”æ¢æ¢›æ¢ƒæª®æ¢¹æ¡´æ¢µæ¢ æ¢ºæ¤æ¢æ¡¾æ¤æ£Šæ¤ˆæ£˜æ¤¢æ¤¦æ£¡æ¤Œæ£"
  ],
  [
    "dca1",
    "æ£”æ£§æ£•æ¤¶æ¤’æ¤„æ£—æ££æ¤¥æ£¹æ£ æ£¯æ¤¨æ¤ªæ¤šæ¤£æ¤¡æ£†æ¥¹æ¥·æ¥œæ¥¸æ¥«æ¥”æ¥¾æ¥®æ¤¹æ¥´æ¤½æ¥™æ¤°æ¥¡æ¥žæ¥æ¦æ¥ªæ¦²æ¦®æ§æ¦¿æ§æ§“æ¦¾æ§Žå¯¨æ§Šæ§æ¦»æ§ƒæ¦§æ¨®æ¦‘æ¦ æ¦œæ¦•æ¦´æ§žæ§¨æ¨‚æ¨›æ§¿æ¬Šæ§¹æ§²æ§§æ¨…æ¦±æ¨žæ§­æ¨”æ§«æ¨Šæ¨’æ«æ¨£æ¨“æ©„æ¨Œæ©²æ¨¶æ©¸æ©‡æ©¢æ©™æ©¦æ©ˆæ¨¸æ¨¢æªæªæª æª„æª¢æª£"
  ],
  [
    "dda1",
    "æª—è˜—æª»æ«ƒæ«‚æª¸æª³æª¬æ«žæ«‘æ«Ÿæªªæ«šæ«ªæ«»æ¬…è˜–æ«ºæ¬’æ¬–é¬±æ¬Ÿæ¬¸æ¬·ç›œæ¬¹é£®æ­‡æ­ƒæ­‰æ­æ­™æ­”æ­›æ­Ÿæ­¡æ­¸æ­¹æ­¿æ®€æ®„æ®ƒæ®æ®˜æ®•æ®žæ®¤æ®ªæ®«æ®¯æ®²æ®±æ®³æ®·æ®¼æ¯†æ¯‹æ¯“æ¯Ÿæ¯¬æ¯«æ¯³æ¯¯éº¾æ°ˆæ°“æ°”æ°›æ°¤æ°£æ±žæ±•æ±¢æ±ªæ²‚æ²æ²šæ²æ²›æ±¾æ±¨æ±³æ²’æ²æ³„æ³±æ³“æ²½æ³—æ³…æ³æ²®æ²±æ²¾"
  ],
  [
    "dea1",
    "æ²ºæ³›æ³¯æ³™æ³ªæ´Ÿè¡æ´¶æ´«æ´½æ´¸æ´™æ´µæ´³æ´’æ´Œæµ£æ¶“æµ¤æµšæµ¹æµ™æ¶Žæ¶•æ¿¤æ¶…æ·¹æ¸•æ¸Šæ¶µæ·‡æ·¦æ¶¸æ·†æ·¬æ·žæ·Œæ·¨æ·’æ·…æ·ºæ·™æ·¤æ·•æ·ªæ·®æ¸­æ¹®æ¸®æ¸™æ¹²æ¹Ÿæ¸¾æ¸£æ¹«æ¸«æ¹¶æ¹æ¸Ÿæ¹ƒæ¸ºæ¹Žæ¸¤æ»¿æ¸æ¸¸æº‚æºªæº˜æ»‰æº·æ»“æº½æº¯æ»„æº²æ»”æ»•æºæº¥æ»‚æºŸæ½æ¼‘çŒæ»¬æ»¸æ»¾æ¼¿æ»²æ¼±æ»¯æ¼²æ»Œ"
  ],
  [
    "dfa1",
    "æ¼¾æ¼“æ»·æ¾†æ½ºæ½¸æ¾æ¾€æ½¯æ½›æ¿³æ½­æ¾‚æ½¼æ½˜æ¾Žæ¾‘æ¿‚æ½¦æ¾³æ¾£æ¾¡æ¾¤æ¾¹æ¿†æ¾ªæ¿Ÿæ¿•æ¿¬æ¿”æ¿˜æ¿±æ¿®æ¿›ç€‰ç€‹æ¿ºç€‘ç€ç€æ¿¾ç€›ç€šæ½´ç€ç€˜ç€Ÿç€°ç€¾ç€²ç‘ç£ç‚™ç‚’ç‚¯çƒ±ç‚¬ç‚¸ç‚³ç‚®çƒŸçƒ‹çƒçƒ™ç„‰çƒ½ç„œç„™ç…¥ç…•ç†ˆç…¦ç…¢ç…Œç…–ç…¬ç†ç‡»ç†„ç†•ç†¨ç†¬ç‡—ç†¹ç†¾ç‡’ç‡‰ç‡”ç‡Žç‡ ç‡¬ç‡§ç‡µç‡¼"
  ],
  [
    "e0a1",
    "ç‡¹ç‡¿çˆçˆçˆ›çˆ¨çˆ­çˆ¬çˆ°çˆ²çˆ»çˆ¼çˆ¿ç‰€ç‰†ç‰‹ç‰˜ç‰´ç‰¾çŠ‚çŠçŠ‡çŠ’çŠ–çŠ¢çŠ§çŠ¹çŠ²ç‹ƒç‹†ç‹„ç‹Žç‹’ç‹¢ç‹ ç‹¡ç‹¹ç‹·å€çŒ—çŒŠçŒœçŒ–çŒçŒ´çŒ¯çŒ©çŒ¥çŒ¾çŽçé»˜ç—çªç¨ç°ç¸çµç»çºçˆçŽ³çŽçŽ»ç€ç¥ç®çžç’¢ç…ç‘¯ç¥ç¸ç²çºç‘•ç¿ç‘Ÿç‘™ç‘ç‘œç‘©ç‘°ç‘£ç‘ªç‘¶ç‘¾ç’‹ç’žç’§ç“Šç“ç“”ç±"
  ],
  [
    "e1a1",
    "ç“ ç“£ç“§ç“©ç“®ç“²ç“°ç“±ç“¸ç“·ç”„ç”ƒç”…ç”Œç”Žç”ç”•ç”“ç”žç”¦ç”¬ç”¼ç•„ç•ç•Šç•‰ç•›ç•†ç•šç•©ç•¤ç•§ç•«ç•­ç•¸ç•¶ç–†ç–‡ç•´ç–Šç–‰ç–‚ç–”ç–šç–ç–¥ç–£ç—‚ç–³ç—ƒç–µç–½ç–¸ç–¼ç–±ç—ç—Šç—’ç—™ç—£ç—žç—¾ç—¿ç—¼ç˜ç—°ç—ºç—²ç—³ç˜‹ç˜ç˜‰ç˜Ÿç˜§ç˜ ç˜¡ç˜¢ç˜¤ç˜´ç˜°ç˜»ç™‡ç™ˆç™†ç™œç™˜ç™¡ç™¢ç™¨ç™©ç™ªç™§ç™¬ç™°"
  ],
  [
    "e2a1",
    "ç™²ç™¶ç™¸ç™¼çš€çšƒçšˆçš‹çšŽçš–çš“çš™çššçš°çš´çš¸çš¹çšºç›‚ç›ç›–ç›’ç›žç›¡ç›¥ç›§ç›ªè˜¯ç›»çœˆçœ‡çœ„çœ©çœ¤çœžçœ¥çœ¦çœ›çœ·çœ¸ç‡çšç¨ç«ç›ç¥ç¿ç¾ç¹çžŽçž‹çž‘çž çžžçž°çž¶çž¹çž¿çž¼çž½çž»çŸ‡çŸçŸ—çŸšçŸœçŸ£çŸ®çŸ¼ç Œç ’ç¤¦ç  ç¤ªç¡…ç¢Žç¡´ç¢†ç¡¼ç¢šç¢Œç¢£ç¢µç¢ªç¢¯ç£‘ç£†ç£‹ç£”ç¢¾ç¢¼ç£…ç£Šç£¬"
  ],
  [
    "e3a1",
    "ç£§ç£šç£½ç£´ç¤‡ç¤’ç¤‘ç¤™ç¤¬ç¤«ç¥€ç¥ ç¥—ç¥Ÿç¥šç¥•ç¥“ç¥ºç¥¿ç¦Šç¦ç¦§é½‹ç¦ªç¦®ç¦³ç¦¹ç¦ºç§‰ç§•ç§§ç§¬ç§¡ç§£ç¨ˆç¨ç¨˜ç¨™ç¨ ç¨Ÿç¦€ç¨±ç¨»ç¨¾ç¨·ç©ƒç©—ç©‰ç©¡ç©¢ç©©é¾ç©°ç©¹ç©½çªˆçª—çª•çª˜çª–çª©ç«ˆçª°çª¶ç«…ç«„çª¿é‚ƒç«‡ç«Šç«ç«ç«•ç«“ç«™ç«šç«ç«¡ç«¢ç«¦ç«­ç«°ç¬‚ç¬ç¬Šç¬†ç¬³ç¬˜ç¬™ç¬žç¬µç¬¨ç¬¶ç­"
  ],
  [
    "e4a1",
    "ç­ºç¬„ç­ç¬‹ç­Œç­…ç­µç­¥ç­´ç­§ç­°ç­±ç­¬ç­®ç®ç®˜ç®Ÿç®ç®œç®šç®‹ç®’ç®ç­ç®™ç¯‹ç¯ç¯Œç¯ç®´ç¯†ç¯ç¯©ç°‘ç°”ç¯¦ç¯¥ç± ç°€ç°‡ç°“ç¯³ç¯·ç°—ç°ç¯¶ç°£ç°§ç°ªç°Ÿç°·ç°«ç°½ç±Œç±ƒç±”ç±ç±€ç±ç±˜ç±Ÿç±¤ç±–ç±¥ç±¬ç±µç²ƒç²ç²¤ç²­ç²¢ç²«ç²¡ç²¨ç²³ç²²ç²±ç²®ç²¹ç²½ç³€ç³…ç³‚ç³˜ç³’ç³œç³¢é¬»ç³¯ç³²ç³´ç³¶ç³ºç´†"
  ],
  [
    "e5a1",
    "ç´‚ç´œç´•ç´Šçµ…çµ‹ç´®ç´²ç´¿ç´µçµ†çµ³çµ–çµŽçµ²çµ¨çµ®çµçµ£ç¶“ç¶‰çµ›ç¶çµ½ç¶›ç¶ºç¶®ç¶£ç¶µç·‡ç¶½ç¶«ç¸½ç¶¢ç¶¯ç·œç¶¸ç¶Ÿç¶°ç·˜ç·ç·¤ç·žç·»ç·²ç·¡ç¸…ç¸Šç¸£ç¸¡ç¸’ç¸±ç¸Ÿç¸‰ç¸‹ç¸¢ç¹†ç¹¦ç¸»ç¸µç¸¹ç¹ƒç¸·ç¸²ç¸ºç¹§ç¹ç¹–ç¹žç¹™ç¹šç¹¹ç¹ªç¹©ç¹¼ç¹»çºƒç·•ç¹½è¾®ç¹¿çºˆçº‰çºŒçº’çºçº“çº”çº–çºŽçº›çºœç¼¸ç¼º"
  ],
  [
    "e6a1",
    "ç½…ç½Œç½ç½Žç½ç½‘ç½•ç½”ç½˜ç½Ÿç½ ç½¨ç½©ç½§ç½¸ç¾‚ç¾†ç¾ƒç¾ˆç¾‡ç¾Œç¾”ç¾žç¾ç¾šç¾£ç¾¯ç¾²ç¾¹ç¾®ç¾¶ç¾¸è­±ç¿…ç¿†ç¿Šç¿•ç¿”ç¿¡ç¿¦ç¿©ç¿³ç¿¹é£œè€†è€„è€‹è€’è€˜è€™è€œè€¡è€¨è€¿è€»èŠè†è’è˜èšèŸè¢è¨è³è²è°è¶è¹è½è¿è‚„è‚†è‚…è‚›è‚“è‚šè‚­å†è‚¬èƒ›èƒ¥èƒ™èƒèƒ„èƒšèƒ–è„‰èƒ¯èƒ±è„›è„©è„£è„¯è…‹"
  ],
  [
    "e7a1",
    "éš‹è…†è„¾è…“è…‘èƒ¼è…±è…®è…¥è…¦è…´è†ƒè†ˆè†Šè†€è†‚è† è†•è†¤è†£è…Ÿè†“è†©è†°è†µè†¾è†¸è†½è‡€è‡‚è†ºè‡‰è‡è‡‘è‡™è‡˜è‡ˆè‡šè‡Ÿè‡ è‡§è‡ºè‡»è‡¾èˆèˆ‚èˆ…èˆ‡èˆŠèˆèˆèˆ–èˆ©èˆ«èˆ¸èˆ³è‰€è‰™è‰˜è‰è‰šè‰Ÿè‰¤è‰¢è‰¨è‰ªè‰«èˆ®è‰±è‰·è‰¸è‰¾èŠèŠ’èŠ«èŠŸèŠ»èŠ¬è‹¡è‹£è‹Ÿè‹’è‹´è‹³è‹ºèŽ“èŒƒè‹»è‹¹è‹žèŒ†è‹œèŒ‰è‹™"
  ],
  [
    "e8a1",
    "èŒµèŒ´èŒ–èŒ²èŒ±è€èŒ¹èè…èŒ¯èŒ«èŒ—èŒ˜èŽ…èŽšèŽªèŽŸèŽ¢èŽ–èŒ£èŽŽèŽ‡èŽŠè¼èŽµè³èµèŽ èŽ‰èŽ¨è´è“è«èŽè½èƒè˜è‹èè·è‡è è²èè¢è èŽ½è¸è”†è»è‘­èªè¼è•šè’„è‘·è‘«è’­è‘®è’‚è‘©è‘†è¬è‘¯è‘¹èµè“Šè‘¢è’¹è’¿è’Ÿè“™è“è’»è“šè“è“è“†è“–è’¡è”¡è“¿è“´è”—è”˜è”¬è”Ÿè”•è””è“¼è•€è•£è•˜è•ˆ"
  ],
  [
    "e9a1",
    "è•è˜‚è•‹è••è–€è–¤è–ˆè–‘è–Šè–¨è•­è–”è–›è—ªè–‡è–œè•·è•¾è–è—‰è–ºè—è–¹è—è—•è—è—¥è—œè—¹è˜Šè˜“è˜‹è—¾è—ºè˜†è˜¢è˜šè˜°è˜¿è™ä¹•è™”è™Ÿè™§è™±èš“èš£èš©èšªèš‹èšŒèš¶èš¯è›„è›†èš°è›‰è £èš«è›”è›žè›©è›¬è›Ÿè››è›¯èœ’èœ†èœˆèœ€èœƒè›»èœ‘èœ‰èœè›¹èœŠèœ´èœ¿èœ·èœ»èœ¥èœ©èœšè èŸè¸èŒèŽè´è—è¨è®è™"
  ],
  [
    "eaa1",
    "è“è£èªè …èž¢èžŸèž‚èž¯èŸ‹èž½èŸ€èŸé›–èž«èŸ„èž³èŸ‡èŸ†èž»èŸ¯èŸ²èŸ è è èŸ¾èŸ¶èŸ·è ŽèŸ’è ‘è –è •è ¢è ¡è ±è ¶è ¹è §è »è¡„è¡‚è¡’è¡™è¡žè¡¢è¡«è¢è¡¾è¢žè¡µè¡½è¢µè¡²è¢‚è¢—è¢’è¢®è¢™è¢¢è¢è¢¤è¢°è¢¿è¢±è£ƒè£„è£”è£˜è£™è£è£¹è¤‚è£¼è£´è£¨è£²è¤„è¤Œè¤Šè¤“è¥ƒè¤žè¤¥è¤ªè¤«è¥è¥„è¤»è¤¶è¤¸è¥Œè¤è¥ è¥ž"
  ],
  [
    "eba1",
    "è¥¦è¥¤è¥­è¥ªè¥¯è¥´è¥·è¥¾è¦ƒè¦ˆè¦Šè¦“è¦˜è¦¡è¦©è¦¦è¦¬è¦¯è¦²è¦ºè¦½è¦¿è§€è§šè§œè§è§§è§´è§¸è¨ƒè¨–è¨è¨Œè¨›è¨è¨¥è¨¶è©è©›è©’è©†è©ˆè©¼è©­è©¬è©¢èª…èª‚èª„èª¨èª¡èª‘èª¥èª¦èªšèª£è«„è«è«‚è«šè««è«³è«§è«¤è«±è¬”è« è«¢è«·è«žè«›è¬Œè¬‡è¬šè«¡è¬–è¬è¬—è¬ è¬³éž«è¬¦è¬«è¬¾è¬¨è­è­Œè­è­Žè­‰è­–è­›è­šè­«"
  ],
  [
    "eca1",
    "è­Ÿè­¬è­¯è­´è­½è®€è®Œè®Žè®’è®“è®–è®™è®šè°ºè±è°¿è±ˆè±Œè±Žè±è±•è±¢è±¬è±¸è±ºè²‚è²‰è²…è²Šè²è²Žè²”è±¼è²˜æˆè²­è²ªè²½è²²è²³è²®è²¶è³ˆè³è³¤è³£è³šè³½è³ºè³»è´„è´…è´Šè´‡è´è´è´é½Žè´“è³è´”è´–èµ§èµ­èµ±èµ³è¶è¶™è·‚è¶¾è¶ºè·è·šè·–è·Œè·›è·‹è·ªè·«è·Ÿè·£è·¼è¸ˆè¸‰è·¿è¸è¸žè¸è¸Ÿè¹‚è¸µè¸°è¸´è¹Š"
  ],
  [
    "eda1",
    "è¹‡è¹‰è¹Œè¹è¹ˆè¹™è¹¤è¹ è¸ªè¹£è¹•è¹¶è¹²è¹¼èºèº‡èº…èº„èº‹èºŠèº“èº‘èº”èº™èºªèº¡èº¬èº°è»†èº±èº¾è»…è»ˆè»‹è»›è»£è»¼è»»è»«è»¾è¼Šè¼…è¼•è¼’è¼™è¼“è¼œè¼Ÿè¼›è¼Œè¼¦è¼³è¼»è¼¹è½…è½‚è¼¾è½Œè½‰è½†è½Žè½—è½œè½¢è½£è½¤è¾œè¾Ÿè¾£è¾­è¾¯è¾·è¿šè¿¥è¿¢è¿ªè¿¯é‚‡è¿´é€…è¿¹è¿ºé€‘é€•é€¡é€é€žé€–é€‹é€§é€¶é€µé€¹è¿¸"
  ],
  [
    "eea1",
    "ééé‘é’é€Žé‰é€¾é–é˜éžé¨é¯é¶éš¨é²é‚‚é½é‚é‚€é‚Šé‚‰é‚é‚¨é‚¯é‚±é‚µéƒ¢éƒ¤æ‰ˆéƒ›é„‚é„’é„™é„²é„°é…Šé…–é…˜é…£é…¥é…©é…³é…²é†‹é†‰é†‚é†¢é†«é†¯é†ªé†µé†´é†ºé‡€é‡é‡‰é‡‹é‡é‡–é‡Ÿé‡¡é‡›é‡¼é‡µé‡¶éˆžé‡¿éˆ”éˆ¬éˆ•éˆ‘é‰žé‰—é‰…é‰‰é‰¤é‰ˆéŠ•éˆ¿é‰‹é‰éŠœéŠ–éŠ“éŠ›é‰šé‹éŠ¹éŠ·é‹©éŒé‹ºé„éŒ®"
  ],
  [
    "efa1",
    "éŒ™éŒ¢éŒšéŒ£éŒºéŒµéŒ»éœé é¼é®é–éŽ°éŽ¬éŽ­éŽ”éŽ¹é–é—é¨é¥é˜éƒéééˆé¤éšé”é“éƒé‡éé¶é«éµé¡éºé‘é‘’é‘„é‘›é‘ é‘¢é‘žé‘ªéˆ©é‘°é‘µé‘·é‘½é‘šé‘¼é‘¾é’é‘¿é–‚é–‡é–Šé–”é––é–˜é–™é– é–¨é–§é–­é–¼é–»é–¹é–¾é—Šæ¿¶é—ƒé—é—Œé—•é—”é—–é—œé—¡é—¥é—¢é˜¡é˜¨é˜®é˜¯é™‚é™Œé™é™‹é™·é™œé™ž"
  ],
  [
    "f0a1",
    "é™é™Ÿé™¦é™²é™¬éšéš˜éš•éš—éšªéš§éš±éš²éš°éš´éš¶éš¸éš¹é›Žé›‹é›‰é›è¥é›œéœé›•é›¹éœ„éœ†éœˆéœ“éœŽéœ‘éœéœ–éœ™éœ¤éœªéœ°éœ¹éœ½éœ¾é„é†éˆé‚é‰éœé é¤é¦é¨å‹’é«é±é¹éž…é¼éžéºéž†éž‹éžéžéžœéž¨éž¦éž£éž³éž´éŸƒéŸ†éŸˆéŸ‹éŸœéŸ­é½éŸ²ç«ŸéŸ¶éŸµé é Œé ¸é ¤é ¡é ·é ½é¡†é¡é¡‹é¡«é¡¯é¡°"
  ],
  [
    "f1a1",
    "é¡±é¡´é¡³é¢ªé¢¯é¢±é¢¶é£„é£ƒé£†é£©é£«é¤ƒé¤‰é¤’é¤”é¤˜é¤¡é¤é¤žé¤¤é¤ é¤¬é¤®é¤½é¤¾é¥‚é¥‰é¥…é¥é¥‹é¥‘é¥’é¥Œé¥•é¦—é¦˜é¦¥é¦­é¦®é¦¼é§Ÿé§›é§é§˜é§‘é§­é§®é§±é§²é§»é§¸é¨é¨é¨…é§¢é¨™é¨«é¨·é©…é©‚é©€é©ƒé¨¾é©•é©é©›é©—é©Ÿé©¢é©¥é©¤é©©é©«é©ªéª­éª°éª¼é«€é«é«‘é«“é«”é«žé«Ÿé«¢é«£é«¦é«¯é««é«®é«´é«±é«·"
  ],
  [
    "f2a1",
    "é«»é¬†é¬˜é¬šé¬Ÿé¬¢é¬£é¬¥é¬§é¬¨é¬©é¬ªé¬®é¬¯é¬²é­„é­ƒé­é­é­Žé­‘é­˜é­´é®“é®ƒé®‘é®–é®—é®Ÿé® é®¨é®´é¯€é¯Šé®¹é¯†é¯é¯‘é¯’é¯£é¯¢é¯¤é¯”é¯¡é°ºé¯²é¯±é¯°é°•é°”é°‰é°“é°Œé°†é°ˆé°’é°Šé°„é°®é°›é°¥é°¤é°¡é°°é±‡é°²é±†é°¾é±šé± é±§é±¶é±¸é³§é³¬é³°é´‰é´ˆé³«é´ƒé´†é´ªé´¦é¶¯é´£é´Ÿéµ„é´•é´’éµé´¿é´¾éµ†éµˆ"
  ],
  [
    "f3a1",
    "éµéµžéµ¤éµ‘éµéµ™éµ²é¶‰é¶‡é¶«éµ¯éµºé¶šé¶¤é¶©é¶²é·„é·é¶»é¶¸é¶ºé·†é·é·‚é·™é·“é·¸é·¦é·­é·¯é·½é¸šé¸›é¸žé¹µé¹¹é¹½éºéºˆéº‹éºŒéº’éº•éº‘éºéº¥éº©éº¸éºªéº­é¡é»Œé»Žé»é»é»”é»œé»žé»é» é»¥é»¨é»¯é»´é»¶é»·é»¹é»»é»¼é»½é¼‡é¼ˆçš·é¼•é¼¡é¼¬é¼¾é½Šé½’é½”é½£é½Ÿé½ é½¡é½¦é½§é½¬é½ªé½·é½²é½¶é¾•é¾œé¾ "
  ],
  [
    "f4a1",
    "å ¯æ§‡é™ç‘¤å‡œç†™"
  ],
  [
    "f9a1",
    "çºŠè¤œéˆéŠˆè“œä¿‰ç‚»æ˜±æ£ˆé‹¹æ›»å½…ä¸¨ä»¡ä»¼ä¼€ä¼ƒä¼¹ä½–ä¾’ä¾Šä¾šä¾”ä¿å€å€¢ä¿¿å€žå†å°å‚å‚”åƒ´åƒ˜å…Šå…¤å†å†¾å‡¬åˆ•åŠœåŠ¦å‹€å‹›åŒ€åŒ‡åŒ¤å²åŽ“åŽ²åï¨Žå’œå’Šå’©å“¿å–†å™å¥åž¬åŸˆåŸ‡ï¨ï¨å¢žå¢²å¤‹å¥“å¥›å¥å¥£å¦¤å¦ºå­–å¯€ç”¯å¯˜å¯¬å°žå²¦å²ºå³µå´§åµ“ï¨‘åµ‚åµ­å¶¸å¶¹å·å¼¡å¼´å½§å¾·"
  ],
  [
    "faa1",
    "å¿žææ‚…æ‚Šæƒžæƒ•æ„ æƒ²æ„‘æ„·æ„°æ†˜æˆ“æŠ¦æµæ‘ æ’æ“Žæ•Žæ˜€æ˜•æ˜»æ˜‰æ˜®æ˜žæ˜¤æ™¥æ™—æ™™ï¨’æ™³æš™æš æš²æš¿æ›ºæœŽï¤©æ¦æž»æ¡’æŸ€æ æ¡„æ£ï¨“æ¥¨ï¨”æ¦˜æ§¢æ¨°æ©«æ©†æ©³æ©¾æ«¢æ«¤æ¯–æ°¿æ±œæ²†æ±¯æ³šæ´„æ¶‡æµ¯æ¶–æ¶¬æ·æ·¸æ·²æ·¼æ¸¹æ¹œæ¸§æ¸¼æº¿æ¾ˆæ¾µæ¿µç€…ç€‡ç€¨ç‚…ç‚«ç„ç„„ç…œç…†ç…‡ï¨•ç‡ç‡¾çŠ±"
  ],
  [
    "fba1",
    "çŠ¾çŒ¤ï¨–ç·çŽ½ç‰ç–ç£ç’ç‡çµç¦çªç©ç®ç‘¢ç’‰ç’Ÿç”ç•¯çš‚çšœçšžçš›çš¦ï¨—ç†åŠ¯ç ¡ç¡Žç¡¤ç¡ºç¤°ï¨˜ï¨™ï¨šç¦”ï¨›ç¦›ç«‘ç«§ï¨œç««ç®žï¨çµˆçµœç¶·ç¶ ç·–ç¹’ç½‡ç¾¡ï¨žèŒè¢è¿è‡è¶è‘ˆè’´è•“è•™è•«ï¨Ÿè–°ï¨ ï¨¡è ‡è£µè¨’è¨·è©¹èª§èª¾è«Ÿï¨¢è«¶è­“è­¿è³°è³´è´’èµ¶ï¨£è»ï¨¤ï¨¥é§éƒžï¨¦é„•é„§é‡š"
  ],
  [
    "fca1",
    "é‡—é‡žé‡­é‡®é‡¤é‡¥éˆ†éˆéˆŠéˆºé‰€éˆ¼é‰Žé‰™é‰‘éˆ¹é‰§éŠ§é‰·é‰¸é‹§é‹—é‹™é‹ï¨§é‹•é‹ é‹“éŒ¥éŒ¡é‹»ï¨¨éŒžé‹¿éŒéŒ‚é°é—éŽ¤é†éžé¸é±é‘…é‘ˆé–’ï§œï¨©éšéš¯éœ³éœ»éƒééé‘é•é¡—é¡¥ï¨ªï¨«é¤§ï¨¬é¦žé©Žé«™é«œé­µé­²é®é®±é®»é°€éµ°éµ«ï¨­é¸™é»‘"
  ],
  [
    "fcf1",
    "â…°",
    9,
    "ï¿¢ï¿¤ï¼‡ï¼‚"
  ],
  [
    "8fa2af",
    "Ë˜Ë‡Â¸Ë™ËÂ¯Ë›Ëšï½žÎ„Î…"
  ],
  [
    "8fa2c2",
    "Â¡Â¦Â¿"
  ],
  [
    "8fa2eb",
    "ÂºÂªÂ©Â®â„¢Â¤â„–"
  ],
  [
    "8fa6e1",
    "Î†ÎˆÎ‰ÎŠÎª"
  ],
  [
    "8fa6e7",
    "ÎŒ"
  ],
  [
    "8fa6e9",
    "ÎŽÎ«"
  ],
  [
    "8fa6ec",
    "Î"
  ],
  [
    "8fa6f1",
    "Î¬Î­Î®Î¯ÏŠÎÏŒÏ‚ÏÏ‹Î°ÏŽ"
  ],
  [
    "8fa7c2",
    "Ð‚",
    10,
    "ÐŽÐ"
  ],
  [
    "8fa7f2",
    "Ñ’",
    10,
    "ÑžÑŸ"
  ],
  [
    "8fa9a1",
    "Ã†Ä"
  ],
  [
    "8fa9a4",
    "Ä¦"
  ],
  [
    "8fa9a6",
    "Ä²"
  ],
  [
    "8fa9a8",
    "ÅÄ¿"
  ],
  [
    "8fa9ab",
    "ÅŠÃ˜Å’"
  ],
  [
    "8fa9af",
    "Å¦Ãž"
  ],
  [
    "8fa9c1",
    "Ã¦Ä‘Ã°Ä§Ä±Ä³Ä¸Å‚Å€Å‰Å‹Ã¸Å“ÃŸÅ§Ã¾"
  ],
  [
    "8faaa1",
    "ÃÃ€Ã„Ã‚Ä‚ÇÄ€Ä„Ã…ÃƒÄ†ÄˆÄŒÃ‡ÄŠÄŽÃ‰ÃˆÃ‹ÃŠÄšÄ–Ä’Ä˜"
  ],
  [
    "8faaba",
    "ÄœÄžÄ¢Ä Ä¤ÃÃŒÃÃŽÇÄ°ÄªÄ®Ä¨Ä´Ä¶Ä¹Ä½Ä»ÅƒÅ‡Å…Ã‘Ã“Ã’Ã–Ã”Ç‘ÅÅŒÃ•Å”Å˜Å–ÅšÅœÅ ÅžÅ¤Å¢ÃšÃ™ÃœÃ›Å¬Ç“Å°ÅªÅ²Å®Å¨Ç—Ç›Ç™Ç•Å´ÃÅ¸Å¶Å¹Å½Å»"
  ],
  [
    "8faba1",
    "Ã¡Ã Ã¤Ã¢ÄƒÇŽÄÄ…Ã¥Ã£Ä‡Ä‰ÄÃ§Ä‹ÄÃ©Ã¨Ã«ÃªÄ›Ä—Ä“Ä™ÇµÄÄŸ"
  ],
  [
    "8fabbd",
    "Ä¡Ä¥Ã­Ã¬Ã¯Ã®Ç"
  ],
  [
    "8fabc5",
    "Ä«Ä¯Ä©ÄµÄ·ÄºÄ¾Ä¼Å„ÅˆÅ†Ã±Ã³Ã²Ã¶Ã´Ç’Å‘ÅÃµÅ•Å™Å—Å›ÅÅ¡ÅŸÅ¥Å£ÃºÃ¹Ã¼Ã»Å­Ç”Å±Å«Å³Å¯Å©Ç˜ÇœÇšÇ–ÅµÃ½Ã¿Å·ÅºÅ¾Å¼"
  ],
  [
    "8fb0a1",
    "ä¸‚ä¸„ä¸…ä¸Œä¸’ä¸Ÿä¸£ä¸¤ä¸¨ä¸«ä¸®ä¸¯ä¸°ä¸µä¹€ä¹ä¹„ä¹‡ä¹‘ä¹šä¹œä¹£ä¹¨ä¹©ä¹´ä¹µä¹¹ä¹¿äºäº–äº—äºäº¯äº¹ä»ƒä»ä»šä»›ä» ä»¡ä»¢ä»¨ä»¯ä»±ä»³ä»µä»½ä»¾ä»¿ä¼€ä¼‚ä¼ƒä¼ˆä¼‹ä¼Œä¼’ä¼•ä¼–ä¼—ä¼™ä¼®ä¼±ä½ ä¼³ä¼µä¼·ä¼¹ä¼»ä¼¾ä½€ä½‚ä½ˆä½‰ä½‹ä½Œä½’ä½”ä½–ä½˜ä½Ÿä½£ä½ªä½¬ä½®ä½±ä½·ä½¸ä½¹ä½ºä½½ä½¾ä¾ä¾‚ä¾„"
  ],
  [
    "8fb1a1",
    "ä¾…ä¾‰ä¾Šä¾Œä¾Žä¾ä¾’ä¾“ä¾”ä¾—ä¾™ä¾šä¾žä¾Ÿä¾²ä¾·ä¾¹ä¾»ä¾¼ä¾½ä¾¾ä¿€ä¿ä¿…ä¿†ä¿ˆä¿‰ä¿‹ä¿Œä¿ä¿ä¿’ä¿œä¿ ä¿¢ä¿°ä¿²ä¿¼ä¿½ä¿¿å€€å€å€„å€‡å€Šå€Œå€Žå€å€“å€—å€˜å€›å€œå€å€žå€¢å€§å€®å€°å€²å€³å€µå€åå‚å…å†åŠåŒåŽå‘å’å“å—å™åŸå å¢å£å¦å§åªå­å°å±å€»å‚å‚ƒå‚„å‚†å‚Šå‚Žå‚å‚"
  ],
  [
    "8fb2a1",
    "å‚’å‚“å‚”å‚–å‚›å‚œå‚ž",
    4,
    "å‚ªå‚¯å‚°å‚¹å‚ºå‚½åƒ€åƒƒåƒ„åƒ‡åƒŒåƒŽåƒåƒ“åƒ”åƒ˜åƒœåƒåƒŸåƒ¢åƒ¤åƒ¦åƒ¨åƒ©åƒ¯åƒ±åƒ¶åƒºåƒ¾å„ƒå„†å„‡å„ˆå„‹å„Œå„å„Žåƒ²å„å„—å„™å„›å„œå„å„žå„£å„§å„¨å„¬å„­å„¯å„±å„³å„´å„µå„¸å„¹å…‚å…Šå…å…“å…•å…—å…˜å…Ÿå…¤å…¦å…¾å†ƒå†„å†‹å†Žå†˜å†å†¡å†£å†­å†¸å†ºå†¼å†¾å†¿å‡‚"
  ],
  [
    "8fb3a1",
    "å‡ˆå‡å‡‘å‡’å‡“å‡•å‡˜å‡žå‡¢å‡¥å‡®å‡²å‡³å‡´å‡·åˆåˆ‚åˆ…åˆ’åˆ“åˆ•åˆ–åˆ˜åˆ¢åˆ¨åˆ±åˆ²åˆµåˆ¼å‰…å‰‰å‰•å‰—å‰˜å‰šå‰œå‰Ÿå‰ å‰¡å‰¦å‰®å‰·å‰¸å‰¹åŠ€åŠ‚åŠ…åŠŠåŠŒåŠ“åŠ•åŠ–åŠ—åŠ˜åŠšåŠœåŠ¤åŠ¥åŠ¦åŠ§åŠ¯åŠ°åŠ¶åŠ·åŠ¸åŠºåŠ»åŠ½å‹€å‹„å‹†å‹ˆå‹Œå‹å‹‘å‹”å‹–å‹›å‹œå‹¡å‹¥å‹¨å‹©å‹ªå‹¬å‹°å‹±å‹´å‹¶å‹·åŒ€åŒƒåŒŠåŒ‹"
  ],
  [
    "8fb4a1",
    "åŒŒåŒ‘åŒ“åŒ˜åŒ›åŒœåŒžåŒŸåŒ¥åŒ§åŒ¨åŒ©åŒ«åŒ¬åŒ­åŒ°åŒ²åŒµåŒ¼åŒ½åŒ¾å‚åŒå‹å™å›å¡å£å¥å¬å­å²å¹å¾åŽƒåŽ‡åŽˆåŽŽåŽ“åŽ”åŽ™åŽåŽ¡åŽ¤åŽªåŽ«åŽ¯åŽ²åŽ´åŽµåŽ·åŽ¸åŽºåŽ½å€å…åå’å“å•åšååžå å¦å§åµå‚å“åšå¡å§å¨åªå¯å±å´åµå‘ƒå‘„å‘‡å‘å‘å‘žå‘¢å‘¤å‘¦å‘§å‘©å‘«å‘­å‘®å‘´å‘¿"
  ],
  [
    "8fb5a1",
    "å’å’ƒå’…å’ˆå’‰å’å’‘å’•å’–å’œå’Ÿå’¡å’¦å’§å’©å’ªå’­å’®å’±å’·å’¹å’ºå’»å’¿å“†å“Šå“å“Žå“ å“ªå“¬å“¯å“¶å“¼å“¾å“¿å”€å”å”…å”ˆå”‰å”Œå”å”Žå”•å”ªå”«å”²å”µå”¶å”»å”¼å”½å•å•‡å•‰å•Šå•å•å•‘å•˜å•šå•›å•žå• å•¡å•¤å•¦å•¿å–å–‚å–†å–ˆå–Žå–å–‘å–’å–“å–”å–—å–£å–¤å–­å–²å–¿å—å—ƒå—†å—‰å—‹å—Œå—Žå—‘å—’"
  ],
  [
    "8fb6a1",
    "å—“å——å—˜å—›å—žå—¢å—©å—¶å—¿å˜…å˜ˆå˜Šå˜",
    5,
    "å˜™å˜¬å˜°å˜³å˜µå˜·å˜¹å˜»å˜¼å˜½å˜¿å™€å™å™ƒå™„å™†å™‰å™‹å™å™å™”å™žå™ å™¡å™¢å™£å™¦å™©å™­å™¯å™±å™²å™µåš„åš…åšˆåš‹åšŒåš•åš™åššåšåšžåšŸåš¦åš§åš¨åš©åš«åš¬åš­åš±åš³åš·åš¾å›…å›‰å›Šå›‹å›å›å›Œå›å›™å›œå›å›Ÿå›¡å›¤",
    4,
    "å›±å›«å›­"
  ],
  [
    "8fb7a1",
    "å›¶å›·åœåœ‚åœ‡åœŠåœŒåœ‘åœ•åœšåœ›åœåœ åœ¢åœ£åœ¤åœ¥åœ©åœªåœ¬åœ®åœ¯åœ³åœ´åœ½åœ¾åœ¿å…å†åŒåå’å¢å¥å§å¨å«å­",
    4,
    "å³å´åµå·å¹åºå»å¼å¾åžåžƒåžŒåž”åž—åž™åžšåžœåžåžžåžŸåž¡åž•åž§åž¨åž©åž¬åž¸åž½åŸ‡åŸˆåŸŒåŸåŸ•åŸåŸžåŸ¤åŸ¦åŸ§åŸ©åŸ­åŸ°åŸµåŸ¶åŸ¸åŸ½åŸ¾åŸ¿å ƒå „å ˆå ‰åŸ¡"
  ],
  [
    "8fb8a1",
    "å Œå å ›å žå Ÿå  å ¦å §å ­å ²å ¹å ¿å¡‰å¡Œå¡å¡å¡å¡•å¡Ÿå¡¡å¡¤å¡§å¡¨å¡¸å¡¼å¡¿å¢€å¢å¢‡å¢ˆå¢‰å¢Šå¢Œå¢å¢å¢å¢”å¢–å¢å¢ å¢¡å¢¢å¢¦å¢©å¢±å¢²å£„å¢¼å£‚å£ˆå£å£Žå£å£’å£”å£–å£šå£å£¡å£¢å£©å£³å¤…å¤†å¤‹å¤Œå¤’å¤“å¤”è™å¤å¤¡å¤£å¤¤å¤¨å¤¯å¤°å¤³å¤µå¤¶å¤¿å¥ƒå¥†å¥’å¥“å¥™å¥›å¥å¥žå¥Ÿå¥¡å¥£å¥«å¥­"
  ],
  [
    "8fb9a1",
    "å¥¯å¥²å¥µå¥¶å¥¹å¥»å¥¼å¦‹å¦Œå¦Žå¦’å¦•å¦—å¦Ÿå¦¤å¦§å¦­å¦®å¦¯å¦°å¦³å¦·å¦ºå¦¼å§å§ƒå§„å§ˆå§Šå§å§’å§å§žå§Ÿå§£å§¤å§§å§®å§¯å§±å§²å§´å§·å¨€å¨„å¨Œå¨å¨Žå¨’å¨“å¨žå¨£å¨¤å¨§å¨¨å¨ªå¨­å¨°å©„å©…å©‡å©ˆå©Œå©å©•å©žå©£å©¥å©§å©­å©·å©ºå©»å©¾åª‹åªåª“åª–åª™åªœåªžåªŸåª åª¢åª§åª¬åª±åª²åª³åªµåª¸åªºåª»åª¿"
  ],
  [
    "8fbaa1",
    "å«„å«†å«ˆå«å«šå«œå« å«¥å«ªå«®å«µå«¶å«½å¬€å¬å¬ˆå¬—å¬´å¬™å¬›å¬å¬¡å¬¥å¬­å¬¸å­å­‹å­Œå­’å­–å­žå­¨å­®å­¯å­¼å­½å­¾å­¿å®å®„å®†å®Šå®Žå®å®‘å®“å®”å®–å®¨å®©å®¬å®­å®¯å®±å®²å®·å®ºå®¼å¯€å¯å¯å¯å¯–",
    4,
    "å¯ å¯¯å¯±å¯´å¯½å°Œå°—å°žå°Ÿå°£å°¦å°©å°«å°¬å°®å°°å°²å°µå°¶å±™å±šå±œå±¢å±£å±§å±¨å±©"
  ],
  [
    "8fbba1",
    "å±­å±°å±´å±µå±ºå±»å±¼å±½å²‡å²ˆå²Šå²å²’å²å²Ÿå² å²¢å²£å²¦å²ªå²²å²´å²µå²ºå³‰å³‹å³’å³å³—å³®å³±å³²å³´å´å´†å´å´’å´«å´£å´¤å´¦å´§å´±å´´å´¹å´½å´¿åµ‚åµƒåµ†åµˆåµ•åµ‘åµ™åµŠåµŸåµ åµ¡åµ¢åµ¤åµªåµ­åµ°åµ¹åµºåµ¾åµ¿å¶å¶ƒå¶ˆå¶Šå¶’å¶“å¶”å¶•å¶™å¶›å¶Ÿå¶ å¶§å¶«å¶°å¶´å¶¸å¶¹å·ƒå·‡å·‹å·å·Žå·˜å·™å· å·¤"
  ],
  [
    "8fbca1",
    "å·©å·¸å·¹å¸€å¸‡å¸å¸’å¸”å¸•å¸˜å¸Ÿå¸ å¸®å¸¨å¸²å¸µå¸¾å¹‹å¹å¹‰å¹‘å¹–å¹˜å¹›å¹œå¹žå¹¨å¹ª",
    4,
    "å¹°åº€åº‹åºŽåº¢åº¤åº¥åº¨åºªåº¬åº±åº³åº½åº¾åº¿å»†å»Œå»‹å»Žå»‘å»’å»”å»•å»œå»žå»¥å»«å¼‚å¼†å¼‡å¼ˆå¼Žå¼™å¼œå¼å¼¡å¼¢å¼£å¼¤å¼¨å¼«å¼¬å¼®å¼°å¼´å¼¶å¼»å¼½å¼¿å½€å½„å½…å½‡å½å½å½”å½˜å½›å½ å½£å½¤å½§"
  ],
  [
    "8fbda1",
    "å½¯å½²å½´å½µå½¸å½ºå½½å½¾å¾‰å¾å¾å¾–å¾œå¾å¾¢å¾§å¾«å¾¤å¾¬å¾¯å¾°å¾±å¾¸å¿„å¿‡å¿ˆå¿‰å¿‹å¿",
    4,
    "å¿žå¿¡å¿¢å¿¨å¿©å¿ªå¿¬å¿­å¿®å¿¯å¿²å¿³å¿¶å¿ºå¿¼æ€‡æ€Šæ€æ€“æ€”æ€—æ€˜æ€šæ€Ÿæ€¤æ€­æ€³æ€µæ€æ‡æˆæ‰æŒæ‘æ”æ–æ—ææ¡æ§æ±æ¾æ¿æ‚‚æ‚†æ‚ˆæ‚Šæ‚Žæ‚‘æ‚“æ‚•æ‚˜æ‚æ‚žæ‚¢æ‚¤æ‚¥æ‚¨æ‚°æ‚±æ‚·"
  ],
  [
    "8fbea1",
    "æ‚»æ‚¾æƒ‚æƒ„æƒˆæƒ‰æƒŠæƒ‹æƒŽæƒæƒ”æƒ•æƒ™æƒ›æƒæƒžæƒ¢æƒ¥æƒ²æƒµæƒ¸æƒ¼æƒ½æ„‚æ„‡æ„Šæ„Œæ„",
    4,
    "æ„–æ„—æ„™æ„œæ„žæ„¢æ„ªæ„«æ„°æ„±æ„µæ„¶æ„·æ„¹æ…æ……æ…†æ…‰æ…žæ… æ…¬æ…²æ…¸æ…»æ…¼æ…¿æ†€æ†æ†ƒæ†„æ†‹æ†æ†’æ†“æ†—æ†˜æ†œæ†æ†Ÿæ† æ†¥æ†¨æ†ªæ†­æ†¸æ†¹æ†¼æ‡€æ‡æ‡‚æ‡Žæ‡æ‡•æ‡œæ‡æ‡žæ‡Ÿæ‡¡æ‡¢æ‡§æ‡©æ‡¥"
  ],
  [
    "8fbfa1",
    "æ‡¬æ‡­æ‡¯æˆæˆƒæˆ„æˆ‡æˆ“æˆ•æˆœæˆ æˆ¢æˆ£æˆ§æˆ©æˆ«æˆ¹æˆ½æ‰‚æ‰ƒæ‰„æ‰†æ‰Œæ‰æ‰‘æ‰’æ‰”æ‰–æ‰šæ‰œæ‰¤æ‰­æ‰¯æ‰³æ‰ºæ‰½æŠæŠŽæŠæŠæŠ¦æŠ¨æŠ³æŠ¶æŠ·æŠºæŠ¾æŠ¿æ‹„æ‹Žæ‹•æ‹–æ‹šæ‹ªæ‹²æ‹´æ‹¼æ‹½æŒƒæŒ„æŒŠæŒ‹æŒæŒæŒ“æŒ–æŒ˜æŒ©æŒªæŒ­æŒµæŒ¶æŒ¹æŒ¼ææ‚æƒæ„æ†æŠæ‹æŽæ’æ“æ”æ˜æ›æ¥æ¦æ¬æ­æ±æ´æµ"
  ],
  [
    "8fc0a1",
    "æ¸æ¼æ½æ¿æŽ‚æŽ„æŽ‡æŽŠæŽæŽ”æŽ•æŽ™æŽšæŽžæŽ¤æŽ¦æŽ­æŽ®æŽ¯æŽ½ææ…æˆæŽæ‘æ“æ”æ•æœæ æ¥æªæ¬æ²æ³æµæ¸æ¹æ‰æŠææ’æ”æ˜æžæ æ¢æ¤æ¥æ©æªæ¯æ°æµæ½æ¿æ‘‹æ‘æ‘‘æ‘’æ‘“æ‘”æ‘šæ‘›æ‘œæ‘æ‘Ÿæ‘ æ‘¡æ‘£æ‘­æ‘³æ‘´æ‘»æ‘½æ’…æ’‡æ’æ’æ’‘æ’˜æ’™æ’›æ’æ’Ÿæ’¡æ’£æ’¦æ’¨æ’¬æ’³æ’½æ’¾æ’¿"
  ],
  [
    "8fc1a1",
    "æ“„æ“‰æ“Šæ“‹æ“Œæ“Žæ“æ“‘æ“•æ“—æ“¤æ“¥æ“©æ“ªæ“­æ“°æ“µæ“·æ“»æ“¿æ”æ”„æ”ˆæ”‰æ”Šæ”æ”“æ””æ”–æ”™æ”›æ”žæ”Ÿæ”¢æ”¦æ”©æ”®æ”±æ”ºæ”¼æ”½æ•ƒæ•‡æ•‰æ•æ•’æ•”æ•Ÿæ• æ•§æ•«æ•ºæ•½æ–æ–…æ–Šæ–’æ–•æ–˜æ–æ– æ–£æ–¦æ–®æ–²æ–³æ–´æ–¿æ—‚æ—ˆæ—‰æ—Žæ—æ—”æ—–æ—˜æ—Ÿæ—°æ—²æ—´æ—µæ—¹æ—¾æ—¿æ˜€æ˜„æ˜ˆæ˜‰æ˜æ˜‘æ˜’æ˜•æ˜–æ˜"
  ],
  [
    "8fc2a1",
    "æ˜žæ˜¡æ˜¢æ˜£æ˜¤æ˜¦æ˜©æ˜ªæ˜«æ˜¬æ˜®æ˜°æ˜±æ˜³æ˜¹æ˜·æ™€æ™…æ™†æ™Šæ™Œæ™‘æ™Žæ™—æ™˜æ™™æ™›æ™œæ™ æ™¡æ›»æ™ªæ™«æ™¬æ™¾æ™³æ™µæ™¿æ™·æ™¸æ™¹æ™»æš€æ™¼æš‹æšŒæšæšæš’æš™æššæš›æšœæšŸæš æš¤æš­æš±æš²æšµæš»æš¿æ›€æ›‚æ›ƒæ›ˆæ›Œæ›Žæ›æ›”æ››æ›Ÿæ›¨æ›«æ›¬æ›®æ›ºæœ…æœ‡æœŽæœ“æœ™æœœæœ æœ¢æœ³æœ¾æ…æ‡æˆæŒæ”æ•æ"
  ],
  [
    "8fc3a1",
    "æ¦æ¬æ®æ´æ¶æ»æžæž„æžŽæžæž‘æž“æž–æž˜æž™æž›æž°æž±æž²æžµæž»æž¼æž½æŸ¹æŸ€æŸ‚æŸƒæŸ…æŸˆæŸ‰æŸ’æŸ—æŸ™æŸœæŸ¡æŸ¦æŸ°æŸ²æŸ¶æŸ·æ¡’æ ”æ ™æ æ Ÿæ ¨æ §æ ¬æ ­æ ¯æ °æ ±æ ³æ »æ ¿æ¡„æ¡…æ¡Šæ¡Œæ¡•æ¡—æ¡˜æ¡›æ¡«æ¡®",
    4,
    "æ¡µæ¡¹æ¡ºæ¡»æ¡¼æ¢‚æ¢„æ¢†æ¢ˆæ¢–æ¢˜æ¢šæ¢œæ¢¡æ¢£æ¢¥æ¢©æ¢ªæ¢®æ¢²æ¢»æ£…æ£ˆæ£Œæ£"
  ],
  [
    "8fc4a1",
    "æ£æ£‘æ£“æ£–æ£™æ£œæ£æ£¥æ£¨æ£ªæ£«æ£¬æ£­æ£°æ£±æ£µæ£¶æ£»æ£¼æ£½æ¤†æ¤‰æ¤Šæ¤æ¤‘æ¤“æ¤–æ¤—æ¤±æ¤³æ¤µæ¤¸æ¤»æ¥‚æ¥…æ¥‰æ¥Žæ¥—æ¥›æ¥£æ¥¤æ¥¥æ¥¦æ¥¨æ¥©æ¥¬æ¥°æ¥±æ¥²æ¥ºæ¥»æ¥¿æ¦€æ¦æ¦’æ¦–æ¦˜æ¦¡æ¦¥æ¦¦æ¦¨æ¦«æ¦­æ¦¯æ¦·æ¦¸æ¦ºæ¦¼æ§…æ§ˆæ§‘æ§–æ§—æ§¢æ§¥æ§®æ§¯æ§±æ§³æ§µæ§¾æ¨€æ¨æ¨ƒæ¨æ¨‘æ¨•æ¨šæ¨æ¨ æ¨¤æ¨¨æ¨°æ¨²"
  ],
  [
    "8fc5a1",
    "æ¨´æ¨·æ¨»æ¨¾æ¨¿æ©…æ©†æ©‰æ©Šæ©Žæ©æ©‘æ©’æ©•æ©–æ©›æ©¤æ©§æ©ªæ©±æ©³æ©¾æªæªƒæª†æª‡æª‰æª‹æª‘æª›æªæªžæªŸæª¥æª«æª¯æª°æª±æª´æª½æª¾æª¿æ«†æ«‰æ«ˆæ«Œæ«æ«”æ«•æ«–æ«œæ«æ«¤æ«§æ«¬æ«°æ«±æ«²æ«¼æ«½æ¬‚æ¬ƒæ¬†æ¬‡æ¬‰æ¬æ¬æ¬‘æ¬—æ¬›æ¬žæ¬¤æ¬¨æ¬«æ¬¬æ¬¯æ¬µæ¬¶æ¬»æ¬¿æ­†æ­Šæ­æ­’æ­–æ­˜æ­æ­ æ­§æ­«æ­®æ­°æ­µæ­½"
  ],
  [
    "8fc6a1",
    "æ­¾æ®‚æ®…æ®—æ®›æ®Ÿæ® æ®¢æ®£æ®¨æ®©æ®¬æ®­æ®®æ®°æ®¸æ®¹æ®½æ®¾æ¯ƒæ¯„æ¯‰æ¯Œæ¯–æ¯šæ¯¡æ¯£æ¯¦æ¯§æ¯®æ¯±æ¯·æ¯¹æ¯¿æ°‚æ°„æ°…æ°‰æ°æ°Žæ°æ°’æ°™æ°Ÿæ°¦æ°§æ°¨æ°¬æ°®æ°³æ°µæ°¶æ°ºæ°»æ°¿æ±Šæ±‹æ±æ±æ±’æ±”æ±™æ±›æ±œæ±«æ±­æ±¯æ±´æ±¶æ±¸æ±¹æ±»æ²…æ²†æ²‡æ²‰æ²”æ²•æ²—æ²˜æ²œæ²Ÿæ²°æ²²æ²´æ³‚æ³†æ³æ³æ³æ³‘æ³’æ³”æ³–"
  ],
  [
    "8fc7a1",
    "æ³šæ³œæ³ æ³§æ³©æ³«æ³¬æ³®æ³²æ³´æ´„æ´‡æ´Šæ´Žæ´æ´‘æ´“æ´šæ´¦æ´§æ´¨æ±§æ´®æ´¯æ´±æ´¹æ´¼æ´¿æµ—æµžæµŸæµ¡æµ¥æµ§æµ¯æµ°æµ¼æ¶‚æ¶‡æ¶‘æ¶’æ¶”æ¶–æ¶—æ¶˜æ¶ªæ¶¬æ¶´æ¶·æ¶¹æ¶½æ¶¿æ·„æ·ˆæ·Šæ·Žæ·æ·–æ·›æ·æ·Ÿæ· æ·¢æ·¥æ·©æ·¯æ·°æ·´æ·¶æ·¼æ¸€æ¸„æ¸žæ¸¢æ¸§æ¸²æ¸¶æ¸¹æ¸»æ¸¼æ¹„æ¹…æ¹ˆæ¹‰æ¹‹æ¹æ¹‘æ¹’æ¹“æ¹”æ¹—æ¹œæ¹æ¹ž"
  ],
  [
    "8fc8a1",
    "æ¹¢æ¹£æ¹¨æ¹³æ¹»æ¹½æºæº“æº™æº æº§æº­æº®æº±æº³æº»æº¿æ»€æ»æ»ƒæ»‡æ»ˆæ»Šæ»æ»Žæ»æ»«æ»­æ»®æ»¹æ»»æ»½æ¼„æ¼ˆæ¼Šæ¼Œæ¼æ¼–æ¼˜æ¼šæ¼›æ¼¦æ¼©æ¼ªæ¼¯æ¼°æ¼³æ¼¶æ¼»æ¼¼æ¼­æ½æ½‘æ½’æ½“æ½—æ½™æ½šæ½æ½žæ½¡æ½¢æ½¨æ½¬æ½½æ½¾æ¾ƒæ¾‡æ¾ˆæ¾‹æ¾Œæ¾æ¾æ¾’æ¾“æ¾”æ¾–æ¾šæ¾Ÿæ¾ æ¾¥æ¾¦æ¾§æ¾¨æ¾®æ¾¯æ¾°æ¾µæ¾¶æ¾¼æ¿…æ¿‡æ¿ˆæ¿Š"
  ],
  [
    "8fc9a1",
    "æ¿šæ¿žæ¿¨æ¿©æ¿°æ¿µæ¿¹æ¿¼æ¿½ç€€ç€…ç€†ç€‡ç€ç€—ç€ ç€£ç€¯ç€´ç€·ç€¹ç€¼çƒç„çˆç‰çŠç‹ç”ç•ççžçŽç¤ç¥ç¬ç®çµç¶ç¾ç‚ç‚…ç‚†ç‚”",
    4,
    "ç‚›ç‚¤ç‚«ç‚°ç‚±ç‚´ç‚·çƒŠçƒ‘çƒ“çƒ”çƒ•çƒ–çƒ˜çƒœçƒ¤çƒºç„ƒ",
    4,
    "ç„‹ç„Œç„ç„žç„ ç„«ç„­ç„¯ç„°ç„±ç„¸ç…ç……ç…†ç…‡ç…Šç…‹ç…ç…’ç…—ç…šç…œç…žç… "
  ],
  [
    "8fcaa1",
    "ç…¨ç…¹ç†€ç†…ç†‡ç†Œç†’ç†šç†›ç† ç†¢ç†¯ç†°ç†²ç†³ç†ºç†¿ç‡€ç‡ç‡„ç‡‹ç‡Œç‡“ç‡–ç‡™ç‡šç‡œç‡¸ç‡¾çˆ€çˆ‡çˆˆçˆ‰çˆ“çˆ—çˆšçˆçˆŸçˆ¤çˆ«çˆ¯çˆ´çˆ¸çˆ¹ç‰ç‰‚ç‰ƒç‰…ç‰Žç‰ç‰ç‰“ç‰•ç‰–ç‰šç‰œç‰žç‰ ç‰£ç‰¨ç‰«ç‰®ç‰¯ç‰±ç‰·ç‰¸ç‰»ç‰¼ç‰¿çŠ„çŠ‰çŠçŠŽçŠ“çŠ›çŠ¨çŠ­çŠ®çŠ±çŠ´çŠ¾ç‹ç‹‡ç‹‰ç‹Œç‹•ç‹–ç‹˜ç‹Ÿç‹¥ç‹³ç‹´ç‹ºç‹»"
  ],
  [
    "8fcba1",
    "ç‹¾çŒ‚çŒ„çŒ…çŒ‡çŒ‹çŒçŒ’çŒ“çŒ˜çŒ™çŒžçŒ¢çŒ¤çŒ§çŒ¨çŒ¬çŒ±çŒ²çŒµçŒºçŒ»çŒ½çƒççç’ç–ç˜ççžçŸç ç¦ç§ç©ç«ç¬ç®ç¯ç±ç·ç¹ç¼çŽ€çŽçŽƒçŽ…çŽ†çŽŽçŽçŽ“çŽ•çŽ—çŽ˜çŽœçŽžçŽŸçŽ çŽ¢çŽ¥çŽ¦çŽªçŽ«çŽ­çŽµçŽ·çŽ¹çŽ¼çŽ½çŽ¿ç…ç†ç‰ç‹çŒçç’ç“ç–ç™çç¡ç£ç¦ç§ç©ç´çµç·ç¹çºç»ç½"
  ],
  [
    "8fcca1",
    "ç¿ç€çç„ç‡çŠç‘çšç›ç¤ç¦ç¨",
    9,
    "ç¹ç‘€ç‘ƒç‘„ç‘†ç‘‡ç‘‹ç‘ç‘‘ç‘’ç‘—ç‘ç‘¢ç‘¦ç‘§ç‘¨ç‘«ç‘­ç‘®ç‘±ç‘²ç’€ç’ç’…ç’†ç’‡ç’‰ç’ç’ç’‘ç’’ç’˜ç’™ç’šç’œç’Ÿç’ ç’¡ç’£ç’¦ç’¨ç’©ç’ªç’«ç’®ç’¯ç’±ç’²ç’µç’¹ç’»ç’¿ç“ˆç“‰ç“Œç“ç““ç“˜ç“šç“›ç“žç“Ÿç“¤ç“¨ç“ªç“«ç“¯ç“´ç“ºç“»ç“¼ç“¿ç”†"
  ],
  [
    "8fcda1",
    "ç”’ç”–ç”—ç” ç”¡ç”¤ç”§ç”©ç”ªç”¯ç”¶ç”¹ç”½ç”¾ç”¿ç•€ç•ƒç•‡ç•ˆç•Žç•ç•’ç•—ç•žç•Ÿç•¡ç•¯ç•±ç•¹",
    5,
    "ç–ç–…ç–ç–’ç–“ç–•ç–™ç–œç–¢ç–¤ç–´ç–ºç–¿ç—€ç—ç—„ç—†ç—Œç—Žç—ç——ç—œç—Ÿç— ç—¡ç—¤ç—§ç—¬ç—®ç—¯ç—±ç—¹ç˜€ç˜‚ç˜ƒç˜„ç˜‡ç˜ˆç˜Šç˜Œç˜ç˜’ç˜“ç˜•ç˜–ç˜™ç˜›ç˜œç˜ç˜žç˜£ç˜¥ç˜¦ç˜©ç˜­ç˜²ç˜³ç˜µç˜¸ç˜¹"
  ],
  [
    "8fcea1",
    "ç˜ºç˜¼ç™Šç™€ç™ç™ƒç™„ç™…ç™‰ç™‹ç™•ç™™ç™Ÿç™¤ç™¥ç™­ç™®ç™¯ç™±ç™´çšçš…çšŒçšçš•çš›çšœçšçšŸçš çš¢",
    6,
    "çšªçš­çš½ç›ç›…ç›‰ç›‹ç›Œç›Žç›”ç›™ç› ç›¦ç›¨ç›¬ç›°ç›±ç›¶ç›¹ç›¼çœ€çœ†çœŠçœŽçœ’çœ”çœ•çœ—çœ™çœšçœœçœ¢çœ¨çœ­çœ®çœ¯çœ´çœµçœ¶çœ¹çœ½çœ¾ç‚ç…ç†çŠççŽçç’ç–ç—çœçžçŸç ç¢"
  ],
  [
    "8fcfa1",
    "ç¤ç§çªç¬ç°ç²ç³ç´çºç½çž€çž„çžŒçžçž”çž•çž–çžšçžŸçž¢çž§çžªçž®çž¯çž±çžµçž¾çŸƒçŸ‰çŸ‘çŸ’çŸ•çŸ™çŸžçŸŸçŸ çŸ¤çŸ¦çŸªçŸ¬çŸ°çŸ±çŸ´çŸ¸çŸ»ç …ç †ç ‰ç ç Žç ‘ç ç ¡ç ¢ç £ç ­ç ®ç °ç µç ·ç¡ƒç¡„ç¡‡ç¡ˆç¡Œç¡Žç¡’ç¡œç¡žç¡ ç¡¡ç¡£ç¡¤ç¡¨ç¡ªç¡®ç¡ºç¡¾ç¢Šç¢ç¢”ç¢˜ç¢¡ç¢ç¢žç¢Ÿç¢¤ç¢¨ç¢¬ç¢­ç¢°ç¢±ç¢²ç¢³"
  ],
  [
    "8fd0a1",
    "ç¢»ç¢½ç¢¿ç£‡ç£ˆç£‰ç£Œç£Žç£’ç£“ç£•ç£–ç£¤ç£›ç£Ÿç£ ç£¡ç£¦ç£ªç£²ç£³ç¤€ç£¶ç£·ç£ºç£»ç£¿ç¤†ç¤Œç¤ç¤šç¤œç¤žç¤Ÿç¤ ç¤¥ç¤§ç¤©ç¤­ç¤±ç¤´ç¤µç¤»ç¤½ç¤¿ç¥„ç¥…ç¥†ç¥Šç¥‹ç¥ç¥‘ç¥”ç¥˜ç¥›ç¥œç¥§ç¥©ç¥«ç¥²ç¥¹ç¥»ç¥¼ç¥¾ç¦‹ç¦Œç¦‘ç¦“ç¦”ç¦•ç¦–ç¦˜ç¦›ç¦œç¦¡ç¦¨ç¦©ç¦«ç¦¯ç¦±ç¦´ç¦¸ç¦»ç§‚ç§„ç§‡ç§ˆç§Šç§ç§”ç§–ç§šç§ç§ž"
  ],
  [
    "8fd1a1",
    "ç§ ç§¢ç§¥ç§ªç§«ç§­ç§±ç§¸ç§¼ç¨‚ç¨ƒç¨‡ç¨‰ç¨Šç¨Œç¨‘ç¨•ç¨›ç¨žç¨¡ç¨§ç¨«ç¨­ç¨¯ç¨°ç¨´ç¨µç¨¸ç¨¹ç¨ºç©„ç©…ç©‡ç©ˆç©Œç©•ç©–ç©™ç©œç©ç©Ÿç© ç©¥ç©§ç©ªç©­ç©µç©¸ç©¾çª€çª‚çª…çª†çªŠçª‹çªçª‘çª”çªžçª çª£çª¬çª³çªµçª¹çª»çª¼ç«†ç«‰ç«Œç«Žç«‘ç«›ç«¨ç«©ç««ç«¬ç«±ç«´ç«»ç«½ç«¾ç¬‡ç¬”ç¬Ÿç¬£ç¬§ç¬©ç¬ªç¬«ç¬­ç¬®ç¬¯ç¬°"
  ],
  [
    "8fd2a1",
    "ç¬±ç¬´ç¬½ç¬¿ç­€ç­ç­‡ç­Žç­•ç­ ç­¤ç­¦ç­©ç­ªç­­ç­¯ç­²ç­³ç­·ç®„ç®‰ç®Žç®ç®‘ç®–ç®›ç®žç® ç®¥ç®¬ç®¯ç®°ç®²ç®µç®¶ç®ºç®»ç®¼ç®½ç¯‚ç¯…ç¯ˆç¯Šç¯”ç¯–ç¯—ç¯™ç¯šç¯›ç¯¨ç¯ªç¯²ç¯´ç¯µç¯¸ç¯¹ç¯ºç¯¼ç¯¾ç°ç°‚ç°ƒç°„ç°†ç°‰ç°‹ç°Œç°Žç°ç°™ç°›ç° ç°¥ç°¦ç°¨ç°¬ç°±ç°³ç°´ç°¶ç°¹ç°ºç±†ç±Šç±•ç±‘ç±’ç±“ç±™",
    5
  ],
  [
    "8fd3a1",
    "ç±¡ç±£ç±§ç±©ç±­ç±®ç±°ç±²ç±¹ç±¼ç±½ç²†ç²‡ç²ç²”ç²žç² ç²¦ç²°ç²¶ç²·ç²ºç²»ç²¼ç²¿ç³„ç³‡ç³ˆç³‰ç³ç³ç³“ç³”ç³•ç³—ç³™ç³šç³ç³¦ç³©ç³«ç³µç´ƒç´‡ç´ˆç´‰ç´ç´‘ç´’ç´“ç´–ç´ç´žç´£ç´¦ç´ªç´­ç´±ç´¼ç´½ç´¾çµ€çµçµ‡çµˆçµçµ‘çµ“çµ—çµ™çµšçµœçµçµ¥çµ§çµªçµ°çµ¸çµºçµ»çµ¿ç¶ç¶‚ç¶ƒç¶…ç¶†ç¶ˆç¶‹ç¶Œç¶ç¶‘ç¶–ç¶—ç¶"
  ],
  [
    "8fd4a1",
    "ç¶žç¶¦ç¶§ç¶ªç¶³ç¶¶ç¶·ç¶¹ç·‚",
    4,
    "ç·Œç·ç·Žç·—ç·™ç¸€ç·¢ç·¥ç·¦ç·ªç·«ç·­ç·±ç·µç·¶ç·¹ç·ºç¸ˆç¸ç¸‘ç¸•ç¸—ç¸œç¸ç¸ ç¸§ç¸¨ç¸¬ç¸­ç¸¯ç¸³ç¸¶ç¸¿ç¹„ç¹…ç¹‡ç¹Žç¹ç¹’ç¹˜ç¹Ÿç¹¡ç¹¢ç¹¥ç¹«ç¹®ç¹¯ç¹³ç¹¸ç¹¾çºçº†çº‡çºŠçºçº‘çº•çº˜çºšçºçºžç¼¼ç¼»ç¼½ç¼¾ç¼¿ç½ƒç½„ç½‡ç½ç½’ç½“ç½›ç½œç½ç½¡ç½£ç½¤ç½¥ç½¦ç½­"
  ],
  [
    "8fd5a1",
    "ç½±ç½½ç½¾ç½¿ç¾€ç¾‹ç¾ç¾ç¾ç¾‘ç¾–ç¾—ç¾œç¾¡ç¾¢ç¾¦ç¾ªç¾­ç¾´ç¾¼ç¾¿ç¿€ç¿ƒç¿ˆç¿Žç¿ç¿›ç¿Ÿç¿£ç¿¥ç¿¨ç¿¬ç¿®ç¿¯ç¿²ç¿ºç¿½ç¿¾ç¿¿è€‡è€ˆè€Šè€è€Žè€è€‘è€“è€”è€–è€è€žè€Ÿè€ è€¤è€¦è€¬è€®è€°è€´è€µè€·è€¹è€ºè€¼è€¾è€è„è è¤è¦è­è±èµè‚è‚ˆè‚Žè‚œè‚žè‚¦è‚§è‚«è‚¸è‚¹èƒˆèƒèƒèƒ’èƒ”èƒ•èƒ—èƒ˜èƒ èƒ­èƒ®"
  ],
  [
    "8fd6a1",
    "èƒ°èƒ²èƒ³èƒ¶èƒ¹èƒºèƒ¾è„ƒè„‹è„–è„—è„˜è„œè„žè„ è„¤è„§è„¬è„°è„µè„ºè„¼è……è…‡è…Šè…Œè…’è…—è… è…¡è…§è…¨è…©è…­è…¯è…·è†è†è†„è†…è††è†‹è†Žè†–è†˜è†›è†žè†¢è†®è†²è†´è†»è‡‹è‡ƒè‡…è‡Šè‡Žè‡è‡•è‡—è‡›è‡è‡žè‡¡è‡¤è‡«è‡¬è‡°è‡±è‡²è‡µè‡¶è‡¸è‡¹è‡½è‡¿èˆ€èˆƒèˆèˆ“èˆ”èˆ™èˆšèˆèˆ¡èˆ¢èˆ¨èˆ²èˆ´èˆºè‰ƒè‰„è‰…è‰†"
  ],
  [
    "8fd7a1",
    "è‰‹è‰Žè‰è‰‘è‰–è‰œè‰ è‰£è‰§è‰­è‰´è‰»è‰½è‰¿èŠ€èŠèŠƒèŠ„èŠ‡èŠ‰èŠŠèŠŽèŠ‘èŠ”èŠ–èŠ˜èŠšèŠ›èŠ èŠ¡èŠ£èŠ¤èŠ§èŠ¨èŠ©èŠªèŠ®èŠ°èŠ²èŠ´èŠ·èŠºèŠ¼èŠ¾èŠ¿è‹†è‹è‹•è‹šè‹ è‹¢è‹¤è‹¨è‹ªè‹­è‹¯è‹¶è‹·è‹½è‹¾èŒ€èŒèŒ‡èŒˆèŒŠèŒ‹è”èŒ›èŒèŒžèŒŸèŒ¡èŒ¢èŒ¬èŒ­èŒ®èŒ°èŒ³èŒ·èŒºèŒ¼èŒ½è‚èƒè„è‡èèŽè‘è•è–è—è°è¸"
  ],
  [
    "8fd8a1",
    "è½è¿èŽ€èŽ‚èŽ„èŽ†èŽèŽ’èŽ”èŽ•èŽ˜èŽ™èŽ›èŽœèŽèŽ¦èŽ§èŽ©èŽ¬èŽ¾èŽ¿è€è‡è‰èèè‘è”èè“è¨èªè¶è¸è¹è¼èè†èŠèè‘è•è™èŽ­è¯è¹è‘…è‘‡è‘ˆè‘Šè‘è‘è‘‘è‘’è‘–è‘˜è‘™è‘šè‘œè‘ è‘¤è‘¥è‘§è‘ªè‘°è‘³è‘´è‘¶è‘¸è‘¼è‘½è’è’…è’’è’“è’•è’žè’¦è’¨è’©è’ªè’¯è’±è’´è’ºè’½è’¾è“€è“‚è“‡è“ˆè“Œè“è““"
  ],
  [
    "8fd9a1",
    "è“œè“§è“ªè“¯è“°è“±è“²è“·è”²è“ºè“»è“½è”‚è”ƒè”‡è”Œè”Žè”è”œè”žè”¢è”£è”¤è”¥è”§è”ªè”«è”¯è”³è”´è”¶è”¿è•†è•",
    4,
    "è•–è•™è•œ",
    6,
    "è•¤è•«è•¯è•¹è•ºè•»è•½è•¿è–è–…è–†è–‰è–‹è–Œè–è–“è–˜è–è–Ÿè– è–¢è–¥è–§è–´è–¶è–·è–¸è–¼è–½è–¾è–¿è—‚è—‡è—Šè—‹è—Žè–­è—˜è—šè—Ÿè— è—¦è—¨è—­è—³è—¶è—¼"
  ],
  [
    "8fdaa1",
    "è—¿è˜€è˜„è˜…è˜è˜Žè˜è˜‘è˜’è˜˜è˜™è˜›è˜žè˜¡è˜§è˜©è˜¶è˜¸è˜ºè˜¼è˜½è™€è™‚è™†è™’è™“è™–è™—è™˜è™™è™è™ ",
    4,
    "è™©è™¬è™¯è™µè™¶è™·è™ºèšèš‘èš–èš˜èššèšœèš¡èš¦èš§èš¨èš­èš±èš³èš´èšµèš·èš¸èš¹èš¿è›€è›è›ƒè›…è›‘è›’è›•è›—è›šè›œè› è›£è›¥è›§èšˆè›ºè›¼è›½èœ„èœ…èœ‡èœ‹èœŽèœèœèœ“èœ”èœ™èœžèœŸèœ¡èœ£"
  ],
  [
    "8fdba1",
    "èœ¨èœ®èœ¯èœ±èœ²èœ¹èœºèœ¼èœ½èœ¾è€èƒè…èè˜èè¡è¤è¥è¯è±è²è»èžƒ",
    6,
    "èž‹èžŒèžèž“èž•èž—èž˜èž™èžžèž èž£èž§èž¬èž­èž®èž±èžµèž¾èž¿èŸèŸˆèŸ‰èŸŠèŸŽèŸ•èŸ–èŸ™èŸšèŸœèŸŸèŸ¢èŸ£èŸ¤èŸªèŸ«èŸ­èŸ±èŸ³èŸ¸èŸºèŸ¿è è ƒè †è ‰è Šè ‹è è ™è ’è “è ”è ˜è šè ›è œè žè Ÿè ¨è ­è ®è °è ²è µ"
  ],
  [
    "8fdca1",
    "è ºè ¼è¡è¡ƒè¡…è¡ˆè¡‰è¡Šè¡‹è¡Žè¡‘è¡•è¡–è¡˜è¡šè¡œè¡Ÿè¡ è¡¤è¡©è¡±è¡¹è¡»è¢€è¢˜è¢šè¢›è¢œè¢Ÿè¢ è¢¨è¢ªè¢ºè¢½è¢¾è£€è£Š",
    4,
    "è£‘è£’è£“è£›è£žè£§è£¯è£°è£±è£µè£·è¤è¤†è¤è¤Žè¤è¤•è¤–è¤˜è¤™è¤šè¤œè¤ è¤¦è¤§è¤¨è¤°è¤±è¤²è¤µè¤¹è¤ºè¤¾è¥€è¥‚è¥…è¥†è¥‰è¥è¥’è¥—è¥šè¥›è¥œè¥¡è¥¢è¥£è¥«è¥®è¥°è¥³è¥µè¥º"
  ],
  [
    "8fdda1",
    "è¥»è¥¼è¥½è¦‰è¦è¦è¦”è¦•è¦›è¦œè¦Ÿè¦ è¦¥è¦°è¦´è¦µè¦¶è¦·è¦¼è§”",
    4,
    "è§¥è§©è§«è§­è§±è§³è§¶è§¹è§½è§¿è¨„è¨…è¨‡è¨è¨‘è¨’è¨”è¨•è¨žè¨ è¨¢è¨¤è¨¦è¨«è¨¬è¨¯è¨µè¨·è¨½è¨¾è©€è©ƒè©…è©‡è©‰è©è©Žè©“è©–è©—è©˜è©œè©è©¡è©¥è©§è©µè©¶è©·è©¹è©ºè©»è©¾è©¿èª€èªƒèª†èª‹èªèªèª’èª–èª—èª™èªŸèª§èª©èª®èª¯èª³"
  ],
  [
    "8fdea1",
    "èª¶èª·èª»èª¾è«ƒè«†è«ˆè«‰è«Šè«‘è«“è«”è«•è«—è«è«Ÿè«¬è«°è«´è«µè«¶è«¼è«¿è¬…è¬†è¬‹è¬‘è¬œè¬žè¬Ÿè¬Šè¬­è¬°è¬·è¬¼è­‚",
    4,
    "è­ˆè­’è­“è­”è­™è­è­žè­£è­­è­¶è­¸è­¹è­¼è­¾è®è®„è®…è®‹è®è®è®”è®•è®œè®žè®Ÿè°¸è°¹è°½è°¾è±…è±‡è±‰è±‹è±è±‘è±“è±”è±—è±˜è±›è±è±™è±£è±¤è±¦è±¨è±©è±­è±³è±µè±¶è±»è±¾è²†"
  ],
  [
    "8fdfa1",
    "è²‡è²‹è²è²’è²“è²™è²›è²œè²¤è²¹è²ºè³…è³†è³‰è³‹è³è³–è³•è³™è³è³¡è³¨è³¬è³¯è³°è³²è³µè³·è³¸è³¾è³¿è´è´ƒè´‰è´’è´—è´›èµ¥èµ©èµ¬èµ®èµ¿è¶‚è¶„è¶ˆè¶è¶è¶‘è¶•è¶žè¶Ÿè¶ è¶¦è¶«è¶¬è¶¯è¶²è¶µè¶·è¶¹è¶»è·€è·…è·†è·‡è·ˆè·Šè·Žè·‘è·”è·•è·—è·™è·¤è·¥è·§è·¬è·°è¶¼è·±è·²è·´è·½è¸è¸„è¸…è¸†è¸‹è¸‘è¸”è¸–è¸ è¸¡è¸¢"
  ],
  [
    "8fe0a1",
    "è¸£è¸¦è¸§è¸±è¸³è¸¶è¸·è¸¸è¸¹è¸½è¹€è¹è¹‹è¹è¹Žè¹è¹”è¹›è¹œè¹è¹žè¹¡è¹¢è¹©è¹¬è¹­è¹¯è¹°è¹±è¹¹è¹ºè¹»èº‚èºƒèº‰èºèº’èº•èºšèº›èºèºžèº¢èº§èº©èº­èº®èº³èºµèººèº»è»€è»è»ƒè»„è»‡è»è»‘è»”è»œè»¨è»®è»°è»±è»·è»¹è»ºè»­è¼€è¼‚è¼‡è¼ˆè¼è¼è¼–è¼—è¼˜è¼žè¼ è¼¡è¼£è¼¥è¼§è¼¨è¼¬è¼­è¼®è¼´è¼µè¼¶è¼·è¼ºè½€è½"
  ],
  [
    "8fe1a1",
    "è½ƒè½‡è½è½‘",
    4,
    "è½˜è½è½žè½¥è¾è¾ è¾¡è¾¤è¾¥è¾¦è¾µè¾¶è¾¸è¾¾è¿€è¿è¿†è¿Šè¿‹è¿è¿è¿’è¿“è¿•è¿ è¿£è¿¤è¿¨è¿®è¿±è¿µè¿¶è¿»è¿¾é€‚é€„é€ˆé€Œé€˜é€›é€¨é€©é€¯é€ªé€¬é€­é€³é€´é€·é€¿éƒé„éŒé›éé¢é¦é§é¬é°é´é¹é‚…é‚ˆé‚‹é‚Œé‚Žé‚é‚•é‚—é‚˜é‚™é‚›é‚ é‚¡é‚¢é‚¥é‚°é‚²é‚³é‚´é‚¶é‚½éƒŒé‚¾éƒƒ"
  ],
  [
    "8fe2a1",
    "éƒ„éƒ…éƒ‡éƒˆéƒ•éƒ—éƒ˜éƒ™éƒœéƒéƒŸéƒ¥éƒ’éƒ¶éƒ«éƒ¯éƒ°éƒ´éƒ¾éƒ¿é„€é„„é„…é„†é„ˆé„é„é„”é„–é„—é„˜é„šé„œé„žé„ é„¥é„¢é„£é„§é„©é„®é„¯é„±é„´é„¶é„·é„¹é„ºé„¼é„½é…ƒé…‡é…ˆé…é…“é…—é…™é…šé…›é…¡é…¤é…§é…­é…´é…¹é…ºé…»é†é†ƒé†…é††é†Šé†Žé†‘é†“é†”é†•é†˜é†žé†¡é†¦é†¨é†¬é†­é†®é†°é†±é†²é†³é†¶é†»é†¼é†½é†¿"
  ],
  [
    "8fe3a1",
    "é‡‚é‡ƒé‡…é‡“é‡”é‡—é‡™é‡šé‡žé‡¤é‡¥é‡©é‡ªé‡¬",
    5,
    "é‡·é‡¹é‡»é‡½éˆ€éˆéˆ„éˆ…éˆ†éˆ‡éˆ‰éˆŠéˆŒéˆéˆ’éˆ“éˆ–éˆ˜éˆœéˆéˆ£éˆ¤éˆ¥éˆ¦éˆ¨éˆ®éˆ¯éˆ°éˆ³éˆµéˆ¶éˆ¸éˆ¹éˆºéˆ¼éˆ¾é‰€é‰‚é‰ƒé‰†é‰‡é‰Šé‰é‰Žé‰é‰‘é‰˜é‰™é‰œé‰é‰ é‰¡é‰¥é‰§é‰¨é‰©é‰®é‰¯é‰°é‰µ",
    4,
    "é‰»é‰¼é‰½é‰¿éŠˆéŠ‰éŠŠéŠéŠŽéŠ’éŠ—"
  ],
  [
    "8fe4a1",
    "éŠ™éŠŸéŠ éŠ¤éŠ¥éŠ§éŠ¨éŠ«éŠ¯éŠ²éŠ¶éŠ¸éŠºéŠ»éŠ¼éŠ½éŠ¿",
    4,
    "é‹…é‹†é‹‡é‹ˆé‹‹é‹Œé‹é‹Žé‹é‹“é‹•é‹—é‹˜é‹™é‹œé‹é‹Ÿé‹ é‹¡é‹£é‹¥é‹§é‹¨é‹¬é‹®é‹°é‹¹é‹»é‹¿éŒ€éŒ‚éŒˆéŒéŒ‘éŒ”éŒ•éŒœéŒéŒžéŒŸéŒ¡éŒ¤éŒ¥éŒ§éŒ©éŒªéŒ³éŒ´éŒ¶éŒ·é‡éˆé‰éé‘é’é•é—é˜éšéžé¤é¥é§é©éªé­é¯é°é±é³é´é¶"
  ],
  [
    "8fe5a1",
    "éºé½é¿éŽ€éŽéŽ‚éŽˆéŽŠéŽ‹éŽéŽéŽ’éŽ•éŽ˜éŽ›éŽžéŽ¡éŽ£éŽ¤éŽ¦éŽ¨éŽ«éŽ´éŽµéŽ¶éŽºéŽ©éé„é…é†é‡é‰",
    4,
    "é“é™éœéžéŸé¢é¦é§é¹é·é¸éºé»é½éé‚é„éˆé‰ééŽéé•é–é—éŸé®é¯é±é²é³é´é»é¿é½é‘ƒé‘…é‘ˆé‘Šé‘Œé‘•é‘™é‘œé‘Ÿé‘¡é‘£é‘¨é‘«é‘­é‘®é‘¯é‘±é‘²é’„é’ƒé•¸é•¹"
  ],
  [
    "8fe6a1",
    "é•¾é–„é–ˆé–Œé–é–Žé–é–žé–Ÿé–¡é–¦é–©é–«é–¬é–´é–¶é–ºé–½é–¿é—†é—ˆé—‰é—‹é—é—‘é—’é—“é—™é—šé—é—žé—Ÿé— é—¤é—¦é˜é˜žé˜¢é˜¤é˜¥é˜¦é˜¬é˜±é˜³é˜·é˜¸é˜¹é˜ºé˜¼é˜½é™é™’é™”é™–é™—é™˜é™¡é™®é™´é™»é™¼é™¾é™¿éšéš‚éšƒéš„éš‰éš‘éš–éššéšéšŸéš¤éš¥éš¦éš©éš®éš¯éš³éšºé›Šé›’å¶²é›˜é›šé›é›žé›Ÿé›©é›¯é›±é›ºéœ‚"
  ],
  [
    "8fe7a1",
    "éœƒéœ…éœ‰éœšéœ›éœéœ¡éœ¢éœ£éœ¨éœ±éœ³ééƒéŠéŽéé•é—é˜éšé›é£é§éªé®é³é¶é·é¸é»é½é¿éž€éž‰éž•éž–éž—éž™éžšéžžéžŸéž¢éž¬éž®éž±éž²éžµéž¶éž¸éž¹éžºéž¼éž¾éž¿éŸéŸ„éŸ…éŸ‡éŸ‰éŸŠéŸŒéŸéŸŽéŸéŸ‘éŸ”éŸ—éŸ˜éŸ™éŸéŸžéŸ éŸ›éŸ¡éŸ¤éŸ¯éŸ±éŸ´éŸ·éŸ¸éŸºé ‡é Šé ™é é Žé ”é –é œé žé  é £é ¦"
  ],
  [
    "8fe8a1",
    "é «é ®é ¯é °é ²é ³é µé ¥é ¾é¡„é¡‡é¡Šé¡‘é¡’é¡“é¡–é¡—é¡™é¡šé¡¢é¡£é¡¥é¡¦é¡ªé¡¬é¢«é¢­é¢®é¢°é¢´é¢·é¢¸é¢ºé¢»é¢¿é£‚é£…é£ˆé£Œé£¡é££é£¥é£¦é£§é£ªé£³é£¶é¤‚é¤‡é¤ˆé¤‘é¤•é¤–é¤—é¤šé¤›é¤œé¤Ÿé¤¢é¤¦é¤§é¤«é¤±",
    4,
    "é¤¹é¤ºé¤»é¤¼é¥€é¥é¥†é¥‡é¥ˆé¥é¥Žé¥”é¥˜é¥™é¥›é¥œé¥žé¥Ÿé¥ é¦›é¦é¦Ÿé¦¦é¦°é¦±é¦²é¦µ"
  ],
  [
    "8fe9a1",
    "é¦¹é¦ºé¦½é¦¿é§ƒé§‰é§“é§”é§™é§šé§œé§žé§§é§ªé§«é§¬é§°é§´é§µé§¹é§½é§¾é¨‚é¨ƒé¨„é¨‹é¨Œé¨é¨‘é¨–é¨žé¨ é¨¢é¨£é¨¤é¨§é¨­é¨®é¨³é¨µé¨¶é¨¸é©‡é©é©„é©Šé©‹é©Œé©Žé©‘é©”é©–é©éªªéª¬éª®éª¯éª²éª´éªµéª¶éª¹éª»éª¾éª¿é«é«ƒé«†é«ˆé«Žé«é«’é«•é«–é«—é«›é«œé« é«¤é«¥é«§é«©é«¬é«²é«³é«µé«¹é«ºé«½é«¿",
    4
  ],
  [
    "8feaa1",
    "é¬„é¬…é¬ˆé¬‰é¬‹é¬Œé¬é¬Žé¬é¬’é¬–é¬™é¬›é¬œé¬ é¬¦é¬«é¬­é¬³é¬´é¬µé¬·é¬¹é¬ºé¬½é­ˆé­‹é­Œé­•é­–é­—é­›é­žé­¡é­£é­¥é­¦é­¨é­ª",
    4,
    "é­³é­µé­·é­¸é­¹é­¿é®€é®„é®…é®†é®‡é®‰é®Šé®‹é®é®é®é®”é®šé®é®žé®¦é®§é®©é®¬é®°é®±é®²é®·é®¸é®»é®¼é®¾é®¿é¯é¯‡é¯ˆé¯Žé¯é¯—é¯˜é¯é¯Ÿé¯¥é¯§é¯ªé¯«é¯¯é¯³é¯·é¯¸"
  ],
  [
    "8feba1",
    "é¯¹é¯ºé¯½é¯¿é°€é°‚é°‹é°é°‘é°–é°˜é°™é°šé°œé°žé°¢é°£é°¦",
    4,
    "é°±é°µé°¶é°·é°½é±é±ƒé±„é±…é±‰é±Šé±Žé±é±é±“é±”é±–é±˜é±›é±é±žé±Ÿé±£é±©é±ªé±œé±«é±¨é±®é±°é±²é±µé±·é±»é³¦é³²é³·é³¹é´‹é´‚é´‘é´—é´˜é´œé´é´žé´¯é´°é´²é´³é´´é´ºé´¼éµ…é´½éµ‚éµƒéµ‡éµŠéµ“éµ”éµŸéµ£éµ¢éµ¥éµ©éµªéµ«éµ°éµ¶éµ·éµ»"
  ],
  [
    "8feca1",
    "éµ¼éµ¾é¶ƒé¶„é¶†é¶Šé¶é¶Žé¶’é¶“é¶•é¶–é¶—é¶˜é¶¡é¶ªé¶¬é¶®é¶±é¶µé¶¹é¶¼é¶¿é·ƒé·‡é·‰é·Šé·”é·•é·–é·—é·šé·žé·Ÿé· é·¥é·§é·©é·«é·®é·°é·³é·´é·¾é¸Šé¸‚é¸‡é¸Žé¸é¸‘é¸’é¸•é¸–é¸™é¸œé¸é¹ºé¹»é¹¼éº€éº‚éºƒéº„éº…éº‡éºŽéºéº–éº˜éº›éºžéº¤éº¨éº¬éº®éº¯éº°éº³éº´éºµé»†é»ˆé»‹é»•é»Ÿé»¤é»§é»¬é»­é»®é»°é»±é»²é»µ"
  ],
  [
    "8feda1",
    "é»¸é»¿é¼‚é¼ƒé¼‰é¼é¼é¼‘é¼’é¼”é¼–é¼—é¼™é¼šé¼›é¼Ÿé¼¢é¼¦é¼ªé¼«é¼¯é¼±é¼²é¼´é¼·é¼¹é¼ºé¼¼é¼½é¼¿é½é½ƒ",
    4,
    "é½“é½•é½–é½—é½˜é½šé½é½žé½¨é½©é½­",
    4,
    "é½³é½µé½ºé½½é¾é¾é¾‘é¾’é¾”é¾–é¾—é¾žé¾¡é¾¢é¾£é¾¥"
  ]
];
const require$$2$1 = [
  [
    "0",
    "\0",
    127,
    "â‚¬"
  ],
  [
    "8140",
    "ä¸‚ä¸„ä¸…ä¸†ä¸ä¸’ä¸—ä¸Ÿä¸ ä¸¡ä¸£ä¸¦ä¸©ä¸®ä¸¯ä¸±ä¸³ä¸µä¸·ä¸¼ä¹€ä¹ä¹‚ä¹„ä¹†ä¹Šä¹‘ä¹•ä¹—ä¹šä¹›ä¹¢ä¹£ä¹¤ä¹¥ä¹§ä¹¨ä¹ª",
    5,
    "ä¹²ä¹´",
    9,
    "ä¹¿",
    6,
    "äº‡äºŠ"
  ],
  [
    "8180",
    "äºäº–äº—äº™äºœäºäºžäº£äºªäº¯äº°äº±äº´äº¶äº·äº¸äº¹äº¼äº½äº¾ä»ˆä»Œä»ä»ä»’ä»šä»›ä»œä» ä»¢ä»¦ä»§ä»©ä»­ä»®ä»¯ä»±ä»´ä»¸ä»¹ä»ºä»¼ä»¾ä¼€ä¼‚",
    6,
    "ä¼‹ä¼Œä¼’",
    4,
    "ä¼œä¼ä¼¡ä¼£ä¼¨ä¼©ä¼¬ä¼­ä¼®ä¼±ä¼³ä¼µä¼·ä¼¹ä¼»ä¼¾",
    4,
    "ä½„ä½…ä½‡",
    5,
    "ä½’ä½”ä½–ä½¡ä½¢ä½¦ä½¨ä½ªä½«ä½­ä½®ä½±ä½²ä½µä½·ä½¸ä½¹ä½ºä½½ä¾€ä¾ä¾‚ä¾…ä¾†ä¾‡ä¾Šä¾Œä¾Žä¾ä¾’ä¾“ä¾•ä¾–ä¾˜ä¾™ä¾šä¾œä¾žä¾Ÿä¾¡ä¾¢"
  ],
  [
    "8240",
    "ä¾¤ä¾«ä¾­ä¾°",
    4,
    "ä¾¶",
    8,
    "ä¿€ä¿ä¿‚ä¿†ä¿‡ä¿ˆä¿‰ä¿‹ä¿Œä¿ä¿’",
    4,
    "ä¿™ä¿›ä¿ ä¿¢ä¿¤ä¿¥ä¿§ä¿«ä¿¬ä¿°ä¿²ä¿´ä¿µä¿¶ä¿·ä¿¹ä¿»ä¿¼ä¿½ä¿¿",
    11
  ],
  [
    "8280",
    "å€‹å€Žå€å€‘å€“å€•å€–å€—å€›å€å€žå€ å€¢å€£å€¤å€§å€«å€¯",
    10,
    "å€»å€½å€¿å€åå‚å„å…å†å‰åŠå‹åå",
    4,
    "å–å—å˜å™å›å",
    7,
    "å¦",
    5,
    "å­",
    8,
    "å¸å¹åºå¼å½å‚å‚‚å‚ƒå‚„å‚†å‚‡å‚‰å‚Šå‚‹å‚Œå‚Ž",
    20,
    "å‚¤å‚¦å‚ªå‚«å‚­",
    4,
    "å‚³",
    6,
    "å‚¼"
  ],
  [
    "8340",
    "å‚½",
    17,
    "åƒ",
    5,
    "åƒ—åƒ˜åƒ™åƒ›",
    10,
    "åƒ¨åƒ©åƒªåƒ«åƒ¯åƒ°åƒ±åƒ²åƒ´åƒ¶",
    4,
    "åƒ¼",
    9,
    "å„ˆ"
  ],
  [
    "8380",
    "å„‰å„Šå„Œ",
    5,
    "å„“",
    13,
    "å„¢",
    28,
    "å…‚å…‡å…Šå…Œå…Žå…å…å…’å…“å…—å…˜å…™å…›å…",
    4,
    "å…£å…¤å…¦å…§å…©å…ªå…¯å…²å…ºå…¾å…¿å†ƒå†„å††å†‡å†Šå†‹å†Žå†å†å†‘å†“å†”å†˜å†šå†å†žå†Ÿå†¡å†£å†¦",
    4,
    "å†­å†®å†´å†¸å†¹å†ºå†¾å†¿å‡å‡‚å‡ƒå‡…å‡ˆå‡Šå‡å‡Žå‡å‡’",
    5
  ],
  [
    "8440",
    "å‡˜å‡™å‡šå‡œå‡žå‡Ÿå‡¢å‡£å‡¥",
    5,
    "å‡¬å‡®å‡±å‡²å‡´å‡·å‡¾åˆ„åˆ…åˆ‰åˆ‹åˆŒåˆåˆåˆ“åˆ”åˆ•åˆœåˆžåˆŸåˆ¡åˆ¢åˆ£åˆ¥åˆ¦åˆ§åˆªåˆ¬åˆ¯åˆ±åˆ²åˆ´åˆµåˆ¼åˆ¾å‰„",
    5,
    "å‰‹å‰Žå‰å‰’å‰“å‰•å‰—å‰˜"
  ],
  [
    "8480",
    "å‰™å‰šå‰›å‰å‰Ÿå‰ å‰¢å‰£å‰¤å‰¦å‰¨å‰«å‰¬å‰­å‰®å‰°å‰±å‰³",
    9,
    "å‰¾åŠ€åŠƒ",
    4,
    "åŠ‰",
    6,
    "åŠ‘åŠ’åŠ”",
    6,
    "åŠœåŠ¤åŠ¥åŠ¦åŠ§åŠ®åŠ¯åŠ°åŠ´",
    9,
    "å‹€å‹å‹‚å‹„å‹…å‹†å‹ˆå‹Šå‹Œå‹å‹Žå‹å‹‘å‹“å‹”å‹•å‹—å‹™",
    5,
    "å‹ å‹¡å‹¢å‹£å‹¥",
    10,
    "å‹±",
    7,
    "å‹»å‹¼å‹½åŒåŒ‚åŒƒåŒ„åŒ‡åŒ‰åŒŠåŒ‹åŒŒåŒŽ"
  ],
  [
    "8540",
    "åŒ‘åŒ’åŒ“åŒ”åŒ˜åŒ›åŒœåŒžåŒŸåŒ¢åŒ¤åŒ¥åŒ§åŒ¨åŒ©åŒ«åŒ¬åŒ­åŒ¯",
    9,
    "åŒ¼åŒ½å€å‚å„å†å‹åŒååå”å˜å™å›åå¥å¨åªå¬å­å²å¶å¹å»å¼å½å¾åŽ€åŽåŽƒåŽ‡åŽˆåŽŠåŽŽåŽ"
  ],
  [
    "8580",
    "åŽ",
    4,
    "åŽ–åŽ—åŽ™åŽ›åŽœåŽžåŽ åŽ¡åŽ¤åŽ§åŽªåŽ«åŽ¬åŽ­åŽ¯",
    6,
    "åŽ·åŽ¸åŽ¹åŽºåŽ¼åŽ½åŽ¾å€åƒ",
    4,
    "åŽååå’å“å•åšåœååžå¡å¢å§å´åºå¾å¿å€å‚å…å‡å‹å”å˜å™åšåœå¢å¤å¥åªå°å³å¶å·åºå½å¿å‘å‘‚å‘„å‘…å‘‡å‘‰å‘Œå‘å‘Žå‘å‘‘å‘šå‘",
    4,
    "å‘£å‘¥å‘§å‘©",
    7,
    "å‘´å‘¹å‘ºå‘¾å‘¿å’å’ƒå’…å’‡å’ˆå’‰å’Šå’å’‘å’“å’—å’˜å’œå’žå’Ÿå’ å’¡"
  ],
  [
    "8640",
    "å’¢å’¥å’®å’°å’²å’µå’¶å’·å’¹å’ºå’¼å’¾å“ƒå“…å“Šå“‹å“–å“˜å“›å“ ",
    4,
    "å“«å“¬å“¯å“°å“±å“´",
    5,
    "å“»å“¾å”€å”‚å”ƒå”„å”…å”ˆå”Š",
    4,
    "å”’å”“å”•",
    5,
    "å”œå”å”žå”Ÿå”¡å”¥å”¦"
  ],
  [
    "8680",
    "å”¨å”©å”«å”­å”²å”´å”µå”¶å”¸å”¹å”ºå”»å”½å•€å•‚å•…å•‡å•ˆå•‹",
    4,
    "å•‘å•’å•“å•”å•—",
    4,
    "å•å•žå•Ÿå• å•¢å•£å•¨å•©å•«å•¯",
    5,
    "å•¹å•ºå•½å•¿å–…å–†å–Œå–å–Žå–å–’å–“å–•å––å–—å–šå–›å–žå– ",
    6,
    "å–¨",
    8,
    "å–²å–´å–¶å–¸å–ºå–¼å–¿",
    4,
    "å—†å—‡å—ˆå—Šå—‹å—Žå—å—å—•å——",
    4,
    "å—žå— å—¢å—§å—©å—­å—®å—°å—±å—´å—¶å—¸",
    4,
    "å—¿å˜‚å˜ƒå˜„å˜…"
  ],
  [
    "8740",
    "å˜†å˜‡å˜Šå˜‹å˜å˜",
    7,
    "å˜™å˜šå˜œå˜å˜ å˜¡å˜¢å˜¥å˜¦å˜¨å˜©å˜ªå˜«å˜®å˜¯å˜°å˜³å˜µå˜·å˜¸å˜ºå˜¼å˜½å˜¾å™€",
    11,
    "å™",
    4,
    "å™•å™–å™šå™›å™",
    4
  ],
  [
    "8780",
    "å™£å™¥å™¦å™§å™­å™®å™¯å™°å™²å™³å™´å™µå™·å™¸å™¹å™ºå™½",
    7,
    "åš‡",
    6,
    "åšåš‘åš’åš”",
    14,
    "åš¤",
    10,
    "åš°",
    6,
    "åš¸åš¹åšºåš»åš½",
    12,
    "å›‹",
    8,
    "å›•å›–å›˜å›™å›œå›£å›¥",
    5,
    "å›¬å›®å›¯å›²å›³å›¶å›·å›¸å›»å›¼åœ€åœåœ‚åœ…åœ‡åœ‹",
    6
  ],
  [
    "8840",
    "åœ’",
    9,
    "åœåœžåœ åœ¡åœ¢åœ¤åœ¥åœ¦åœ§åœ«åœ±åœ²åœ´",
    4,
    "åœ¼åœ½åœ¿ååƒå„å…å†åˆå‰å‹å’",
    4,
    "å˜å™å¢å£å¥å§å¬å®å°å±å²å´åµå¸å¹åºå½å¾å¿åž€"
  ],
  [
    "8880",
    "åžåž‡åžˆåž‰åžŠåž",
    4,
    "åž”",
    6,
    "åžœåžåžžåžŸåž¥åž¨åžªåž¬åž¯åž°åž±åž³åžµåž¶åž·åž¹",
    8,
    "åŸ„",
    6,
    "åŸŒåŸåŸåŸ‘åŸ“åŸ–åŸ—åŸ›åŸœåŸžåŸ¡åŸ¢åŸ£åŸ¥",
    7,
    "åŸ®åŸ°åŸ±åŸ²åŸ³åŸµåŸ¶åŸ·åŸ»åŸ¼åŸ¾åŸ¿å å ƒå „å …å ˆå ‰å Šå Œå Žå å å ’å “å ”å –å —å ˜å šå ›å œå å Ÿå ¢å £å ¥",
    4,
    "å «",
    4,
    "å ±å ²å ³å ´å ¶",
    7
  ],
  [
    "8940",
    "å ¾",
    5,
    "å¡…",
    6,
    "å¡Žå¡å¡å¡’å¡“å¡•å¡–å¡—å¡™",
    4,
    "å¡Ÿ",
    5,
    "å¡¦",
    4,
    "å¡­",
    16,
    "å¡¿å¢‚å¢„å¢†å¢‡å¢ˆå¢Šå¢‹å¢Œ"
  ],
  [
    "8980",
    "å¢",
    4,
    "å¢”",
    4,
    "å¢›å¢œå¢å¢ ",
    7,
    "å¢ª",
    17,
    "å¢½å¢¾å¢¿å£€å£‚å£ƒå£„å£†",
    10,
    "å£’å£“å£”å£–",
    13,
    "å£¥",
    5,
    "å£­å£¯å£±å£²å£´å£µå£·å£¸å£º",
    7,
    "å¤ƒå¤…å¤†å¤ˆ",
    4,
    "å¤Žå¤å¤‘å¤’å¤“å¤—å¤˜å¤›å¤å¤žå¤ å¤¡å¤¢å¤£å¤¦å¤¨å¤¬å¤°å¤²å¤³å¤µå¤¶å¤»"
  ],
  [
    "8a40",
    "å¤½å¤¾å¤¿å¥€å¥ƒå¥…å¥†å¥Šå¥Œå¥å¥å¥’å¥“å¥™å¥›",
    4,
    "å¥¡å¥£å¥¤å¥¦",
    12,
    "å¥µå¥·å¥ºå¥»å¥¼å¥¾å¥¿å¦€å¦…å¦‰å¦‹å¦Œå¦Žå¦å¦å¦‘å¦”å¦•å¦˜å¦šå¦›å¦œå¦å¦Ÿå¦ å¦¡å¦¢å¦¦"
  ],
  [
    "8a80",
    "å¦§å¦¬å¦­å¦°å¦±å¦³",
    5,
    "å¦ºå¦¼å¦½å¦¿",
    6,
    "å§‡å§ˆå§‰å§Œå§å§Žå§å§•å§–å§™å§›å§ž",
    4,
    "å§¤å§¦å§§å§©å§ªå§«å§­",
    11,
    "å§ºå§¼å§½å§¾å¨€å¨‚å¨Šå¨‹å¨å¨Žå¨å¨å¨’å¨”å¨•å¨–å¨—å¨™å¨šå¨›å¨å¨žå¨¡å¨¢å¨¤å¨¦å¨§å¨¨å¨ª",
    6,
    "å¨³å¨µå¨·",
    4,
    "å¨½å¨¾å¨¿å©",
    4,
    "å©‡å©ˆå©‹",
    9,
    "å©–å©—å©˜å©™å©›",
    5
  ],
  [
    "8b40",
    "å©¡å©£å©¤å©¥å©¦å©¨å©©å©«",
    8,
    "å©¸å©¹å©»å©¼å©½å©¾åª€",
    17,
    "åª“",
    6,
    "åªœ",
    13,
    "åª«åª¬"
  ],
  [
    "8b80",
    "åª­",
    4,
    "åª´åª¶åª·åª¹",
    4,
    "åª¿å«€å«ƒ",
    5,
    "å«Šå«‹å«",
    4,
    "å«“å«•å«—å«™å«šå«›å«å«žå«Ÿå«¢å«¤å«¥å«§å«¨å«ªå«¬",
    4,
    "å«²",
    22,
    "å¬Š",
    11,
    "å¬˜",
    25,
    "å¬³å¬µå¬¶å¬¸",
    7,
    "å­",
    6
  ],
  [
    "8c40",
    "å­ˆ",
    7,
    "å­’å­–å­žå­ å­¡å­§å­¨å­«å­­å­®å­¯å­²å­´å­¶å­·å­¸å­¹å­»å­¼å­¾å­¿å®‚å®†å®Šå®å®Žå®å®‘å®’å®”å®–å®Ÿå®§å®¨å®©å®¬å®­å®®å®¯å®±å®²å®·å®ºå®»å®¼å¯€å¯å¯ƒå¯ˆå¯‰å¯Šå¯‹å¯å¯Žå¯"
  ],
  [
    "8c80",
    "å¯‘å¯”",
    8,
    "å¯ å¯¢å¯£å¯¦å¯§å¯©",
    4,
    "å¯¯å¯±",
    6,
    "å¯½å¯¾å°€å°‚å°ƒå°…å°‡å°ˆå°‹å°Œå°å°Žå°å°’å°“å°—å°™å°›å°žå°Ÿå° å°¡å°£å°¦å°¨å°©å°ªå°«å°­å°®å°¯å°°å°²å°³å°µå°¶å°·å±ƒå±„å±†å±‡å±Œå±å±’å±“å±”å±–å±—å±˜å±šå±›å±œå±å±Ÿå±¢å±¤å±§",
    6,
    "å±°å±²",
    6,
    "å±»å±¼å±½å±¾å²€å²ƒ",
    4,
    "å²‰å²Šå²‹å²Žå²å²’å²“å²•å²",
    4,
    "å²¤",
    4
  ],
  [
    "8d40",
    "å²ªå²®å²¯å²°å²²å²´å²¶å²¹å²ºå²»å²¼å²¾å³€å³‚å³ƒå³…",
    5,
    "å³Œ",
    5,
    "å³“",
    5,
    "å³š",
    6,
    "å³¢å³£å³§å³©å³«å³¬å³®å³¯å³±",
    9,
    "å³¼",
    4
  ],
  [
    "8d80",
    "å´å´„å´…å´ˆ",
    5,
    "å´",
    4,
    "å´•å´—å´˜å´™å´šå´œå´å´Ÿ",
    4,
    "å´¥å´¨å´ªå´«å´¬å´¯",
    4,
    "å´µ",
    7,
    "å´¿",
    7,
    "åµˆåµ‰åµ",
    10,
    "åµ™åµšåµœåµž",
    10,
    "åµªåµ­åµ®åµ°åµ±åµ²åµ³åµµ",
    12,
    "å¶ƒ",
    21,
    "å¶šå¶›å¶œå¶žå¶Ÿå¶ "
  ],
  [
    "8e40",
    "å¶¡",
    21,
    "å¶¸",
    12,
    "å·†",
    6,
    "å·Ž",
    12,
    "å·œå·Ÿå· å·£å·¤å·ªå·¬å·­"
  ],
  [
    "8e80",
    "å·°å·µå·¶å·¸",
    4,
    "å·¿å¸€å¸„å¸‡å¸‰å¸Šå¸‹å¸å¸Žå¸’å¸“å¸—å¸ž",
    7,
    "å¸¨",
    4,
    "å¸¯å¸°å¸²",
    4,
    "å¸¹å¸ºå¸¾å¸¿å¹€å¹å¹ƒå¹†",
    5,
    "å¹",
    6,
    "å¹–",
    4,
    "å¹œå¹å¹Ÿå¹ å¹£",
    14,
    "å¹µå¹·å¹¹å¹¾åºåº‚åºƒåº…åºˆåº‰åºŒåºåºŽåº’åº˜åº›åºåº¡åº¢åº£åº¤åº¨",
    4,
    "åº®",
    4,
    "åº´åººåº»åº¼åº½åº¿",
    6
  ],
  [
    "8f40",
    "å»†å»‡å»ˆå»‹",
    5,
    "å»”å»•å»—å»˜å»™å»šå»œ",
    11,
    "å»©å»«",
    8,
    "å»µå»¸å»¹å»»å»¼å»½å¼…å¼†å¼‡å¼‰å¼Œå¼å¼Žå¼å¼’å¼”å¼–å¼™å¼šå¼œå¼å¼žå¼¡å¼¢å¼£å¼¤"
  ],
  [
    "8f80",
    "å¼¨å¼«å¼¬å¼®å¼°å¼²",
    6,
    "å¼»å¼½å¼¾å¼¿å½",
    14,
    "å½‘å½”å½™å½šå½›å½œå½žå½Ÿå½ å½£å½¥å½§å½¨å½«å½®å½¯å½²å½´å½µå½¶å½¸å½ºå½½å½¾å½¿å¾ƒå¾†å¾å¾Žå¾å¾‘å¾“å¾”å¾–å¾šå¾›å¾å¾žå¾Ÿå¾ å¾¢",
    5,
    "å¾©å¾«å¾¬å¾¯",
    5,
    "å¾¶å¾¸å¾¹å¾ºå¾»å¾¾",
    4,
    "å¿‡å¿ˆå¿Šå¿‹å¿Žå¿“å¿”å¿•å¿šå¿›å¿œå¿žå¿Ÿå¿¢å¿£å¿¥å¿¦å¿¨å¿©å¿¬å¿¯å¿°å¿²å¿³å¿´å¿¶å¿·å¿¹å¿ºå¿¼æ€‡"
  ],
  [
    "9040",
    "æ€ˆæ€‰æ€‹æ€Œæ€æ€‘æ€“æ€—æ€˜æ€šæ€žæ€Ÿæ€¢æ€£æ€¤æ€¬æ€­æ€®æ€°",
    4,
    "æ€¶",
    4,
    "æ€½æ€¾æ€æ„",
    6,
    "æŒæŽææ‘æ“æ”æ–æ—æ˜æ›æœæžæŸæ æ¡æ¥æ¦æ®æ±æ²æ´æµæ·æ¾æ‚€"
  ],
  [
    "9080",
    "æ‚æ‚‚æ‚…æ‚†æ‚‡æ‚ˆæ‚Šæ‚‹æ‚Žæ‚æ‚æ‚‘æ‚“æ‚•æ‚—æ‚˜æ‚™æ‚œæ‚žæ‚¡æ‚¢æ‚¤æ‚¥æ‚§æ‚©æ‚ªæ‚®æ‚°æ‚³æ‚µæ‚¶æ‚·æ‚¹æ‚ºæ‚½",
    7,
    "æƒ‡æƒˆæƒ‰æƒŒ",
    4,
    "æƒ’æƒ“æƒ”æƒ–æƒ—æƒ™æƒ›æƒžæƒ¡",
    4,
    "æƒªæƒ±æƒ²æƒµæƒ·æƒ¸æƒ»",
    4,
    "æ„‚æ„ƒæ„„æ„…æ„‡æ„Šæ„‹æ„Œæ„",
    4,
    "æ„–æ„—æ„˜æ„™æ„›æ„œæ„æ„žæ„¡æ„¢æ„¥æ„¨æ„©æ„ªæ„¬",
    18,
    "æ…€",
    6
  ],
  [
    "9140",
    "æ…‡æ…‰æ…‹æ…æ…æ…æ…’æ…“æ…”æ…–",
    6,
    "æ…žæ…Ÿæ… æ…¡æ…£æ…¤æ…¥æ…¦æ…©",
    6,
    "æ…±æ…²æ…³æ…´æ…¶æ…¸",
    18,
    "æ†Œæ†æ†",
    4,
    "æ†•"
  ],
  [
    "9180",
    "æ†–",
    6,
    "æ†ž",
    8,
    "æ†ªæ†«æ†­",
    9,
    "æ†¸",
    5,
    "æ†¿æ‡€æ‡æ‡ƒ",
    4,
    "æ‡‰æ‡Œ",
    4,
    "æ‡“æ‡•",
    16,
    "æ‡§",
    13,
    "æ‡¶",
    8,
    "æˆ€",
    5,
    "æˆ‡æˆ‰æˆ“æˆ”æˆ™æˆœæˆæˆžæˆ æˆ£æˆ¦æˆ§æˆ¨æˆ©æˆ«æˆ­æˆ¯æˆ°æˆ±æˆ²æˆµæˆ¶æˆ¸",
    4,
    "æ‰‚æ‰„æ‰…æ‰†æ‰Š"
  ],
  [
    "9240",
    "æ‰æ‰æ‰•æ‰–æ‰—æ‰™æ‰šæ‰œ",
    6,
    "æ‰¤æ‰¥æ‰¨æ‰±æ‰²æ‰´æ‰µæ‰·æ‰¸æ‰ºæ‰»æ‰½æŠæŠ‚æŠƒæŠ…æŠ†æŠ‡æŠˆæŠ‹",
    5,
    "æŠ”æŠ™æŠœæŠæŠžæŠ£æŠ¦æŠ§æŠ©æŠªæŠ­æŠ®æŠ¯æŠ°æŠ²æŠ³æŠ´æŠ¶æŠ·æŠ¸æŠºæŠ¾æ‹€æ‹"
  ],
  [
    "9280",
    "æ‹ƒæ‹‹æ‹æ‹‘æ‹•æ‹æ‹žæ‹ æ‹¡æ‹¤æ‹ªæ‹«æ‹°æ‹²æ‹µæ‹¸æ‹¹æ‹ºæ‹»æŒ€æŒƒæŒ„æŒ…æŒ†æŒŠæŒ‹æŒŒæŒæŒæŒæŒ’æŒ“æŒ”æŒ•æŒ—æŒ˜æŒ™æŒœæŒ¦æŒ§æŒ©æŒ¬æŒ­æŒ®æŒ°æŒ±æŒ³",
    5,
    "æŒ»æŒ¼æŒ¾æŒ¿æ€ææ„æ‡æˆæŠæ‘æ’æ“æ”æ–",
    7,
    "æ æ¤æ¥æ¦æ¨æªæ«æ¬æ¯æ°æ²æ³æ´æµæ¸æ¹æ¼æ½æ¾æ¿æŽæŽƒæŽ„æŽ…æŽ†æŽ‹æŽæŽ‘æŽ“æŽ”æŽ•æŽ—æŽ™",
    6,
    "æŽ¡æŽ¤æŽ¦æŽ«æŽ¯æŽ±æŽ²æŽµæŽ¶æŽ¹æŽ»æŽ½æŽ¿æ€"
  ],
  [
    "9340",
    "ææ‚æƒæ…æ‡æˆæŠæ‹æŒæ‘æ“æ”æ•æ—",
    6,
    "æŸæ¢æ¤",
    4,
    "æ«æ¬æ®æ¯æ°æ±æ³æµæ·æ¹æºæ»æ¼æ¾æƒæ„æ†",
    4,
    "ææŽæ‘æ’æ•",
    5,
    "ææŸæ¢æ£æ¤"
  ],
  [
    "9380",
    "æ¥æ§æ¨æ©æ«æ®",
    5,
    "æµ",
    4,
    "æ»æ¼æ¾æ‘€æ‘‚æ‘ƒæ‘‰æ‘‹",
    6,
    "æ‘“æ‘•æ‘–æ‘—æ‘™",
    4,
    "æ‘Ÿ",
    7,
    "æ‘¨æ‘ªæ‘«æ‘¬æ‘®",
    9,
    "æ‘»",
    6,
    "æ’ƒæ’†æ’ˆ",
    8,
    "æ’“æ’”æ’—æ’˜æ’šæ’›æ’œæ’æ’Ÿ",
    4,
    "æ’¥æ’¦æ’§æ’¨æ’ªæ’«æ’¯æ’±æ’²æ’³æ’´æ’¶æ’¹æ’»æ’½æ’¾æ’¿æ“æ“ƒæ“„æ“†",
    6,
    "æ“æ“‘æ““æ“”æ“•æ“–æ“™æ“š"
  ],
  [
    "9440",
    "æ“›æ“œæ“æ“Ÿæ“ æ“¡æ“£æ“¥æ“§",
    24,
    "æ”",
    7,
    "æ”Š",
    7,
    "æ”“",
    4,
    "æ”™",
    8
  ],
  [
    "9480",
    "æ”¢æ”£æ”¤æ”¦",
    4,
    "æ”¬æ”­æ”°æ”±æ”²æ”³æ”·æ”ºæ”¼æ”½æ•€",
    4,
    "æ•†æ•‡æ•Šæ•‹æ•æ•Žæ•æ•’æ•“æ•”æ•—æ•˜æ•šæ•œæ•Ÿæ• æ•¡æ•¤æ•¥æ•§æ•¨æ•©æ•ªæ•­æ•®æ•¯æ•±æ•³æ•µæ•¶æ•¸",
    14,
    "æ–ˆæ–‰æ–Šæ–æ–Žæ–æ–’æ–”æ–•æ––æ–˜æ–šæ–æ–žæ– æ–¢æ–£æ–¦æ–¨æ–ªæ–¬æ–®æ–±",
    7,
    "æ–ºæ–»æ–¾æ–¿æ—€æ—‚æ—‡æ—ˆæ—‰æ—Šæ—æ—æ—‘æ—“æ—”æ—•æ—˜",
    7,
    "æ—¡æ—£æ—¤æ—ªæ—«"
  ],
  [
    "9540",
    "æ—²æ—³æ—´æ—µæ—¸æ—¹æ—»",
    4,
    "æ˜æ˜„æ˜…æ˜‡æ˜ˆæ˜‰æ˜‹æ˜æ˜æ˜‘æ˜’æ˜–æ˜—æ˜˜æ˜šæ˜›æ˜œæ˜žæ˜¡æ˜¢æ˜£æ˜¤æ˜¦æ˜©æ˜ªæ˜«æ˜¬æ˜®æ˜°æ˜²æ˜³æ˜·",
    4,
    "æ˜½æ˜¿æ™€æ™‚æ™„",
    6,
    "æ™æ™Žæ™æ™‘æ™˜"
  ],
  [
    "9580",
    "æ™™æ™›æ™œæ™æ™žæ™ æ™¢æ™£æ™¥æ™§æ™©",
    4,
    "æ™±æ™²æ™³æ™µæ™¸æ™¹æ™»æ™¼æ™½æ™¿æš€æšæšƒæš…æš†æšˆæš‰æšŠæš‹æšæšŽæšæšæš’æš“æš”æš•æš˜",
    4,
    "æšž",
    8,
    "æš©",
    4,
    "æš¯",
    4,
    "æšµæš¶æš·æš¸æšºæš»æš¼æš½æš¿",
    25,
    "æ›šæ›ž",
    7,
    "æ›§æ›¨æ›ª",
    5,
    "æ›±æ›µæ›¶æ›¸æ›ºæ›»æ›½æœæœ‚æœƒ"
  ],
  [
    "9640",
    "æœ„æœ…æœ†æœ‡æœŒæœŽæœæœ‘æœ’æœ“æœ–æœ˜æœ™æœšæœœæœžæœ ",
    5,
    "æœ§æœ©æœ®æœ°æœ²æœ³æœ¶æœ·æœ¸æœ¹æœ»æœ¼æœ¾æœ¿ææ„æ…æ‡æŠæ‹ææ’æ”æ•æ—",
    4,
    "ææ¢æ£æ¤æ¦æ§æ«æ¬æ®æ±æ´æ¶"
  ],
  [
    "9680",
    "æ¸æ¹æºæ»æ½æž€æž‚æžƒæž…æž†æžˆæžŠæžŒæžæžŽæžæž‘æž’æž“æž”æž–æž™æž›æžŸæž æž¡æž¤æž¦æž©æž¬æž®æž±æž²æž´æž¹",
    7,
    "æŸ‚æŸ…",
    9,
    "æŸ•æŸ–æŸ—æŸ›æŸŸæŸ¡æŸ£æŸ¤æŸ¦æŸ§æŸ¨æŸªæŸ«æŸ­æŸ®æŸ²æŸµ",
    7,
    "æŸ¾æ æ ‚æ ƒæ „æ †æ æ æ ’æ ”æ •æ ˜",
    4,
    "æ žæ Ÿæ  æ ¢",
    6,
    "æ «",
    6,
    "æ ´æ µæ ¶æ ºæ »æ ¿æ¡‡æ¡‹æ¡æ¡æ¡’æ¡–",
    5
  ],
  [
    "9740",
    "æ¡œæ¡æ¡žæ¡Ÿæ¡ªæ¡¬",
    7,
    "æ¡µæ¡¸",
    8,
    "æ¢‚æ¢„æ¢‡",
    7,
    "æ¢æ¢‘æ¢’æ¢”æ¢•æ¢–æ¢˜",
    9,
    "æ¢£æ¢¤æ¢¥æ¢©æ¢ªæ¢«æ¢¬æ¢®æ¢±æ¢²æ¢´æ¢¶æ¢·æ¢¸"
  ],
  [
    "9780",
    "æ¢¹",
    6,
    "æ£æ£ƒ",
    5,
    "æ£Šæ£Œæ£Žæ£æ£æ£‘æ£“æ£”æ£–æ£—æ£™æ£›",
    4,
    "æ£¡æ£¢æ£¤",
    9,
    "æ£¯æ£²æ£³æ£´æ£¶æ£·æ£¸æ£»æ£½æ£¾æ£¿æ¤€æ¤‚æ¤ƒæ¤„æ¤†",
    4,
    "æ¤Œæ¤æ¤‘æ¤“",
    11,
    "æ¤¡æ¤¢æ¤£æ¤¥",
    7,
    "æ¤®æ¤¯æ¤±æ¤²æ¤³æ¤µæ¤¶æ¤·æ¤¸æ¤ºæ¤»æ¤¼æ¤¾æ¥€æ¥æ¥ƒ",
    16,
    "æ¥•æ¥–æ¥˜æ¥™æ¥›æ¥œæ¥Ÿ"
  ],
  [
    "9840",
    "æ¥¡æ¥¢æ¥¤æ¥¥æ¥§æ¥¨æ¥©æ¥ªæ¥¬æ¥­æ¥¯æ¥°æ¥²",
    4,
    "æ¥ºæ¥»æ¥½æ¥¾æ¥¿æ¦æ¦ƒæ¦…æ¦Šæ¦‹æ¦Œæ¦Ž",
    5,
    "æ¦–æ¦—æ¦™æ¦šæ¦",
    9,
    "æ¦©æ¦ªæ¦¬æ¦®æ¦¯æ¦°æ¦²æ¦³æ¦µæ¦¶æ¦¸æ¦¹æ¦ºæ¦¼æ¦½"
  ],
  [
    "9880",
    "æ¦¾æ¦¿æ§€æ§‚",
    7,
    "æ§‹æ§æ§æ§‘æ§’æ§“æ§•",
    5,
    "æ§œæ§æ§žæ§¡",
    11,
    "æ§®æ§¯æ§°æ§±æ§³",
    9,
    "æ§¾æ¨€",
    9,
    "æ¨‹",
    11,
    "æ¨™",
    5,
    "æ¨ æ¨¢",
    5,
    "æ¨©æ¨«æ¨¬æ¨­æ¨®æ¨°æ¨²æ¨³æ¨´æ¨¶",
    6,
    "æ¨¿",
    4,
    "æ©…æ©†æ©ˆ",
    7,
    "æ©‘",
    6,
    "æ©š"
  ],
  [
    "9940",
    "æ©œ",
    4,
    "æ©¢æ©£æ©¤æ©¦",
    10,
    "æ©²",
    6,
    "æ©ºæ©»æ©½æ©¾æ©¿æªæª‚æªƒæª…",
    8,
    "æªæª’",
    4,
    "æª˜",
    7,
    "æª¡",
    5
  ],
  [
    "9980",
    "æª§æª¨æªªæª­",
    114,
    "æ¬¥æ¬¦æ¬¨",
    6
  ],
  [
    "9a40",
    "æ¬¯æ¬°æ¬±æ¬³æ¬´æ¬µæ¬¶æ¬¸æ¬»æ¬¼æ¬½æ¬¿æ­€æ­æ­‚æ­„æ­…æ­ˆæ­Šæ­‹æ­",
    11,
    "æ­š",
    7,
    "æ­¨æ­©æ­«",
    13,
    "æ­ºæ­½æ­¾æ­¿æ®€æ®…æ®ˆ"
  ],
  [
    "9a80",
    "æ®Œæ®Žæ®æ®æ®‘æ®”æ®•æ®—æ®˜æ®™æ®œ",
    4,
    "æ®¢",
    7,
    "æ®«",
    7,
    "æ®¶æ®¸",
    6,
    "æ¯€æ¯ƒæ¯„æ¯†",
    4,
    "æ¯Œæ¯Žæ¯æ¯‘æ¯˜æ¯šæ¯œ",
    4,
    "æ¯¢",
    7,
    "æ¯¬æ¯­æ¯®æ¯°æ¯±æ¯²æ¯´æ¯¶æ¯·æ¯¸æ¯ºæ¯»æ¯¼æ¯¾",
    6,
    "æ°ˆ",
    4,
    "æ°Žæ°’æ°—æ°œæ°æ°žæ° æ°£æ°¥æ°«æ°¬æ°­æ°±æ°³æ°¶æ°·æ°¹æ°ºæ°»æ°¼æ°¾æ°¿æ±ƒæ±„æ±…æ±ˆæ±‹",
    4,
    "æ±‘æ±’æ±“æ±–æ±˜"
  ],
  [
    "9b40",
    "æ±™æ±šæ±¢æ±£æ±¥æ±¦æ±§æ±«",
    4,
    "æ±±æ±³æ±µæ±·æ±¸æ±ºæ±»æ±¼æ±¿æ²€æ²„æ²‡æ²Šæ²‹æ²æ²Žæ²‘æ²’æ²•æ²–æ²—æ²˜æ²šæ²œæ²æ²žæ² æ²¢æ²¨æ²¬æ²¯æ²°æ²´æ²µæ²¶æ²·æ²ºæ³€æ³æ³‚æ³ƒæ³†æ³‡æ³ˆæ³‹æ³æ³Žæ³æ³‘æ³’æ³˜"
  ],
  [
    "9b80",
    "æ³™æ³šæ³œæ³æ³Ÿæ³¤æ³¦æ³§æ³©æ³¬æ³­æ³²æ³´æ³¹æ³¿æ´€æ´‚æ´ƒæ´…æ´†æ´ˆæ´‰æ´Šæ´æ´æ´æ´‘æ´“æ´”æ´•æ´–æ´˜æ´œæ´æ´Ÿ",
    5,
    "æ´¦æ´¨æ´©æ´¬æ´­æ´¯æ´°æ´´æ´¶æ´·æ´¸æ´ºæ´¿æµ€æµ‚æµ„æµ‰æµŒæµæµ•æµ–æµ—æµ˜æµ›æµæµŸæµ¡æµ¢æµ¤æµ¥æµ§æµ¨æµ«æµ¬æµ­æµ°æµ±æµ²æµ³æµµæµ¶æµ¹æµºæµ»æµ½",
    4,
    "æ¶ƒæ¶„æ¶†æ¶‡æ¶Šæ¶‹æ¶æ¶æ¶æ¶’æ¶–",
    4,
    "æ¶œæ¶¢æ¶¥æ¶¬æ¶­æ¶°æ¶±æ¶³æ¶´æ¶¶æ¶·æ¶¹",
    5,
    "æ·æ·‚æ·ƒæ·ˆæ·‰æ·Š"
  ],
  [
    "9c40",
    "æ·æ·Žæ·æ·æ·’æ·“æ·”æ·•æ·—æ·šæ·›æ·œæ·Ÿæ·¢æ·£æ·¥æ·§æ·¨æ·©æ·ªæ·­æ·¯æ·°æ·²æ·´æ·µæ·¶æ·¸æ·ºæ·½",
    7,
    "æ¸†æ¸‡æ¸ˆæ¸‰æ¸‹æ¸æ¸’æ¸“æ¸•æ¸˜æ¸™æ¸›æ¸œæ¸žæ¸Ÿæ¸¢æ¸¦æ¸§æ¸¨æ¸ªæ¸¬æ¸®æ¸°æ¸±æ¸³æ¸µ"
  ],
  [
    "9c80",
    "æ¸¶æ¸·æ¸¹æ¸»",
    7,
    "æ¹…",
    7,
    "æ¹æ¹æ¹‘æ¹’æ¹•æ¹—æ¹™æ¹šæ¹œæ¹æ¹žæ¹ ",
    10,
    "æ¹¬æ¹­æ¹¯",
    14,
    "æº€æºæº‚æº„æº‡æºˆæºŠ",
    4,
    "æº‘",
    6,
    "æº™æºšæº›æºæºžæº æº¡æº£æº¤æº¦æº¨æº©æº«æº¬æº­æº®æº°æº³æºµæº¸æº¹æº¼æº¾æº¿æ»€æ»ƒæ»„æ»…æ»†æ»ˆæ»‰æ»Šæ»Œæ»æ»Žæ»æ»’æ»–æ»˜æ»™æ»›æ»œæ»æ»£æ»§æ»ª",
    5
  ],
  [
    "9d40",
    "æ»°æ»±æ»²æ»³æ»µæ»¶æ»·æ»¸æ»º",
    7,
    "æ¼ƒæ¼„æ¼…æ¼‡æ¼ˆæ¼Š",
    4,
    "æ¼æ¼‘æ¼’æ¼–",
    9,
    "æ¼¡æ¼¢æ¼£æ¼¥æ¼¦æ¼§æ¼¨æ¼¬æ¼®æ¼°æ¼²æ¼´æ¼µæ¼·",
    6,
    "æ¼¿æ½€æ½æ½‚"
  ],
  [
    "9d80",
    "æ½ƒæ½„æ½…æ½ˆæ½‰æ½Šæ½Œæ½Ž",
    9,
    "æ½™æ½šæ½›æ½æ½Ÿæ½ æ½¡æ½£æ½¤æ½¥æ½§",
    5,
    "æ½¯æ½°æ½±æ½³æ½µæ½¶æ½·æ½¹æ½»æ½½",
    6,
    "æ¾…æ¾†æ¾‡æ¾Šæ¾‹æ¾",
    12,
    "æ¾æ¾žæ¾Ÿæ¾ æ¾¢",
    4,
    "æ¾¨",
    10,
    "æ¾´æ¾µæ¾·æ¾¸æ¾º",
    5,
    "æ¿æ¿ƒ",
    5,
    "æ¿Š",
    6,
    "æ¿“",
    10,
    "æ¿Ÿæ¿¢æ¿£æ¿¤æ¿¥"
  ],
  [
    "9e40",
    "æ¿¦",
    7,
    "æ¿°",
    32,
    "ç€’",
    7,
    "ç€œ",
    6,
    "ç€¤",
    6
  ],
  [
    "9e80",
    "ç€«",
    9,
    "ç€¶ç€·ç€¸ç€º",
    17,
    "ççŽç",
    13,
    "çŸ",
    11,
    "ç®ç±ç²ç³ç´ç·ç¹çºç»ç½ç‚ç‚‚ç‚ƒç‚„ç‚†ç‚‡ç‚ˆç‚‹ç‚Œç‚ç‚ç‚ç‚‘ç‚“ç‚—ç‚˜ç‚šç‚›ç‚ž",
    12,
    "ç‚°ç‚²ç‚´ç‚µç‚¶ç‚ºç‚¾ç‚¿çƒ„çƒ…çƒ†çƒ‡çƒ‰çƒ‹",
    12,
    "çƒš"
  ],
  [
    "9f40",
    "çƒœçƒçƒžçƒ çƒ¡çƒ¢çƒ£çƒ¥çƒªçƒ®çƒ°",
    6,
    "çƒ¸çƒºçƒ»çƒ¼çƒ¾",
    10,
    "ç„‹",
    4,
    "ç„‘ç„’ç„”ç„—ç„›",
    10,
    "ç„§",
    7,
    "ç„²ç„³ç„´"
  ],
  [
    "9f80",
    "ç„µç„·",
    13,
    "ç…†ç…‡ç…ˆç…‰ç…‹ç…ç…",
    12,
    "ç…ç…Ÿ",
    4,
    "ç…¥ç…©",
    4,
    "ç…¯ç…°ç…±ç…´ç…µç…¶ç…·ç…¹ç…»ç…¼ç…¾",
    5,
    "ç†…",
    4,
    "ç†‹ç†Œç†ç†Žç†ç†‘ç†’ç†“ç†•ç†–ç†—ç†š",
    4,
    "ç†¡",
    6,
    "ç†©ç†ªç†«ç†­",
    5,
    "ç†´ç†¶ç†·ç†¸ç†º",
    8,
    "ç‡„",
    9,
    "ç‡",
    4
  ],
  [
    "a040",
    "ç‡–",
    9,
    "ç‡¡ç‡¢ç‡£ç‡¤ç‡¦ç‡¨",
    5,
    "ç‡¯",
    9,
    "ç‡º",
    11,
    "çˆ‡",
    19
  ],
  [
    "a080",
    "çˆ›çˆœçˆž",
    9,
    "çˆ©çˆ«çˆ­çˆ®çˆ¯çˆ²çˆ³çˆ´çˆºçˆ¼çˆ¾ç‰€",
    6,
    "ç‰‰ç‰Šç‰‹ç‰Žç‰ç‰ç‰‘ç‰“ç‰”ç‰•ç‰—ç‰˜ç‰šç‰œç‰žç‰ ç‰£ç‰¤ç‰¥ç‰¨ç‰ªç‰«ç‰¬ç‰­ç‰°ç‰±ç‰³ç‰´ç‰¶ç‰·ç‰¸ç‰»ç‰¼ç‰½çŠ‚çŠƒçŠ…",
    4,
    "çŠŒçŠŽçŠçŠ‘çŠ“",
    11,
    "çŠ ",
    11,
    "çŠ®çŠ±çŠ²çŠ³çŠµçŠº",
    6,
    "ç‹…ç‹†ç‹‡ç‹‰ç‹Šç‹‹ç‹Œç‹ç‹‘ç‹“ç‹”ç‹•ç‹–ç‹˜ç‹šç‹›"
  ],
  [
    "a1a1",
    "ã€€ã€ã€‚Â·Ë‰Ë‡Â¨ã€ƒã€…â€”ï½žâ€–â€¦â€˜â€™â€œâ€ã€”ã€•ã€ˆ",
    7,
    "ã€–ã€—ã€ã€‘Â±Ã—Ã·âˆ¶âˆ§âˆ¨âˆ‘âˆâˆªâˆ©âˆˆâˆ·âˆšâŠ¥âˆ¥âˆ âŒ’âŠ™âˆ«âˆ®â‰¡â‰Œâ‰ˆâˆ½âˆâ‰ â‰®â‰¯â‰¤â‰¥âˆžâˆµâˆ´â™‚â™€Â°â€²â€³â„ƒï¼„Â¤ï¿ ï¿¡â€°Â§â„–â˜†â˜…â—‹â—â—Žâ—‡â—†â–¡â– â–³â–²â€»â†’â†â†‘â†“ã€“"
  ],
  [
    "a2a1",
    "â…°",
    9
  ],
  [
    "a2b1",
    "â’ˆ",
    19,
    "â‘´",
    19,
    "â‘ ",
    9
  ],
  [
    "a2e5",
    "ãˆ ",
    9
  ],
  [
    "a2f1",
    "â… ",
    11
  ],
  [
    "a3a1",
    "ï¼ï¼‚ï¼ƒï¿¥ï¼…",
    88,
    "ï¿£"
  ],
  [
    "a4a1",
    "ã",
    82
  ],
  [
    "a5a1",
    "ã‚¡",
    85
  ],
  [
    "a6a1",
    "Î‘",
    16,
    "Î£",
    6
  ],
  [
    "a6c1",
    "Î±",
    16,
    "Ïƒ",
    6
  ],
  [
    "a6e0",
    "ï¸µï¸¶ï¸¹ï¸ºï¸¿ï¹€ï¸½ï¸¾ï¹ï¹‚ï¹ƒï¹„"
  ],
  [
    "a6ee",
    "ï¸»ï¸¼ï¸·ï¸¸ï¸±"
  ],
  [
    "a6f4",
    "ï¸³ï¸´"
  ],
  [
    "a7a1",
    "Ð",
    5,
    "ÐÐ–",
    25
  ],
  [
    "a7d1",
    "Ð°",
    5,
    "Ñ‘Ð¶",
    25
  ],
  [
    "a840",
    "ËŠË‹Ë™â€“â€•â€¥â€µâ„…â„‰â†–â†—â†˜â†™âˆ•âˆŸâˆ£â‰’â‰¦â‰§âŠ¿â•",
    35,
    "â–",
    6
  ],
  [
    "a880",
    "â–ˆ",
    7,
    "â–“â–”â–•â–¼â–½â—¢â—£â—¤â—¥â˜‰âŠ•ã€’ã€ã€ž"
  ],
  [
    "a8a1",
    "ÄÃ¡ÇŽÃ Ä“Ã©Ä›Ã¨Ä«Ã­ÇÃ¬ÅÃ³Ç’Ã²Å«ÃºÇ”Ã¹Ç–Ç˜ÇšÇœÃ¼ÃªÉ‘"
  ],
  [
    "a8bd",
    "Å„Åˆ"
  ],
  [
    "a8c0",
    "É¡"
  ],
  [
    "a8c5",
    "ã„…",
    36
  ],
  [
    "a940",
    "ã€¡",
    8,
    "ãŠ£ãŽŽãŽãŽœãŽãŽžãŽ¡ã„ãŽã‘ã’ã•ï¸°ï¿¢ï¿¤"
  ],
  [
    "a959",
    "â„¡ãˆ±"
  ],
  [
    "a95c",
    "â€"
  ],
  [
    "a960",
    "ãƒ¼ã‚›ã‚œãƒ½ãƒ¾ã€†ã‚ã‚žï¹‰",
    9,
    "ï¹”ï¹•ï¹–ï¹—ï¹™",
    8
  ],
  [
    "a980",
    "ï¹¢",
    4,
    "ï¹¨ï¹©ï¹ªï¹«"
  ],
  [
    "a996",
    "ã€‡"
  ],
  [
    "a9a4",
    "â”€",
    75
  ],
  [
    "aa40",
    "ç‹œç‹ç‹Ÿç‹¢",
    5,
    "ç‹ªç‹«ç‹µç‹¶ç‹¹ç‹½ç‹¾ç‹¿çŒ€çŒ‚çŒ„",
    5,
    "çŒ‹çŒŒçŒçŒçŒçŒ‘çŒ’çŒ”çŒ˜çŒ™çŒšçŒŸçŒ çŒ£çŒ¤çŒ¦çŒ§çŒ¨çŒ­çŒ¯çŒ°çŒ²çŒ³çŒµçŒ¶çŒºçŒ»çŒ¼çŒ½ç€",
    8
  ],
  [
    "aa80",
    "ç‰çŠç‹çŒçŽçç‘ç“ç”ç•ç–ç˜",
    7,
    "ç¡",
    10,
    "ç®ç°ç±"
  ],
  [
    "ab40",
    "ç²",
    11,
    "ç¿",
    4,
    "çŽ…çŽ†çŽˆçŽŠçŽŒçŽçŽçŽçŽ’çŽ“çŽ”çŽ•çŽ—çŽ˜çŽ™çŽšçŽœçŽçŽžçŽ çŽ¡çŽ£",
    5,
    "çŽªçŽ¬çŽ­çŽ±çŽ´çŽµçŽ¶çŽ¸çŽ¹çŽ¼çŽ½çŽ¾çŽ¿ççƒ",
    4
  ],
  [
    "ab80",
    "ç‹çŒçŽç’",
    6,
    "çšç›çœççŸç¡ç¢ç£ç¤ç¦ç¨çªç«ç¬ç®ç¯ç°ç±ç³",
    4
  ],
  [
    "ac40",
    "ç¸",
    10,
    "ç„ç‡çˆç‹çŒççŽç‘",
    8,
    "çœ",
    5,
    "ç£ç¤ç§ç©ç«ç­ç¯ç±ç²ç·",
    4,
    "ç½ç¾ç¿ç‘€ç‘‚",
    11
  ],
  [
    "ac80",
    "ç‘Ž",
    6,
    "ç‘–ç‘˜ç‘ç‘ ",
    12,
    "ç‘®ç‘¯ç‘±",
    4,
    "ç‘¸ç‘¹ç‘º"
  ],
  [
    "ad40",
    "ç‘»ç‘¼ç‘½ç‘¿ç’‚ç’„ç’…ç’†ç’ˆç’‰ç’Šç’Œç’ç’ç’‘",
    10,
    "ç’ç’Ÿ",
    7,
    "ç’ª",
    15,
    "ç’»",
    12
  ],
  [
    "ad80",
    "ç“ˆ",
    9,
    "ç““",
    8,
    "ç“ç“Ÿç“¡ç“¥ç“§",
    6,
    "ç“°ç“±ç“²"
  ],
  [
    "ae40",
    "ç“³ç“µç“¸",
    6,
    "ç”€ç”ç”‚ç”ƒç”…",
    7,
    "ç”Žç”ç”’ç””ç”•ç”–ç”—ç”›ç”ç”žç” ",
    4,
    "ç”¦ç”§ç”ªç”®ç”´ç”¶ç”¹ç”¼ç”½ç”¿ç•ç•‚ç•ƒç•„ç•†ç•‡ç•‰ç•Šç•ç•ç•‘ç•’ç•“ç••ç•–ç•—ç•˜"
  ],
  [
    "ae80",
    "ç•",
    7,
    "ç•§ç•¨ç•©ç•«",
    6,
    "ç•³ç•µç•¶ç•·ç•º",
    4,
    "ç–€ç–ç–‚ç–„ç–…ç–‡"
  ],
  [
    "af40",
    "ç–ˆç–‰ç–Šç–Œç–ç–Žç–ç–“ç–•ç–˜ç–›ç–œç–žç–¢ç–¦",
    4,
    "ç–­ç–¶ç–·ç–ºç–»ç–¿ç—€ç—ç—†ç—‹ç—Œç—Žç—ç—ç—‘ç—“ç——ç—™ç—šç—œç—ç—Ÿç— ç—¡ç—¥ç—©ç—¬ç—­ç—®ç—¯ç—²ç—³ç—µç—¶ç—·ç—¸ç—ºç—»ç—½ç—¾ç˜‚ç˜„ç˜†ç˜‡"
  ],
  [
    "af80",
    "ç˜ˆç˜‰ç˜‹ç˜ç˜Žç˜ç˜‘ç˜’ç˜“ç˜”ç˜–ç˜šç˜œç˜ç˜žç˜¡ç˜£ç˜§ç˜¨ç˜¬ç˜®ç˜¯ç˜±ç˜²ç˜¶ç˜·ç˜¹ç˜ºç˜»ç˜½ç™ç™‚ç™„"
  ],
  [
    "b040",
    "ç™…",
    6,
    "ç™Ž",
    5,
    "ç™•ç™—",
    4,
    "ç™ç™Ÿç™ ç™¡ç™¢ç™¤",
    6,
    "ç™¬ç™­ç™®ç™°",
    7,
    "ç™¹ç™ºç™¼ç™¿çš€çšçšƒçš…çš‰çšŠçšŒçšçšçšçš’çš”çš•çš—çš˜çššçš›"
  ],
  [
    "b080",
    "çšœ",
    7,
    "çš¥",
    8,
    "çš¯çš°çš³çšµ",
    9,
    "ç›€ç›ç›ƒå•Šé˜¿åŸƒæŒ¨å“Žå”‰å“€çš‘ç™Œè”¼çŸ®è‰¾ç¢çˆ±éš˜éžæ°¨å®‰ä¿ºæŒ‰æš—å²¸èƒºæ¡ˆè‚®æ˜‚ç›Žå‡¹æ•–ç†¬ç¿±è¢„å‚²å¥¥æ‡Šæ¾³èŠ­æŒæ‰’å­å§ç¬†å…«ç–¤å·´æ‹”è·‹é¶æŠŠè€™åéœ¸ç½¢çˆ¸ç™½æŸç™¾æ‘†ä½°è´¥æ‹œç¨—æ–‘ç­æ¬æ‰³èˆ¬é¢æ¿ç‰ˆæ‰®æ‹Œä¼´ç“£åŠåŠžç»Šé‚¦å¸®æ¢†æ¦œè†€ç»‘æ£’ç£…èšŒé•‘å‚è°¤è‹žèƒžåŒ…è¤’å‰¥"
  ],
  [
    "b140",
    "ç›„ç›‡ç›‰ç›‹ç›Œç›“ç›•ç›™ç›šç›œç›ç›žç› ",
    4,
    "ç›¦",
    7,
    "ç›°ç›³ç›µç›¶ç›·ç›ºç›»ç›½ç›¿çœ€çœ‚çœƒçœ…çœ†çœŠçœŒçœŽ",
    10,
    "çœ›çœœçœçœžçœ¡çœ£çœ¤çœ¥çœ§çœªçœ«"
  ],
  [
    "b180",
    "çœ¬çœ®çœ°",
    4,
    "çœ¹çœ»çœ½çœ¾çœ¿ç‚ç„ç…ç†çˆ",
    7,
    "ç’",
    7,
    "çœè–„é›¹ä¿å ¡é¥±å®æŠ±æŠ¥æš´è±¹é²çˆ†æ¯ç¢‘æ‚²å‘åŒ—è¾ˆèƒŒè´é’¡å€ç‹ˆå¤‡æƒ«ç„™è¢«å¥”è‹¯æœ¬ç¬¨å´©ç»·ç”­æ³µè¹¦è¿¸é€¼é¼»æ¯”é„™ç¬”å½¼ç¢§è“–è”½æ¯•æ¯™æ¯–å¸åº‡ç—¹é—­æ•å¼Šå¿…è¾Ÿå£è‡‚é¿é™›éž­è¾¹ç¼–è´¬æ‰ä¾¿å˜åžè¾¨è¾©è¾«éæ ‡å½ªè†˜è¡¨é³–æ†‹åˆ«ç˜ªå½¬æ–Œæ¿’æ»¨å®¾æ‘ˆå…µå†°æŸ„ä¸™ç§‰é¥¼ç‚³"
  ],
  [
    "b240",
    "ççžçŸç ç¤ç§ç©çªç­",
    11,
    "çºç»ç¼çžçž‚çžƒçž†",
    5,
    "çžçžçž“",
    11,
    "çž¡çž£çž¤çž¦çž¨çž«çž­çž®çž¯çž±çž²çž´çž¶",
    4
  ],
  [
    "b280",
    "çž¼çž¾çŸ€",
    12,
    "çŸŽ",
    8,
    "çŸ˜çŸ™çŸšçŸ",
    4,
    "çŸ¤ç—…å¹¶çŽ»è æ’­æ‹¨é’µæ³¢åšå‹ƒæé“‚ç®”ä¼¯å¸›èˆ¶è„–è†Šæ¸¤æ³Šé©³æ•åœå“ºè¡¥åŸ ä¸å¸ƒæ­¥ç°¿éƒ¨æ€–æ“¦çŒœè£ææ‰è´¢ç¬è¸©é‡‡å½©èœè”¡é¤å‚èš•æ®‹æƒ­æƒ¨ç¿è‹èˆ±ä»“æ²§è—æ“ç³™æ§½æ›¹è‰åŽ•ç­–ä¾§å†Œæµ‹å±‚è¹­æ’å‰èŒ¬èŒ¶æŸ¥ç¢´æ½å¯Ÿå²”å·®è¯§æ‹†æŸ´è±ºæ€æŽºè‰é¦‹è°—ç¼ é“²äº§é˜é¢¤æ˜ŒçŒ–"
  ],
  [
    "b340",
    "çŸ¦çŸ¨çŸªçŸ¯çŸ°çŸ±çŸ²çŸ´çŸµçŸ·çŸ¹çŸºçŸ»çŸ¼ç ƒ",
    5,
    "ç Šç ‹ç Žç ç ç “ç •ç ™ç ›ç žç  ç ¡ç ¢ç ¤ç ¨ç ªç «ç ®ç ¯ç ±ç ²ç ³ç µç ¶ç ½ç ¿ç¡ç¡‚ç¡ƒç¡„ç¡†ç¡ˆç¡‰ç¡Šç¡‹ç¡ç¡ç¡‘ç¡“ç¡”ç¡˜ç¡™ç¡š"
  ],
  [
    "b380",
    "ç¡›ç¡œç¡ž",
    11,
    "ç¡¯",
    7,
    "ç¡¸ç¡¹ç¡ºç¡»ç¡½",
    6,
    "åœºå°å¸¸é•¿å¿è‚ åŽ‚æ•žç•…å”±å€¡è¶…æŠ„é’žæœå˜²æ½®å·¢åµç‚’è½¦æ‰¯æ’¤æŽ£å½»æ¾ˆéƒ´è‡£è¾°å°˜æ™¨å¿±æ²‰é™ˆè¶è¡¬æ’‘ç§°åŸŽæ©™æˆå‘ˆä¹˜ç¨‹æƒ©æ¾„è¯šæ‰¿é€žéª‹ç§¤åƒç—´æŒåŒ™æ± è¿Ÿå¼›é©°è€»é½¿ä¾ˆå°ºèµ¤ç¿…æ–¥ç‚½å……å†²è™«å´‡å® æŠ½é…¬ç•´è¸Œç¨ æ„ç­¹ä»‡ç»¸çž…ä¸‘è‡­åˆå‡ºæ©±åŽ¨èº‡é”„é›æ»é™¤æ¥š"
  ],
  [
    "b440",
    "ç¢„ç¢…ç¢†ç¢ˆç¢Šç¢‹ç¢ç¢ç¢’ç¢”ç¢•ç¢–ç¢™ç¢ç¢žç¢ ç¢¢ç¢¤ç¢¦ç¢¨",
    7,
    "ç¢µç¢¶ç¢·ç¢¸ç¢ºç¢»ç¢¼ç¢½ç¢¿ç£€ç£‚ç£ƒç£„ç£†ç£‡ç£ˆç£Œç£ç£Žç£ç£‘ç£’ç£“ç£–ç£—ç£˜ç£š",
    9
  ],
  [
    "b480",
    "ç£¤ç£¥ç£¦ç£§ç£©ç£ªç£«ç£­",
    4,
    "ç£³ç£µç£¶ç£¸ç£¹ç£»",
    5,
    "ç¤‚ç¤ƒç¤„ç¤†",
    6,
    "ç¡€å‚¨çŸ—æè§¦å¤„æ£å·ç©¿æ¤½ä¼ èˆ¹å–˜ä¸²ç–®çª—å¹¢åºŠé—¯åˆ›å¹ç‚Šæ¶é”¤åž‚æ˜¥æ¤¿é†‡å”‡æ·³çº¯è ¢æˆ³ç»°ç–µèŒ¨ç£é›Œè¾žæ…ˆç“·è¯æ­¤åˆºèµæ¬¡èªè‘±å›±åŒ†ä»Žä¸›å‡‘ç²—é†‹ç°‡ä¿ƒè¹¿ç¯¡çªœæ‘§å´”å‚¬è„†ç˜ç²¹æ·¬ç¿ æ‘å­˜å¯¸ç£‹æ’®æ“æŽªæŒ«é”™æ­è¾¾ç­”ç˜©æ‰“å¤§å‘†æ­¹å‚£æˆ´å¸¦æ®†ä»£è´·è¢‹å¾…é€®"
  ],
  [
    "b540",
    "ç¤",
    5,
    "ç¤”",
    9,
    "ç¤Ÿ",
    4,
    "ç¤¥",
    14,
    "ç¤µ",
    4,
    "ç¤½ç¤¿ç¥‚ç¥ƒç¥„ç¥…ç¥‡ç¥Š",
    8,
    "ç¥”ç¥•ç¥˜ç¥™ç¥¡ç¥£"
  ],
  [
    "b580",
    "ç¥¤ç¥¦ç¥©ç¥ªç¥«ç¥¬ç¥®ç¥°",
    6,
    "ç¥¹ç¥»",
    4,
    "ç¦‚ç¦ƒç¦†ç¦‡ç¦ˆç¦‰ç¦‹ç¦Œç¦ç¦Žç¦ç¦‘ç¦’æ€ è€½æ‹…ä¸¹å•éƒ¸æŽ¸èƒ†æ—¦æ°®ä½†æƒ®æ·¡è¯žå¼¹è›‹å½“æŒ¡å…šè¡æ¡£åˆ€æ£è¹ˆå€’å²›ç¥·å¯¼åˆ°ç¨»æ‚¼é“ç›—å¾·å¾—çš„è¹¬ç¯ç™»ç­‰çžªå‡³é‚“å ¤ä½Žæ»´è¿ªæ•Œç¬›ç‹„æ¶¤ç¿Ÿå«¡æŠµåº•åœ°è’‚ç¬¬å¸å¼Ÿé€’ç¼”é¢ æŽ‚æ»‡ç¢˜ç‚¹å…¸é›åž«ç”µä½ƒç”¸åº—æƒ¦å¥ æ·€æ®¿ç¢‰å¼é›•å‡‹åˆæŽ‰åŠé’“è°ƒè·Œçˆ¹ç¢Ÿè¶è¿­è°å "
  ],
  [
    "b640",
    "ç¦“",
    6,
    "ç¦›",
    11,
    "ç¦¨",
    10,
    "ç¦´",
    4,
    "ç¦¼ç¦¿ç§‚ç§„ç§…ç§‡ç§ˆç§Šç§Œç§Žç§ç§ç§“ç§”ç§–ç§—ç§™",
    5,
    "ç§ ç§¡ç§¢ç§¥ç§¨ç§ª"
  ],
  [
    "b680",
    "ç§¬ç§®ç§±",
    6,
    "ç§¹ç§ºç§¼ç§¾ç§¿ç¨ç¨„ç¨…ç¨‡ç¨ˆç¨‰ç¨Šç¨Œç¨",
    4,
    "ç¨•ç¨–ç¨˜ç¨™ç¨›ç¨œä¸ç›¯å®é’‰é¡¶é¼Žé”­å®šè®¢ä¸¢ä¸œå†¬è‘£æ‡‚åŠ¨æ ‹ä¾—æ«å†»æ´žå…œæŠ–æ–—é™¡è±†é€—ç—˜éƒ½ç£æ¯’çŠŠç‹¬è¯»å µç¹èµŒæœé•€è‚šåº¦æ¸¡å¦’ç«¯çŸ­é”»æ®µæ–­ç¼Žå †å…‘é˜Ÿå¯¹å¢©å¨è¹²æ•¦é¡¿å›¤é’ç›¾éæŽ‡å“†å¤šå¤ºåž›èº²æœµè·ºèˆµå‰æƒ°å •è›¾å³¨é¹…ä¿„é¢è®¹å¨¥æ¶åŽ„æ‰¼éé„‚é¥¿æ©è€Œå„¿è€³å°”é¥µæ´±äºŒ"
  ],
  [
    "b740",
    "ç¨ç¨Ÿç¨¡ç¨¢ç¨¤",
    14,
    "ç¨´ç¨µç¨¶ç¨¸ç¨ºç¨¾ç©€",
    5,
    "ç©‡",
    9,
    "ç©’",
    4,
    "ç©˜",
    16
  ],
  [
    "b780",
    "ç©©",
    6,
    "ç©±ç©²ç©³ç©µç©»ç©¼ç©½ç©¾çª‚çª…çª‡çª‰çªŠçª‹çªŒçªŽçªçªçª“çª”çª™çªšçª›çªžçª¡çª¢è´°å‘ç½šç­ä¼ä¹é˜€æ³•çè—©å¸†ç•ªç¿»æ¨ŠçŸ¾é’’ç¹å‡¡çƒ¦åè¿”èŒƒè´©çŠ¯é¥­æ³›åŠèŠ³æ–¹è‚ªæˆ¿é˜²å¦¨ä»¿è®¿çººæ”¾è²éžå•¡é£žè‚¥åŒªè¯½å è‚ºåºŸæ²¸è´¹èŠ¬é…šå©æ°›åˆ†çº·åŸç„šæ±¾ç²‰å¥‹ä»½å¿¿æ„¤ç²ªä¸°å°æž«èœ‚å³°é”‹é£Žç–¯çƒ½é€¢å†¯ç¼è®½å¥‰å‡¤ä½›å¦å¤«æ•·è‚¤å­µæ‰¶æ‹‚è¾å¹…æ°Ÿç¬¦ä¼ä¿˜æœ"
  ],
  [
    "b840",
    "çª£çª¤çª§çª©çªªçª«çª®",
    4,
    "çª´",
    10,
    "ç«€",
    10,
    "ç«Œ",
    9,
    "ç«—ç«˜ç«šç«›ç«œç«ç«¡ç«¢ç«¤ç«§",
    5,
    "ç«®ç«°ç«±ç«²ç«³"
  ],
  [
    "b880",
    "ç«´",
    4,
    "ç«»ç«¼ç«¾ç¬€ç¬ç¬‚ç¬…ç¬‡ç¬‰ç¬Œç¬ç¬Žç¬ç¬’ç¬“ç¬–ç¬—ç¬˜ç¬šç¬œç¬ç¬Ÿç¬¡ç¬¢ç¬£ç¬§ç¬©ç¬­æµ®æ¶ªç¦è¢±å¼—ç”«æŠšè¾…ä¿¯é‡œæ–§è„¯è…‘åºœè…èµ´å‰¯è¦†èµ‹å¤å‚…ä»˜é˜œçˆ¶è…¹è´Ÿå¯Œè®£é™„å¦‡ç¼šå’å™¶å˜Žè¯¥æ”¹æ¦‚é’™ç›–æº‰å¹²ç”˜æ†æŸ‘ç«¿è‚èµ¶æ„Ÿç§†æ•¢èµ£å†ˆåˆšé’¢ç¼¸è‚›çº²å²—æ¸¯æ ç¯™çš‹é«˜è†ç¾”ç³•æžé•ç¨¿å‘Šå“¥æ­Œææˆˆé¸½èƒ³ç–™å‰²é©è‘›æ ¼è›¤é˜éš”é“¬ä¸ªå„ç»™æ ¹è·Ÿè€•æ›´åºšç¾¹"
  ],
  [
    "b940",
    "ç¬¯ç¬°ç¬²ç¬´ç¬µç¬¶ç¬·ç¬¹ç¬»ç¬½ç¬¿",
    5,
    "ç­†ç­ˆç­Šç­ç­Žç­“ç­•ç­—ç­™ç­œç­žç­Ÿç­¡ç­£",
    10,
    "ç­¯ç­°ç­³ç­´ç­¶ç­¸ç­ºç­¼ç­½ç­¿ç®ç®‚ç®ƒç®„ç®†",
    6,
    "ç®Žç®"
  ],
  [
    "b980",
    "ç®‘ç®’ç®“ç®–ç®˜ç®™ç®šç®›ç®žç®Ÿç® ç®£ç®¤ç®¥ç®®ç®¯ç®°ç®²ç®³ç®µç®¶ç®·ç®¹",
    7,
    "ç¯‚ç¯ƒç¯„åŸ‚è€¿æ¢—å·¥æ”»åŠŸæ­é¾šä¾›èº¬å…¬å®«å¼“å·©æ±žæ‹±è´¡å…±é’©å‹¾æ²Ÿè‹Ÿç‹—åž¢æž„è´­å¤Ÿè¾œè‡å’•ç®ä¼°æ²½å­¤å§‘é¼“å¤è›Šéª¨è°·è‚¡æ•…é¡¾å›ºé›‡åˆ®ç“œå‰å¯¡æŒ‚è¤‚ä¹–æ‹æ€ªæ£ºå…³å®˜å† è§‚ç®¡é¦†ç½æƒ¯çŒè´¯å…‰å¹¿é€›ç‘°è§„åœ­ç¡…å½’é¾Ÿé—ºè½¨é¬¼è¯¡ç™¸æ¡‚æŸœè·ªè´µåˆ½è¾Šæ»šæ£é”…éƒ­å›½æžœè£¹è¿‡å“ˆ"
  ],
  [
    "ba40",
    "ç¯…ç¯ˆç¯‰ç¯Šç¯‹ç¯ç¯Žç¯ç¯ç¯’ç¯”",
    4,
    "ç¯›ç¯œç¯žç¯Ÿç¯ ç¯¢ç¯£ç¯¤ç¯§ç¯¨ç¯©ç¯«ç¯¬ç¯­ç¯¯ç¯°ç¯²",
    4,
    "ç¯¸ç¯¹ç¯ºç¯»ç¯½ç¯¿",
    7,
    "ç°ˆç°‰ç°Šç°ç°Žç°",
    5,
    "ç°—ç°˜ç°™"
  ],
  [
    "ba80",
    "ç°š",
    4,
    "ç° ",
    5,
    "ç°¨ç°©ç°«",
    12,
    "ç°¹",
    5,
    "ç±‚éª¸å­©æµ·æ°¦äº¥å®³éª‡é…£æ†¨é‚¯éŸ©å«æ¶µå¯’å‡½å–Šç½•ç¿°æ’¼ææ—±æ†¾æ‚ç„Šæ±—æ±‰å¤¯æ­èˆªå£•åšŽè±ªæ¯«éƒå¥½è€—å·æµ©å‘µå–è·èæ ¸ç¦¾å’Œä½•åˆç›’è²‰é˜‚æ²³æ¶¸èµ«è¤é¹¤è´ºå˜¿é»‘ç—•å¾ˆç‹ æ¨å“¼äº¨æ¨ªè¡¡æ’è½°å“„çƒ˜è™¹é¸¿æ´ªå®å¼˜çº¢å–‰ä¾¯çŒ´å¼åŽšå€™åŽå‘¼ä¹Žå¿½ç‘šå£¶è‘«èƒ¡è´ç‹ç³Šæ¹–"
  ],
  [
    "bb40",
    "ç±ƒ",
    9,
    "ç±Ž",
    36,
    "ç±µ",
    5,
    "ç±¾",
    9
  ],
  [
    "bb80",
    "ç²ˆç²Š",
    6,
    "ç²“ç²”ç²–ç²™ç²šç²›ç² ç²¡ç²£ç²¦ç²§ç²¨ç²©ç²«ç²¬ç²­ç²¯ç²°ç²´",
    4,
    "ç²ºç²»å¼§è™Žå”¬æŠ¤äº’æ²ªæˆ·èŠ±å“—åŽçŒ¾æ»‘ç”»åˆ’åŒ–è¯æ§å¾Šæ€€æ·®åæ¬¢çŽ¯æ¡“è¿˜ç¼“æ¢æ‚£å”¤ç—ªè±¢ç„•æ¶£å®¦å¹»è’æ…Œé»„ç£ºè—ç°§çš‡å‡°æƒ¶ç…Œæ™ƒå¹Œæè°Žç°æŒ¥è¾‰å¾½æ¢è›”å›žæ¯æ‚”æ…§å‰æƒ æ™¦è´¿ç§½ä¼šçƒ©æ±‡è®³è¯²ç»˜è¤æ˜å©šé­‚æµ‘æ··è±æ´»ä¼™ç«èŽ·æˆ–æƒ‘éœè´§ç¥¸å‡»åœ¾åŸºæœºç•¸ç¨½ç§¯ç®•"
  ],
  [
    "bc40",
    "ç²¿ç³€ç³‚ç³ƒç³„ç³†ç³‰ç³‹ç³Ž",
    6,
    "ç³˜ç³šç³›ç³ç³žç³¡",
    6,
    "ç³©",
    5,
    "ç³°",
    7,
    "ç³¹ç³ºç³¼",
    13,
    "ç´‹",
    5
  ],
  [
    "bc80",
    "ç´‘",
    14,
    "ç´¡ç´£ç´¤ç´¥ç´¦ç´¨ç´©ç´ªç´¬ç´­ç´®ç´°",
    6,
    "è‚Œé¥¥è¿¹æ¿€è®¥é¸¡å§¬ç»©ç¼‰å‰æžæ£˜è¾‘ç±é›†åŠæ€¥ç–¾æ±²å³å«‰çº§æŒ¤å‡ è„Šå·±è“ŸæŠ€å†€å­£ä¼Žç¥­å‰‚æ‚¸æµŽå¯„å¯‚è®¡è®°æ—¢å¿Œé™…å¦“ç»§çºªå˜‰æž·å¤¹ä½³å®¶åŠ èšé¢Šè´¾ç”²é’¾å‡ç¨¼ä»·æž¶é©¾å«æ­¼ç›‘åšå°–ç¬ºé—´ç…Žå…¼è‚©è‰°å¥¸ç¼„èŒ§æ£€æŸ¬ç¢±ç¡·æ‹£æ¡ç®€ä¿­å‰ªå‡èæ§›é‰´è·µè´±è§é”®ç®­ä»¶"
  ],
  [
    "bd40",
    "ç´·",
    54,
    "çµ¯",
    7
  ],
  [
    "bd80",
    "çµ¸",
    32,
    "å¥èˆ°å‰‘é¥¯æ¸æº…æ¶§å»ºåƒµå§œå°†æµ†æ±Ÿç–†è’‹æ¡¨å¥–è®²åŒ é…±é™è•‰æ¤’ç¤ç„¦èƒ¶äº¤éƒŠæµ‡éª„å¨‡åš¼æ…é“°çŸ«ä¾¥è„šç‹¡è§’é¥ºç¼´ç»žå‰¿æ•™é…µè½¿è¾ƒå«çª–æ­æŽ¥çš†ç§¸è¡—é˜¶æˆªåŠ«èŠ‚æ¡”æ°æ·ç«ç«­æ´ç»“è§£å§æˆ’è—‰èŠ¥ç•Œå€Ÿä»‹ç–¥è¯«å±Šå·¾ç­‹æ–¤é‡‘ä»Šæ´¥è¥Ÿç´§é”¦ä»…è°¨è¿›é³æ™‹ç¦è¿‘çƒ¬æµ¸"
  ],
  [
    "be40",
    "ç¶™",
    12,
    "ç¶§",
    6,
    "ç¶¯",
    42
  ],
  [
    "be80",
    "ç·š",
    32,
    "å°½åŠ²è†å…¢èŒŽç›æ™¶é²¸äº¬æƒŠç²¾ç²³ç»äº•è­¦æ™¯é¢ˆé™å¢ƒæ•¬é•œå¾„ç—‰é–ç«Ÿç«žå‡€ç‚¯çª˜æªç©¶çº çŽ–éŸ­ä¹…ç¸ä¹é…’åŽ©æ•‘æ—§è‡¼èˆ…å’Žå°±ç–šéž æ‹˜ç‹™ç–½å±…é©¹èŠå±€å’€çŸ©ä¸¾æ²®èšæ‹’æ®å·¨å…·è·è¸žé”¯ä¿±å¥æƒ§ç‚¬å‰§æé¹ƒå¨Ÿå€¦çœ·å·ç»¢æ’…æ”«æŠ‰æŽ˜å€”çˆµè§‰å†³è¯€ç»å‡èŒé’§å†›å›å³»"
  ],
  [
    "bf40",
    "ç·»",
    62
  ],
  [
    "bf80",
    "ç¸ºç¸¼",
    4,
    "ç¹‚",
    4,
    "ç¹ˆ",
    21,
    "ä¿Šç«£æµšéƒ¡éªå–€å’–å¡å’¯å¼€æ©æ¥·å‡¯æ…¨åˆŠå ªå‹˜åŽç çœ‹åº·æ…·ç³ æ‰›æŠ—äº¢ç‚•è€ƒæ‹·çƒ¤é å·è‹›æŸ¯æ£µç£•é¢—ç§‘å£³å’³å¯æ¸´å…‹åˆ»å®¢è¯¾è‚¯å•ƒåž¦æ³å‘å­ç©ºæå­”æŽ§æŠ å£æ‰£å¯‡æž¯å“­çªŸè‹¦é…·åº“è£¤å¤¸åž®æŒŽè·¨èƒ¯å—ç­·ä¾©å¿«å®½æ¬¾åŒ¡ç­ç‹‚æ¡†çŸ¿çœ¶æ—·å†µäºç›”å²¿çª¥è‘µå¥Žé­å‚€"
  ],
  [
    "c040",
    "ç¹ž",
    35,
    "çºƒ",
    23,
    "çºœçºçºž"
  ],
  [
    "c080",
    "çº®çº´çº»çº¼ç»–ç»¤ç»¬ç»¹ç¼Šç¼ç¼žç¼·ç¼¹ç¼»",
    6,
    "ç½ƒç½†",
    9,
    "ç½’ç½“é¦ˆæ„§æºƒå¤æ˜†æ†å›°æ‹¬æ‰©å»“é˜”åžƒæ‹‰å–‡èœ¡è…Šè¾£å•¦èŽ±æ¥èµ–è“å©ªæ æ‹¦ç¯®é˜‘å…°æ¾œè°°æ½è§ˆæ‡’ç¼†çƒ‚æ»¥ç…æ¦”ç‹¼å»ŠéƒŽæœ—æµªæžåŠ³ç‰¢è€ä½¬å§¥é…ªçƒ™æ¶å‹’ä¹é›·é•­è•¾ç£Šç´¯å„¡åž’æ“‚è‚‹ç±»æ³ªæ£±æ¥žå†·åŽ˜æ¢¨çŠé»Žç¯±ç‹¸ç¦»æ¼“ç†æŽé‡Œé²¤ç¤¼èŽ‰è”åæ —ä¸½åŽ‰åŠ±ç ¾åŽ†åˆ©å‚ˆä¾‹ä¿"
  ],
  [
    "c140",
    "ç½–ç½™ç½›ç½œç½ç½žç½ ç½£",
    4,
    "ç½«ç½¬ç½­ç½¯ç½°ç½³ç½µç½¶ç½·ç½¸ç½ºç½»ç½¼ç½½ç½¿ç¾€ç¾‚",
    7,
    "ç¾‹ç¾ç¾",
    4,
    "ç¾•",
    4,
    "ç¾›ç¾œç¾ ç¾¢ç¾£ç¾¥ç¾¦ç¾¨",
    6,
    "ç¾±"
  ],
  [
    "c180",
    "ç¾³",
    4,
    "ç¾ºç¾»ç¾¾ç¿€ç¿‚ç¿ƒç¿„ç¿†ç¿‡ç¿ˆç¿‰ç¿‹ç¿ç¿",
    4,
    "ç¿–ç¿—ç¿™",
    5,
    "ç¿¢ç¿£ç—¢ç«‹ç²’æ²¥éš¶åŠ›ç’ƒå“©ä¿©è”èŽ²è¿žé•°å»‰æ€œæ¶Ÿå¸˜æ•›è„¸é“¾æ‹ç‚¼ç»ƒç²®å‡‰æ¢ç²±è‰¯ä¸¤è¾†é‡æ™¾äº®è°…æ’©èŠåƒšç–—ç‡Žå¯¥è¾½æ½¦äº†æ’‚é•£å»–æ–™åˆ—è£‚çƒˆåŠ£çŒŽç³æž—ç£·éœ–ä¸´é‚»é³žæ·‹å‡›èµåæ‹ŽçŽ²è±é›¶é¾„é“ƒä¼¶ç¾šå‡Œçµé™µå²­é¢†å¦ä»¤æºœç‰æ¦´ç¡«é¦ç•™åˆ˜ç˜¤æµæŸ³å…­é¾™è‹å’™ç¬¼çª¿"
  ],
  [
    "c240",
    "ç¿¤ç¿§ç¿¨ç¿ªç¿«ç¿¬ç¿­ç¿¯ç¿²ç¿´",
    6,
    "ç¿½ç¿¾ç¿¿è€‚è€‡è€ˆè€‰è€Šè€Žè€è€‘è€“è€šè€›è€è€žè€Ÿè€¡è€£è€¤è€«",
    5,
    "è€²è€´è€¹è€ºè€¼è€¾è€èè„è…è‡èˆè‰èŽèèè‘è“è•è–è—"
  ],
  [
    "c280",
    "è™è›",
    13,
    "è«",
    5,
    "è²",
    11,
    "éš†åž„æ‹¢é™‡æ¥¼å¨„æ‚ç¯“æ¼é™‹èŠ¦å¢é¢…åºç‚‰æŽ³å¤è™é²éº“ç¢Œéœ²è·¯èµ‚é¹¿æ½žç¦„å½•é™†æˆ®é©´å•é“ä¾£æ—…å±¥å±¡ç¼•è™‘æ°¯å¾‹çŽ‡æ»¤ç»¿å³¦æŒ›å­ªæ»¦åµä¹±æŽ ç•¥æŠ¡è½®ä¼¦ä»‘æ²¦çº¶è®ºèèžºç½—é€»é”£ç®©éª¡è£¸è½æ´›éª†ç»œå¦ˆéº»çŽ›ç èš‚é©¬éª‚å˜›å—åŸ‹ä¹°éº¦å–è¿ˆè„‰çž’é¦’è›®æ»¡è”“æ›¼æ…¢æ¼«"
  ],
  [
    "c340",
    "è¾è‚è‚‚è‚…è‚ˆè‚Šè‚",
    5,
    "è‚”è‚•è‚—è‚™è‚žè‚£è‚¦è‚§è‚¨è‚¬è‚°è‚³è‚µè‚¶è‚¸è‚¹è‚»èƒ…èƒ‡",
    4,
    "èƒ",
    6,
    "èƒ˜èƒŸèƒ èƒ¢èƒ£èƒ¦èƒ®èƒµèƒ·èƒ¹èƒ»èƒ¾èƒ¿è„€è„è„ƒè„„è„…è„‡è„ˆè„‹"
  ],
  [
    "c380",
    "è„Œè„•è„—è„™è„›è„œè„è„Ÿ",
    12,
    "è„­è„®è„°è„³è„´è„µè„·è„¹",
    4,
    "è„¿è°©èŠ’èŒ«ç›²æ°“å¿™èŽ½çŒ«èŒ…é”šæ¯›çŸ›é“†å¯èŒ‚å†’å¸½è²Œè´¸ä¹ˆçŽ«æžšæ¢…é…¶éœ‰ç…¤æ²¡çœ‰åª’é•æ¯ç¾Žæ˜§å¯å¦¹åªšé—¨é—·ä»¬èŒè’™æª¬ç›Ÿé”°çŒ›æ¢¦å­Ÿçœ¯é†šé¡ç³œè¿·è°œå¼¥ç±³ç§˜è§…æ³Œèœœå¯†å¹‚æ£‰çœ ç»µå†•å…å‹‰å¨©ç¼…é¢è‹—æçž„è—ç§’æ¸ºåº™å¦™è”‘ç­æ°‘æŠ¿çš¿æ•æ‚¯é—½æ˜ŽèžŸé¸£é“­åå‘½è°¬æ‘¸"
  ],
  [
    "c440",
    "è…€",
    5,
    "è…‡è…‰è…è…Žè…è…’è…–è…—è…˜è…›",
    4,
    "è…¡è…¢è…£è…¤è…¦è…¨è…ªè…«è…¬è…¯è…²è…³è…µè…¶è…·è…¸è†è†ƒ",
    4,
    "è†‰è†‹è†Œè†è†Žè†è†’",
    5,
    "è†™è†šè†ž",
    4,
    "è†¤è†¥"
  ],
  [
    "c480",
    "è†§è†©è†«",
    7,
    "è†´",
    5,
    "è†¼è†½è†¾è†¿è‡„è‡…è‡‡è‡ˆè‡‰è‡‹è‡",
    6,
    "æ‘¹è˜‘æ¨¡è†œç£¨æ‘©é­”æŠ¹æœ«èŽ«å¢¨é»˜æ²«æ¼ å¯žé™Œè°‹ç‰ŸæŸæ‹‡ç‰¡äº©å§†æ¯å¢“æš®å¹•å‹Ÿæ…•æœ¨ç›®ç¦ç‰§ç©†æ‹¿å“ªå‘é’ é‚£å¨œçº³æ°–ä¹ƒå¥¶è€å¥ˆå—ç”·éš¾å›ŠæŒ è„‘æ¼é—¹æ·–å‘¢é¦å†…å«©èƒ½å¦®éœ“å€ªæ³¥å°¼æ‹Ÿä½ åŒ¿è…»é€†æººè”«æ‹ˆå¹´ç¢¾æ’µæ»å¿µå¨˜é…¿é¸Ÿå°¿æè‚å­½å•®é•Šé•æ¶…æ‚¨æŸ ç‹žå‡å®"
  ],
  [
    "c540",
    "è‡”",
    14,
    "è‡¤è‡¥è‡¦è‡¨è‡©è‡«è‡®",
    4,
    "è‡µ",
    5,
    "è‡½è‡¿èˆƒèˆ‡",
    4,
    "èˆŽèˆèˆ‘èˆ“èˆ•",
    5,
    "èˆèˆ èˆ¤èˆ¥èˆ¦èˆ§èˆ©èˆ®èˆ²èˆºèˆ¼èˆ½èˆ¿"
  ],
  [
    "c580",
    "è‰€è‰è‰‚è‰ƒè‰…è‰†è‰ˆè‰Šè‰Œè‰è‰Žè‰",
    7,
    "è‰™è‰›è‰œè‰è‰žè‰ ",
    7,
    "è‰©æ‹§æ³žç‰›æ‰­é’®çº½è„“æµ“å†œå¼„å¥´åŠªæ€’å¥³æš–è™ç–ŸæŒªæ‡¦ç³¯è¯ºå“¦æ¬§é¸¥æ®´è—•å‘•å¶æ²¤å•ªè¶´çˆ¬å¸•æ€•ç¶æ‹æŽ’ç‰Œå¾˜æ¹ƒæ´¾æ”€æ½˜ç›˜ç£ç›¼ç•”åˆ¤å›ä¹“åºžæ—è€ªèƒ–æŠ›å’†åˆ¨ç‚®è¢è·‘æ³¡å‘¸èƒšåŸ¹è£´èµ”é™ªé…ä½©æ²›å–·ç›†ç °æŠ¨çƒ¹æ¾Žå½­è“¬æ£šç¡¼ç¯·è†¨æœ‹é¹æ§ç¢°å¯ç ’éœ¹æ‰¹æŠ«åŠˆçµæ¯—"
  ],
  [
    "c640",
    "è‰ªè‰«è‰¬è‰­è‰±è‰µè‰¶è‰·è‰¸è‰»è‰¼èŠ€èŠèŠƒèŠ…èŠ†èŠ‡èŠ‰èŠŒèŠèŠ“èŠ”èŠ•èŠ–èŠšèŠ›èŠžèŠ èŠ¢èŠ£èŠ§èŠ²èŠµèŠ¶èŠºèŠ»èŠ¼èŠ¿è‹€è‹‚è‹ƒè‹…è‹†è‹‰è‹è‹–è‹™è‹šè‹è‹¢è‹§è‹¨è‹©è‹ªè‹¬è‹­è‹®è‹°è‹²è‹³è‹µè‹¶è‹¸"
  ],
  [
    "c680",
    "è‹ºè‹¼",
    4,
    "èŒŠèŒ‹èŒèŒèŒ’èŒ“èŒ–èŒ˜èŒ™èŒ",
    9,
    "èŒ©èŒªèŒ®èŒ°èŒ²èŒ·èŒ»èŒ½å•¤è„¾ç–²çš®åŒ¹ç—žåƒ»å±è­¬ç¯‡åç‰‡éª—é£˜æ¼‚ç“¢ç¥¨æ’‡çž¥æ‹¼é¢‘è´«å“è˜ä¹’åªè‹¹èå¹³å‡­ç“¶è¯„å±å¡æ³¼é¢‡å©†ç ´é­„è¿«ç²•å‰–æ‰‘é“ºä»†èŽ†è‘¡è©è’²åŸ”æœ´åœƒæ™®æµ¦è°±æ›ç€‘æœŸæ¬ºæ –æˆšå¦»ä¸ƒå‡„æ¼†æŸ’æ²å…¶æ£‹å¥‡æ­§ç•¦å´Žè„é½æ——ç¥ˆç¥éª‘èµ·å²‚ä¹žä¼å¯å¥‘ç Œå™¨æ°”è¿„å¼ƒæ±½æ³£è®«æŽ"
  ],
  [
    "c740",
    "èŒ¾èŒ¿èè‚è„è…èˆèŠ",
    4,
    "è“è•",
    4,
    "èè¢è°",
    6,
    "è¹èºè¾",
    6,
    "èŽ‡èŽˆèŽŠèŽ‹èŽŒèŽèŽèŽèŽ‘èŽ”èŽ•èŽ–èŽ—èŽ™èŽšèŽèŽŸèŽ¡",
    6,
    "èŽ¬èŽ­èŽ®"
  ],
  [
    "c780",
    "èŽ¯èŽµèŽ»èŽ¾èŽ¿è‚èƒè„è†èˆè‰è‹èèŽèè‘è’è“è•è—è™èšè›èžè¢è£è¤è¦è§è¨è«è¬è­æ°æ´½ç‰µæ‰¦é’Žé“…åƒè¿ç­¾ä»Ÿè°¦ä¹¾é»”é’±é’³å‰æ½œé£æµ…è°´å ‘åµŒæ¬ æ­‰æžªå‘›è…”ç¾Œå¢™è”·å¼ºæŠ¢æ©‡é”¹æ•²æ‚„æ¡¥çž§ä¹”ä¾¨å·§éž˜æ’¬ç¿˜å³­ä¿çªåˆ‡èŒ„ä¸”æ€¯çªƒé’¦ä¾µäº²ç§¦ç´å‹¤èŠ¹æ“’ç¦½å¯æ²é’è½»æ°¢å€¾å¿æ¸…æ“Žæ™´æ°°æƒ…é¡·è¯·åº†ç¼ç©·ç§‹ä¸˜é‚±çƒæ±‚å›šé…‹æ³…è¶‹åŒºè›†æ›²èº¯å±ˆé©±æ¸ "
  ],
  [
    "c840",
    "è®è¯è³",
    4,
    "èºè»è¼è¾è¿è€è‚è…è‡èˆè‰èŠèè’",
    5,
    "è™èšè›èž",
    5,
    "è©",
    7,
    "è²",
    5,
    "è¹èºè»è¾",
    7,
    "è‘‡è‘ˆè‘‰"
  ],
  [
    "c880",
    "è‘Š",
    6,
    "è‘’",
    4,
    "è‘˜è‘è‘žè‘Ÿè‘ è‘¢è‘¤",
    4,
    "è‘ªè‘®è‘¯è‘°è‘²è‘´è‘·è‘¹è‘»è‘¼å–å¨¶é¾‹è¶£åŽ»åœˆé¢§æƒé†›æ³‰å…¨ç—Šæ‹³çŠ¬åˆ¸åŠç¼ºç‚”ç˜¸å´é¹Šæ¦·ç¡®é›€è£™ç¾¤ç„¶ç‡ƒå†‰æŸ“ç“¤å£¤æ”˜åš·è®©é¥¶æ‰°ç»•æƒ¹çƒ­å£¬ä»äººå¿éŸ§ä»»è®¤åˆƒå¦Šçº«æ‰”ä»æ—¥æˆŽèŒ¸è“‰è£èžç†”æº¶å®¹ç»’å†—æ‰æŸ”è‚‰èŒ¹è •å„’å­ºå¦‚è¾±ä¹³æ±å…¥è¤¥è½¯é˜®è•Šç‘žé”é—°æ¶¦è‹¥å¼±æ’’æ´’è¨è…®é³ƒå¡žèµ›ä¸‰å"
  ],
  [
    "c940",
    "è‘½",
    4,
    "è’ƒè’„è’…è’†è’Šè’è’",
    7,
    "è’˜è’šè’›è’è’žè’Ÿè’ è’¢",
    12,
    "è’°è’±è’³è’µè’¶è’·è’»è’¼è’¾è“€è“‚è“ƒè“…è“†è“‡è“ˆè“‹è“Œè“Žè“è“’è“”è“•è“—"
  ],
  [
    "c980",
    "è“˜",
    4,
    "è“žè“¡è“¢è“¤è“§",
    4,
    "è“­è“®è“¯è“±",
    10,
    "è“½è“¾è”€è”è”‚ä¼žæ•£æ¡‘å—“ä¸§æ”éªšæ‰«å«‚ç‘Ÿè‰²æ¶©æ£®åƒ§èŽŽç ‚æ€åˆ¹æ²™çº±å‚»å•¥ç…žç­›æ™’çŠè‹«æ‰å±±åˆ ç…½è¡«é—ªé™•æ“…èµ¡è†³å–„æ±•æ‰‡ç¼®å¢’ä¼¤å•†èµæ™Œä¸Šå°šè£³æ¢¢æŽç¨çƒ§èŠå‹ºéŸ¶å°‘å“¨é‚µç»å¥¢èµŠè›‡èˆŒèˆèµ¦æ‘„å°„æ…‘æ¶‰ç¤¾è®¾ç ·ç”³å‘»ä¼¸èº«æ·±å¨ ç»…ç¥žæ²ˆå®¡å©¶ç”šè‚¾æ…Žæ¸—å£°ç”Ÿç”¥ç‰²å‡ç»³"
  ],
  [
    "ca40",
    "è”ƒ",
    8,
    "è”è”Žè”è”è”’è””è”•è”–è”˜è”™è”›è”œè”è”žè” è”¢",
    8,
    "è”­",
    9,
    "è”¾",
    4,
    "è•„è•…è•†è•‡è•‹",
    10
  ],
  [
    "ca80",
    "è•—è•˜è•šè•›è•œè•è•Ÿ",
    4,
    "è•¥è•¦è•§è•©",
    8,
    "è•³è•µè•¶è•·è•¸è•¼è•½è•¿è–€è–çœç››å‰©èƒœåœ£å¸ˆå¤±ç‹®æ–½æ¹¿è¯—å°¸è™±åçŸ³æ‹¾æ—¶ä»€é£Ÿèš€å®žè¯†å²çŸ¢ä½¿å±Žé©¶å§‹å¼ç¤ºå£«ä¸–æŸ¿äº‹æ‹­èª“é€åŠ¿æ˜¯å—œå™¬é€‚ä»•ä¾é‡Šé¥°æ°å¸‚æƒå®¤è§†è¯•æ”¶æ‰‹é¦–å®ˆå¯¿æŽˆå”®å—ç˜¦å…½è”¬æž¢æ¢³æ®ŠæŠ’è¾“å”èˆ’æ·‘ç–ä¹¦èµŽå­°ç†Ÿè–¯æš‘æ›™ç½²èœ€é»é¼ å±žæœ¯è¿°æ ‘æŸæˆç«–å¢…åº¶æ•°æ¼±"
  ],
  [
    "cb40",
    "è–‚è–ƒè–†è–ˆ",
    6,
    "è–",
    10,
    "è–",
    6,
    "è–¥è–¦è–§è–©è–«è–¬è–­è–±",
    5,
    "è–¸è–º",
    6,
    "è—‚",
    6,
    "è—Š",
    4,
    "è—‘è—’"
  ],
  [
    "cb80",
    "è—”è—–",
    5,
    "è—",
    6,
    "è—¥è—¦è—§è—¨è—ª",
    14,
    "æ•åˆ·è€æ‘”è¡°ç”©å¸…æ “æ‹´éœœåŒçˆ½è°æ°´ç¡ç¨Žå®çž¬é¡ºèˆœè¯´ç¡•æœ”çƒæ–¯æ’•å˜¶æ€ç§å¸ä¸æ­»è‚†å¯ºå—£å››ä¼ºä¼¼é¥²å·³æ¾è€¸æ€‚é¢‚é€å®‹è®¼è¯µæœè‰˜æ“žå—½è‹é…¥ä¿—ç´ é€Ÿç²Ÿåƒ³å¡‘æº¯å®¿è¯‰è‚ƒé…¸è’œç®—è™½éš‹éšç»¥é«“ç¢Žå²ç©—é‚éš§ç¥Ÿå­™æŸç¬‹è“‘æ¢­å”†ç¼©çç´¢é”æ‰€å¡Œä»–å®ƒå¥¹å¡”"
  ],
  [
    "cc40",
    "è—¹è—ºè—¼è—½è—¾è˜€",
    4,
    "è˜†",
    10,
    "è˜’è˜“è˜”è˜•è˜—",
    15,
    "è˜¨è˜ª",
    13,
    "è˜¹è˜ºè˜»è˜½è˜¾è˜¿è™€"
  ],
  [
    "cc80",
    "è™",
    11,
    "è™’è™“è™•",
    4,
    "è™›è™œè™è™Ÿè™ è™¡è™£",
    7,
    "ç­æŒžè¹‹è¸èƒŽè‹”æŠ¬å°æ³°é…žå¤ªæ€æ±°åæ‘Šè´ªç˜«æ»©å›æª€ç—°æ½­è°­è°ˆå¦æ¯¯è¢’ç¢³æŽ¢å¹ç‚­æ±¤å¡˜æªå ‚æ£ è†›å”ç³–å€˜èººæ·Œè¶Ÿçƒ«æŽæ¶›æ»”ç»¦è„æ¡ƒé€ƒæ·˜é™¶è®¨å¥—ç‰¹è—¤è…¾ç–¼èªŠæ¢¯å‰”è¸¢é”‘æé¢˜è¹„å•¼ä½“æ›¿åšæƒ•æ¶•å‰ƒå±‰å¤©æ·»å¡«ç”°ç”œæ¬èˆ”è…†æŒ‘æ¡è¿¢çœºè·³è´´é“å¸–åŽ…å¬çƒƒ"
  ],
  [
    "cd40",
    "è™­è™¯è™°è™²",
    6,
    "èšƒ",
    6,
    "èšŽ",
    4,
    "èš”èš–",
    5,
    "èšž",
    4,
    "èš¥èš¦èš«èš­èš®èš²èš³èš·èš¸èš¹èš»",
    4,
    "è›è›‚è›ƒè›…è›ˆè›Œè›è›’è›“è›•è›–è›—è›šè›œ"
  ],
  [
    "cd80",
    "è›è› è›¡è›¢è›£è›¥è›¦è›§è›¨è›ªè›«è›¬è›¯è›µè›¶è›·è›ºè›»è›¼è›½è›¿èœèœ„èœ…èœ†èœ‹èœŒèœŽèœèœèœ‘èœ”èœ–æ±€å»·åœäº­åº­æŒºè‰‡é€šæ¡é…®çž³åŒé“œå½¤ç«¥æ¡¶æ…ç­’ç»Ÿç—›å·æŠ•å¤´é€å‡¸ç§ƒçªå›¾å¾’é€”æ¶‚å± åœŸåå…”æ¹å›¢æŽ¨é¢“è…¿èœ•è¤ªé€€åžå±¯è‡€æ‹–æ‰˜è„±é¸µé™€é©®é©¼æ¤­å¦¥æ‹“å”¾æŒ–å“‡è›™æ´¼å¨ƒç“¦è¢œæ­ªå¤–è±Œå¼¯æ¹¾çŽ©é¡½ä¸¸çƒ·å®Œç¢—æŒ½æ™šçš–æƒ‹å®›å©‰ä¸‡è…•æ±ªçŽ‹äº¡æž‰ç½‘å¾€æ—ºæœ›å¿˜å¦„å¨"
  ],
  [
    "ce40",
    "èœ™èœ›èœèœŸèœ èœ¤èœ¦èœ§èœ¨èœªèœ«èœ¬èœ­èœ¯èœ°èœ²èœ³èœµèœ¶èœ¸èœ¹èœºèœ¼èœ½è€",
    6,
    "èŠè‹èèèè‘è’è”è•è–è˜èš",
    5,
    "è¡è¢è¦",
    7,
    "è¯è±è²è³èµ"
  ],
  [
    "ce80",
    "è·è¸è¹èºè¿èž€èžèž„èž†èž‡èž‰èžŠèžŒèžŽ",
    4,
    "èž”èž•èž–èž˜",
    6,
    "èž ",
    4,
    "å·å¾®å±éŸ¦è¿æ¡…å›´å”¯æƒŸä¸ºæ½ç»´è‹‡èŽå§”ä¼Ÿä¼ªå°¾çº¬æœªè”šå‘³ç•èƒƒå–‚é­ä½æ¸­è°“å°‰æ…°å«ç˜Ÿæ¸©èšŠæ–‡é—»çº¹å»ç¨³ç´Šé—®å—¡ç¿ç“®æŒèœ—æ¶¡çªæˆ‘æ–¡å§æ¡æ²ƒå·«å‘œé’¨ä¹Œæ±¡è¯¬å±‹æ— èŠœæ¢§å¾å´æ¯‹æ­¦äº”æ‚åˆèˆžä¼ä¾®åžæˆŠé›¾æ™¤ç‰©å‹¿åŠ¡æ‚Ÿè¯¯æ˜”ç†™æžè¥¿ç¡’çŸ½æ™°å˜»å¸é”¡ç‰º"
  ],
  [
    "cf40",
    "èž¥èž¦èž§èž©èžªèž®èž°èž±èž²èž´èž¶èž·èž¸èž¹èž»èž¼èž¾èž¿èŸ",
    4,
    "èŸ‡èŸˆèŸ‰èŸŒ",
    4,
    "èŸ”",
    6,
    "èŸœèŸèŸžèŸŸèŸ¡èŸ¢èŸ£èŸ¤èŸ¦èŸ§èŸ¨èŸ©èŸ«èŸ¬èŸ­èŸ¯",
    9
  ],
  [
    "cf80",
    "èŸºèŸ»èŸ¼èŸ½èŸ¿è €è è ‚è „",
    5,
    "è ‹",
    7,
    "è ”è —è ˜è ™è šè œ",
    4,
    "è £ç¨€æ¯å¸Œæ‚‰è†å¤•æƒœç†„çƒ¯æºªæ±çŠ€æª„è¢­å¸­ä¹ åª³å–œé“£æ´—ç³»éš™æˆç»†çžŽè™¾åŒ£éœžè¾–æš‡å³¡ä¾ ç‹­ä¸‹åŽ¦å¤å“æŽ€é”¨å…ˆä»™é²œçº¤å’¸è´¤è¡”èˆ·é—²æ¶Žå¼¦å«Œæ˜¾é™©çŽ°çŒ®åŽ¿è…ºé¦…ç¾¡å®ªé™·é™çº¿ç›¸åŽ¢é•¶é¦™ç®±è¥„æ¹˜ä¹¡ç¿”ç¥¥è¯¦æƒ³å“äº«é¡¹å··æ©¡åƒå‘è±¡è§ç¡éœ„å‰Šå“®åš£é”€æ¶ˆå®µæ·†æ™“"
  ],
  [
    "d040",
    "è ¤",
    13,
    "è ³",
    5,
    "è ºè »è ½è ¾è ¿è¡è¡‚è¡ƒè¡†",
    5,
    "è¡Ž",
    5,
    "è¡•è¡–è¡˜è¡š",
    6,
    "è¡¦è¡§è¡ªè¡­è¡¯è¡±è¡³è¡´è¡µè¡¶è¡¸è¡¹è¡º"
  ],
  [
    "d080",
    "è¡»è¡¼è¢€è¢ƒè¢†è¢‡è¢‰è¢Šè¢Œè¢Žè¢è¢è¢‘è¢“è¢”è¢•è¢—",
    4,
    "è¢",
    4,
    "è¢£è¢¥",
    5,
    "å°å­æ ¡è‚–å•¸ç¬‘æ•ˆæ¥”äº›æ­‡èŽéž‹åæŒŸæºé‚ªæ–œèƒè°å†™æ¢°å¸èŸ¹æ‡ˆæ³„æ³»è°¢å±‘è–ªèŠ¯é”Œæ¬£è¾›æ–°å¿»å¿ƒä¿¡è¡…æ˜Ÿè…¥çŒ©æƒºå…´åˆ‘åž‹å½¢é‚¢è¡Œé†’å¹¸ææ€§å§“å…„å‡¶èƒ¸åŒˆæ±¹é›„ç†Šä¼‘ä¿®ç¾žæœ½å—…é”ˆç§€è¢–ç»£å¢ŸæˆŒéœ€è™šå˜˜é¡»å¾è®¸è“„é…—å™æ—­åºç•œæ¤çµ®å©¿ç»ªç»­è½©å–§å®£æ‚¬æ—‹çŽ„"
  ],
  [
    "d140",
    "è¢¬è¢®è¢¯è¢°è¢²",
    4,
    "è¢¸è¢¹è¢ºè¢»è¢½è¢¾è¢¿è£€è£ƒè£„è£‡è£ˆè£Šè£‹è£Œè£è£è£è£‘è£“è£–è£—è£š",
    4,
    "è£ è£¡è£¦è£§è£©",
    6,
    "è£²è£µè£¶è£·è£ºè£»è£½è£¿è¤€è¤è¤ƒ",
    5
  ],
  [
    "d180",
    "è¤‰è¤‹",
    4,
    "è¤‘è¤”",
    4,
    "è¤œ",
    4,
    "è¤¢è¤£è¤¤è¤¦è¤§è¤¨è¤©è¤¬è¤­è¤®è¤¯è¤±è¤²è¤³è¤µè¤·é€‰ç™£çœ©ç»šé´è–›å­¦ç©´é›ªè¡€å‹‹ç†å¾ªæ—¬è¯¢å¯»é©¯å·¡æ®‰æ±›è®­è®¯é€Šè¿…åŽ‹æŠ¼é¸¦é¸­å‘€ä¸«èŠ½ç‰™èšœå´–è¡™æ¶¯é›…å“‘äºšè®¶ç„‰å’½é˜‰çƒŸæ·¹ç›ä¸¥ç ”èœ’å²©å»¶è¨€é¢œé˜Žç‚Žæ²¿å¥„æŽ©çœ¼è¡æ¼”è‰³å °ç‡•åŽŒç šé›å”å½¦ç„°å®´è°šéªŒæ®ƒå¤®é¸¯ç§§æ¨æ‰¬ä½¯ç–¡ç¾Šæ´‹é˜³æ°§ä»°ç—’å…»æ ·æ¼¾é‚€è…°å¦–ç‘¶"
  ],
  [
    "d240",
    "è¤¸",
    8,
    "è¥‚è¥ƒè¥…",
    24,
    "è¥ ",
    5,
    "è¥§",
    19,
    "è¥¼"
  ],
  [
    "d280",
    "è¥½è¥¾è¦€è¦‚è¦„è¦…è¦‡",
    26,
    "æ‘‡å°§é¥çª‘è°£å§šå’¬èˆ€è¯è¦è€€æ¤°å™Žè€¶çˆ·é‡Žå†¶ä¹Ÿé¡µæŽ–ä¸šå¶æ›³è…‹å¤œæ¶²ä¸€å£¹åŒ»æ–é“±ä¾ä¼Šè¡£é¢å¤·é—ç§»ä»ªèƒ°ç–‘æ²‚å®œå§¨å½æ¤…èšå€šå·²ä¹™çŸ£ä»¥è‰ºæŠ‘æ˜“é‚‘å±¹äº¿å½¹è‡†é€¸è‚„ç–«äº¦è£”æ„æ¯…å¿†ä¹‰ç›Šæº¢è¯£è®®è°Šè¯‘å¼‚ç¿¼ç¿Œç»ŽèŒµè«å› æ®·éŸ³é˜´å§»åŸé“¶æ·«å¯…é¥®å°¹å¼•éš"
  ],
  [
    "d340",
    "è¦¢",
    30,
    "è§ƒè§è§“è§”è§•è§—è§˜è§™è§›è§è§Ÿè§ è§¡è§¢è§¤è§§è§¨è§©è§ªè§¬è§­è§®è§°è§±è§²è§´",
    6
  ],
  [
    "d380",
    "è§»",
    4,
    "è¨",
    5,
    "è¨ˆ",
    21,
    "å°è‹±æ¨±å©´é¹°åº”ç¼¨èŽ¹è¤è¥è§è‡è¿Žèµ¢ç›ˆå½±é¢–ç¡¬æ˜ å“Ÿæ‹¥ä½£è‡ƒç—ˆåº¸é›è¸Šè›¹å’æ³³æ¶Œæ°¸æ¿å‹‡ç”¨å¹½ä¼˜æ‚ å¿§å°¤ç”±é‚®é“€çŠ¹æ²¹æ¸¸é…‰æœ‰å‹å³ä½‘é‡‰è¯±åˆå¹¼è¿‚æ·¤äºŽç›‚æ¦†è™žæ„šèˆ†ä½™ä¿žé€¾é±¼æ„‰æ¸æ¸”éš…äºˆå¨±é›¨ä¸Žå±¿ç¦¹å®‡è¯­ç¾½çŽ‰åŸŸèŠ‹éƒåé‡å–»å³ªå¾¡æ„ˆæ¬²ç‹±è‚²èª‰"
  ],
  [
    "d440",
    "è¨ž",
    31,
    "è¨¿",
    8,
    "è©‰",
    21
  ],
  [
    "d480",
    "è©Ÿ",
    25,
    "è©º",
    6,
    "æµ´å¯“è£•é¢„è±«é©­é¸³æ¸Šå†¤å…ƒåž£è¢åŽŸæ´è¾•å›­å‘˜åœ†çŒ¿æºç¼˜è¿œè‹‘æ„¿æ€¨é™¢æ›°çº¦è¶Šè·ƒé’¥å²³ç²¤æœˆæ‚¦é˜…è€˜äº‘éƒ§åŒ€é™¨å…è¿è•´é…æ™•éŸµå­•åŒç ¸æ‚æ ½å“‰ç¾å®°è½½å†åœ¨å’±æ”’æš‚èµžèµƒè„è‘¬é­ç³Ÿå‡¿è—»æž£æ—©æ¾¡èš¤èºå™ªé€ çš‚ç¶ç‡¥è´£æ‹©åˆ™æ³½è´¼æ€Žå¢žæ†Žæ›¾èµ æ‰Žå–³æ¸£æœ­è½§"
  ],
  [
    "d540",
    "èª",
    7,
    "èª‹",
    7,
    "èª”",
    46
  ],
  [
    "d580",
    "è«ƒ",
    32,
    "é“¡é—¸çœ¨æ …æ¦¨å’‹ä¹ç‚¸è¯ˆæ‘˜æ–‹å®…çª„å€ºå¯¨çž»æ¯¡è©¹ç²˜æ²¾ç›æ–©è¾—å´­å±•è˜¸æ ˆå æˆ˜ç«™æ¹›ç»½æ¨Ÿç« å½°æ¼³å¼ æŽŒæ¶¨æ–ä¸ˆå¸è´¦ä»—èƒ€ç˜´éšœæ‹›æ˜­æ‰¾æ²¼èµµç…§ç½©å…†è‚‡å¬é®æŠ˜å“²è›°è¾™è€…é”—è”—è¿™æµ™çæ–ŸçœŸç”„ç §è‡»è´žé’ˆä¾¦æž•ç–¹è¯Šéœ‡æŒ¯é•‡é˜µè’¸æŒ£çå¾ç‹°äº‰æ€”æ•´æ‹¯æ­£æ”¿"
  ],
  [
    "d640",
    "è«¤",
    34,
    "è¬ˆ",
    27
  ],
  [
    "d680",
    "è¬¤è¬¥è¬§",
    30,
    "å¸§ç—‡éƒ‘è¯èŠæžæ”¯å±èœ˜çŸ¥è‚¢è„‚æ±ä¹‹ç»‡èŒç›´æ¤æ®–æ‰§å€¼ä¾„å€æŒ‡æ­¢è¶¾åªæ—¨çº¸å¿—æŒšæŽ·è‡³è‡´ç½®å¸œå³™åˆ¶æ™ºç§©ç¨šè´¨ç‚™ç—”æ»žæ²»çª’ä¸­ç›…å¿ é’Ÿè¡·ç»ˆç§è‚¿é‡ä»²ä¼—èˆŸå‘¨å·žæ´²è¯Œç²¥è½´è‚˜å¸šå’’çš±å®™æ˜¼éª¤ç æ ªè››æœ±çŒªè¯¸è¯›é€ç«¹çƒ›ç…®æ‹„çž©å˜±ä¸»è‘—æŸ±åŠ©è›€è´®é“¸ç­‘"
  ],
  [
    "d740",
    "è­†",
    31,
    "è­§",
    4,
    "è­­",
    25
  ],
  [
    "d780",
    "è®‡",
    24,
    "è®¬è®±è®»è¯‡è¯è¯ªè°‰è°žä½æ³¨ç¥é©»æŠ“çˆªæ‹½ä¸“ç –è½¬æ’°èµšç¯†æ¡©åº„è£…å¦†æ’žå£®çŠ¶æ¤Žé”¥è¿½èµ˜å ç¼€è°†å‡†æ‰æ‹™å“æ¡Œç¢èŒé…Œå•„ç€ç¼æµŠå…¹å’¨èµ„å§¿æ»‹æ·„å­œç´«ä»”ç±½æ»“å­è‡ªæ¸å­—é¬ƒæ£•è¸ªå®—ç»¼æ€»çºµé‚¹èµ°å¥æç§Ÿè¶³å’æ—ç¥–è¯…é˜»ç»„é’»çº‚å˜´é†‰æœ€ç½ªå°Šéµæ˜¨å·¦ä½æŸžåšä½œååº§"
  ],
  [
    "d840",
    "è°¸",
    8,
    "è±‚è±ƒè±„è±…è±ˆè±Šè±‹è±",
    7,
    "è±–è±—è±˜è±™è±›",
    5,
    "è±£",
    6,
    "è±¬",
    6,
    "è±´è±µè±¶è±·è±»",
    6,
    "è²ƒè²„è²†è²‡"
  ],
  [
    "d880",
    "è²ˆè²‹è²",
    6,
    "è²•è²–è²—è²™",
    20,
    "äºä¸Œå…€ä¸å»¿å…ä¸•äº˜ä¸žé¬²å­¬å™©ä¸¨ç¦ºä¸¿åŒ•ä¹‡å¤­çˆ»å®æ°å›Ÿèƒ¤é¦—æ¯“ç¾é¼—ä¸¶äºŸé¼ä¹œä¹©äº“èŠˆå­›å•¬å˜ä»„åŽåŽåŽ£åŽ¥åŽ®é¥èµåŒšåµåŒ¦åŒ®åŒ¾èµœå¦å£åˆ‚åˆˆåˆŽåˆ­åˆ³åˆ¿å‰€å‰Œå‰žå‰¡å‰œè’¯å‰½åŠ‚åŠåŠåŠ“å†‚ç½”äº»ä»ƒä»‰ä»‚ä»¨ä»¡ä»«ä»žä¼›ä»³ä¼¢ä½¤ä»µä¼¥ä¼§ä¼‰ä¼«ä½žä½§æ”¸ä½šä½"
  ],
  [
    "d940",
    "è²®",
    62
  ],
  [
    "d980",
    "è³­",
    32,
    "ä½Ÿä½—ä¼²ä¼½ä½¶ä½´ä¾‘ä¾‰ä¾ƒä¾ä½¾ä½»ä¾ªä½¼ä¾¬ä¾”ä¿¦ä¿¨ä¿ªä¿…ä¿šä¿£ä¿œä¿‘ä¿Ÿä¿¸å€©åŒä¿³å€¬å€å€®å€­ä¿¾å€œå€Œå€¥å€¨å¾åƒå•åˆåŽå¬å»å‚¥å‚§å‚©å‚ºåƒ–å„†åƒ­åƒ¬åƒ¦åƒ®å„‡å„‹ä»æ°½ä½˜ä½¥ä¿Žé¾ æ±†ç±´å…®å·½é»‰é¦˜å†å¤”å‹¹åŒè¨‡åŒå‡«å¤™å…•äº å…–äº³è¡®è¢¤äºµè„”è£’ç¦€å¬´è ƒç¾¸å†«å†±å†½å†¼"
  ],
  [
    "da40",
    "è´Ž",
    14,
    "è´ èµ‘èµ’èµ—èµŸèµ¥èµ¨èµ©èµªèµ¬èµ®èµ¯èµ±èµ²èµ¸",
    8,
    "è¶‚è¶ƒè¶†è¶‡è¶ˆè¶‰è¶Œ",
    4,
    "è¶’è¶“è¶•",
    9,
    "è¶ è¶¡"
  ],
  [
    "da80",
    "è¶¢è¶¤",
    12,
    "è¶²è¶¶è¶·è¶¹è¶»è¶½è·€è·è·‚è·…è·‡è·ˆè·‰è·Šè·è·è·’è·“è·”å‡‡å†–å†¢å†¥è® è®¦è®§è®ªè®´è®µè®·è¯‚è¯ƒè¯‹è¯è¯Žè¯’è¯“è¯”è¯–è¯˜è¯™è¯œè¯Ÿè¯ è¯¤è¯¨è¯©è¯®è¯°è¯³è¯¶è¯¹è¯¼è¯¿è°€è°‚è°„è°‡è°Œè°è°‘è°’è°”è°•è°–è°™è°›è°˜è°è°Ÿè° è°¡è°¥è°§è°ªè°«è°®è°¯è°²è°³è°µè°¶å©åºé˜é˜¢é˜¡é˜±é˜ªé˜½é˜¼é™‚é™‰é™”é™Ÿé™§é™¬é™²é™´éšˆéšéš—éš°é‚—é‚›é‚é‚™é‚¬é‚¡é‚´é‚³é‚¶é‚º"
  ],
  [
    "db40",
    "è·•è·˜è·™è·œè· è·¡è·¢è·¥è·¦è·§è·©è·­è·®è·°è·±è·²è·´è·¶è·¼è·¾",
    6,
    "è¸†è¸‡è¸ˆè¸‹è¸è¸Žè¸è¸‘è¸’è¸“è¸•",
    7,
    "è¸ è¸¡è¸¤",
    4,
    "è¸«è¸­è¸°è¸²è¸³è¸´è¸¶è¸·è¸¸è¸»è¸¼è¸¾"
  ],
  [
    "db80",
    "è¸¿è¹ƒè¹…è¹†è¹Œ",
    4,
    "è¹“",
    5,
    "è¹š",
    11,
    "è¹§è¹¨è¹ªè¹«è¹®è¹±é‚¸é‚°éƒéƒ…é‚¾éƒéƒ„éƒ‡éƒ“éƒ¦éƒ¢éƒœéƒ—éƒ›éƒ«éƒ¯éƒ¾é„„é„¢é„žé„£é„±é„¯é„¹é…ƒé…†åˆå¥‚åŠ¢åŠ¬åŠ­åŠ¾å“¿å‹å‹–å‹°åŸç‡®çŸå»´å‡µå‡¼é¬¯åŽ¶å¼ç•šå·¯åŒåž©åž¡å¡¾å¢¼å£…å£‘åœ©åœ¬åœªåœ³åœ¹åœ®åœ¯åœåœ»å‚å©åž…å«åž†å¼å»å¨å­å¶å³åž­åž¤åžŒåž²åŸåž§åž´åž“åž åŸ•åŸ˜åŸšåŸ™åŸ’åž¸åŸ´åŸ¯åŸ¸åŸ¤åŸ"
  ],
  [
    "dc40",
    "è¹³è¹µè¹·",
    4,
    "è¹½è¹¾èº€èº‚èºƒèº„èº†èºˆ",
    6,
    "èº‘èº’èº“èº•",
    6,
    "èºèºŸ",
    11,
    "èº­èº®èº°èº±èº³",
    6,
    "èº»",
    7
  ],
  [
    "dc80",
    "è»ƒ",
    10,
    "è»",
    21,
    "å ‹å åŸ½åŸ­å €å žå ™å¡„å  å¡¥å¡¬å¢å¢‰å¢šå¢€é¦¨é¼™æ‡¿è‰¹è‰½è‰¿èŠèŠŠèŠ¨èŠ„èŠŽèŠ‘èŠ—èŠ™èŠ«èŠ¸èŠ¾èŠ°è‹ˆè‹Šè‹£èŠ˜èŠ·èŠ®è‹‹è‹Œè‹èŠ©èŠ´èŠ¡èŠªèŠŸè‹„è‹ŽèŠ¤è‹¡èŒ‰è‹·è‹¤èŒèŒ‡è‹œè‹´è‹’è‹˜èŒŒè‹»è‹“èŒ‘èŒšèŒ†èŒ”èŒ•è‹ è‹•èŒœè‘è›èœèŒˆèŽ’èŒ¼èŒ´èŒ±èŽ›èžèŒ¯èè‡èƒèŸè€èŒ—è èŒ­èŒºèŒ³è¦è¥"
  ],
  [
    "dd40",
    "è»¥",
    62
  ],
  [
    "dd80",
    "è¼¤",
    32,
    "è¨èŒ›è©è¬èªè­è®èŽ°è¸èŽ³èŽ´èŽ èŽªèŽ“èŽœèŽ…è¼èŽ¶èŽ©è½èŽ¸è»èŽ˜èŽžèŽ¨èŽºèŽ¼èèè¥è˜å ‡è˜è‹èè½è–èœè¸è‘è†è”èŸèèƒè¸è¹èªè…è€è¦è°è¡è‘œè‘‘è‘šè‘™è‘³è’‡è’ˆè‘ºè’‰è‘¸è¼è‘†è‘©è‘¶è’Œè’Žè±è‘­è“è“è“è“¦è’½è““è“Šè’¿è’ºè“ è’¡è’¹è’´è’—è“¥è“£è”Œç”è”¸è“°è”¹è”Ÿè”º"
  ],
  [
    "de40",
    "è½…",
    32,
    "è½ªè¾€è¾Œè¾’è¾è¾ è¾¡è¾¢è¾¤è¾¥è¾¦è¾§è¾ªè¾¬è¾­è¾®è¾¯è¾²è¾³è¾´è¾µè¾·è¾¸è¾ºè¾»è¾¼è¾¿è¿€è¿ƒè¿†"
  ],
  [
    "de80",
    "è¿‰",
    4,
    "è¿è¿’è¿–è¿—è¿šè¿ è¿¡è¿£è¿§è¿¬è¿¯è¿±è¿²è¿´è¿µè¿¶è¿ºè¿»è¿¼è¿¾è¿¿é€‡é€ˆé€Œé€Žé€“é€•é€˜è•–è”»è“¿è“¼è•™è•ˆè•¨è•¤è•žè•ºçž¢è•ƒè•²è•»è–¤è–¨è–‡è–è•¹è–®è–œè–…è–¹è–·è–°è—“è—è—œè—¿è˜§è˜…è˜©è˜–è˜¼å»¾å¼ˆå¤¼å¥è€·å¥•å¥šå¥˜åŒå°¢å°¥å°¬å°´æ‰Œæ‰ªæŠŸæŠ»æ‹Šæ‹šæ‹—æ‹®æŒ¢æ‹¶æŒ¹æ‹æƒæŽ­æ¶æ±æºæŽŽæŽ´æ­æŽ¬æŽŠæ©æŽ®æŽ¼æ²æ¸æ æ¿æ„æžæŽæ‘’æ†æŽ¾æ‘…æ‘æ‹æ›æ æŒæ¦æ¡æ‘žæ’„æ‘­æ’–"
  ],
  [
    "df40",
    "é€™é€œé€£é€¤é€¥é€§",
    5,
    "é€°",
    4,
    "é€·é€¹é€ºé€½é€¿é€éƒé…é†éˆ",
    4,
    "éŽé”é•é–é™éšéœ",
    5,
    "é¤é¦é§é©éªé«é¬é¯",
    4,
    "é¶",
    6,
    "é¾é‚"
  ],
  [
    "df80",
    "é‚„é‚…é‚†é‚‡é‚‰é‚Šé‚Œ",
    4,
    "é‚’é‚”é‚–é‚˜é‚šé‚œé‚žé‚Ÿé‚ é‚¤é‚¥é‚§é‚¨é‚©é‚«é‚­é‚²é‚·é‚¼é‚½é‚¿éƒ€æ‘ºæ’·æ’¸æ’™æ’ºæ“€æ“æ“—æ“¤æ“¢æ”‰æ”¥æ”®å¼‹å¿’ç”™å¼‘åŸå±å½å©å¨å»å’å–å†å‘‹å‘’å‘“å‘”å‘–å‘ƒå¡å‘—å‘™å£å²å’‚å’”å‘·å‘±å‘¤å’šå’›å’„å‘¶å‘¦å’å“å’­å“‚å’´å“’å’§å’¦å““å“”å‘²å’£å“•å’»å’¿å“Œå“™å“šå“œå’©å’ªå’¤å“å“å“žå”›å“§å” å“½å””å“³å”¢å”£å”å”‘å”§å”ªå•§å–å–µå•‰å•­å•å••å”¿å•å”¼"
  ],
  [
    "e040",
    "éƒ‚éƒƒéƒ†éƒˆéƒ‰éƒ‹éƒŒéƒéƒ’éƒ”éƒ•éƒ–éƒ˜éƒ™éƒšéƒžéƒŸéƒ éƒ£éƒ¤éƒ¥éƒ©éƒªéƒ¬éƒ®éƒ°éƒ±éƒ²éƒ³éƒµéƒ¶éƒ·éƒ¹éƒºéƒ»éƒ¼éƒ¿é„€é„é„ƒé„…",
    19,
    "é„šé„›é„œ"
  ],
  [
    "e080",
    "é„é„Ÿé„ é„¡é„¤",
    10,
    "é„°é„²",
    6,
    "é„º",
    8,
    "é…„å”·å•–å•µå•¶å•·å”³å”°å•œå–‹å—’å–ƒå–±å–¹å–ˆå–å–Ÿå•¾å—–å–‘å•»å—Ÿå–½å–¾å–”å–™å—ªå—·å—‰å˜Ÿå—‘å—«å—¬å—”å—¦å—å—„å—¯å—¥å—²å—³å—Œå—å—¨å—µå—¤è¾”å˜žå˜ˆå˜Œå˜å˜¤å˜£å—¾å˜€å˜§å˜­å™˜å˜¹å™—å˜¬å™å™¢å™™å™œå™Œå™”åš†å™¤å™±å™«å™»å™¼åš…åš“åš¯å›”å›—å›å›¡å›µå›«å›¹å›¿åœ„åœŠåœ‰åœœå¸å¸™å¸”å¸‘å¸±å¸»å¸¼"
  ],
  [
    "e140",
    "é……é…‡é…ˆé…‘é…“é…”é…•é…–é…˜é…™é…›é…œé…Ÿé… é…¦é…§é…¨é…«é…­é…³é…ºé…»é…¼é†€",
    4,
    "é††é†ˆé†Šé†Žé†é†“",
    6,
    "é†œ",
    5,
    "é†¤",
    5,
    "é†«é†¬é†°é†±é†²é†³é†¶é†·é†¸é†¹é†»"
  ],
  [
    "e180",
    "é†¼",
    10,
    "é‡ˆé‡‹é‡é‡’",
    9,
    "é‡",
    8,
    "å¸·å¹„å¹”å¹›å¹žå¹¡å²Œå±ºå²å²å²–å²ˆå²˜å²™å²‘å²šå²œå²µå²¢å²½å²¬å²«å²±å²£å³å²·å³„å³’å³¤å³‹å³¥å´‚å´ƒå´§å´¦å´®å´¤å´žå´†å´›åµ˜å´¾å´´å´½åµ¬åµ›åµ¯åµåµ«åµ‹åµŠåµ©åµ´å¶‚å¶™å¶è±³å¶·å·…å½³å½·å¾‚å¾‡å¾‰å¾Œå¾•å¾™å¾œå¾¨å¾­å¾µå¾¼è¡¢å½¡çŠ­çŠ°çŠ´çŠ·çŠ¸ç‹ƒç‹ç‹Žç‹ç‹’ç‹¨ç‹¯ç‹©ç‹²ç‹´ç‹·çŒç‹³çŒƒç‹º"
  ],
  [
    "e240",
    "é‡¦",
    62
  ],
  [
    "e280",
    "éˆ¥",
    32,
    "ç‹»çŒ—çŒ“çŒ¡çŒŠçŒžçŒçŒ•çŒ¢çŒ¹çŒ¥çŒ¬çŒ¸çŒ±ççç—ç ç¬ç¯ç¾èˆ›å¤¥é£§å¤¤å¤‚é¥£é¥§",
    5,
    "é¥´é¥·é¥½é¦€é¦„é¦‡é¦Šé¦é¦é¦‘é¦“é¦”é¦•åº€åº‘åº‹åº–åº¥åº åº¹åºµåº¾åº³èµ“å»’å»‘å»›å»¨å»ªè†ºå¿„å¿‰å¿–å¿æ€ƒå¿®æ€„å¿¡å¿¤å¿¾æ€…æ€†å¿ªå¿­å¿¸æ€™æ€µæ€¦æ€›æ€æ€æ€©æ€«æ€Šæ€¿æ€¡æ¸æ¹æ»æºæ‚"
  ],
  [
    "e340",
    "é‰†",
    45,
    "é‰µ",
    16
  ],
  [
    "e380",
    "éŠ†",
    7,
    "éŠ",
    24,
    "æªæ½æ‚–æ‚šæ‚­æ‚æ‚ƒæ‚’æ‚Œæ‚›æƒ¬æ‚»æ‚±æƒæƒ˜æƒ†æƒšæ‚´æ„ æ„¦æ„•æ„£æƒ´æ„€æ„Žæ„«æ…Šæ…µæ†¬æ†”æ†§æ†·æ‡”æ‡µå¿éš³é—©é—«é—±é—³é—µé—¶é—¼é—¾é˜ƒé˜„é˜†é˜ˆé˜Šé˜‹é˜Œé˜é˜é˜’é˜•é˜–é˜—é˜™é˜šä¸¬çˆ¿æˆ•æ°µæ±”æ±œæ±Šæ²£æ²…æ²æ²”æ²Œæ±¨æ±©æ±´æ±¶æ²†æ²©æ³æ³”æ²­æ³·æ³¸æ³±æ³—æ²²æ³ æ³–æ³ºæ³«æ³®æ²±æ³“æ³¯æ³¾"
  ],
  [
    "e440",
    "éŠ¨",
    5,
    "éŠ¯",
    24,
    "é‹‰",
    31
  ],
  [
    "e480",
    "é‹©",
    32,
    "æ´¹æ´§æ´Œæµƒæµˆæ´‡æ´„æ´™æ´Žæ´«æµæ´®æ´µæ´šæµæµ’æµ”æ´³æ¶‘æµ¯æ¶žæ¶ æµžæ¶“æ¶”æµœæµ æµ¼æµ£æ¸šæ·‡æ·…æ·žæ¸Žæ¶¿æ· æ¸‘æ·¦æ·æ·™æ¸–æ¶«æ¸Œæ¶®æ¸«æ¹®æ¹Žæ¹«æº²æ¹Ÿæº†æ¹“æ¹”æ¸²æ¸¥æ¹„æ»Ÿæº±æº˜æ» æ¼­æ»¢æº¥æº§æº½æº»æº·æ»—æº´æ»æºæ»‚æºŸæ½¢æ½†æ½‡æ¼¤æ¼•æ»¹æ¼¯æ¼¶æ½‹æ½´æ¼ªæ¼‰æ¼©æ¾‰æ¾æ¾Œæ½¸æ½²æ½¼æ½ºæ¿‘"
  ],
  [
    "e540",
    "éŒŠ",
    51,
    "éŒ¿",
    10
  ],
  [
    "e580",
    "éŠ",
    31,
    "é«æ¿‰æ¾§æ¾¹æ¾¶æ¿‚æ¿¡æ¿®æ¿žæ¿ æ¿¯ç€šç€£ç€›ç€¹ç€µççžå®€å®„å®•å®“å®¥å®¸ç”¯éªžæ´å¯¤å¯®è¤°å¯°è¹‡è¬‡è¾¶è¿“è¿•è¿¥è¿®è¿¤è¿©è¿¦è¿³è¿¨é€…é€„é€‹é€¦é€‘é€é€–é€¡é€µé€¶é€­é€¯é„é‘é’éé¨é˜é¢é›æš¹é´é½é‚‚é‚ˆé‚ƒé‚‹å½å½—å½–å½˜å°»å’«å±å±™å­±å±£å±¦ç¾¼å¼ªå¼©å¼­è‰´å¼¼é¬»å±®å¦å¦ƒå¦å¦©å¦ªå¦£"
  ],
  [
    "e640",
    "é¬",
    34,
    "éŽ",
    27
  ],
  [
    "e680",
    "éŽ¬",
    29,
    "é‹éŒéå¦—å§Šå¦«å¦žå¦¤å§’å¦²å¦¯å§—å¦¾å¨…å¨†å§å¨ˆå§£å§˜å§¹å¨Œå¨‰å¨²å¨´å¨‘å¨£å¨“å©€å©§å©Šå©•å¨¼å©¢å©µèƒ¬åªªåª›å©·å©ºåª¾å««åª²å«’å«”åª¸å« å«£å«±å«–å«¦å«˜å«œå¬‰å¬—å¬–å¬²å¬·å­€å°•å°œå­šå­¥å­³å­‘å­“å­¢é©µé©·é©¸é©ºé©¿é©½éª€éªéª…éªˆéªŠéªéª’éª“éª–éª˜éª›éªœéªéªŸéª éª¢éª£éª¥éª§çºŸçº¡çº£çº¥çº¨çº©"
  ],
  [
    "e740",
    "éŽ",
    7,
    "é—",
    54
  ],
  [
    "e780",
    "éŽ",
    32,
    "çº­çº°çº¾ç»€ç»ç»‚ç»‰ç»‹ç»Œç»ç»”ç»—ç»›ç» ç»¡ç»¨ç»«ç»®ç»¯ç»±ç»²ç¼ç»¶ç»ºç»»ç»¾ç¼ç¼‚ç¼ƒç¼‡ç¼ˆç¼‹ç¼Œç¼ç¼‘ç¼’ç¼—ç¼™ç¼œç¼›ç¼Ÿç¼¡",
    6,
    "ç¼ªç¼«ç¼¬ç¼­ç¼¯",
    4,
    "ç¼µå¹ºç•¿å·›ç”¾é‚•çŽŽçŽ‘çŽ®çŽ¢çŽŸçç‚ç‘çŽ·çŽ³ç€ç‰çˆç¥ç™é¡¼çŠç©ç§çžçŽºç²ççªç‘›ç¦ç¥ç¨ç°ç®ç¬"
  ],
  [
    "e840",
    "é¯",
    14,
    "é¿",
    43,
    "é‘¬é‘­é‘®é‘¯"
  ],
  [
    "e880",
    "é‘°",
    20,
    "é’‘é’–é’˜é“‡é“é““é“”é“šé“¦é“»é”œé” ç›çšç‘ç‘œç‘—ç‘•ç‘™ç‘·ç‘­ç‘¾ç’œç’Žç’€ç’ç’‡ç’‹ç’žç’¨ç’©ç’ç’§ç“’ç’ºéŸªéŸ«éŸ¬æŒæ“æžæˆæ©æž¥æž‡æªæ³æž˜æž§æµæž¨æžžæž­æž‹æ·æ¼æŸ°æ ‰æŸ˜æ ŠæŸ©æž°æ ŒæŸ™æžµæŸšæž³æŸæ €æŸƒæž¸æŸ¢æ ŽæŸæŸ½æ ²æ ³æ¡ æ¡¡æ¡Žæ¡¢æ¡„æ¡¤æ¢ƒæ æ¡•æ¡¦æ¡æ¡§æ¡€æ ¾æ¡Šæ¡‰æ ©æ¢µæ¢æ¡´æ¡·æ¢“æ¡«æ£‚æ¥®æ£¼æ¤Ÿæ¤ æ£¹"
  ],
  [
    "e940",
    "é”§é”³é”½é•ƒé•ˆé•‹é••é•šé• é•®é•´é•µé•·",
    7,
    "é–€",
    42
  ],
  [
    "e980",
    "é–«",
    32,
    "æ¤¤æ£°æ¤‹æ¤æ¥—æ££æ¤æ¥±æ¤¹æ¥ æ¥‚æ¥æ¦„æ¥«æ¦€æ¦˜æ¥¸æ¤´æ§Œæ¦‡æ¦ˆæ§Žæ¦‰æ¥¦æ¥£æ¥¹æ¦›æ¦§æ¦»æ¦«æ¦­æ§”æ¦±æ§æ§Šæ§Ÿæ¦•æ§ æ¦æ§¿æ¨¯æ§­æ¨—æ¨˜æ©¥æ§²æ©„æ¨¾æª æ©æ©›æ¨µæªŽæ©¹æ¨½æ¨¨æ©˜æ©¼æª‘æªæª©æª—æª«çŒ·ç’æ®æ®‚æ®‡æ®„æ®’æ®“æ®æ®šæ®›æ®¡æ®ªè½«è½­è½±è½²è½³è½µè½¶è½¸è½·è½¹è½ºè½¼è½¾è¾è¾‚è¾„è¾‡è¾‹"
  ],
  [
    "ea40",
    "é—Œ",
    27,
    "é—¬é—¿é˜‡é˜“é˜˜é˜›é˜žé˜ é˜£",
    6,
    "é˜«é˜¬é˜­é˜¯é˜°é˜·é˜¸é˜¹é˜ºé˜¾é™é™ƒé™Šé™Žé™é™‘é™’é™“é™–é™—"
  ],
  [
    "ea80",
    "é™˜é™™é™šé™œé™é™žé™ é™£é™¥é™¦é™«é™­",
    4,
    "é™³é™¸",
    12,
    "éš‡éš‰éšŠè¾è¾Žè¾è¾˜è¾šè»Žæˆ‹æˆ—æˆ›æˆŸæˆ¢æˆ¡æˆ¥æˆ¤æˆ¬è‡§ç“¯ç“´ç“¿ç”ç”‘ç”“æ”´æ—®æ—¯æ—°æ˜Šæ˜™æ²æ˜ƒæ˜•æ˜€ç‚…æ›·æ˜æ˜´æ˜±æ˜¶æ˜µè€†æ™Ÿæ™”æ™æ™æ™–æ™¡æ™—æ™·æš„æšŒæš§æšæš¾æ››æ›œæ›¦æ›©è´²è´³è´¶è´»è´½èµ€èµ…èµ†èµˆèµ‰èµ‡èµèµ•èµ™è§‡è§Šè§‹è§Œè§Žè§è§è§‘ç‰®çŠŸç‰ç‰¦ç‰¯ç‰¾ç‰¿çŠ„çŠ‹çŠçŠçŠ’æŒˆæŒ²æŽ°"
  ],
  [
    "eb40",
    "éšŒéšŽéš‘éš’éš“éš•éš–éššéš›éš",
    9,
    "éš¨",
    7,
    "éš±éš²éš´éšµéš·éš¸éšºéš»éš¿é›‚é›ƒé›ˆé›Šé›‹é›é›‘é›“é›”é›–",
    9,
    "é›¡",
    6,
    "é›«"
  ],
  [
    "eb80",
    "é›¬é›­é›®é›°é›±é›²é›´é›µé›¸é›ºé›»é›¼é›½é›¿éœ‚éœƒéœ…éœŠéœ‹éœŒéœéœ‘éœ’éœ”éœ•éœ—",
    4,
    "éœéœŸéœ æ¿æ“˜è€„æ¯ªæ¯³æ¯½æ¯µæ¯¹æ°…æ°‡æ°†æ°æ°•æ°˜æ°™æ°šæ°¡æ°©æ°¤æ°ªæ°²æ”µæ••æ•«ç‰ç‰’ç‰–çˆ°è™¢åˆ–è‚Ÿè‚œè‚“è‚¼æœŠè‚½è‚±è‚«è‚­è‚´è‚·èƒ§èƒ¨èƒ©èƒªèƒ›èƒ‚èƒ„èƒ™èƒèƒ—æœèƒèƒ«èƒ±èƒ´èƒ­è„è„Žèƒ²èƒ¼æœ•è„’è±šè„¶è„žè„¬è„˜è„²è…ˆè…Œè…“è…´è…™è…šè…±è… è…©è…¼è…½è…­è…§å¡åªµè†ˆè†‚è†‘æ»•è†£è†ªè‡Œæœ¦è‡Šè†»"
  ],
  [
    "ec40",
    "éœ¡",
    8,
    "éœ«éœ¬éœ®éœ¯éœ±éœ³",
    4,
    "éœºéœ»éœ¼éœ½éœ¿",
    18,
    "é”é•é—é˜éšéœééŸé£é¤é¦é§é¨éª",
    7
  ],
  [
    "ec80",
    "é²éµé·",
    4,
    "é½",
    7,
    "éž†",
    4,
    "éžŒéžŽéžéžéž“éž•éž–éž—éž™",
    4,
    "è‡è†¦æ¬¤æ¬·æ¬¹æ­ƒæ­†æ­™é£‘é£’é£“é£•é£™é£šæ®³å½€æ¯‚è§³æ–é½‘æ–“æ–¼æ—†æ—„æ—ƒæ—Œæ—Žæ—’æ—–ç‚€ç‚œç‚–ç‚ç‚»çƒ€ç‚·ç‚«ç‚±çƒ¨çƒŠç„ç„“ç„–ç„¯ç„±ç…³ç…œç…¨ç……ç…²ç…Šç…¸ç…ºç†˜ç†³ç†µç†¨ç† ç‡ ç‡”ç‡§ç‡¹çˆçˆ¨ç¬ç„˜ç…¦ç†¹æˆ¾æˆ½æ‰ƒæ‰ˆæ‰‰ç¤»ç¥€ç¥†ç¥‰ç¥›ç¥œç¥“ç¥šç¥¢ç¥—ç¥ ç¥¯ç¥§ç¥ºç¦…ç¦Šç¦šç¦§ç¦³å¿‘å¿"
  ],
  [
    "ed40",
    "éžžéžŸéž¡éž¢éž¤",
    6,
    "éž¬éž®éž°éž±éž³éžµ",
    46
  ],
  [
    "ed80",
    "éŸ¤éŸ¥éŸ¨éŸ®",
    4,
    "éŸ´éŸ·",
    23,
    "æ€¼ææšæ§ææ™æ£æ‚«æ„†æ„æ…æ†©æ†æ‡‹æ‡‘æˆ†è‚€è¿æ²“æ³¶æ·¼çŸ¶çŸ¸ç €ç ‰ç —ç ˜ç ‘æ–«ç ­ç œç ç ¹ç ºç »ç Ÿç ¼ç ¥ç ¬ç £ç ©ç¡Žç¡­ç¡–ç¡—ç ¦ç¡ç¡‡ç¡Œç¡ªç¢›ç¢“ç¢šç¢‡ç¢œç¢¡ç¢£ç¢²ç¢¹ç¢¥ç£”ç£™ç£‰ç£¬ç£²ç¤…ç£´ç¤“ç¤¤ç¤žç¤´é¾›é»¹é»»é»¼ç›±çœ„çœç›¹çœ‡çœˆçœšçœ¢çœ™çœ­çœ¦çœµçœ¸çç‘ç‡çƒçšç¨"
  ],
  [
    "ee40",
    "é ",
    62
  ],
  [
    "ee80",
    "é¡Ž",
    32,
    "ç¢ç¥ç¿çžç½çž€çžŒçž‘çžŸçž çž°çžµçž½ç”ºç•€ç•Žç•‹ç•ˆç•›ç•²ç•¹ç–ƒç½˜ç½¡ç½Ÿè©ˆç½¨ç½´ç½±ç½¹ç¾ç½¾ç›ç›¥è ²é’…é’†é’‡é’‹é’Šé’Œé’é’é’é’”é’—é’•é’šé’›é’œé’£é’¤é’«é’ªé’­é’¬é’¯é’°é’²é’´é’¶",
    4,
    "é’¼é’½é’¿é“„é“ˆ",
    6,
    "é“é“‘é“’é“•é“–é“—é“™é“˜é“›é“žé“Ÿé“ é“¢é“¤é“¥é“§é“¨é“ª"
  ],
  [
    "ef40",
    "é¡¯",
    5,
    "é¢‹é¢Žé¢’é¢•é¢™é¢£é¢¨",
    37,
    "é£é£é£”é£–é£—é£›é£œé£é£ ",
    4
  ],
  [
    "ef80",
    "é£¥é£¦é£©",
    30,
    "é“©é“«é“®é“¯é“³é“´é“µé“·é“¹é“¼é“½é“¿é”ƒé”‚é”†é”‡é”‰é”Šé”é”Žé”é”’",
    4,
    "é”˜é”›é”é”žé”Ÿé”¢é”ªé”«é”©é”¬é”±é”²é”´é”¶é”·é”¸é”¼é”¾é”¿é•‚é”µé•„é•…é•†é•‰é•Œé•Žé•é•’é•“é•”é•–é•—é•˜é•™é•›é•žé•Ÿé•é•¡é•¢é•¤",
    8,
    "é•¯é•±é•²é•³é”ºçŸ§çŸ¬é›‰ç§•ç§­ç§£ç§«ç¨†åµ‡ç¨ƒç¨‚ç¨žç¨”"
  ],
  [
    "f040",
    "é¤ˆ",
    4,
    "é¤Žé¤é¤‘",
    28,
    "é¤¯",
    26
  ],
  [
    "f080",
    "é¥Š",
    9,
    "é¥–",
    12,
    "é¥¤é¥¦é¥³é¥¸é¥¹é¥»é¥¾é¦‚é¦ƒé¦‰ç¨¹ç¨·ç©‘é»é¦¥ç©°çšˆçšŽçš“çš™çš¤ç“žç“ ç”¬é¸ é¸¢é¸¨",
    4,
    "é¸²é¸±é¸¶é¸¸é¸·é¸¹é¸ºé¸¾é¹é¹‚é¹„é¹†é¹‡é¹ˆé¹‰é¹‹é¹Œé¹Žé¹‘é¹•é¹—é¹šé¹›é¹œé¹žé¹£é¹¦",
    6,
    "é¹±é¹­é¹³ç–’ç–”ç––ç– ç–ç–¬ç–£ç–³ç–´ç–¸ç—„ç–±ç–°ç—ƒç—‚ç—–ç—ç—£ç—¨ç—¦ç—¤ç—«ç—§ç˜ƒç—±ç—¼ç—¿ç˜ç˜€ç˜…ç˜Œç˜—ç˜Šç˜¥ç˜˜ç˜•ç˜™"
  ],
  [
    "f140",
    "é¦Œé¦Žé¦š",
    10,
    "é¦¦é¦§é¦©",
    47
  ],
  [
    "f180",
    "é§™",
    32,
    "ç˜›ç˜¼ç˜¢ç˜ ç™€ç˜­ç˜°ç˜¿ç˜µç™ƒç˜¾ç˜³ç™ç™žç™”ç™œç™–ç™«ç™¯ç¿Šç«¦ç©¸ç©¹çª€çª†çªˆçª•çª¦çª çª¬çª¨çª­çª³è¡¤è¡©è¡²è¡½è¡¿è¢‚è¢¢è£†è¢·è¢¼è£‰è£¢è£Žè££è£¥è£±è¤šè£¼è£¨è£¾è£°è¤¡è¤™è¤“è¤›è¤Šè¤´è¤«è¤¶è¥è¥¦è¥»ç–‹èƒ¥çš²çš´çŸœè€’è€”è€–è€œè€ è€¢è€¥è€¦è€§è€©è€¨è€±è€‹è€µèƒè†èè’è©è±è¦ƒé¡¸é¢€é¢ƒ"
  ],
  [
    "f240",
    "é§º",
    62
  ],
  [
    "f280",
    "é¨¹",
    32,
    "é¢‰é¢Œé¢é¢é¢”é¢šé¢›é¢žé¢Ÿé¢¡é¢¢é¢¥é¢¦è™è™”è™¬è™®è™¿è™ºè™¼è™»èš¨èšèš‹èš¬èšèš§èš£èšªèš“èš©èš¶è›„èšµè›Žèš°èšºèš±èš¯è›‰è›èš´è›©è›±è›²è›­è›³è›èœ“è›žè›´è›Ÿè›˜è›‘èœƒèœ‡è›¸èœˆèœŠèœèœ‰èœ£èœ»èœžèœ¥èœ®èœšèœ¾èˆèœ´èœ±èœ©èœ·èœ¿èž‚èœ¢è½è¾è»è è°èŒè®èž‹è“è£è¼è¤è™è¥èž“èž¯èž¨èŸ’"
  ],
  [
    "f340",
    "é©š",
    17,
    "é©²éªƒéª‰éªéªŽéª”éª•éª™éª¦éª©",
    6,
    "éª²éª³éª´éªµéª¹éª»éª½éª¾éª¿é«ƒé«„é«†",
    4,
    "é«é«Žé«é«é«’é«”é«•é«–é«—é«™é«šé«›é«œ"
  ],
  [
    "f380",
    "é«é«žé« é«¢é«£é«¤é«¥é«§é«¨é«©é«ªé«¬é«®é«°",
    8,
    "é«ºé«¼",
    6,
    "é¬„é¬…é¬†èŸ†èžˆèž…èž­èž—èžƒèž«èŸ¥èž¬èžµèž³èŸ‹èŸ“èž½èŸ‘èŸ€èŸŠèŸ›èŸªèŸ èŸ®è –è “èŸ¾è Šè ›è ¡è ¹è ¼ç¼¶ç½‚ç½„ç½…èˆç«ºç«½ç¬ˆç¬ƒç¬„ç¬•ç¬Šç¬«ç¬ç­‡ç¬¸ç¬ªç¬™ç¬®ç¬±ç¬ ç¬¥ç¬¤ç¬³ç¬¾ç¬žç­˜ç­šç­…ç­µç­Œç­ç­ ç­®ç­»ç­¢ç­²ç­±ç®ç®¦ç®§ç®¸ç®¬ç®ç®¨ç®…ç®ªç®œç®¢ç®«ç®´ç¯‘ç¯ç¯Œç¯ç¯šç¯¥ç¯¦ç¯ªç°Œç¯¾ç¯¼ç°ç°–ç°‹"
  ],
  [
    "f440",
    "é¬‡é¬‰",
    5,
    "é¬é¬‘é¬’é¬”",
    10,
    "é¬ é¬¡é¬¢é¬¤",
    10,
    "é¬°é¬±é¬³",
    7,
    "é¬½é¬¾é¬¿é­€é­†é­Šé­‹é­Œé­Žé­é­’é­“é­•",
    5
  ],
  [
    "f480",
    "é­›",
    32,
    "ç°Ÿç°ªç°¦ç°¸ç±ç±€è‡¾èˆèˆ‚èˆ„è‡¬è¡„èˆ¡èˆ¢èˆ£èˆ­èˆ¯èˆ¨èˆ«èˆ¸èˆ»èˆ³èˆ´èˆ¾è‰„è‰‰è‰‹è‰è‰šè‰Ÿè‰¨è¡¾è¢…è¢ˆè£˜è£Ÿè¥žç¾ç¾Ÿç¾§ç¾¯ç¾°ç¾²ç±¼æ•‰ç²‘ç²ç²œç²žç²¢ç²²ç²¼ç²½ç³ç³‡ç³Œç³ç³ˆç³…ç³—ç³¨è‰®æš¨ç¾¿ç¿Žç¿•ç¿¥ç¿¡ç¿¦ç¿©ç¿®ç¿³ç³¸çµ·ç¶¦ç¶®ç¹‡çº›éº¸éº´èµ³è¶„è¶”è¶‘è¶±èµ§èµ­è±‡è±‰é…Šé…é…Žé…é…¤"
  ],
  [
    "f540",
    "é­¼",
    62
  ],
  [
    "f580",
    "é®»",
    32,
    "é…¢é…¡é…°é…©é…¯é…½é…¾é…²é…´é…¹é†Œé†…é†é†é†‘é†¢é†£é†ªé†­é†®é†¯é†µé†´é†ºè±•é¹¾è¶¸è·«è¸…è¹™è¹©è¶µè¶¿è¶¼è¶ºè·„è·–è·—è·šè·žè·Žè·è·›è·†è·¬è··è·¸è·£è·¹è·»è·¤è¸‰è·½è¸”è¸è¸Ÿè¸¬è¸®è¸£è¸¯è¸ºè¹€è¸¹è¸µè¸½è¸±è¹‰è¹è¹‚è¹‘è¹’è¹Šè¹°è¹¶è¹¼è¹¯è¹´èº…èºèº”èºèºœèºžè±¸è²‚è²Šè²…è²˜è²”æ–›è§–è§žè§šè§œ"
  ],
  [
    "f640",
    "é¯œ",
    62
  ],
  [
    "f680",
    "é°›",
    32,
    "è§¥è§«è§¯è¨¾è¬¦é“é›©é›³é›¯éœ†éœéœˆéœéœŽéœªéœ­éœ°éœ¾é¾€é¾ƒé¾…",
    5,
    "é¾Œé»¾é¼‹é¼éš¹éš¼éš½é›Žé›’çž¿é› éŠŽéŠ®é‹ˆéŒ¾éªéŠéŽé¾é‘«é±¿é²‚é²…é²†é²‡é²ˆç¨£é²‹é²Žé²é²‘é²’é²”é²•é²šé²›é²ž",
    5,
    "é²¥",
    4,
    "é²«é²­é²®é²°",
    7,
    "é²ºé²»é²¼é²½é³„é³…é³†é³‡é³Šé³‹"
  ],
  [
    "f740",
    "é°¼",
    62
  ],
  [
    "f780",
    "é±»é±½é±¾é²€é²ƒé²„é²‰é²Šé²Œé²é²“é²–é²—é²˜é²™é²é²ªé²¬é²¯é²¹é²¾",
    4,
    "é³ˆé³‰é³‘é³’é³šé³›é³ é³¡é³Œ",
    4,
    "é³“é³”é³•é³—é³˜é³™é³œé³é³Ÿé³¢é¼éž…éž‘éž’éž”éž¯éž«éž£éž²éž´éª±éª°éª·é¹˜éª¶éªºéª¼é«é«€é«…é«‚é«‹é«Œé«‘é­…é­ƒé­‡é­‰é­ˆé­é­‘é£¨é¤é¤®é¥•é¥”é«Ÿé«¡é«¦é«¯é««é«»é«­é«¹é¬ˆé¬é¬“é¬Ÿé¬£éº½éº¾ç¸»éº‚éº‡éºˆéº‹éº’é–éºéºŸé»›é»œé»é» é»Ÿé»¢é»©é»§é»¥é»ªé»¯é¼¢é¼¬é¼¯é¼¹é¼·é¼½é¼¾é½„"
  ],
  [
    "f840",
    "é³£",
    62
  ],
  [
    "f880",
    "é´¢",
    32
  ],
  [
    "f940",
    "éµƒ",
    62
  ],
  [
    "f980",
    "é¶‚",
    32
  ],
  [
    "fa40",
    "é¶£",
    62
  ],
  [
    "fa80",
    "é·¢",
    32
  ],
  [
    "fb40",
    "é¸ƒ",
    27,
    "é¸¤é¸§é¸®é¸°é¸´é¸»é¸¼é¹€é¹é¹é¹’é¹“é¹”é¹–é¹™é¹é¹Ÿé¹ é¹¡é¹¢é¹¥é¹®é¹¯é¹²é¹´",
    9,
    "éº€"
  ],
  [
    "fb80",
    "éºéºƒéº„éº…éº†éº‰éºŠéºŒ",
    5,
    "éº”",
    8,
    "éºžéº ",
    5,
    "éº§éº¨éº©éºª"
  ],
  [
    "fc40",
    "éº«",
    8,
    "éºµéº¶éº·éº¹éººéº¼éº¿",
    4,
    "é»…é»†é»‡é»ˆé»Šé»‹é»Œé»é»’é»“é»•é»–é»—é»™é»šé»žé»¡é»£é»¤é»¦é»¨é»«é»¬é»­é»®é»°",
    8,
    "é»ºé»½é»¿",
    6
  ],
  [
    "fc80",
    "é¼†",
    4,
    "é¼Œé¼é¼‘é¼’é¼”é¼•é¼–é¼˜é¼š",
    5,
    "é¼¡é¼£",
    8,
    "é¼­é¼®é¼°é¼±"
  ],
  [
    "fd40",
    "é¼²",
    4,
    "é¼¸é¼ºé¼¼é¼¿",
    4,
    "é½…",
    10,
    "é½’",
    38
  ],
  [
    "fd80",
    "é½¹",
    5,
    "é¾é¾‚é¾",
    11,
    "é¾œé¾é¾žé¾¡",
    4,
    "ï¤¬ï¥¹ï¦•ï§§ï§±"
  ],
  [
    "fe40",
    "ï¨Œï¨ï¨Žï¨ï¨‘ï¨“ï¨”ï¨˜ï¨Ÿï¨ ï¨¡ï¨£ï¨¤ï¨§ï¨¨ï¨©"
  ]
];
const require$$3 = [
  [
    "a140",
    "î“†",
    62
  ],
  [
    "a180",
    "î”…",
    32
  ],
  [
    "a240",
    "î”¦",
    62
  ],
  [
    "a280",
    "î•¥",
    32
  ],
  [
    "a2ab",
    "î¦",
    5
  ],
  [
    "a2e3",
    "â‚¬î­"
  ],
  [
    "a2ef",
    "î®î¯"
  ],
  [
    "a2fd",
    "î°î±"
  ],
  [
    "a340",
    "î–†",
    62
  ],
  [
    "a380",
    "î—…",
    31,
    "ã€€"
  ],
  [
    "a440",
    "î—¦",
    62
  ],
  [
    "a480",
    "î˜¥",
    32
  ],
  [
    "a4f4",
    "î²",
    10
  ],
  [
    "a540",
    "î™†",
    62
  ],
  [
    "a580",
    "îš…",
    32
  ],
  [
    "a5f7",
    "î½",
    7
  ],
  [
    "a640",
    "îš¦",
    62
  ],
  [
    "a680",
    "î›¥",
    32
  ],
  [
    "a6b9",
    "îž…",
    7
  ],
  [
    "a6d9",
    "îž",
    6
  ],
  [
    "a6ec",
    "îž”îž•"
  ],
  [
    "a6f3",
    "îž–"
  ],
  [
    "a6f6",
    "îž—",
    8
  ],
  [
    "a740",
    "îœ†",
    62
  ],
  [
    "a780",
    "î…",
    32
  ],
  [
    "a7c2",
    "îž ",
    14
  ],
  [
    "a7f2",
    "îž¯",
    12
  ],
  [
    "a896",
    "îž¼",
    10
  ],
  [
    "a8bc",
    "îŸ‡"
  ],
  [
    "a8bf",
    "Ç¹"
  ],
  [
    "a8c1",
    "îŸ‰îŸŠîŸ‹îŸŒ"
  ],
  [
    "a8ea",
    "îŸ",
    20
  ],
  [
    "a958",
    "îŸ¢"
  ],
  [
    "a95b",
    "îŸ£"
  ],
  [
    "a95d",
    "îŸ¤îŸ¥îŸ¦"
  ],
  [
    "a989",
    "ã€¾â¿°",
    11
  ],
  [
    "a997",
    "îŸ´",
    12
  ],
  [
    "a9f0",
    "î ",
    14
  ],
  [
    "aaa1",
    "î€€",
    93
  ],
  [
    "aba1",
    "îž",
    93
  ],
  [
    "aca1",
    "î‚¼",
    93
  ],
  [
    "ada1",
    "î„š",
    93
  ],
  [
    "aea1",
    "î…¸",
    93
  ],
  [
    "afa1",
    "î‡–",
    93
  ],
  [
    "d7fa",
    "î ",
    4
  ],
  [
    "f8a1",
    "îˆ´",
    93
  ],
  [
    "f9a1",
    "îŠ’",
    93
  ],
  [
    "faa1",
    "î‹°",
    93
  ],
  [
    "fba1",
    "îŽ",
    93
  ],
  [
    "fca1",
    "îŽ¬",
    93
  ],
  [
    "fda1",
    "îŠ",
    93
  ],
  [
    "fe50",
    "âºî –î —î ˜âº„ã‘³ã‘‡âºˆâº‹î žã–žã˜šã˜ŽâºŒâº—ã¥®ã¤˜î ¦ã§ã§Ÿã©³ã§î «î ¬ã­Žã±®ã³ âº§î ±î ²âºªä–ä…Ÿâº®äŒ·âº³âº¶âº·î »äŽ±äŽ¬âº»ää“–ä™¡ä™Œî¡ƒ"
  ],
  [
    "fe80",
    "äœ£äœ©ä¼äžâ»Šä¥‡ä¥ºä¥½ä¦‚ä¦ƒä¦…ä¦†ä¦Ÿä¦›ä¦·ä¦¶î¡”î¡•ä²£ä²Ÿä² ä²¡ä±·ä²¢ä´“",
    6,
    "ä¶®î¡¤î‘¨",
    93
  ]
];
const uChars = [
  128,
  165,
  169,
  178,
  184,
  216,
  226,
  235,
  238,
  244,
  248,
  251,
  253,
  258,
  276,
  284,
  300,
  325,
  329,
  334,
  364,
  463,
  465,
  467,
  469,
  471,
  473,
  475,
  477,
  506,
  594,
  610,
  712,
  716,
  730,
  930,
  938,
  962,
  970,
  1026,
  1104,
  1106,
  8209,
  8215,
  8218,
  8222,
  8231,
  8241,
  8244,
  8246,
  8252,
  8365,
  8452,
  8454,
  8458,
  8471,
  8482,
  8556,
  8570,
  8596,
  8602,
  8713,
  8720,
  8722,
  8726,
  8731,
  8737,
  8740,
  8742,
  8748,
  8751,
  8760,
  8766,
  8777,
  8781,
  8787,
  8802,
  8808,
  8816,
  8854,
  8858,
  8870,
  8896,
  8979,
  9322,
  9372,
  9548,
  9588,
  9616,
  9622,
  9634,
  9652,
  9662,
  9672,
  9676,
  9680,
  9702,
  9735,
  9738,
  9793,
  9795,
  11906,
  11909,
  11913,
  11917,
  11928,
  11944,
  11947,
  11951,
  11956,
  11960,
  11964,
  11979,
  12284,
  12292,
  12312,
  12319,
  12330,
  12351,
  12436,
  12447,
  12535,
  12543,
  12586,
  12842,
  12850,
  12964,
  13200,
  13215,
  13218,
  13253,
  13263,
  13267,
  13270,
  13384,
  13428,
  13727,
  13839,
  13851,
  14617,
  14703,
  14801,
  14816,
  14964,
  15183,
  15471,
  15585,
  16471,
  16736,
  17208,
  17325,
  17330,
  17374,
  17623,
  17997,
  18018,
  18212,
  18218,
  18301,
  18318,
  18760,
  18811,
  18814,
  18820,
  18823,
  18844,
  18848,
  18872,
  19576,
  19620,
  19738,
  19887,
  40870,
  59244,
  59336,
  59367,
  59413,
  59417,
  59423,
  59431,
  59437,
  59443,
  59452,
  59460,
  59478,
  59493,
  63789,
  63866,
  63894,
  63976,
  63986,
  64016,
  64018,
  64021,
  64025,
  64034,
  64037,
  64042,
  65074,
  65093,
  65107,
  65112,
  65127,
  65132,
  65375,
  65510,
  65536
];
const gbChars = [
  0,
  36,
  38,
  45,
  50,
  81,
  89,
  95,
  96,
  100,
  103,
  104,
  105,
  109,
  126,
  133,
  148,
  172,
  175,
  179,
  208,
  306,
  307,
  308,
  309,
  310,
  311,
  312,
  313,
  341,
  428,
  443,
  544,
  545,
  558,
  741,
  742,
  749,
  750,
  805,
  819,
  820,
  7922,
  7924,
  7925,
  7927,
  7934,
  7943,
  7944,
  7945,
  7950,
  8062,
  8148,
  8149,
  8152,
  8164,
  8174,
  8236,
  8240,
  8262,
  8264,
  8374,
  8380,
  8381,
  8384,
  8388,
  8390,
  8392,
  8393,
  8394,
  8396,
  8401,
  8406,
  8416,
  8419,
  8424,
  8437,
  8439,
  8445,
  8482,
  8485,
  8496,
  8521,
  8603,
  8936,
  8946,
  9046,
  9050,
  9063,
  9066,
  9076,
  9092,
  9100,
  9108,
  9111,
  9113,
  9131,
  9162,
  9164,
  9218,
  9219,
  11329,
  11331,
  11334,
  11336,
  11346,
  11361,
  11363,
  11366,
  11370,
  11372,
  11375,
  11389,
  11682,
  11686,
  11687,
  11692,
  11694,
  11714,
  11716,
  11723,
  11725,
  11730,
  11736,
  11982,
  11989,
  12102,
  12336,
  12348,
  12350,
  12384,
  12393,
  12395,
  12397,
  12510,
  12553,
  12851,
  12962,
  12973,
  13738,
  13823,
  13919,
  13933,
  14080,
  14298,
  14585,
  14698,
  15583,
  15847,
  16318,
  16434,
  16438,
  16481,
  16729,
  17102,
  17122,
  17315,
  17320,
  17402,
  17418,
  17859,
  17909,
  17911,
  17915,
  17916,
  17936,
  17939,
  17961,
  18664,
  18703,
  18814,
  18962,
  19043,
  33469,
  33470,
  33471,
  33484,
  33485,
  33490,
  33497,
  33501,
  33505,
  33513,
  33520,
  33536,
  33550,
  37845,
  37921,
  37948,
  38029,
  38038,
  38064,
  38065,
  38066,
  38069,
  38075,
  38076,
  38078,
  39108,
  39109,
  39113,
  39114,
  39115,
  39116,
  39265,
  39394,
  189e3
];
const require$$4 = {
  uChars,
  gbChars
};
const require$$5 = [
  [
    "0",
    "\0",
    127
  ],
  [
    "8141",
    "ê°‚ê°ƒê°…ê°†ê°‹",
    4,
    "ê°˜ê°žê°Ÿê°¡ê°¢ê°£ê°¥",
    6,
    "ê°®ê°²ê°³ê°´"
  ],
  [
    "8161",
    "ê°µê°¶ê°·ê°ºê°»ê°½ê°¾ê°¿ê±",
    9,
    "ê±Œê±Ž",
    5,
    "ê±•"
  ],
  [
    "8181",
    "ê±–ê±—ê±™ê±šê±›ê±",
    18,
    "ê±²ê±³ê±µê±¶ê±¹ê±»",
    4,
    "ê²‚ê²‡ê²ˆê²ê²Žê²ê²‘ê²’ê²“ê²•",
    6,
    "ê²žê²¢",
    5,
    "ê²«ê²­ê²®ê²±",
    6,
    "ê²ºê²¾ê²¿ê³€ê³‚ê³ƒê³…ê³†ê³‡ê³‰ê³Šê³‹ê³",
    7,
    "ê³–ê³˜",
    7,
    "ê³¢ê³£ê³¥ê³¦ê³©ê³«ê³­ê³®ê³²ê³´ê³·",
    4,
    "ê³¾ê³¿ê´ê´‚ê´ƒê´…ê´‡",
    4,
    "ê´Žê´ê´’ê´“"
  ],
  [
    "8241",
    "ê´”ê´•ê´–ê´—ê´™ê´šê´›ê´ê´žê´Ÿê´¡",
    7,
    "ê´ªê´«ê´®",
    5
  ],
  [
    "8261",
    "ê´¶ê´·ê´¹ê´ºê´»ê´½",
    6,
    "êµ†êµˆêµŠ",
    5,
    "êµ‘êµ’êµ“êµ•êµ–êµ—"
  ],
  [
    "8281",
    "êµ™",
    7,
    "êµ¢êµ¤",
    7,
    "êµ®êµ¯êµ±êµ²êµ·êµ¸êµ¹êµºêµ¾ê¶€ê¶ƒ",
    4,
    "ê¶Šê¶‹ê¶ê¶Žê¶ê¶‘",
    10,
    "ê¶ž",
    5,
    "ê¶¥",
    17,
    "ê¶¸",
    7,
    "ê·‚ê·ƒê·…ê·†ê·‡ê·‰",
    6,
    "ê·’ê·”",
    7,
    "ê·ê·žê·Ÿê·¡ê·¢ê·£ê·¥",
    18
  ],
  [
    "8341",
    "ê·ºê·»ê·½ê·¾ê¸‚",
    5,
    "ê¸Šê¸Œê¸Ž",
    5,
    "ê¸•",
    7
  ],
  [
    "8361",
    "ê¸",
    18,
    "ê¸²ê¸³ê¸µê¸¶ê¸¹ê¸»ê¸¼"
  ],
  [
    "8381",
    "ê¸½ê¸¾ê¸¿ê¹‚ê¹„ê¹‡ê¹ˆê¹‰ê¹‹ê¹ê¹‘ê¹’ê¹“ê¹•ê¹—",
    4,
    "ê¹žê¹¢ê¹£ê¹¤ê¹¦ê¹§ê¹ªê¹«ê¹­ê¹®ê¹¯ê¹±",
    6,
    "ê¹ºê¹¾",
    5,
    "êº†",
    5,
    "êº",
    46,
    "êº¿ê»ê»‚ê»ƒê»…",
    6,
    "ê»Žê»’",
    5,
    "ê»šê»›ê»",
    8
  ],
  [
    "8441",
    "ê»¦ê»§ê»©ê»ªê»¬ê»®",
    5,
    "ê»µê»¶ê»·ê»¹ê»ºê»»ê»½",
    8
  ],
  [
    "8461",
    "ê¼†ê¼‰ê¼Šê¼‹ê¼Œê¼Žê¼ê¼‘",
    18
  ],
  [
    "8481",
    "ê¼¤",
    7,
    "ê¼®ê¼¯ê¼±ê¼³ê¼µ",
    6,
    "ê¼¾ê½€ê½„ê½…ê½†ê½‡ê½Š",
    5,
    "ê½‘",
    10,
    "ê½ž",
    5,
    "ê½¦",
    18,
    "ê½º",
    5,
    "ê¾ê¾‚ê¾ƒê¾…ê¾†ê¾‡ê¾‰",
    6,
    "ê¾’ê¾“ê¾”ê¾–",
    5,
    "ê¾",
    26,
    "ê¾ºê¾»ê¾½ê¾¾"
  ],
  [
    "8541",
    "ê¾¿ê¿",
    5,
    "ê¿Šê¿Œê¿",
    4,
    "ê¿•",
    6,
    "ê¿",
    4
  ],
  [
    "8561",
    "ê¿¢",
    5,
    "ê¿ª",
    5,
    "ê¿²ê¿³ê¿µê¿¶ê¿·ê¿¹",
    6,
    "ë€‚ë€ƒ"
  ],
  [
    "8581",
    "ë€…",
    6,
    "ë€ë€Žë€ë€‘ë€’ë€“ë€•",
    6,
    "ë€ž",
    9,
    "ë€©",
    26,
    "ë†ë‡ë‰ë‹ëëëë‘ë’ë–ë˜ëšë›ëœëž",
    29,
    "ë¾ë¿ë‚ë‚‚ë‚ƒë‚…",
    6,
    "ë‚Žë‚ë‚’",
    5,
    "ë‚›ë‚ë‚žë‚£ë‚¤"
  ],
  [
    "8641",
    "ë‚¥ë‚¦ë‚§ë‚ªë‚°ë‚²ë‚¶ë‚·ë‚¹ë‚ºë‚»ë‚½",
    6,
    "ëƒ†ëƒŠ",
    5,
    "ëƒ’"
  ],
  [
    "8661",
    "ëƒ“ëƒ•ëƒ–ëƒ—ëƒ™",
    6,
    "ëƒ¡ëƒ¢ëƒ£ëƒ¤ëƒ¦",
    10
  ],
  [
    "8681",
    "ëƒ±",
    22,
    "ë„Šë„ë„Žë„ë„‘ë„”ë„•ë„–ë„—ë„šë„ž",
    4,
    "ë„¦ë„§ë„©ë„ªë„«ë„­",
    6,
    "ë„¶ë„º",
    5,
    "ë…‚ë…ƒë……ë…†ë…‡ë…‰",
    6,
    "ë…’ë…“ë…–ë…—ë…™ë…šë…›ë…ë…žë…Ÿë…¡",
    22,
    "ë…ºë…»ë…½ë…¾ë…¿ë†ë†ƒ",
    4,
    "ë†Šë†Œë†Žë†ë†ë†‘ë†•ë†–ë†—ë†™ë†šë†›ë†"
  ],
  [
    "8741",
    "ë†ž",
    9,
    "ë†©",
    15
  ],
  [
    "8761",
    "ë†¹",
    18,
    "ë‡ë‡Žë‡ë‡‘ë‡’ë‡“ë‡•"
  ],
  [
    "8781",
    "ë‡–",
    5,
    "ë‡žë‡ ",
    7,
    "ë‡ªë‡«ë‡­ë‡®ë‡¯ë‡±",
    7,
    "ë‡ºë‡¼ë‡¾",
    5,
    "ëˆ†ëˆ‡ëˆ‰ëˆŠëˆ",
    6,
    "ëˆ–ëˆ˜ëˆš",
    5,
    "ëˆ¡",
    18,
    "ëˆµ",
    6,
    "ëˆ½",
    26,
    "ë‰™ë‰šë‰›ë‰ë‰žë‰Ÿë‰¡",
    6,
    "ë‰ª",
    4
  ],
  [
    "8841",
    "ë‰¯",
    4,
    "ë‰¶",
    5,
    "ë‰½",
    6,
    "ëŠ†ëŠ‡ëŠˆëŠŠ",
    4
  ],
  [
    "8861",
    "ëŠëŠ’ëŠ“ëŠ•ëŠ–ëŠ—ëŠ›",
    4,
    "ëŠ¢ëŠ¤ëŠ§ëŠ¨ëŠ©ëŠ«ëŠ­ëŠ®ëŠ¯ëŠ±ëŠ²ëŠ³ëŠµëŠ¶ëŠ·"
  ],
  [
    "8881",
    "ëŠ¸",
    15,
    "ë‹Šë‹‹ë‹ë‹Žë‹ë‹‘ë‹“",
    4,
    "ë‹šë‹œë‹žë‹Ÿë‹ ë‹¡ë‹£ë‹§ë‹©ë‹ªë‹°ë‹±ë‹²ë‹¶ë‹¼ë‹½ë‹¾ëŒ‚ëŒƒëŒ…ëŒ†ëŒ‡ëŒ‰",
    6,
    "ëŒ’ëŒ–",
    5,
    "ëŒ",
    54,
    "ë—ë™ëšëë ë¡ë¢ë£"
  ],
  [
    "8941",
    "ë¦ë¨ëªë¬ë­ë¯ë²ë³ëµë¶ë·ë¹",
    6,
    "ëŽ‚ëŽ†",
    5,
    "ëŽ"
  ],
  [
    "8961",
    "ëŽŽëŽëŽ‘ëŽ’ëŽ“ëŽ•",
    10,
    "ëŽ¢",
    5,
    "ëŽ©ëŽªëŽ«ëŽ­"
  ],
  [
    "8981",
    "ëŽ®",
    21,
    "ë†ë‡ë‰ëŠëëë‘ë’ë“ë–ë˜ëšëœëžëŸë¡ë¢ë£ë¥ë¦ë§ë©",
    18,
    "ë½",
    18,
    "ë‘",
    6,
    "ë™ëšë›ëëžëŸë¡",
    6,
    "ëªë¬",
    7,
    "ëµ",
    15
  ],
  [
    "8a41",
    "ë‘…",
    10,
    "ë‘’ë‘“ë‘•ë‘–ë‘—ë‘™",
    6,
    "ë‘¢ë‘¤ë‘¦"
  ],
  [
    "8a61",
    "ë‘§",
    4,
    "ë‘­",
    18,
    "ë’ë’‚"
  ],
  [
    "8a81",
    "ë’ƒ",
    4,
    "ë’‰",
    19,
    "ë’ž",
    5,
    "ë’¥ë’¦ë’§ë’©ë’ªë’«ë’­",
    7,
    "ë’¶ë’¸ë’º",
    5,
    "ë“ë“‚ë“ƒë“…ë“†ë“‡ë“‰",
    6,
    "ë“‘ë“’ë““ë“”ë“–",
    5,
    "ë“žë“Ÿë“¡ë“¢ë“¥ë“§",
    4,
    "ë“®ë“°ë“²",
    5,
    "ë“¹",
    26,
    "ë”–ë”—ë”™ë”šë”"
  ],
  [
    "8b41",
    "ë”ž",
    5,
    "ë”¦ë”«",
    4,
    "ë”²ë”³ë”µë”¶ë”·ë”¹",
    6,
    "ë•‚ë•†"
  ],
  [
    "8b61",
    "ë•‡ë•ˆë•‰ë•Šë•Žë•ë•‘ë•’ë•“ë••",
    6,
    "ë•žë•¢",
    8
  ],
  [
    "8b81",
    "ë•«",
    52,
    "ë–¢ë–£ë–¥ë–¦ë–§ë–©ë–¬ë–­ë–®ë–¯ë–²ë–¶",
    4,
    "ë–¾ë–¿ë—ë—‚ë—ƒë—…",
    6,
    "ë—Žë—’",
    5,
    "ë—™",
    18,
    "ë—­",
    18
  ],
  [
    "8c41",
    "ë˜€",
    15,
    "ë˜’ë˜“ë˜•ë˜–ë˜—ë˜™",
    4
  ],
  [
    "8c61",
    "ë˜ž",
    6,
    "ë˜¦",
    5,
    "ë˜­",
    6,
    "ë˜µ",
    5
  ],
  [
    "8c81",
    "ë˜»",
    12,
    "ë™‰",
    26,
    "ë™¥ë™¦ë™§ë™©",
    50,
    "ëšžëšŸëš¡ëš¢ëš£ëš¥",
    5,
    "ëš­ëš®ëš¯ëš°ëš²",
    16
  ],
  [
    "8d41",
    "ë›ƒ",
    16,
    "ë›•",
    8
  ],
  [
    "8d61",
    "ë›ž",
    17,
    "ë›±ë›²ë›³ë›µë›¶ë›·ë›¹ë›º"
  ],
  [
    "8d81",
    "ë›»",
    4,
    "ëœ‚ëœƒëœ„ëœ†",
    33,
    "ëœªëœ«ëœ­ëœ®ëœ±",
    6,
    "ëœºëœ¼",
    7,
    "ë…ë†ë‡ë‰ëŠë‹ë",
    6,
    "ë–",
    9,
    "ë¡ë¢ë£ë¥ë¦ë§ë©",
    6,
    "ë²ë´ë¶",
    5,
    "ë¾ë¿ëžëž‚ëžƒëž…",
    6,
    "ëžŽëž“ëž”ëž•ëžšëž›ëžëžž"
  ],
  [
    "8e41",
    "ëžŸëž¡",
    6,
    "ëžªëž®",
    5,
    "ëž¶ëž·ëž¹",
    8
  ],
  [
    "8e61",
    "ëŸ‚",
    4,
    "ëŸˆëŸŠ",
    19
  ],
  [
    "8e81",
    "ëŸž",
    13,
    "ëŸ®ëŸ¯ëŸ±ëŸ²ëŸ³ëŸµ",
    6,
    "ëŸ¾ë ‚",
    4,
    "ë Šë ‹ë ë Žë ë ‘",
    6,
    "ë šë œë ž",
    5,
    "ë ¦ë §ë ©ë ªë «ë ­",
    6,
    "ë ¶ë º",
    5,
    "ë¡ë¡‚ë¡ƒë¡…",
    11,
    "ë¡’ë¡”",
    7,
    "ë¡žë¡Ÿë¡¡ë¡¢ë¡£ë¡¥",
    6,
    "ë¡®ë¡°ë¡²",
    5,
    "ë¡¹ë¡ºë¡»ë¡½",
    7
  ],
  [
    "8f41",
    "ë¢…",
    7,
    "ë¢Ž",
    17
  ],
  [
    "8f61",
    "ë¢ ",
    7,
    "ë¢©",
    6,
    "ë¢±ë¢²ë¢³ë¢µë¢¶ë¢·ë¢¹",
    4
  ],
  [
    "8f81",
    "ë¢¾ë¢¿ë£‚ë£„ë£†",
    5,
    "ë£ë£Žë£ë£‘ë£’ë£“ë£•",
    7,
    "ë£žë£ ë£¢",
    5,
    "ë£ªë£«ë£­ë£®ë£¯ë£±",
    6,
    "ë£ºë£¼ë£¾",
    5,
    "ë¤…",
    18,
    "ë¤™",
    6,
    "ë¤¡",
    26,
    "ë¤¾ë¤¿ë¥ë¥‚ë¥ƒë¥…",
    6,
    "ë¥ë¥Žë¥ë¥’",
    5
  ],
  [
    "9041",
    "ë¥šë¥›ë¥ë¥žë¥Ÿë¥¡",
    6,
    "ë¥ªë¥¬ë¥®",
    5,
    "ë¥¶ë¥·ë¥¹ë¥ºë¥»ë¥½"
  ],
  [
    "9061",
    "ë¥¾",
    5,
    "ë¦†ë¦ˆë¦‹ë¦Œë¦",
    15
  ],
  [
    "9081",
    "ë¦Ÿ",
    12,
    "ë¦®ë¦¯ë¦±ë¦²ë¦³ë¦µ",
    6,
    "ë¦¾ë§€ë§‚",
    5,
    "ë§Šë§‹ë§ë§“",
    4,
    "ë§šë§œë§Ÿë§ ë§¢ë§¦ë§§ë§©ë§ªë§«ë§­",
    6,
    "ë§¶ë§»",
    4,
    "ë¨‚",
    5,
    "ë¨‰",
    11,
    "ë¨–",
    33,
    "ë¨ºë¨»ë¨½ë¨¾ë¨¿ë©ë©ƒë©„ë©…ë©†"
  ],
  [
    "9141",
    "ë©‡ë©Šë©Œë©ë©ë©‘ë©’ë©–ë©—ë©™ë©šë©›ë©",
    6,
    "ë©¦ë©ª",
    5
  ],
  [
    "9161",
    "ë©²ë©³ë©µë©¶ë©·ë©¹",
    9,
    "ëª†ëªˆëª‰ëªŠëª‹ëª",
    5
  ],
  [
    "9181",
    "ëª“",
    20,
    "ëªªëª­ëª®ëª¯ëª±ëª³",
    4,
    "ëªºëª¼ëª¾",
    5,
    "ë«…ë«†ë«‡ë«‰",
    14,
    "ë«š",
    33,
    "ë«½ë«¾ë«¿ë¬ë¬‚ë¬ƒë¬…",
    7,
    "ë¬Žë¬ë¬’",
    5,
    "ë¬™ë¬šë¬›ë¬ë¬žë¬Ÿë¬¡",
    6
  ],
  [
    "9241",
    "ë¬¨ë¬ªë¬¬",
    7,
    "ë¬·ë¬¹ë¬ºë¬¿",
    4,
    "ë­†ë­ˆë­Šë­‹ë­Œë­Žë­‘ë­’"
  ],
  [
    "9261",
    "ë­“ë­•ë­–ë­—ë­™",
    7,
    "ë­¢ë­¤",
    7,
    "ë­­",
    4
  ],
  [
    "9281",
    "ë­²",
    21,
    "ë®‰ë®Šë®‹ë®ë®Žë®ë®‘",
    18,
    "ë®¥ë®¦ë®§ë®©ë®ªë®«ë®­",
    6,
    "ë®µë®¶ë®¸",
    7,
    "ë¯ë¯‚ë¯ƒë¯…ë¯†ë¯‡ë¯‰",
    6,
    "ë¯‘ë¯’ë¯”",
    35,
    "ë¯ºë¯»ë¯½ë¯¾ë°"
  ],
  [
    "9341",
    "ë°ƒ",
    4,
    "ë°Šë°Žë°ë°’ë°“ë°™ë°šë° ë°¡ë°¢ë°£ë°¦ë°¨ë°ªë°«ë°¬ë°®ë°¯ë°²ë°³ë°µ"
  ],
  [
    "9361",
    "ë°¶ë°·ë°¹",
    6,
    "ë±‚ë±†ë±‡ë±ˆë±Šë±‹ë±Žë±ë±‘",
    8
  ],
  [
    "9381",
    "ë±šë±›ë±œë±ž",
    37,
    "ë²†ë²‡ë²‰ë²Šë²ë²",
    4,
    "ë²–ë²˜ë²›",
    4,
    "ë²¢ë²£ë²¥ë²¦ë²©",
    6,
    "ë²²ë²¶",
    5,
    "ë²¾ë²¿ë³ë³‚ë³ƒë³…",
    7,
    "ë³Žë³’ë³“ë³”ë³–ë³—ë³™ë³šë³›ë³",
    22,
    "ë³·ë³¹ë³ºë³»ë³½"
  ],
  [
    "9441",
    "ë³¾",
    5,
    "ë´†ë´ˆë´Š",
    5,
    "ë´‘ë´’ë´“ë´•",
    8
  ],
  [
    "9461",
    "ë´ž",
    5,
    "ë´¥",
    6,
    "ë´­",
    12
  ],
  [
    "9481",
    "ë´º",
    5,
    "ëµ",
    6,
    "ëµŠëµ‹ëµëµŽëµëµ‘",
    6,
    "ëµš",
    9,
    "ëµ¥ëµ¦ëµ§ëµ©",
    22,
    "ë¶‚ë¶ƒë¶…ë¶†ë¶‹",
    4,
    "ë¶’ë¶”ë¶–ë¶—ë¶˜ë¶›ë¶",
    6,
    "ë¶¥",
    10,
    "ë¶±",
    6,
    "ë¶¹",
    24
  ],
  [
    "9541",
    "ë·’ë·“ë·–ë·—ë·™ë·šë·›ë·",
    11,
    "ë·ª",
    5,
    "ë·±"
  ],
  [
    "9561",
    "ë·²ë·³ë·µë·¶ë··ë·¹",
    6,
    "ë¸ë¸‚ë¸„ë¸†",
    5,
    "ë¸Žë¸ë¸‘ë¸’ë¸“"
  ],
  [
    "9581",
    "ë¸•",
    6,
    "ë¸žë¸ ",
    35,
    "ë¹†ë¹‡ë¹‰ë¹Šë¹‹ë¹ë¹",
    4,
    "ë¹–ë¹˜ë¹œë¹ë¹žë¹Ÿë¹¢ë¹£ë¹¥ë¹¦ë¹§ë¹©ë¹«",
    4,
    "ë¹²ë¹¶",
    4,
    "ë¹¾ë¹¿ëºëº‚ëºƒëº…",
    6,
    "ëºŽëº’",
    5,
    "ëºš",
    13,
    "ëº©",
    14
  ],
  [
    "9641",
    "ëº¸",
    23,
    "ë»’ë»“"
  ],
  [
    "9661",
    "ë»•ë»–ë»™",
    6,
    "ë»¡ë»¢ë»¦",
    5,
    "ë»­",
    8
  ],
  [
    "9681",
    "ë»¶",
    10,
    "ë¼‚",
    5,
    "ë¼Š",
    13,
    "ë¼šë¼ž",
    33,
    "ë½‚ë½ƒë½…ë½†ë½‡ë½‰",
    6,
    "ë½’ë½“ë½”ë½–",
    44
  ],
  [
    "9741",
    "ë¾ƒ",
    16,
    "ë¾•",
    8
  ],
  [
    "9761",
    "ë¾ž",
    17,
    "ë¾±",
    7
  ],
  [
    "9781",
    "ë¾¹",
    11,
    "ë¿†",
    5,
    "ë¿Žë¿ë¿‘ë¿’ë¿“ë¿•",
    6,
    "ë¿ë¿žë¿ ë¿¢",
    89,
    "ì€½ì€¾ì€¿"
  ],
  [
    "9841",
    "ì€",
    16,
    "ì’",
    5,
    "ì™ìšì›"
  ],
  [
    "9861",
    "ììžìŸì¡",
    6,
    "ìª",
    15
  ],
  [
    "9881",
    "ìº",
    21,
    "ì‚’ì‚“ì‚•ì‚–ì‚—ì‚™",
    6,
    "ì‚¢ì‚¤ì‚¦",
    5,
    "ì‚®ì‚±ì‚²ì‚·",
    4,
    "ì‚¾ìƒ‚ìƒƒìƒ„ìƒ†ìƒ‡ìƒŠìƒ‹ìƒìƒŽìƒìƒ‘",
    6,
    "ìƒšìƒž",
    5,
    "ìƒ¦ìƒ§ìƒ©ìƒªìƒ«ìƒ­",
    6,
    "ìƒ¶ìƒ¸ìƒº",
    5,
    "ì„ì„‚ì„ƒì„…ì„†ì„‡ì„‰",
    6,
    "ì„‘ì„’ì„“ì„”ì„–",
    5,
    "ì„¡ì„¢ì„¥ì„¨ì„©ì„ªì„«ì„®"
  ],
  [
    "9941",
    "ì„²ì„³ì„´ì„µì„·ì„ºì„»ì„½ì„¾ì„¿ì…",
    6,
    "ì…Šì…Ž",
    5,
    "ì…–ì…—"
  ],
  [
    "9961",
    "ì…™ì…šì…›ì…",
    6,
    "ì…¦ì…ª",
    5,
    "ì…±ì…²ì…³ì…µì…¶ì…·ì…¹ì…ºì…»"
  ],
  [
    "9981",
    "ì…¼",
    8,
    "ì††",
    5,
    "ì†ì†‘ì†’ì†“ì†•ì†—",
    4,
    "ì†žì† ì†¢ì†£ì†¤ì†¦ì†§ì†ªì†«ì†­ì†®ì†¯ì†±",
    11,
    "ì†¾",
    5,
    "ì‡…ì‡†ì‡‡ì‡‰ì‡Šì‡‹ì‡",
    6,
    "ì‡•ì‡–ì‡™",
    6,
    "ì‡¡ì‡¢ì‡£ì‡¥ì‡¦ì‡§ì‡©",
    6,
    "ì‡²ì‡´",
    7,
    "ì‡¾ì‡¿ìˆìˆ‚ìˆƒìˆ…",
    6,
    "ìˆŽìˆìˆ’",
    5,
    "ìˆšìˆ›ìˆìˆžìˆ¡ìˆ¢ìˆ£"
  ],
  [
    "9a41",
    "ìˆ¤ìˆ¥ìˆ¦ìˆ§ìˆªìˆ¬ìˆ®ìˆ°ìˆ³ìˆµ",
    16
  ],
  [
    "9a61",
    "ì‰†ì‰‡ì‰‰",
    6,
    "ì‰’ì‰“ì‰•ì‰–ì‰—ì‰™",
    6,
    "ì‰¡ì‰¢ì‰£ì‰¤ì‰¦"
  ],
  [
    "9a81",
    "ì‰§",
    4,
    "ì‰®ì‰¯ì‰±ì‰²ì‰³ì‰µ",
    6,
    "ì‰¾ìŠ€ìŠ‚",
    5,
    "ìŠŠ",
    5,
    "ìŠ‘",
    6,
    "ìŠ™ìŠšìŠœìŠž",
    5,
    "ìŠ¦ìŠ§ìŠ©ìŠªìŠ«ìŠ®",
    5,
    "ìŠ¶ìŠ¸ìŠº",
    33,
    "ì‹žì‹Ÿì‹¡ì‹¢ì‹¥",
    5,
    "ì‹®ì‹°ì‹²ì‹³ì‹´ì‹µì‹·ì‹ºì‹½ì‹¾ì‹¿ìŒ",
    6,
    "ìŒŠìŒ‹ìŒŽìŒ"
  ],
  [
    "9b41",
    "ìŒìŒ‘ìŒ’ìŒ–ìŒ—ìŒ™ìŒšìŒ›ìŒ",
    6,
    "ìŒ¦ìŒ§ìŒª",
    8
  ],
  [
    "9b61",
    "ìŒ³",
    17,
    "ì†",
    7
  ],
  [
    "9b81",
    "ìŽ",
    25,
    "ìªì«ì­ì®ì¯ì±ì³",
    4,
    "ìºì»ì¾",
    5,
    "ìŽ…ìŽ†ìŽ‡ìŽ‰ìŽŠìŽ‹ìŽ",
    50,
    "ì",
    22,
    "ìš"
  ],
  [
    "9c41",
    "ì›ììžì¡ì£",
    4,
    "ìªì«ì¬ì®",
    5,
    "ì¶ì·ì¹",
    5
  ],
  [
    "9c61",
    "ì¿",
    8,
    "ì‰",
    6,
    "ì‘",
    9
  ],
  [
    "9c81",
    "ì›",
    8,
    "ì¥",
    6,
    "ì­ì®ì¯ì±ì²ì³ìµ",
    6,
    "ì¾",
    9,
    "ì‘‰",
    26,
    "ì‘¦ì‘§ì‘©ì‘ªì‘«ì‘­",
    6,
    "ì‘¶ì‘·ì‘¸ì‘º",
    5,
    "ì’",
    18,
    "ì’•",
    6,
    "ì’",
    12
  ],
  [
    "9d41",
    "ì’ª",
    13,
    "ì’¹ì’ºì’»ì’½",
    8
  ],
  [
    "9d61",
    "ì“†",
    25
  ],
  [
    "9d81",
    "ì“ ",
    8,
    "ì“ª",
    5,
    "ì“²ì“³ì“µì“¶ì“·ì“¹ì“»ì“¼ì“½ì“¾ì”‚",
    9,
    "ì”ì”Žì”ì”‘ì”’ì”“ì”•",
    6,
    "ì”",
    10,
    "ì”ªì”«ì”­ì”®ì”¯ì”±",
    6,
    "ì”ºì”¼ì”¾",
    5,
    "ì•†ì•‡ì•‹ì•ì•ì•‘ì•’ì•–ì•šì•›ì•œì•Ÿì•¢ì•£ì•¥ì•¦ì•§ì•©",
    6,
    "ì•²ì•¶",
    5,
    "ì•¾ì•¿ì–ì–‚ì–ƒì–…ì–†ì–ˆì–‰ì–Šì–‹ì–Žì–ì–’ì–“ì–”"
  ],
  [
    "9e41",
    "ì––ì–™ì–šì–›ì–ì–žì–Ÿì–¡",
    7,
    "ì–ª",
    9,
    "ì–¶"
  ],
  [
    "9e61",
    "ì–·ì–ºì–¿",
    4,
    "ì—‹ì—ì—ì—’ì—“ì—•ì—–ì——ì—™",
    6,
    "ì—¢ì—¤ì—¦ì—§"
  ],
  [
    "9e81",
    "ì—¨ì—©ì—ªì—«ì—¯ì—±ì—²ì—³ì—µì—¸ì—¹ì—ºì—»ì˜‚ì˜ƒì˜„ì˜‰ì˜Šì˜‹ì˜ì˜Žì˜ì˜‘",
    6,
    "ì˜šì˜",
    6,
    "ì˜¦ì˜§ì˜©ì˜ªì˜«ì˜¯ì˜±ì˜²ì˜¶ì˜¸ì˜ºì˜¼ì˜½ì˜¾ì˜¿ì™‚ì™ƒì™…ì™†ì™‡ì™‰",
    6,
    "ì™’ì™–",
    5,
    "ì™žì™Ÿì™¡",
    10,
    "ì™­ì™®ì™°ì™²",
    5,
    "ì™ºì™»ì™½ì™¾ì™¿ìš",
    6,
    "ìšŠìšŒìšŽ",
    5,
    "ìš–ìš—ìš™ìššìš›ìš",
    6,
    "ìš¦"
  ],
  [
    "9f41",
    "ìš¨ìšª",
    5,
    "ìš²ìš³ìšµìš¶ìš·ìš»",
    4,
    "ì›‚ì›„ì›†",
    5,
    "ì›Ž"
  ],
  [
    "9f61",
    "ì›ì›‘ì›’ì›“ì›•",
    6,
    "ì›žì›Ÿì›¢",
    5,
    "ì›ªì›«ì›­ì›®ì›¯ì›±ì›²"
  ],
  [
    "9f81",
    "ì›³",
    4,
    "ì›ºì›»ì›¼ì›¾",
    5,
    "ìœ†ìœ‡ìœ‰ìœŠìœ‹ìœ",
    6,
    "ìœ–ìœ˜ìœš",
    5,
    "ìœ¢ìœ£ìœ¥ìœ¦ìœ§ìœ©",
    6,
    "ìœ²ìœ´ìœ¶ìœ¸ìœ¹ìœºìœ»ìœ¾ìœ¿ìì‚ìƒì…",
    4,
    "ì‹ìŽìì™ìšì›ììžìŸì¡",
    6,
    "ì©ìªì¬",
    7,
    "ì¶ì·ì¹ìºì»ì¿ìž€ìžìž‚ìž†ìž‹ìžŒìžìžìž’ìž“ìž•ìž™ìž›",
    4,
    "ìž¢ìž§",
    4,
    "ìž®ìž¯ìž±ìž²ìž³ìžµìž¶ìž·"
  ],
  [
    "a041",
    "ìž¸ìž¹ìžºìž»ìž¾ìŸ‚",
    5,
    "ìŸŠìŸ‹ìŸìŸìŸ‘",
    6,
    "ìŸ™ìŸšìŸ›ìŸœ"
  ],
  [
    "a061",
    "ìŸž",
    5,
    "ìŸ¥ìŸ¦ìŸ§ìŸ©ìŸªìŸ«ìŸ­",
    13
  ],
  [
    "a081",
    "ìŸ»",
    4,
    "ì ‚ì ƒì …ì †ì ‡ì ‰ì ‹",
    4,
    "ì ’ì ”ì —",
    4,
    "ì žì Ÿì ¡ì ¢ì £ì ¥",
    6,
    "ì ®ì °ì ²",
    5,
    "ì ¹ì ºì »ì ½ì ¾ì ¿ì¡",
    6,
    "ì¡Šì¡‹ì¡Ž",
    5,
    "ì¡•",
    26,
    "ì¡²ì¡³ì¡µì¡¶ì¡·ì¡¹ì¡»",
    4,
    "ì¢‚ì¢„ì¢ˆì¢‰ì¢Šì¢Ž",
    5,
    "ì¢•",
    7,
    "ì¢žì¢ ì¢¢ì¢£ì¢¤"
  ],
  [
    "a141",
    "ì¢¥ì¢¦ì¢§ì¢©",
    18,
    "ì¢¾ì¢¿ì£€ì£"
  ],
  [
    "a161",
    "ì£‚ì£ƒì£…ì£†ì£‡ì£‰ì£Šì£‹ì£",
    6,
    "ì£–ì£˜ì£š",
    5,
    "ì£¢ì££ì£¥"
  ],
  [
    "a181",
    "ì£¦",
    14,
    "ì£¶",
    5,
    "ì£¾ì£¿ì¤ì¤‚ì¤ƒì¤‡",
    4,
    "ì¤Žã€€ã€ã€‚Â·â€¥â€¦Â¨ã€ƒÂ­â€•âˆ¥ï¼¼âˆ¼â€˜â€™â€œâ€ã€”ã€•ã€ˆ",
    9,
    "Â±Ã—Ã·â‰ â‰¤â‰¥âˆžâˆ´Â°â€²â€³â„ƒâ„«ï¿ ï¿¡ï¿¥â™‚â™€âˆ âŠ¥âŒ’âˆ‚âˆ‡â‰¡â‰’Â§â€»â˜†â˜…â—‹â—â—Žâ—‡â—†â–¡â– â–³â–²â–½â–¼â†’â†â†‘â†“â†”ã€“â‰ªâ‰«âˆšâˆ½âˆâˆµâˆ«âˆ¬âˆˆâˆ‹âŠ†âŠ‡âŠ‚âŠƒâˆªâˆ©âˆ§âˆ¨ï¿¢"
  ],
  [
    "a241",
    "ì¤ì¤’",
    5,
    "ì¤™",
    18
  ],
  [
    "a261",
    "ì¤­",
    6,
    "ì¤µ",
    18
  ],
  [
    "a281",
    "ì¥ˆ",
    7,
    "ì¥’ì¥“ì¥•ì¥–ì¥—ì¥™",
    6,
    "ì¥¢ì¥¤",
    7,
    "ì¥­ì¥®ì¥¯â‡’â‡”âˆ€âˆƒÂ´ï½žË‡Ë˜ËËšË™Â¸Ë›Â¡Â¿Ëâˆ®âˆ‘âˆÂ¤â„‰â€°â—â—€â–·â–¶â™¤â™ â™¡â™¥â™§â™£âŠ™â—ˆâ–£â—â—‘â–’â–¤â–¥â–¨â–§â–¦â–©â™¨â˜â˜Žâ˜œâ˜žÂ¶â€ â€¡â†•â†—â†™â†–â†˜â™­â™©â™ªâ™¬ã‰¿ãˆœâ„–ã‡â„¢ã‚ã˜â„¡â‚¬Â®"
  ],
  [
    "a341",
    "ì¥±ì¥²ì¥³ì¥µ",
    6,
    "ì¥½",
    10,
    "ì¦Šì¦‹ì¦ì¦Žì¦"
  ],
  [
    "a361",
    "ì¦‘",
    6,
    "ì¦šì¦œì¦ž",
    16
  ],
  [
    "a381",
    "ì¦¯",
    16,
    "ì§‚ì§ƒì§…ì§†ì§‰ì§‹",
    4,
    "ì§’ì§”ì§—ì§˜ì§›ï¼",
    58,
    "ï¿¦ï¼½",
    32,
    "ï¿£"
  ],
  [
    "a441",
    "ì§žì§Ÿì§¡ì§£ì§¥ì§¦ì§¨ì§©ì§ªì§«ì§®ì§²",
    5,
    "ì§ºì§»ì§½ì§¾ì§¿ì¨ì¨‚ì¨ƒì¨„"
  ],
  [
    "a461",
    "ì¨…ì¨†ì¨‡ì¨Šì¨Ž",
    5,
    "ì¨•ì¨–ì¨—ì¨™",
    12
  ],
  [
    "a481",
    "ì¨¦ì¨§ì¨¨ì¨ª",
    28,
    "ã„±",
    93
  ],
  [
    "a541",
    "ì©‡",
    4,
    "ì©Žì©ì©‘ì©’ì©“ì©•",
    6,
    "ì©žì©¢",
    5,
    "ì©©ì©ª"
  ],
  [
    "a561",
    "ì©«",
    17,
    "ì©¾",
    5,
    "ìª…ìª†"
  ],
  [
    "a581",
    "ìª‡",
    16,
    "ìª™",
    14,
    "â…°",
    9
  ],
  [
    "a5b0",
    "â… ",
    9
  ],
  [
    "a5c1",
    "Î‘",
    16,
    "Î£",
    6
  ],
  [
    "a5e1",
    "Î±",
    16,
    "Ïƒ",
    6
  ],
  [
    "a641",
    "ìª¨",
    19,
    "ìª¾ìª¿ì«ì«‚ì«ƒì«…"
  ],
  [
    "a661",
    "ì«†",
    5,
    "ì«Žì«ì«’ì«”ì«•ì«–ì«—ì«š",
    5,
    "ì«¡",
    6
  ],
  [
    "a681",
    "ì«¨ì«©ì«ªì««ì«­",
    6,
    "ì«µ",
    18,
    "ì¬‰ì¬Šâ”€â”‚â”Œâ”â”˜â””â”œâ”¬â”¤â”´â”¼â”â”ƒâ”â”“â”›â”—â”£â”³â”«â”»â•‹â” â”¯â”¨â”·â”¿â”â”°â”¥â”¸â•‚â”’â”‘â”šâ”™â”–â”•â”Žâ”â”žâ”Ÿâ”¡â”¢â”¦â”§â”©â”ªâ”­â”®â”±â”²â”µâ”¶â”¹â”ºâ”½â”¾â•€â•â•ƒ",
    7
  ],
  [
    "a741",
    "ì¬‹",
    4,
    "ì¬‘ì¬’ì¬“ì¬•ì¬–ì¬—ì¬™",
    6,
    "ì¬¢",
    7
  ],
  [
    "a761",
    "ì¬ª",
    22,
    "ì­‚ì­ƒì­„"
  ],
  [
    "a781",
    "ì­…ì­†ì­‡ì­Šì­‹ì­ì­Žì­ì­‘",
    6,
    "ì­šì­›ì­œì­ž",
    5,
    "ì­¥",
    7,
    "ãŽ•ãŽ–ãŽ—â„“ãŽ˜ã„ãŽ£ãŽ¤ãŽ¥ãŽ¦ãŽ™",
    9,
    "ãŠãŽãŽŽãŽããŽˆãŽ‰ãˆãŽ§ãŽ¨ãŽ°",
    9,
    "ãŽ€",
    4,
    "ãŽº",
    5,
    "ãŽ",
    4,
    "â„¦ã€ããŽŠãŽ‹ãŽŒã–ã…ãŽ­ãŽ®ãŽ¯ã›ãŽ©ãŽªãŽ«ãŽ¬ããã“ãƒã‰ãœã†"
  ],
  [
    "a841",
    "ì­­",
    10,
    "ì­º",
    14
  ],
  [
    "a861",
    "ì®‰",
    18,
    "ì®",
    6
  ],
  [
    "a881",
    "ì®¤",
    19,
    "ì®¹",
    11,
    "Ã†ÃÂªÄ¦"
  ],
  [
    "a8a6",
    "Ä²"
  ],
  [
    "a8a8",
    "Ä¿ÅÃ˜Å’ÂºÃžÅ¦ÅŠ"
  ],
  [
    "a8b1",
    "ã‰ ",
    27,
    "â“",
    25,
    "â‘ ",
    14,
    "Â½â…“â…”Â¼Â¾â…›â…œâ…â…ž"
  ],
  [
    "a941",
    "ì¯…",
    14,
    "ì¯•",
    10
  ],
  [
    "a961",
    "ì¯ ì¯¡ì¯¢ì¯£ì¯¥ì¯¦ì¯¨ì¯ª",
    18
  ],
  [
    "a981",
    "ì¯½",
    14,
    "ì°Žì°ì°‘ì°’ì°“ì°•",
    6,
    "ì°žì°Ÿì° ì°£ì°¤Ã¦Ä‘Ã°Ä§Ä±Ä³Ä¸Å€Å‚Ã¸Å“ÃŸÃ¾Å§Å‹Å‰ãˆ€",
    27,
    "â’œ",
    25,
    "â‘´",
    14,
    "Â¹Â²Â³â´â¿â‚â‚‚â‚ƒâ‚„"
  ],
  [
    "aa41",
    "ì°¥ì°¦ì°ªì°«ì°­ì°¯ì°±",
    6,
    "ì°ºì°¿",
    4,
    "ì±†ì±‡ì±‰ì±Šì±‹ì±ì±Ž"
  ],
  [
    "aa61",
    "ì±",
    4,
    "ì±–ì±š",
    5,
    "ì±¡ì±¢ì±£ì±¥ì±§ì±©",
    6,
    "ì±±ì±²"
  ],
  [
    "aa81",
    "ì±³ì±´ì±¶",
    29,
    "ã",
    82
  ],
  [
    "ab41",
    "ì²”ì²•ì²–ì²—ì²šì²›ì²ì²žì²Ÿì²¡",
    6,
    "ì²ªì²®",
    5,
    "ì²¶ì²·ì²¹"
  ],
  [
    "ab61",
    "ì²ºì²»ì²½",
    6,
    "ì³†ì³ˆì³Š",
    5,
    "ì³‘ì³’ì³“ì³•",
    5
  ],
  [
    "ab81",
    "ì³›",
    8,
    "ì³¥",
    6,
    "ì³­ì³®ì³¯ì³±",
    12,
    "ã‚¡",
    85
  ],
  [
    "ac41",
    "ì³¾ì³¿ì´€ì´‚",
    5,
    "ì´Šì´‹ì´ì´Žì´ì´‘",
    6,
    "ì´šì´œì´žì´Ÿì´ "
  ],
  [
    "ac61",
    "ì´¡ì´¢ì´£ì´¥ì´¦ì´§ì´©ì´ªì´«ì´­",
    11,
    "ì´º",
    4
  ],
  [
    "ac81",
    "ì´¿",
    28,
    "ìµìµžìµŸÐ",
    5,
    "ÐÐ–",
    25
  ],
  [
    "acd1",
    "Ð°",
    5,
    "Ñ‘Ð¶",
    25
  ],
  [
    "ad41",
    "ìµ¡ìµ¢ìµ£ìµ¥",
    6,
    "ìµ®ìµ°ìµ²",
    5,
    "ìµ¹",
    7
  ],
  [
    "ad61",
    "ì¶",
    6,
    "ì¶‰",
    10,
    "ì¶–ì¶—ì¶™ì¶šì¶›ì¶ì¶žì¶Ÿ"
  ],
  [
    "ad81",
    "ì¶ ì¶¡ì¶¢ì¶£ì¶¦ì¶¨ì¶ª",
    5,
    "ì¶±",
    18,
    "ì·…"
  ],
  [
    "ae41",
    "ì·†",
    5,
    "ì·ì·Žì·ì·‘",
    16
  ],
  [
    "ae61",
    "ì·¢",
    5,
    "ì·©ì·ªì·«ì·­ì·®ì·¯ì·±",
    6,
    "ì·ºì·¼ì·¾",
    4
  ],
  [
    "ae81",
    "ì¸ƒì¸…ì¸†ì¸‡ì¸‰ì¸Šì¸‹ì¸",
    6,
    "ì¸•ì¸–ì¸—ì¸˜ì¸š",
    5,
    "ì¸¢ì¸£ì¸¥ì¸¦ì¸§ì¸©ì¸ªì¸«"
  ],
  [
    "af41",
    "ì¸¬ì¸­ì¸®ì¸¯ì¸²ì¸´ì¸¶",
    19
  ],
  [
    "af61",
    "ì¹Š",
    13,
    "ì¹šì¹›ì¹ì¹žì¹¢",
    5,
    "ì¹ªì¹¬"
  ],
  [
    "af81",
    "ì¹®",
    5,
    "ì¹¶ì¹·ì¹¹ì¹ºì¹»ì¹½",
    6,
    "ìº†ìºˆìºŠ",
    5,
    "ìº’ìº“ìº•ìº–ìº—ìº™"
  ],
  [
    "b041",
    "ìºš",
    5,
    "ìº¢ìº¦",
    5,
    "ìº®",
    12
  ],
  [
    "b061",
    "ìº»",
    5,
    "ì»‚",
    19
  ],
  [
    "b081",
    "ì»–",
    13,
    "ì»¦ì»§ì»©ì»ªì»­",
    6,
    "ì»¶ì»º",
    5,
    "ê°€ê°ê°„ê°‡ê°ˆê°‰ê°Šê°",
    7,
    "ê°™",
    4,
    "ê° ê°¤ê°¬ê°­ê°¯ê°°ê°±ê°¸ê°¹ê°¼ê±€ê±‹ê±ê±”ê±˜ê±œê±°ê±±ê±´ê±·ê±¸ê±ºê²€ê²ê²ƒê²„ê²…ê²†ê²‰ê²Šê²‹ê²Œê²ê²”ê²œê²ê²Ÿê² ê²¡ê²¨ê²©ê²ªê²¬ê²¯ê²°ê²¸ê²¹ê²»ê²¼ê²½ê³ê³„ê³ˆê³Œê³•ê³—ê³ ê³¡ê³¤ê³§ê³¨ê³ªê³¬ê³¯ê³°ê³±ê³³ê³µê³¶ê³¼ê³½ê´€ê´„ê´†"
  ],
  [
    "b141",
    "ì¼‚ì¼ƒì¼…ì¼†ì¼‡ì¼‰",
    6,
    "ì¼’ì¼”ì¼–",
    5,
    "ì¼ì¼žì¼Ÿì¼¡ì¼¢ì¼£"
  ],
  [
    "b161",
    "ì¼¥",
    6,
    "ì¼®ì¼²",
    5,
    "ì¼¹",
    11
  ],
  [
    "b181",
    "ì½…",
    14,
    "ì½–ì½—ì½™ì½šì½›ì½",
    6,
    "ì½¦ì½¨ì½ªì½«ì½¬ê´Œê´ê´ê´‘ê´˜ê´œê´ ê´©ê´¬ê´­ê´´ê´µê´¸ê´¼êµ„êµ…êµ‡êµ‰êµêµ”êµ˜êµ¡êµ£êµ¬êµ­êµ°êµ³êµ´êµµêµ¶êµ»êµ¼êµ½êµ¿ê¶ê¶‚ê¶ˆê¶‰ê¶Œê¶ê¶œê¶ê¶¤ê¶·ê·€ê·ê·„ê·ˆê·ê·‘ê·“ê·œê· ê·¤ê·¸ê·¹ê·¼ê·¿ê¸€ê¸ê¸ˆê¸‰ê¸‹ê¸ê¸”ê¸°ê¸±ê¸´ê¸·ê¸¸ê¸ºê¹€ê¹ê¹ƒê¹…ê¹†ê¹Šê¹Œê¹ê¹Žê¹ê¹”ê¹–ê¹œê¹ê¹Ÿê¹ ê¹¡ê¹¥ê¹¨ê¹©ê¹¬ê¹°ê¹¸"
  ],
  [
    "b241",
    "ì½­ì½®ì½¯ì½²ì½³ì½µì½¶ì½·ì½¹",
    6,
    "ì¾ì¾‚ì¾ƒì¾„ì¾†",
    5,
    "ì¾"
  ],
  [
    "b261",
    "ì¾Ž",
    18,
    "ì¾¢",
    5,
    "ì¾©"
  ],
  [
    "b281",
    "ì¾ª",
    5,
    "ì¾±",
    18,
    "ì¿…",
    6,
    "ê¹¹ê¹»ê¹¼ê¹½êº„êº…êºŒêº¼êº½êº¾ê»€ê»„ê»Œê»ê»ê»ê»‘ê»˜ê»™ê»œê»¨ê»«ê»­ê»´ê»¸ê»¼ê¼‡ê¼ˆê¼ê¼ê¼¬ê¼­ê¼°ê¼²ê¼´ê¼¼ê¼½ê¼¿ê½ê½‚ê½ƒê½ˆê½‰ê½ê½œê½ê½¤ê½¥ê½¹ê¾€ê¾„ê¾ˆê¾ê¾‘ê¾•ê¾œê¾¸ê¾¹ê¾¼ê¿€ê¿‡ê¿ˆê¿‰ê¿‹ê¿ê¿Žê¿”ê¿œê¿¨ê¿©ê¿°ê¿±ê¿´ê¿¸ë€€ë€ë€„ë€Œë€ë€”ë€œë€ë€¨ë„ë…ëˆëŠëŒëŽë“ë”ë•ë—ë™"
  ],
  [
    "b341",
    "ì¿Œ",
    19,
    "ì¿¢ì¿£ì¿¥ì¿¦ì¿§ì¿©"
  ],
  [
    "b361",
    "ì¿ª",
    5,
    "ì¿²ì¿´ì¿¶",
    5,
    "ì¿½ì¿¾ì¿¿í€í€‚í€ƒí€…",
    5
  ],
  [
    "b381",
    "í€‹",
    5,
    "í€’",
    5,
    "í€™",
    19,
    "ëë¼ë½ë‚€ë‚„ë‚Œë‚ë‚ë‚‘ë‚˜ë‚™ë‚šë‚œë‚Ÿë‚ ë‚¡ë‚¢ë‚¨ë‚©ë‚«",
    4,
    "ë‚±ë‚³ë‚´ë‚µë‚¸ë‚¼ëƒ„ëƒ…ëƒ‡ëƒˆëƒ‰ëƒëƒ‘ëƒ”ëƒ˜ëƒ ëƒ¥ë„ˆë„‰ë„‹ë„Œë„ë„’ë„“ë„˜ë„™ë„›ë„œë„ë„£ë„¤ë„¥ë„¨ë„¬ë„´ë„µë„·ë„¸ë„¹ë…€ë…ë…„ë…ˆë…ë…‘ë…”ë…•ë…˜ë…œë… ë…¸ë…¹ë…¼ë†€ë†‚ë†ˆë†‰ë†‹ë†ë†’ë†“ë†”ë†˜ë†œë†¨ë‡Œë‡ë‡”ë‡œë‡"
  ],
  [
    "b441",
    "í€®",
    5,
    "í€¶í€·í€¹í€ºí€»í€½",
    6,
    "í†íˆíŠ",
    5
  ],
  [
    "b461",
    "í‘í’í“í•í–í—í™",
    6,
    "í¡",
    10,
    "í®í¯"
  ],
  [
    "b481",
    "í±í²í³íµ",
    6,
    "í¾í¿í‚€í‚‚",
    18,
    "ë‡Ÿë‡¨ë‡©ë‡¬ë‡°ë‡¹ë‡»ë‡½ëˆ„ëˆ…ëˆˆëˆ‹ëˆŒëˆ”ëˆ•ëˆ—ëˆ™ëˆ ëˆ´ëˆ¼ë‰˜ë‰œë‰ ë‰¨ë‰©ë‰´ë‰µë‰¼ëŠ„ëŠ…ëŠ‰ëŠëŠ‘ëŠ”ëŠ˜ëŠ™ëŠšëŠ ëŠ¡ëŠ£ëŠ¥ëŠ¦ëŠªëŠ¬ëŠ°ëŠ´ë‹ˆë‹‰ë‹Œë‹ë‹’ë‹˜ë‹™ë‹›ë‹ë‹¢ë‹¤ë‹¥ë‹¦ë‹¨ë‹«",
    4,
    "ë‹³ë‹´ë‹µë‹·",
    4,
    "ë‹¿ëŒ€ëŒëŒ„ëŒˆëŒëŒ‘ëŒ“ëŒ”ëŒ•ëŒœë”ë•ë–ë˜ë›ëœëžëŸë¤ë¥"
  ],
  [
    "b541",
    "í‚•",
    14,
    "í‚¦í‚§í‚©í‚ªí‚«í‚­",
    5
  ],
  [
    "b561",
    "í‚³í‚¶í‚¸í‚º",
    5,
    "íƒ‚íƒƒíƒ…íƒ†íƒ‡íƒŠ",
    5,
    "íƒ’íƒ–",
    4
  ],
  [
    "b581",
    "íƒ›íƒžíƒŸíƒ¡íƒ¢íƒ£íƒ¥",
    6,
    "íƒ®íƒ²",
    5,
    "íƒ¹",
    11,
    "ë§ë©ë«ë®ë°ë±ë´ë¸ëŽ€ëŽëŽƒëŽ„ëŽ…ëŽŒëŽëŽ”ëŽ ëŽ¡ëŽ¨ëŽ¬ë„ë…ëˆë‹ëŒëŽëë”ë•ë—ë™ë›ëë ë¤ë¨ë¼ëë˜ëœë ë¨ë©ë«ë´ë‘ë‘‘ë‘”ë‘˜ë‘ ë‘¡ë‘£ë‘¥ë‘¬ë’€ë’ˆë’ë’¤ë’¨ë’¬ë’µë’·ë’¹ë“€ë“„ë“ˆë“ë“•ë“œë“ë“ ë“£ë“¤ë“¦ë“¬ë“­ë“¯ë“±ë“¸ë””ë”•ë”˜ë”›ë”œë”¤ë”¥ë”§ë”¨ë”©ë”ªë”°ë”±ë”´ë”¸"
  ],
  [
    "b641",
    "í„…",
    7,
    "í„Ž",
    17
  ],
  [
    "b661",
    "í„ ",
    15,
    "í„²í„³í„µí„¶í„·í„¹í„»í„¼í„½í„¾"
  ],
  [
    "b681",
    "í„¿í…‚í…†",
    5,
    "í…Ží…í…‘í…’í…“í…•",
    6,
    "í…ží… í…¢",
    5,
    "í…©í…ªí…«í…­ë•€ë•ë•ƒë•„ë•…ë•‹ë•Œë•ë•ë•”ë•œë•ë•Ÿë• ë•¡ë– ë–¡ë–¤ë–¨ë–ªë–«ë–°ë–±ë–³ë–´ë–µë–»ë–¼ë–½ë—€ë—„ë—Œë—ë—ë—ë—‘ë—˜ë—¬ë˜ë˜‘ë˜”ë˜˜ë˜¥ë˜¬ë˜´ë™ˆë™¤ë™¨ëšœëšëš ëš¤ëš«ëš¬ëš±ë›”ë›°ë›´ë›¸ëœ€ëœëœ…ëœ¨ëœ©ëœ¬ëœ¯ëœ°ëœ¸ëœ¹ëœ»ë„ëˆëŒë”ë•ë ë¤ë¨ë°ë±ë³ëµë¼ë½ëž€ëž„ëžŒëžëžëžëž‘ëž’ëž–ëž—"
  ],
  [
    "b741",
    "í…®",
    13,
    "í…½",
    6,
    "í†…í††í†‡í†‰í†Š"
  ],
  [
    "b761",
    "í†‹",
    20,
    "í†¢í†£í†¥í†¦í†§"
  ],
  [
    "b781",
    "í†©",
    6,
    "í†²í†´í†¶í†·í†¸í†¹í†»í†½í†¾í†¿í‡",
    14,
    "ëž˜ëž™ëžœëž ëž¨ëž©ëž«ëž¬ëž­ëž´ëžµëž¸ëŸ‡ëŸ‰ëŸ¬ëŸ­ëŸ°ëŸ´ëŸ¼ëŸ½ëŸ¿ë €ë ë ‡ë ˆë ‰ë Œë ë ˜ë ™ë ›ë ë ¤ë ¥ë ¨ë ¬ë ´ë µë ·ë ¸ë ¹ë¡€ë¡„ë¡‘ë¡“ë¡œë¡ë¡ ë¡¤ë¡¬ë¡­ë¡¯ë¡±ë¡¸ë¡¼ë¢ë¢¨ë¢°ë¢´ë¢¸ë£€ë£ë£ƒë£…ë£Œë£ë£”ë£ë£Ÿë£¡ë£¨ë£©ë£¬ë£°ë£¸ë£¹ë£»ë£½ë¤„ë¤˜ë¤ ë¤¼ë¤½ë¥€ë¥„ë¥Œë¥ë¥‘ë¥˜ë¥™ë¥œë¥ ë¥¨ë¥©"
  ],
  [
    "b841",
    "í‡",
    7,
    "í‡™",
    17
  ],
  [
    "b861",
    "í‡«",
    8,
    "í‡µí‡¶í‡·í‡¹",
    13
  ],
  [
    "b881",
    "íˆˆíˆŠ",
    5,
    "íˆ‘",
    24,
    "ë¥«ë¥­ë¥´ë¥µë¥¸ë¥¼ë¦„ë¦…ë¦‡ë¦‰ë¦Šë¦ë¦Žë¦¬ë¦­ë¦°ë¦´ë¦¼ë¦½ë¦¿ë§ë§ˆë§‰ë§Œë§Ž",
    4,
    "ë§˜ë§™ë§›ë§ë§žë§¡ë§£ë§¤ë§¥ë§¨ë§¬ë§´ë§µë§·ë§¸ë§¹ë§ºë¨€ë¨ë¨ˆë¨•ë¨¸ë¨¹ë¨¼ë©€ë©‚ë©ˆë©‰ë©‹ë©ë©Žë©“ë©”ë©•ë©˜ë©œë©¤ë©¥ë©§ë©¨ë©©ë©°ë©±ë©´ë©¸ëªƒëª„ëª…ëª‡ëªŒëª¨ëª©ëª«ëª¬ëª°ëª²ëª¸ëª¹ëª»ëª½ë«„ë«ˆë«˜ë«™ë«¼"
  ],
  [
    "b941",
    "íˆªíˆ«íˆ®íˆ¯íˆ±íˆ²íˆ³íˆµ",
    6,
    "íˆ¾í‰€í‰‚",
    5,
    "í‰‰í‰Ší‰‹í‰Œ"
  ],
  [
    "b961",
    "í‰",
    14,
    "í‰",
    6,
    "í‰¥í‰¦í‰§í‰¨"
  ],
  [
    "b981",
    "í‰©",
    22,
    "íŠ‚íŠƒíŠ…íŠ†íŠ‡íŠ‰íŠŠíŠ‹íŠŒë¬€ë¬„ë¬ë¬ë¬‘ë¬˜ë¬œë¬ ë¬©ë¬«ë¬´ë¬µë¬¶ë¬¸ë¬»ë¬¼ë¬½ë¬¾ë­„ë­…ë­‡ë­‰ë­ë­ë­ë­”ë­˜ë­¡ë­£ë­¬ë®ˆë®Œë®ë®¤ë®¨ë®¬ë®´ë®·ë¯€ë¯„ë¯ˆë¯ë¯“ë¯¸ë¯¹ë¯¼ë¯¿ë°€ë°‚ë°ˆë°‰ë°‹ë°Œë°ë°ë°‘ë°”",
    4,
    "ë°›",
    4,
    "ë°¤ë°¥ë°§ë°©ë°­ë°°ë°±ë°´ë°¸ë±€ë±ë±ƒë±„ë±…ë±‰ë±Œë±ë±ë±ë²„ë²…ë²ˆë²‹ë²Œë²Žë²”ë²•ë²—"
  ],
  [
    "ba41",
    "íŠíŠŽíŠíŠ’íŠ“íŠ”íŠ–",
    5,
    "íŠíŠžíŠŸíŠ¡íŠ¢íŠ£íŠ¥",
    6,
    "íŠ­"
  ],
  [
    "ba61",
    "íŠ®íŠ¯íŠ°íŠ²",
    5,
    "íŠºíŠ»íŠ½íŠ¾í‹í‹ƒ",
    4,
    "í‹Ší‹Œ",
    5
  ],
  [
    "ba81",
    "í‹’í‹“í‹•í‹–í‹—í‹™í‹ší‹›í‹",
    6,
    "í‹¦",
    9,
    "í‹²í‹³í‹µí‹¶í‹·í‹¹í‹ºë²™ë²šë² ë²¡ë²¤ë²§ë²¨ë²°ë²±ë²³ë²´ë²µë²¼ë²½ë³€ë³„ë³ë³ë³ë³‘ë³•ë³˜ë³œë³´ë³µë³¶ë³¸ë³¼ë´„ë´…ë´‡ë´‰ë´ë´”ë´¤ë´¬ëµ€ëµˆëµ‰ëµŒëµëµ˜ëµ™ëµ¤ëµ¨ë¶€ë¶ë¶„ë¶‡ë¶ˆë¶‰ë¶Šë¶ë¶‘ë¶“ë¶•ë¶™ë¶šë¶œë¶¤ë¶°ë¶¸ë·”ë·•ë·˜ë·œë·©ë·°ë·´ë·¸ë¸€ë¸ƒë¸…ë¸Œë¸ë¸ë¸”ë¸œë¸ë¸Ÿë¹„ë¹…ë¹ˆë¹Œë¹Žë¹”ë¹•ë¹—ë¹™ë¹šë¹›ë¹ ë¹¡ë¹¤"
  ],
  [
    "bb41",
    "í‹»",
    4,
    "íŒ‚íŒ„íŒ†",
    5,
    "íŒíŒ‘íŒ’íŒ“íŒ•íŒ—",
    4,
    "íŒžíŒ¢íŒ£"
  ],
  [
    "bb61",
    "íŒ¤íŒ¦íŒ§íŒªíŒ«íŒ­íŒ®íŒ¯íŒ±",
    6,
    "íŒºíŒ¾",
    5,
    "í†í‡íˆí‰"
  ],
  [
    "bb81",
    "íŠ",
    31,
    "ë¹¨ë¹ªë¹°ë¹±ë¹³ë¹´ë¹µë¹»ë¹¼ë¹½ëº€ëº„ëºŒëºëºëºëº‘ëº˜ëº™ëº¨ë»ë»‘ë»”ë»—ë»˜ë» ë»£ë»¤ë»¥ë»¬ë¼ë¼ˆë¼‰ë¼˜ë¼™ë¼›ë¼œë¼ë½€ë½ë½„ë½ˆë½ë½‘ë½•ë¾”ë¾°ë¿…ë¿Œë¿ë¿ë¿”ë¿œë¿Ÿë¿¡ì€¼ì‘ì˜ìœì ì¨ì©ì‚ì‚‘ì‚”ì‚˜ì‚ ì‚¡ì‚£ì‚¥ì‚¬ì‚­ì‚¯ì‚°ì‚³ì‚´ì‚µì‚¶ì‚¼ì‚½ì‚¿ìƒ€ìƒìƒ…ìƒˆìƒ‰ìƒŒìƒìƒ˜ìƒ™ìƒ›ìƒœìƒìƒ¤"
  ],
  [
    "bc41",
    "íª",
    17,
    "í¾í¿íŽíŽ‚íŽƒíŽ…íŽ†íŽ‡"
  ],
  [
    "bc61",
    "íŽˆíŽ‰íŽŠíŽ‹íŽŽíŽ’",
    5,
    "íŽšíŽ›íŽíŽžíŽŸíŽ¡",
    6,
    "íŽªíŽ¬íŽ®"
  ],
  [
    "bc81",
    "íŽ¯",
    4,
    "íŽµíŽ¶íŽ·íŽ¹íŽºíŽ»íŽ½",
    6,
    "í†í‡íŠ",
    5,
    "í‘",
    5,
    "ìƒ¥ìƒ¨ìƒ¬ìƒ´ìƒµìƒ·ìƒ¹ì„€ì„„ì„ˆì„ì„•ì„œ",
    4,
    "ì„£ì„¤ì„¦ì„§ì„¬ì„­ì„¯ì„°ì„±ì„¶ì„¸ì„¹ì„¼ì…€ì…ˆì…‰ì…‹ì…Œì…ì…”ì…•ì…˜ì…œì…¤ì…¥ì…§ì…¨ì…©ì…°ì…´ì…¸ì†…ì†Œì†ì†Žì†ì†”ì†–ì†œì†ì†Ÿì†¡ì†¥ì†¨ì†©ì†¬ì†°ì†½ì‡„ì‡ˆì‡Œì‡”ì‡—ì‡˜ì‡ ì‡¤ì‡¨ì‡°ì‡±ì‡³ì‡¼ì‡½ìˆ€ìˆ„ìˆŒìˆìˆìˆ‘ìˆ˜ìˆ™ìˆœìˆŸìˆ ìˆ¨ìˆ©ìˆ«ìˆ­"
  ],
  [
    "bd41",
    "í—í™",
    7,
    "í¢í¤",
    7,
    "í®í¯í±í²í³íµí¶í·"
  ],
  [
    "bd61",
    "í¸í¹íºí»í¾í€í‚",
    5,
    "í‰",
    13
  ],
  [
    "bd81",
    "í—",
    5,
    "íž",
    25,
    "ìˆ¯ìˆ±ìˆ²ìˆ´ì‰ˆì‰ì‰‘ì‰”ì‰˜ì‰ ì‰¥ì‰¬ì‰­ì‰°ì‰´ì‰¼ì‰½ì‰¿ìŠìŠˆìŠ‰ìŠìŠ˜ìŠ›ìŠìŠ¤ìŠ¥ìŠ¨ìŠ¬ìŠ­ìŠ´ìŠµìŠ·ìŠ¹ì‹œì‹ì‹ ì‹£ì‹¤ì‹«ì‹¬ì‹­ì‹¯ì‹±ì‹¶ì‹¸ì‹¹ì‹»ì‹¼ìŒ€ìŒˆìŒ‰ìŒŒìŒìŒ“ìŒ”ìŒ•ìŒ˜ìŒœìŒ¤ìŒ¥ìŒ¨ìŒ©ì…ì¨ì©ì¬ì°ì²ì¸ì¹ì¼ì½ìŽ„ìŽˆìŽŒì€ì˜ì™ìœìŸì ì¢ì¨ì©ì­ì´ìµì¸ìˆìì¤ì¬ì°"
  ],
  [
    "be41",
    "í¸",
    7,
    "í‘í‘‚í‘ƒí‘…",
    14
  ],
  [
    "be61",
    "í‘”",
    7,
    "í‘í‘ží‘Ÿí‘¡í‘¢í‘£í‘¥",
    7,
    "í‘®í‘°í‘±í‘²"
  ],
  [
    "be81",
    "í‘³",
    4,
    "í‘ºí‘»í‘½í‘¾í’í’ƒ",
    4,
    "í’Ší’Œí’Ž",
    5,
    "í’•",
    8,
    "ì´ì¼ì½ì‘ˆì‘¤ì‘¥ì‘¨ì‘¬ì‘´ì‘µì‘¹ì’€ì’”ì’œì’¸ì’¼ì“©ì“°ì“±ì“´ì“¸ì“ºì“¿ì”€ì”ì”Œì”ì””ì”œì”¨ì”©ì”¬ì”°ì”¸ì”¹ì”»ì”½ì•„ì•…ì•ˆì•‰ì•Šì•Œì•ì•Žì•“ì•”ì••ì•—ì•˜ì•™ì•ì•žì• ì•¡ì•¤ì•¨ì•°ì•±ì•³ì•´ì•µì•¼ì•½ì–€ì–„ì–‡ì–Œì–ì–ì–‘ì–•ì–—ì–˜ì–œì– ì–©ì–´ì–µì–¸ì–¹ì–»ì–¼ì–½ì–¾ì—„",
    6,
    "ì—Œì—Ž"
  ],
  [
    "bf41",
    "í’ž",
    10,
    "í’ª",
    14
  ],
  [
    "bf61",
    "í’¹",
    18,
    "í“í“Ží“í“‘í“’í““í“•"
  ],
  [
    "bf81",
    "í“–",
    5,
    "í“í“ží“ ",
    7,
    "í“©í“ªí“«í“­í“®í“¯í“±",
    6,
    "í“¹í“ºí“¼ì—ì—‘ì—”ì—˜ì— ì—¡ì—£ì—¥ì—¬ì—­ì—®ì—°ì—´ì—¶ì—·ì—¼",
    5,
    "ì˜…ì˜†ì˜‡ì˜ˆì˜Œì˜ì˜˜ì˜™ì˜›ì˜œì˜¤ì˜¥ì˜¨ì˜¬ì˜­ì˜®ì˜°ì˜³ì˜´ì˜µì˜·ì˜¹ì˜»ì™€ì™ì™„ì™ˆì™ì™‘ì™“ì™”ì™•ì™œì™ì™ ì™¬ì™¯ì™±ì™¸ì™¹ì™¼ìš€ìšˆìš‰ìš‹ìšìš”ìš•ìš˜ìšœìš¤ìš¥ìš§ìš©ìš°ìš±ìš´ìš¸ìš¹ìšºì›€ì›ì›ƒì›…ì›Œì›ì›ì›”ì›œì›ì› ì›¡ì›¨"
  ],
  [
    "c041",
    "í“¾",
    5,
    "í”…í”†í”‡í”‰í”Ší”‹í”",
    6,
    "í”–í”˜",
    5
  ],
  [
    "c061",
    "í”ž",
    25
  ],
  [
    "c081",
    "í”¸í”¹í”ºí”»í”¾í”¿í•í•‚í•ƒí•…",
    6,
    "í•Ží•í•’",
    5,
    "í•ší•›í•í•ží•Ÿí•¡í•¢í•£ì›©ì›¬ì›°ì›¸ì›¹ì›½ìœ„ìœ…ìœˆìœŒìœ”ìœ•ìœ—ìœ™ìœ ìœ¡ìœ¤ìœ¨ìœ°ìœ±ìœ³ìœµìœ·ìœ¼ìœ½ì€ì„ìŠìŒììì‘",
    7,
    "ìœì ì¨ì«ì´ìµì¸ì¼ì½ì¾ìžƒìž„ìž…ìž‡ìžˆìž‰ìžŠìžŽìžìž‘ìž”ìž–ìž—ìž˜ìžšìž ìž¡ìž£ìž¤ìž¥ìž¦ìž¬ìž­ìž°ìž´ìž¼ìž½ìž¿ìŸ€ìŸìŸˆìŸ‰ìŸŒìŸŽìŸìŸ˜ìŸìŸ¤ìŸ¨ìŸ¬ì €ì ì „ì ˆì Š"
  ],
  [
    "c141",
    "í•¤í•¦í•§í•ªí•¬í•®",
    5,
    "í•¶í•·í•¹í•ºí•»í•½",
    6,
    "í–†í–Ší–‹"
  ],
  [
    "c161",
    "í–Œí–í–Ží–í–‘",
    19,
    "í–¦í–§"
  ],
  [
    "c181",
    "í–¨",
    31,
    "ì ì ‘ì “ì •ì –ì œì ì  ì ¤ì ¬ì ­ì ¯ì ±ì ¸ì ¼ì¡€ì¡ˆì¡‰ì¡Œì¡ì¡”ì¡°ì¡±ì¡´ì¡¸ì¡ºì¢€ì¢ì¢ƒì¢…ì¢†ì¢‡ì¢‹ì¢Œì¢ì¢”ì¢ì¢Ÿì¢¡ì¢¨ì¢¼ì¢½ì£„ì£ˆì£Œì£”ì£•ì£—ì£™ì£ ì£¡ì£¤ì£µì£¼ì£½ì¤€ì¤„ì¤…ì¤†ì¤Œì¤ì¤ì¤‘ì¤˜ì¤¬ì¤´ì¥ì¥‘ì¥”ì¥˜ì¥ ì¥¡ì¥£ì¥¬ì¥°ì¥´ì¥¼ì¦ˆì¦‰ì¦Œì¦ì¦˜ì¦™ì¦›ì¦ì§€ì§ì§„ì§‡ì§ˆì§Šì§ì§‘ì§“"
  ],
  [
    "c241",
    "í—Ší—‹í—í—Ží—í—‘í—“",
    4,
    "í—ší—œí—ž",
    5,
    "í—¦í—§í—©í—ªí—«í—­í—®"
  ],
  [
    "c261",
    "í—¯",
    4,
    "í—¶í—¸í—º",
    5,
    "í˜‚í˜ƒí˜…í˜†í˜‡í˜‰",
    6,
    "í˜’"
  ],
  [
    "c281",
    "í˜–",
    5,
    "í˜í˜ží˜Ÿí˜¡í˜¢í˜£í˜¥",
    7,
    "í˜®",
    9,
    "í˜ºí˜»ì§•ì§–ì§™ì§šì§œì§ì§ ì§¢ì§¤ì§§ì§¬ì§­ì§¯ì§°ì§±ì§¸ì§¹ì§¼ì¨€ì¨ˆì¨‰ì¨‹ì¨Œì¨ì¨”ì¨˜ì¨©ì©Œì©ì©ì©”ì©œì©ì©Ÿì© ì©¡ì©¨ì©½ìª„ìª˜ìª¼ìª½ì«€ì«„ì«Œì«ì«ì«‘ì«“ì«˜ì«™ì« ì«¬ì«´ì¬ˆì¬ì¬”ì¬˜ì¬ ì¬¡ì­ì­ˆì­‰ì­Œì­ì­˜ì­™ì­ì­¤ì­¸ì­¹ì®œì®¸ì¯”ì¯¤ì¯§ì¯©ì°Œì°ì°ì°”ì°œì°ì°¡ì°¢ì°§ì°¨ì°©ì°¬ì°®ì°°ì°¸ì°¹ì°»"
  ],
  [
    "c341",
    "í˜½í˜¾í˜¿í™í™‚í™ƒí™„í™†í™‡í™Ší™Œí™Ží™í™í™’í™“í™–í™—í™™í™ší™›í™",
    4
  ],
  [
    "c361",
    "í™¢",
    4,
    "í™¨í™ª",
    5,
    "í™²í™³í™µ",
    11
  ],
  [
    "c381",
    "íšíš‚íš„íš†",
    5,
    "íšŽíšíš‘íš’íš“íš•",
    7,
    "íšžíš íš¢",
    5,
    "íš©íšªì°¼ì°½ì°¾ì±„ì±…ì±ˆì±Œì±”ì±•ì±—ì±˜ì±™ì± ì±¤ì±¦ì±¨ì±°ì±µì²˜ì²™ì²œì² ì²¨ì²©ì²«ì²¬ì²­ì²´ì²µì²¸ì²¼ì³„ì³…ì³‡ì³‰ì³ì³”ì³¤ì³¬ì³°ì´ì´ˆì´‰ì´Œì´ì´˜ì´™ì´›ì´ì´¤ì´¨ì´¬ì´¹ìµœìµ ìµ¤ìµ¬ìµ­ìµ¯ìµ±ìµ¸ì¶ˆì¶”ì¶•ì¶˜ì¶œì¶¤ì¶¥ì¶§ì¶©ì¶°ì·„ì·Œì·ì·¨ì·¬ì·°ì·¸ì·¹ì·»ì·½ì¸„ì¸ˆì¸Œì¸”ì¸™ì¸ ì¸¡ì¸¤ì¸¨ì¸°ì¸±ì¸³ì¸µ"
  ],
  [
    "c441",
    "íš«íš­íš®íš¯íš±",
    7,
    "íšºíš¼",
    7,
    "í›†í›‡í›‰í›Ší›‹"
  ],
  [
    "c461",
    "í›í›Ží›í›í›’í›“í›•í›–í›˜í›š",
    5,
    "í›¡í›¢í›£í›¥í›¦í›§í›©",
    4
  ],
  [
    "c481",
    "í›®í›¯í›±í›²í›³í›´í›¶",
    5,
    "í›¾í›¿íœíœ‚íœƒíœ…",
    11,
    "íœ’íœ“íœ”ì¹˜ì¹™ì¹œì¹Ÿì¹ ì¹¡ì¹¨ì¹©ì¹«ì¹­ì¹´ì¹µì¹¸ì¹¼ìº„ìº…ìº‡ìº‰ìºìº‘ìº”ìº˜ìº ìº¡ìº£ìº¤ìº¥ìº¬ìº­ì»ì»¤ì»¥ì»¨ì»«ì»¬ì»´ì»µì»·ì»¸ì»¹ì¼€ì¼ì¼„ì¼ˆì¼ì¼‘ì¼“ì¼•ì¼œì¼ ì¼¤ì¼¬ì¼­ì¼¯ì¼°ì¼±ì¼¸ì½”ì½•ì½˜ì½œì½¤ì½¥ì½§ì½©ì½°ì½±ì½´ì½¸ì¾€ì¾…ì¾Œì¾¡ì¾¨ì¾°ì¿„ì¿ ì¿¡ì¿¤ì¿¨ì¿°ì¿±ì¿³ì¿µì¿¼í€€í€„í€‘í€˜í€­í€´í€µí€¸í€¼"
  ],
  [
    "c541",
    "íœ•íœ–íœ—íœšíœ›íœíœžíœŸíœ¡",
    6,
    "íœªíœ¬íœ®",
    5,
    "íœ¶íœ·íœ¹"
  ],
  [
    "c561",
    "íœºíœ»íœ½",
    6,
    "í…í†íˆíŠ",
    5,
    "í’í“í•íš",
    4
  ],
  [
    "c581",
    "íŸí¢í¤í¦í§í¨íªí«í­í®í¯í±í²í³íµ",
    6,
    "í¾í¿íž€íž‚",
    5,
    "ížŠíž‹í„í…í‡í‰íí”í˜í í¬í­í°í´í¼í½í‚í‚¤í‚¥í‚¨í‚¬í‚´í‚µí‚·í‚¹íƒ€íƒíƒ„íƒˆíƒ‰íƒíƒ‘íƒ“íƒ”íƒ•íƒœíƒíƒ íƒ¤íƒ¬íƒ­íƒ¯íƒ°íƒ±íƒ¸í„í„°í„±í„´í„¸í„ºí…€í…í…ƒí…„í……í…Œí…í…í…”í…œí…í…Ÿí…¡í…¨í…¬í…¼í†„í†ˆí† í†¡í†¤í†¨í†°í†±í†³í†µí†ºí†¼í‡€í‡˜í‡´í‡¸íˆ‡íˆ‰íˆíˆ¬íˆ­íˆ°íˆ´íˆ¼íˆ½íˆ¿í‰í‰ˆí‰œ"
  ],
  [
    "c641",
    "ížížŽížíž‘",
    6,
    "ížšížœížž",
    5
  ],
  [
    "c6a1",
    "í‰¤íŠ€íŠíŠ„íŠˆíŠíŠ‘íŠ•íŠœíŠ íŠ¤íŠ¬íŠ±íŠ¸íŠ¹íŠ¼íŠ¿í‹€í‹‚í‹ˆí‹‰í‹‹í‹”í‹˜í‹œí‹¤í‹¥í‹°í‹±í‹´í‹¸íŒ€íŒíŒƒíŒ…íŒŒíŒíŒŽíŒíŒ”íŒ–íŒœíŒíŒŸíŒ íŒ¡íŒ¥íŒ¨íŒ©íŒ¬íŒ°íŒ¸íŒ¹íŒ»íŒ¼íŒ½í„í…í¼í½íŽ€íŽ„íŽŒíŽíŽíŽíŽ‘íŽ˜íŽ™íŽœíŽ íŽ¨íŽ©íŽ«íŽ­íŽ´íŽ¸íŽ¼í„í…íˆí‰íí˜í¡í£í¬í­í°í´í¼í½í¿í"
  ],
  [
    "c7a1",
    "íˆíí‘€í‘„í‘œí‘ í‘¤í‘­í‘¯í‘¸í‘¹í‘¼í‘¿í’€í’‚í’ˆí’‰í’‹í’í’”í’©í“Œí“í“”í“œí“Ÿí“¨í“¬í“°í“¸í“»í“½í”„í”ˆí”Œí””í”•í”—í”¼í”½í•€í•„í•Œí•í•í•‘í•˜í•™í•œí• í•¥í•¨í•©í•«í•­í•´í•µí•¸í•¼í–„í–…í–‡í–ˆí–‰í–í–¥í—ˆí—‰í—Œí—í—’í—˜í—™í—›í—í—¤í—¥í—¨í—¬í—´í—µí—·í—¹í˜€í˜í˜„í˜ˆí˜í˜‘í˜“í˜”í˜•í˜œí˜ "
  ],
  [
    "c8a1",
    "í˜¤í˜­í˜¸í˜¹í˜¼í™€í™…í™ˆí™‰í™‹í™í™‘í™”í™•í™˜í™œí™§í™©í™°í™±í™´íšƒíš…íšŒíšíšíš”íšíšŸíš¡íš¨íš¬íš°íš¹íš»í›„í›…í›ˆí›Œí›‘í›”í›—í›™í› í›¤í›¨í›°í›µí›¼í›½íœ€íœ„íœ‘íœ˜íœ™íœœíœ íœ¨íœ©íœ«íœ­íœ´íœµíœ¸íœ¼í„í‡í‰íí‘í”í–í—í˜í™í í¡í£í¥í©í¬í°í´í¼í½ížížˆíž‰ížŒížíž˜íž™íž›íž"
  ],
  [
    "caa1",
    "ä¼½ä½³å‡åƒ¹åŠ å¯å‘µå“¥å˜‰å«å®¶æš‡æž¶æž·æŸ¯æ­Œç‚ç—‚ç¨¼è‹›èŒ„è¡—è¢ˆè¨¶è³ˆè·è»»è¿¦é§•åˆ»å´å„æªæ…¤æ®¼çè„šè¦ºè§’é–£ä¾ƒåˆŠå¢¾å¥¸å§¦å¹²å¹¹æ‡‡æ€æ†æŸ¬æ¡¿æ¾—ç™Žçœ‹ç£µç¨ˆç«¿ç°¡è‚è‰®è‰±è««é–“ä¹«å–æ›·æ¸´ç¢£ç«­è‘›è¤èŽéž¨å‹˜åŽå ªåµŒæ„Ÿæ†¾æˆ¡æ•¢æŸ‘æ©„æ¸›ç”˜ç–³ç›£çž°ç´ºé‚¯é‘‘é‘’é¾•"
  ],
  [
    "cba1",
    "åŒ£å²¬ç”²èƒ›é‰€é–˜å‰›å ˆå§œå²¡å´—åº·å¼ºå½Šæ…·æ±Ÿç•ºç–†ç³ çµ³ç¶±ç¾Œè…”èˆ¡è–‘è¥è¬›é‹¼é™é±‡ä»‹ä»·å€‹å‡±å¡æ„·æ„¾æ…¨æ”¹æ§ªæ¼‘ç–¥çš†ç›–ç®‡èŠ¥è“‹ï¤€éŽ§é–‹å–€å®¢å‘ï¤ç²³ç¾¹é†µå€¨åŽ»å±…å·¨æ‹’æ®æ“šæ“§æ¸ ç‚¬ç¥›è·è¸žï¤‚é½é‰…é‹¸ä¹¾ä»¶å¥å·¾å»ºæ„†æ¥—è…±è™”è¹‡éµé¨«ä¹žå‚‘æ°æ¡€å„‰åŠåŠ’æª¢"
  ],
  [
    "cca1",
    "çž¼éˆé»”åŠ«æ€¯è¿²åˆæ†©æ­æ“Šæ ¼æª„æ¿€è†ˆè¦¡éš”å …ç‰½çŠ¬ç”„çµ¹ç¹­è‚©è¦‹è­´é£éµ‘æŠ‰æ±ºæ½”çµç¼ºè¨£å…¼æ…Šç®è¬™é‰—éŽŒäº¬ä¿“å€žå‚¾å„†å‹å‹å¿å°å¢ƒåºšå¾‘æ…¶æ†¬æ“Žæ•¬æ™¯æš»æ›´æ¢—æ¶‡ç‚…çƒ±ç’Ÿç’¥ç“Šç—™ç¡¬ç£¬ç«Ÿç«¶çµ…ç¶“è€•è€¿è„›èŽ–è­¦è¼•é€•é¡é ƒé ¸é©šé¯¨ä¿‚å•“å ºå¥‘å­£å±†æ‚¸æˆ’æ¡‚æ¢°"
  ],
  [
    "cda1",
    "æ£¨æºªç•Œç™¸ç£Žç¨½ç³»ç¹«ç¹¼è¨ˆèª¡è°¿éšŽé·„å¤å©å‘Šå‘±å›ºå§‘å­¤å°»åº«æ‹·æ”·æ•…æ•²æš æž¯æ§æ²½ç—¼çšç¾ç¨¿ç¾”è€ƒè‚¡è†è‹¦è‹½è°è—è ±è¢´èª¥ï¤ƒè¾œéŒ®é›‡é¡§é«˜é¼“å“­æ–›æ›²æ¢ç©€è°·éµ å›°å¤å´‘æ˜†æ¢±æ£æ»¾ç¨è¢žé¯¤æ±¨ï¤„éª¨ä¾›å…¬å…±åŠŸå­”å·¥ææ­æ‹±æŽ§æ”»ç™ç©ºèš£è²¢éžä¸²å¯¡æˆˆæžœç“œ"
  ],
  [
    "cea1",
    "ç§‘è“èª‡èª²è·¨éŽé‹é¡†å»“æ§¨è—¿éƒ­ï¤…å† å®˜å¯¬æ…£æ£ºæ¬¾çŒç¯ç“˜ç®¡ç½è…è§€è²«é—œé¤¨åˆ®ææ‹¬é€‚ä¾Šå…‰åŒ¡å£™å»£æ› æ´¸ç‚šç‹‚ç–ç­èƒ±é‘›å¦æŽ›ç½«ä¹–å‚€å¡Šå£žæ€ªæ„§æ‹æ§é­å®ç´˜è‚±è½Ÿäº¤åƒ‘å’¬å–¬å¬Œå¶ å·§æ”ªæ•Žæ ¡æ©‹ç‹¡çšŽçŸ¯çµžç¿¹è† è•Žè›Ÿè¼ƒè½ŽéƒŠé¤ƒé©•é®«ä¸˜ä¹…ä¹ä»‡ä¿±å…·å‹¾"
  ],
  [
    "cfa1",
    "å€å£å¥å’Žå˜”åµåž¢å¯‡å¶‡å»æ‡¼æ‹˜æ•‘æž¸æŸ©æ§‹æ­æ¯†æ¯¬æ±‚æºç¸ç‹—çŽ–çƒçž¿çŸ©ç©¶çµ¿è€‰è‡¼èˆ…èˆŠè‹Ÿè¡¢è¬³è³¼è»€é€‘é‚±é‰¤éŠ¶é§’é©…é³©é·—é¾œåœ‹å±€èŠéž éž«éº´å›çª˜ç¾¤è£™è»éƒ¡å €å±ˆæŽ˜çªŸå®®å¼“ç©¹çª®èŠŽèº¬å€¦åˆ¸å‹¸å·åœˆæ‹³æ²æ¬Šæ·ƒçœ·åŽ¥ç—è•¨è¹¶é—•æœºæ«ƒæ½°è©­è»Œé¥‹ï¤†æ™·æ­¸è²´"
  ],
  [
    "d0a1",
    "é¬¼ï¤‡å«åœ­å¥Žæ†æ§»çªç¡…çªºç«…ç³¾è‘µè¦èµ³é€µé–¨å‹»å‡ç•‡ç­ èŒéˆžï¤ˆæ©˜å…‹å‰‹åŠ‡æˆŸæ£˜æ¥µéš™åƒ…åŠ¤å‹¤æ‡ƒæ–¤æ ¹æ§¿ç‘¾ç­‹èŠ¹è«è¦²è¬¹è¿‘é¥‰ï¤‰ä»Šå¦—æ“’æ˜‘æªŽç´ç¦ç¦½èŠ©è¡¾è¡¿è¥Ÿï¤ŠéŒ¦ä¼‹åŠæ€¥æ‰±æ±²ç´šçµ¦äº˜å…¢çŸœè‚¯ä¼ä¼Žå…¶å†€å—œå™¨åœ»åŸºåŸ¼å¤”å¥‡å¦“å¯„å²å´Žå·±å¹¾å¿ŒæŠ€æ——æ—£"
  ],
  [
    "d1a1",
    "æœžæœŸæžæ£‹æ£„æ©Ÿæ¬ºæ°£æ±½æ²‚æ·‡çŽ˜ç¦çªç’‚ç’£ç•¸ç•¿ç¢ç£¯ç¥ç¥‡ç¥ˆç¥ºç®•ç´€ç¶ºç¾ˆè€†è€­è‚Œè¨˜è­è±ˆèµ·éŒ¡éŒ¤é£¢é¥‘é¨Žé¨é©¥éº’ç·Šä½¶å‰æ‹®æ¡”é‡‘å–«å„ºï¤‹ï¤Œå¨œæ‡¦ï¤æ‹æ‹¿ï¤Ž",
    5,
    "é‚£ï¤”",
    4,
    "è«¾ï¤™ï¤šï¤›ï¤œæš–ï¤ç…–ï¤žï¤Ÿé›£ï¤ ææºå—ï¤¡æžæ¥ æ¹³ï¤¢ç”·ï¤£ï¤¤ï¤¥"
  ],
  [
    "d2a1",
    "ç´ï¤¦ï¤§è¡²å›Šå¨˜ï¤¨",
    4,
    "ä¹ƒï¤­å…§å¥ˆæŸ°è€ï¤®å¥³å¹´æ’šç§Šå¿µæ¬æ‹ˆæ»å¯§å¯—åŠªï¤¯å¥´å¼©æ€’ï¤°ï¤±ï¤²ç‘™ï¤³",
    5,
    "é§‘ï¤¹",
    10,
    "æ¿ƒï¥„ï¥…è†¿è¾²æƒ±ï¥†ï¥‡è…¦ï¥ˆï¥‰å°¿ï¥Š",
    7,
    "å«©è¨¥æ»ç´ï¥’",
    5,
    "èƒ½ï¥˜ï¥™å°¼æ³¥åŒ¿æººå¤šèŒ¶"
  ],
  [
    "d3a1",
    "ä¸¹äº¶ä½†å–®åœ˜å£‡å½–æ–·æ—¦æª€æ®µæ¹çŸ­ç«¯ç°žç·žè›‹è¢’é„²é›æ’»æ¾¾çºç–¸é”å•–åæ†ºæ“”æ›‡æ·¡æ¹›æ½­æ¾¹ç—°èƒè†½è•è¦ƒè«‡è­šéŒŸæ²“ç•“ç­”è¸éå”å ‚å¡˜å¹¢æˆ‡æ’žæ£ ç•¶ç³–èž³é»¨ä»£åžˆå®å¤§å°å²±å¸¶å¾…æˆ´æ“¡çŽ³è‡ºè¢‹è²¸éšŠé»›å®…å¾·æ‚³å€’åˆ€åˆ°åœ–å µå¡—å°Žå± å³¶å¶‹åº¦å¾’æ‚¼æŒ‘æŽ‰æ—æ¡ƒ"
  ],
  [
    "d4a1",
    "æ£¹æ«‚æ·˜æ¸¡æ»”æ¿¤ç‡¾ç›œç¹ç¦±ç¨»è„è¦©è³­è·³è¹ˆé€ƒé€”é“éƒ½éé™¶éŸœæ¯’ç€†ç‰˜çŠ¢ç¨ç£ç¦¿ç¯¤çº›è®€å¢©æƒ‡æ•¦æ—½æš¾æ²Œç„žç‡‰è±šé “ä¹­çªä»å†¬å‡å‹•åŒæ†§æ±æ¡æ£Ÿæ´žæ½¼ç–¼çž³ç«¥èƒ´è‘£éŠ…å…œæ–—æœæž“ç—˜ç«‡è³ï¥šè±†é€—é ­å±¯è‡€èŠšéé¯éˆå¾—å¶æ©™ç‡ˆç™»ç­‰è—¤è¬„é„§é¨°å–‡æ‡¶ï¥›ç™©ç¾…"
  ],
  [
    "d5a1",
    "è˜¿èžºè£¸é‚ï¥œæ´›çƒ™çžçµ¡è½ï¥é…ªé§±ï¥žäº‚åµæ¬„æ¬’ç€¾çˆ›è˜­é¸žå‰Œè¾£åµæ“¥æ”¬æ¬–æ¿«ç±ƒçºœè—è¥¤è¦½æ‹‰è‡˜è Ÿå»Šæœ—æµªç‹¼ç…ç‘¯èž‚éƒžä¾†å´å¾ èŠå†·æŽ ç•¥äº®å€†å…©å‡‰æ¢æ¨‘ç²®ç²±ç³§è‰¯è«’è¼›é‡ä¾¶å„·å‹µå‘‚å»¬æ…®æˆ¾æ—…æ«šæ¿¾ç¤ªè—œè £é–­é©¢é©ªéº—é»ŽåŠ›æ›†æ­·ç€ç¤«è½¢é‚æ†æˆ€æ”£æ¼£"
  ],
  [
    "d6a1",
    "ç…‰ç’‰ç·´è¯è“®è¼¦é€£éŠå†½åˆ—åŠ£æ´Œçƒˆè£‚å»‰æ–‚æ®®æ¿‚ç°¾çµä»¤ä¼¶å›¹ï¥Ÿå²ºå¶ºæ€œçŽ²ç¬­ç¾šç¿Žè†é€žéˆ´é›¶éˆé ˜é½¡ä¾‹æ¾§ç¦®é†´éš·å‹žï¥ æ’ˆæ“„æ«“æ½žç€˜çˆç›§è€è˜†è™œè·¯è¼…éœ²é­¯é·ºé¹µç¢Œç¥¿ç¶ è‰éŒ„é¹¿éº“è«–å£Ÿå¼„æœ§ç€§ç“ç± è¾å„¡ç€¨ç‰¢ç£Šè³‚è³šè³´é›·äº†åƒšå¯®å»–æ–™ç‡Žç™‚çž­èŠè“¼"
  ],
  [
    "d7a1",
    "é¼é¬§é¾å£˜å©å±¢æ¨“æ·šæ¼ç˜»ç´¯ç¸·è”žè¤¸é¤é™‹åŠ‰æ—’æŸ³æ¦´æµæºœç€ç‰ç‘ ç•™ç˜¤ç¡«è¬¬é¡žå…­æˆ®é™¸ä¾–å€«å´™æ·ªç¶¸è¼ªå¾‹æ…„æ —ï¥¡éš†å‹’è‚‹å‡œå‡Œæ¥žç¨œç¶¾è±é™µä¿šåˆ©åŽ˜åå”Žå±¥æ‚§æŽæ¢¨æµ¬çŠç‹¸ç†ç’ƒï¥¢ç—¢ç±¬ç½¹ç¾¸èŽ‰è£è£¡é‡Œé‡é›¢é¯‰åæ½¾ç‡ç’˜è—ºèºªéš£é±—éºŸæž—æ·‹ç³è‡¨éœ–ç ¬"
  ],
  [
    "d8a1",
    "ç«‹ç¬ ç²’æ‘©ç‘ªç—²ç¢¼ç£¨é¦¬é­”éº»å¯žå¹•æ¼ è†œèŽ«é‚ˆä¸‡åå¨©å·’å½Žæ…¢æŒ½æ™©æ›¼æ»¿æ¼«ç£çžžè¬è”“è »è¼“é¥…é°»å”œæŠ¹æœ«æ²«èŒ‰è¥ªéºäº¡å¦„å¿˜å¿™æœ›ç¶²ç½”èŠ’èŒ«èŽ½è¼žé‚™åŸ‹å¦¹åª’å¯æ˜§æžšæ¢…æ¯ç…¤ç½µè²·è³£é‚é­…è„ˆè²Šé™Œé©€éº¥å­Ÿæ°“çŒ›ç›²ç›ŸèŒå†ªè¦“å…å†•å‹‰æ£‰æ²”çœ„çœ ç¶¿ç·¬é¢éºµæ»…"
  ],
  [
    "d9a1",
    "è”‘å†¥åå‘½æ˜Žæšæ¤§æºŸçš¿çž‘èŒ—è“‚èžŸé…©éŠ˜é³´è¢‚ä¾®å†’å‹Ÿå§†å¸½æ…•æ‘¸æ‘¹æš®æŸæ¨¡æ¯æ¯›ç‰Ÿç‰¡ç‘çœ¸çŸ›è€—èŠ¼èŒ…è¬€è¬¨è²Œæœ¨æ²ç‰§ç›®ç¦ç©†é¶©æ­¿æ²’å¤¢æœ¦è’™å¯å¢“å¦™å»Ÿææ˜´æ³æ¸ºçŒ«ç«—è‹—éŒ¨å‹™å·«æ†®æ‡‹æˆŠæ‹‡æ’«æ— æ¥™æ­¦æ¯‹ç„¡ç·ç•ç¹†èˆžèŒ‚è•ªèª£è²¿éœ§éµ¡å¢¨é»˜å€‘åˆŽå»å•æ–‡"
  ],
  [
    "daa1",
    "æ±¶ç´Šç´‹èžèšŠé–€é›¯å‹¿æ²•ç‰©å‘³åªšå°¾åµ‹å½Œå¾®æœªæ¢¶æ¥£æ¸¼æ¹„çœ‰ç±³ç¾Žè–‡è¬Žè¿·é¡é»´å²·æ‚¶æ„æ†«æ•æ—»æ—¼æ°‘æ³¯çŽŸç‰ç·¡é–”å¯†èœœè¬å‰åšæ‹ææ’²æœ´æ¨¸æ³Šç€ç’žç®”ç²•ç¸›è†Šèˆ¶è–„è¿«é›¹é§ä¼´åŠåå›æ‹Œæ¬æ”€æ–‘æ§ƒæ³®æ½˜ç­ç•”ç˜¢ç›¤ç›¼ç£ç£»ç¤¬çµ†èˆ¬èŸ è¿”é ’é£¯å‹ƒæ‹”æ’¥æ¸¤æ½‘"
  ],
  [
    "dba1",
    "ç™¼è·‹é†±é‰¢é«®é­ƒå€£å‚åŠå¦¨å°¨å¹‡å½·æˆ¿æ”¾æ–¹æ—æ˜‰æž‹æ¦œæ»‚ç£…ç´¡è‚ªè†€èˆ«èŠ³è’¡èšŒè¨ªè¬—é‚¦é˜²é¾å€ä¿³ï¥£åŸ¹å¾˜æ‹œæŽ’æ¯æ¹ƒç„™ç›ƒèƒŒèƒšè£´è£µè¤™è³ è¼©é…é™ªä¼¯ä½°å¸›æŸæ ¢ç™½ç™¾é­„å¹¡æ¨Šç…©ç‡”ç•ªï¥¤ç¹è•ƒè—©é£œä¼ç­ç½°é–¥å‡¡å¸†æ¢µæ°¾æ±Žæ³›çŠ¯ç¯„èŒƒæ³•çºåƒ»åŠˆå£æ“˜æª—ç’§ç™–"
  ],
  [
    "dca1",
    "ç¢§è˜—é—¢éœ¹ï¥¥åžå¼è®Šè¾¨è¾¯é‚Šåˆ¥çž¥é±‰é¼ˆä¸™å€‚å…µå±›å¹·æ˜žæ˜ºæŸ„æ£…ç‚³ç”ç—…ç§‰ç«è¼§é¤ é¨ˆä¿å ¡å ±å¯¶æ™®æ­¥æ´‘æ¹ºæ½½ç¤ç”«è©è£œè¤“è­œè¼”ä¼åƒ•åŒåœå®“å¾©æœç¦è…¹èŒ¯è””è¤‡è¦†è¼¹è¼»é¦¥é°’æœ¬ä¹¶ä¿¸å¥‰å°å³¯å³°æ§æ£’çƒ½ç†¢ç«ç¸«è“¬èœ‚é€¢é‹’é³³ä¸ä»˜ä¿¯å‚…å‰–å‰¯å¦å’åŸ å¤«å©¦"
  ],
  [
    "dda1",
    "å­šå­µå¯Œåºœï¥¦æ‰¶æ•·æ–§æµ®æº¥çˆ¶ç¬¦ç°¿ç¼¶è…è…‘è†šè‰€èŠ™èŽ©è¨ƒè² è³¦è³»èµ´è¶ºéƒ¨é‡œé˜œé™„é§™é³§åŒ—åˆ†å©å™´å¢³å¥”å¥®å¿¿æ†¤æ‰®æ˜æ±¾ç„šç›†ç²‰ç³žç´›èŠ¬è³é›°ï¥§ä½›å¼—å½¿æ‹‚å´©æœ‹æ£šç¡¼ç¹ƒéµ¬ä¸•å‚™åŒ•åŒªå‘å¦ƒå©¢åº‡æ‚²æ†Šæ‰‰æ‰¹æ–æž‡æ¦§æ¯”æ¯–æ¯—æ¯˜æ²¸ï¥¨çµç—ºç ’ç¢‘ç§•ç§˜ç²ƒç·‹ç¿¡è‚¥"
  ],
  [
    "dea1",
    "è„¾è‡‚è²èœšè£¨èª¹è­¬è²»é„™éžé£›é¼»åš¬å¬ªå½¬æ–Œæª³æ®¯æµœæ¿±ç€•ç‰çŽ­è²§è³“é »æ†‘æ°·è˜é¨ä¹äº‹äº›ä»•ä¼ºä¼¼ä½¿ä¿Ÿåƒ¿å²å¸å”†å—£å››å£«å¥¢å¨‘å¯«å¯ºå°„å·³å¸«å¾™æ€æ¨æ–œæ–¯æŸ¶æŸ»æ¢­æ­»æ²™æ³—æ¸£ç€‰ç…ç ‚ç¤¾ç¥€ç¥ ç§ç¯©ç´—çµ²è‚†èˆèŽŽè“‘è›‡è£Ÿè©è©žè¬è³œèµ¦è¾­é‚ªé£¼é§Ÿéºå‰Šï¥©æœ”ï¥ª"
  ],
  [
    "dfa1",
    "å‚˜åˆªå±±æ•£æ±•çŠç”£ç–ç®—è’œé…¸éœ°ä¹·æ’’æ®ºç…žè–©ä¸‰ï¥«æ‰æ£®æ¸—èŠŸè”˜è¡«æ·æ¾éˆ’é¢¯ä¸Šå‚·åƒå„Ÿå•†å–ªå˜—å­€å°™å³ å¸¸åºŠåº å»‚æƒ³æ¡‘æ©¡æ¹˜çˆ½ç‰€ç‹€ç›¸ç¥¥ç®±ç¿”è£³è§´è©³è±¡è³žéœœå¡žç’½è³½å—‡ï¥¬ç©¡ç´¢è‰²ç‰²ç”Ÿç”¥ï¥­ç¬™å¢…å£»å¶¼åºåº¶å¾æ•æŠ’æ¿æ•æš‘æ›™æ›¸æ –æ£²çŠ€ç‘žç­®çµ®ç·–ç½²"
  ],
  [
    "e0a1",
    "èƒ¥èˆ’è–¯è¥¿èª“é€é‹¤é»é¼ å¤•å¥­å¸­æƒœæ˜”æ™³æžæ±æ·…æ½ŸçŸ³ç¢©è“†é‡‹éŒ«ä»™åƒŠå…ˆå–„å¬‹å®£æ‰‡æ•¾æ—‹æ¸²ç…½çç‘„ç’‡ç’¿ç™¬ç¦ªç·šç¹•ç¾¨è…ºè†³èˆ¹è˜šèŸ¬è©µè·£é¸éŠ‘é¥é¥é®®å¨å±‘æ¥”æ³„æ´©æ¸«èˆŒè–›è¤»è¨­èªªé›ªé½§å‰¡æš¹æ®²çº–èŸ¾è´é–ƒé™æ”æ¶‰ç‡®ï¥®åŸŽå§“å®¬æ€§æƒºæˆæ˜Ÿæ™ŸçŒ©ç¹ç››çœç­¬"
  ],
  [
    "e1a1",
    "è–è²è…¥èª é†’ä¸–å‹¢æ­²æ´—ç¨…ç¬¹ç´°ï¥¯è²°å¬å˜¯å¡‘å®µå°å°‘å·¢æ‰€æŽƒæ”æ˜­æ¢³æ²¼æ¶ˆæº¯ç€Ÿç‚¤ç‡’ç”¦ç–ç–Žç˜™ç¬‘ç¯ ç°«ç´ ç´¹è”¬è•­è˜‡è¨´é€é¡é‚µéŠ·éŸ¶é¨·ä¿—å±¬æŸæ¶‘ç²ŸçºŒè¬–è´–é€Ÿå­«å·½æè“€éœé£¡çŽ‡å®‹æ‚šæ¾æ·žè¨Ÿèª¦é€é Œåˆ·ï¥°ç‘ç¢ŽéŽ–è¡°é‡—ä¿®å—å—½å›šåž‚å£½å«‚å®ˆå²«å³€å¸¥æ„"
  ],
  [
    "e2a1",
    "æˆæ‰‹æŽˆæœæ”¶æ•¸æ¨¹æ®Šæ°´æ´™æ¼±ç‡§ç‹©ç¸ç‡ç’²ç˜¦ç¡ç§€ç©—ç«ªç²¹ç¶ç¶¬ç¹¡ç¾žè„©èŒ±è’è“šè—ªè¢–èª°è®è¼¸é‚é‚ƒé…¬éŠ–éŠ¹éš‹éš§éš¨é›–éœ€é ˆé¦–é«“é¬šå”å¡¾å¤™å­°å®¿æ·‘æ½šç†Ÿç¡ç’¹è‚…è½å·¡å¾‡å¾ªæ‚æ—¬æ ’æ¥¯æ©“æ®‰æ´µæ·³ç£ç›¾çž¬ç­ç´”è„£èˆœè€è“´è•£è©¢è«„é†‡éŒžé †é¦´æˆŒè¡“è¿°é‰¥å´‡å´§"
  ],
  [
    "e3a1",
    "åµ©ç‘Ÿè†è¨æ¿•æ‹¾ç¿’è¤¶è¥²ä¸žä¹˜åƒ§å‹å‡æ‰¿æ˜‡ç¹©è …é™žä¾åŒ™å˜¶å§‹åª¤å°¸å±Žå±å¸‚å¼‘æƒæ–½æ˜¯æ™‚æž¾æŸ´çŒœçŸ¢ç¤ºç¿…è’”è“è¦–è©¦è©©è«¡è±•è±ºåŸ´å¯”å¼æ¯æ‹­æ¤æ®–æ¹œç†„ç¯’è•è­˜è»¾é£Ÿé£¾ä¼¸ä¾ä¿¡å‘»å¨ å®¸æ„¼æ–°æ™¨ç‡¼ç”³ç¥žç´³è…Žè‡£èŽ˜è–ªè—Žèœƒè¨Šèº«è¾›ï¥±è¿…å¤±å®¤å¯¦æ‚‰å¯©å°‹å¿ƒæ²"
  ],
  [
    "e4a1",
    "ï¥²æ·±ç€‹ç”šèŠ¯è«¶ä»€åï¥³é›™æ°äºžä¿„å…’å•žå¨¥å³¨æˆ‘ç‰™èŠ½èŽªè›¾è¡™è¨é˜¿é›…é¤“é´‰éµå Šå²³å¶½å¹„æƒ¡æ„•æ¡æ¨‚æ¸¥é„‚é”é¡Žé°é½·å®‰å²¸æŒ‰æ™æ¡ˆçœ¼é›éžé¡”é®Ÿæ–¡è¬è»‹é–¼å”µå²©å·–åºµæš—ç™Œè´é—‡å£“æŠ¼ç‹Žé´¨ä»°å¤®æ€æ˜»æ®ƒç§§é´¦åŽ“å“€åŸƒå´–æ„›æ›–æ¶¯ç¢è‰¾éš˜é„åŽ„æ‰¼æŽ–æ¶²ç¸Šè…‹é¡"
  ],
  [
    "e5a1",
    "æ«»ç½Œé¶¯é¸šä¹Ÿå€»å†¶å¤œæƒ¹æ¶æ¤°çˆºè€¶ï¥´é‡Žå¼±ï¥µï¥¶ç´„è‹¥è‘¯è’»è—¥èºï¥·ä½¯ï¥¸ï¥¹å£¤å­ƒæ™æšæ”˜æ•­æš˜ï¥ºæ¥Šæ¨£æ´‹ç€ç…¬ç—’ç˜ç¦³ç©°ï¥»ç¾Šï¥¼è¥„ï¥½è®“é‡€é™½ï¥¾é¤Šåœ„å¾¡æ–¼æ¼ç˜€ç¦¦èªžé¦­é­šé½¬å„„æ†¶æŠ‘æªè‡†åƒå °å½¦ç„‰è¨€è«ºå­¼è˜–ä¿ºå„¼åš´å¥„æŽ©æ·¹å¶ªæ¥­å††äºˆä½™ï¥¿ï¦€ï¦å¦‚ï¦‚"
  ],
  [
    "e6a1",
    "ï¦ƒæ­Ÿæ±ï¦„ç’µç¤–ï¦…èˆ‡è‰…èŒ¹è¼¿è½ï¦†é¤˜ï¦‡ï¦ˆï¦‰äº¦ï¦ŠåŸŸå½¹æ˜“ï¦‹ï¦Œç–«ç¹¹è­¯ï¦é€†é©›åš¥å §å§¸å¨Ÿå®´ï¦Žå»¶ï¦ï¦ææŒ»ï¦‘æ¤½æ²‡æ²¿æ¶Žæ¶“æ·µæ¼”ï¦’çƒŸç„¶ç…™ï¦“ç‡ƒç‡•ï¦”ç¡ç¡¯ï¦•ç­µç·£ï¦–ç¸¯ï¦—è¡è»Ÿï¦˜ï¦™ï¦šé‰›ï¦›é³¶ï¦œï¦ï¦žæ‚…æ¶…ï¦Ÿç†±ï¦ ï¦¡é–±åŽ­ï¦¢ï¦£ï¦¤æŸ“ï¦¥ç‚Žç„°ç°è‰¶è‹’"
  ],
  [
    "e7a1",
    "ï¦¦é–»é«¥é¹½æ›„ï¦§ç‡è‘‰ï¦¨ï¦©å¡‹ï¦ªï¦«å¶¸å½±ï¦¬æ˜ æšŽæ¥¹æ¦®æ°¸æ³³æ¸¶æ½æ¿šç€›ç€¯ç…ç‡Ÿç°ï¦­ç‘›ï¦®ç“”ç›ˆç©Žçº“ï¦¯ï¦°è‹±è© è¿Žï¦±éˆï¦²éœ™ï¦³ï¦´ä¹‚å€ªï¦µåˆˆå¡æ›³æ±­æ¿ŠçŒŠç¿ç©¢èŠ®è—è˜‚ï¦¶è£”è©£è­½è±«ï¦·éŠ³ï¦¸éœ“é äº”ä¼ä¿‰å‚²åˆå¾å³å—šå¡¢å¢ºå¥§å¨›å¯¤æ‚Ÿï¦¹æ‡Šæ•–æ—¿æ™¤æ¢§æ±šæ¾³"
  ],
  [
    "e8a1",
    "çƒç†¬ç’ç­½èœˆèª¤é°²é¼‡å±‹æ²ƒç„çŽ‰éˆºæº«ç‘¥ç˜Ÿç©©ç¸•è˜Šå…€å£…æ“ç“®ç”•ç™°ç¿é‚•é›é¥”æ¸¦ç“¦çª©çªªè‡¥è›™è¸è¨›å©‰å®Œå®›æ¢¡æ¤€æµ£çŽ©ç“ç¬ç¢—ç·©ç¿«è„˜è…•èŽžè±Œé˜®é ‘æ›°å¾€æ—ºæž‰æ±ªçŽ‹å€­å¨ƒæ­ªçŸ®å¤–åµ¬å·çŒ¥ç•ï¦ºï¦»åƒ¥å‡¹å ¯å¤­å¦–å§šå¯¥ï¦¼ï¦½å¶¢æ‹—æ–æ’“æ“¾ï¦¾æ›œï¦¿æ©ˆï§€ç‡¿ç‘¤ï§"
  ],
  [
    "e9a1",
    "çªˆçª¯ç¹‡ç¹žè€€è…°ï§‚èŸ¯è¦è¬ é™ï§ƒé‚€é¥’æ…¾æ¬²æµ´ç¸Ÿè¤¥è¾±ä¿‘å‚­å†—å‹‡åŸ‡å¢‰å®¹åº¸æ…‚æ¦•æ¶Œæ¹§æº¶ç†”ç‘¢ç”¨ç”¬è³èŒ¸è“‰è¸ŠéŽ”éžï§„äºŽä½‘å¶å„ªåˆå‹å³å®‡å¯“å°¤æ„šæ†‚æ—´ç‰›çŽ—ç‘€ç›‚ç¥ç¦‘ç¦¹ç´†ç¾½èŠ‹è—•è™žè¿‚é‡éƒµé‡ªéš…é›¨é›©å‹–å½§æ—­æ˜±æ ¯ç…œç¨¶éƒé Šäº‘ï§…æ©’æ®žæ¾ç†‰è€˜èŠ¸è•“"
  ],
  [
    "eaa1",
    "é‹éš•é›²éŸ»è”šé¬±äºç†Šé›„å…ƒåŽŸå“¡åœ“åœ’åž£åª›å«„å¯ƒæ€¨æ„¿æ´æ²…æ´¹æ¹²æºçˆ°çŒ¿ç‘—è‹‘è¢è½…é ï§†é™¢é¡˜é´›æœˆè¶Šé‰žä½å‰åƒžå±åœå§”å¨å°‰æ…°æšæ¸­çˆ²ç‘‹ç·¯èƒƒèŽè‘¦è”¿èŸè¡›è¤˜è¬‚é•éŸ‹é­ä¹³ä¾‘å„’å…ªï§‡å”¯å–©å­ºå®¥å¹¼å¹½åº¾æ‚ æƒŸæ„ˆæ„‰æ„æ”¸æœ‰ï§ˆæŸ”æŸšï§‰æ¥¡æ¥¢æ²¹æ´§ï§Šæ¸¸ï§‹"
  ],
  [
    "eba1",
    "æ¿¡çŒ¶çŒ·ï§Œç‘œç”±ï§ç™’ï§Žï§ç¶­è‡¾è¸è£•èª˜è«›è«­è¸°è¹‚éŠé€¾éºé…‰é‡‰é®ï§ï§‘å ‰ï§’æ¯“è‚‰è‚²ï§“ï§”å…å¥«å°¹ï§•ï§–æ½¤çŽ§èƒ¤è´‡ï§—éˆ—é–ï§˜ï§™ï§šï§›è¿æˆŽç€œçµ¨èžï§œåž æ©æ…‡æ®·èª¾éŠ€éš±ä¹™åŸæ·«è”­é™°éŸ³é£®æ–æ³£é‚‘å‡æ‡‰è†ºé·¹ä¾å€šå„€å®œæ„æ‡¿æ“¬æ¤…æ¯…ç–‘çŸ£ç¾©è‰¤è–èŸ»è¡£èª¼"
  ],
  [
    "eca1",
    "è­°é†«äºŒä»¥ä¼Šï§ï§žå¤·å§¨ï§Ÿå·²å¼›å½›æ€¡ï§ ï§¡ï§¢ï§£çˆ¾ç¥ï§¤ç•°ç—ï§¥ç§»ï§¦è€Œè€³è‚„è‹¡è‘ï§§ï§¨è²½è²³é‚‡ï§©ï§ªé£´é¤Œï§«ï§¬ç€·ç›Šç¿Šç¿Œç¿¼è¬šäººä»åˆƒå°ï§­å’½å› å§»å¯…å¼•å¿æ¹®ï§®ï§¯çµªèŒµï§°èš“èªï§±é­é·ï§²ï§³ä¸€ä½šä½¾å£¹æ—¥æº¢é€¸éŽ°é¦¹ä»»å£¬å¦Šå§™æï§´ï§µç¨”ï§¶èè³ƒå…¥å„"
  ],
  [
    "eda1",
    "ï§·ï§¸ï§¹ä»å‰©å­•èŠ¿ä»”åˆºå’¨å§‰å§¿å­å­—å­œæ£æ…ˆæ»‹ç‚™ç…®çŽ†ç“·ç–µç£ç´«è€…è‡ªèŒ¨è”—è—‰è«®è³‡é›Œä½œå‹ºåš¼æ–«æ˜¨ç¼ç‚¸çˆµç¶½èŠé…Œé›€éµ²å­±æ£§æ®˜æ½ºç›žå²‘æš«æ½›ç®´ç°ªè ¶é›œä¸ˆä»—åŒ å ´å¢»å£¯å¥¬å°‡å¸³åº„å¼µæŽŒæš²æ–æ¨Ÿæª£æ¬Œæ¼¿ç‰†ï§ºçç’‹ç« ç²§è…¸è‡Ÿè‡§èŽŠè‘¬è”£è–”è—è£è´“é†¬é•·"
  ],
  [
    "eea1",
    "éšœå†å“‰åœ¨å®°æ‰ææ ½æ¢“æ¸½æ»“ç½ç¸¡è£è²¡è¼‰é½‹é½Žçˆ­ç®è«éŒšä½‡ä½Žå„²å’€å§åº•æŠµæµæ¥®æ¨—æ²®æ¸šç‹™çŒªç–½ç®¸ç´µè‹§è¹è‘—è—·è©›è²¯èº‡é€™é‚¸é›Žé½Ÿå‹£åŠå«¡å¯‚æ‘˜æ•µæ»´ç‹„ï§»çš„ç©ç¬›ç±ç¸¾ç¿Ÿè»è¬«è³Šèµ¤è·¡è¹Ÿè¿ªè¿¹é©é‘ä½ƒä½ºå‚³å…¨å…¸å‰å‰ªå¡¡å¡¼å¥ å°ˆå±•å»›æ‚›æˆ°æ “æ®¿æ°ˆæ¾±"
  ],
  [
    "efa1",
    "ç…Žç ç”°ç”¸ç•‘ç™²ç­Œç®‹ç®­ç¯†çºè©®è¼¾è½‰éˆ¿éŠ“éŒ¢é«é›»é¡šé¡«é¤žåˆ‡æˆªæŠ˜æµ™ç™¤ç«Šç¯€çµ¶å å²¾åº—æ¼¸ç‚¹ç²˜éœ‘é®Žé»žæŽ¥æ‘ºè¶ä¸äº•äº­åœåµå‘ˆå§ƒå®šå¹€åº­å»·å¾æƒ…æŒºæ”¿æ•´æ—Œæ™¶æ™¸æŸ¾æ¥¨æª‰æ­£æ±€æ·€æ·¨æ¸Ÿæ¹žç€žç‚¡çŽŽç½ç”ºç›ç¢‡ç¦Žç¨‹ç©½ç²¾ç¶Žè‰‡è¨‚è«ªè²žé„­é…Šé‡˜é‰¦é‹ŒéŒ éœ†é–"
  ],
  [
    "f0a1",
    "éœé ‚é¼Žåˆ¶åŠ‘å•¼å ¤å¸å¼Ÿæ‚Œææ¢¯æ¿Ÿç¥­ç¬¬è‡è–ºè£½è«¸è¹„é†é™¤éš›éœ½é¡Œé½Šä¿Žå…†å‡‹åŠ©å˜²å¼”å½«æŽªæ“æ—©æ™æ›ºæ›¹æœæ¢æ£—æ§½æ¼•æ½®ç…§ç‡¥çˆªç’ªçœºç¥–ç¥šç§Ÿç¨ çª•ç²—ç³Ÿçµ„ç¹°è‚‡è—»èš¤è©”èª¿è¶™èºé€ é­é‡£é˜»é›•é³¥æ—ç°‡è¶³éƒå­˜å°Šå’æ‹™çŒå€§å®—å¾žæ‚°æ…«æ£•æ·™ç®ç¨®çµ‚ç¶œç¸±è…«"
  ],
  [
    "f1a1",
    "è¸ªè¸µé¾é˜ä½åå·¦åº§æŒ«ç½ªä¸»ä½ä¾åšå§èƒ„å‘ªå‘¨å—¾å¥å®™å·žå»šæ™æœ±æŸ±æ ªæ³¨æ´²æ¹Šæ¾ç‚·ç ç–‡ç±Œç´‚ç´¬ç¶¢èˆŸè››è¨»èª…èµ°èºŠè¼³é€±é…Žé…’é‘„é§ç«¹ç²¥ä¿Šå„å‡†åŸˆå¯¯å³»æ™™æ¨½æµšæº–æ¿¬ç„Œç•¯ç«£è ¢é€¡éµé›‹é§¿èŒä¸­ä»²è¡†é‡å½æ«›æ¥«æ±è‘ºå¢žæ†Žæ›¾æ‹¯çƒç”‘ç—‡ç¹’è’¸è­‰è´ˆä¹‹åª"
  ],
  [
    "f2a1",
    "å’«åœ°å€å¿—æŒæŒ‡æ‘¯æ”¯æ—¨æ™ºæžæž³æ­¢æ± æ²šæ¼¬çŸ¥ç ¥ç¥‰ç¥—ç´™è‚¢è„‚è‡³èŠèŠ·èœ˜èªŒï§¼è´„è¶¾é²ç›´ç¨™ç¨·ç¹”è·å”‡å—”å¡µæŒ¯æ¢æ™‰æ™‹æ¡­æ¦›æ®„æ´¥æº±çç‘¨ç’¡ç•›ç–¹ç›¡çœžçž‹ç§¦ç¸‰ç¸è‡»è”¯è¢—è¨ºè³‘è»«è¾°é€²éŽ­é™£é™³éœ‡ä¾„å±å§ªå«‰å¸™æ¡Žç“†ç–¾ç§©çª’è†£è›­è³ªè·Œè¿­æ–Ÿæœ•ï§½åŸ·æ½—ç·è¼¯"
  ],
  [
    "f3a1",
    "é¶é›†å¾µæ‡²æ¾„ä¸”ä¾˜å€Ÿå‰å—Ÿåµ¯å·®æ¬¡æ­¤ç£‹ç®šï§¾è¹‰è»Šé®æ‰æ¾ç€çª„éŒ¯é‘¿é½ªæ’°æ¾¯ç‡¦ç’¨ç“šç«„ç°’çº‚ç²²çº˜è®šè´Šé‘½é¤é¥Œåˆ¹å¯Ÿæ“¦æœ­ç´®åƒ­åƒå¡¹æ…˜æ…™æ‡ºæ–¬ç«™è®’è®–å€‰å€¡å‰µå”±å¨¼å» å½°æ„´æ•žæ˜Œæ˜¶æš¢æ§æ»„æ¼²çŒ–ç˜¡çª“è„¹è‰™è–è’¼å‚µåŸ°å¯€å¯¨å½©æŽ¡ç ¦ç¶µèœè”¡é‡‡é‡µå†ŠæŸµç­–"
  ],
  [
    "f4a1",
    "è²¬å‡„å¦»æ‚½è™•å€œï§¿å‰”å°ºæ…½æˆšæ‹“æ“²æ–¥æ»Œç˜ è„Šè¹ é™Ÿéš»ä»Ÿåƒå–˜å¤©å·æ“…æ³‰æ·ºçŽ”ç©¿èˆ›è–¦è³¤è¸é·é‡§é—¡é˜¡éŸ†å‡¸å“²å–†å¾¹æ’¤æ¾ˆç¶´è¼Ÿè½éµåƒ‰å°–æ²¾æ·»ç”›çž»ç°½ç±¤è©¹è«‚å žå¦¾å¸–æ·ç‰’ç–Šç«è«œè²¼è¼’å»³æ™´æ·¸è½èè«‹é‘é¯–ï¨€å‰ƒæ›¿æ¶•æ»¯ç· è«¦é€®éžé«”åˆå‰¿å“¨æ†”æŠ„æ‹›æ¢¢"
  ],
  [
    "f5a1",
    "æ¤’æ¥šæ¨µç‚’ç„¦ç¡ç¤ç¤Žç§’ç¨è‚–è‰¸è‹•è‰è•‰è²‚è¶…é…¢é†‹é†®ä¿ƒå›‘ç‡­çŸ—èœ€è§¸å¯¸å¿–æ‘é‚¨å¢å¡šå¯µæ‚¤æ†æ‘ ç¸½è°è”¥éŠƒæ’®å‚¬å´”æœ€å¢œæŠ½æŽ¨æ¤Žæ¥¸æ¨žæ¹«çšºç§‹èŠ»è©è«è¶¨è¿½é„’é…‹é†œéŒéŒ˜éŽšé››é¨¶é°ä¸‘ç•œç¥ç«ºç­‘ç¯‰ç¸®è“„è¹™è¹´è»¸é€æ˜¥æ¤¿ç‘ƒå‡ºæœ®é»œå……å¿ æ²–èŸ²è¡è¡·æ‚´è†µèƒ"
  ],
  [
    "f6a1",
    "è´…å–å¹å˜´å¨¶å°±ç‚Šç¿ èšè„†è‡­è¶£é†‰é©Ÿé·²å´ä»„åŽ æƒ»æ¸¬å±¤ä¾ˆå€¤å—¤å³™å¹Ÿæ¥æ¢”æ²»æ·„ç†¾ç—”ç—´ç™¡ç¨šç©‰ç·‡ç·»ç½®è‡´èš©è¼œé›‰é¦³é½’å‰‡å‹…é£­è¦ªä¸ƒæŸ’æ¼†ä¾µå¯¢æž•æ²ˆæµ¸ç›ç §é‡é¼èŸ„ç§¤ç¨±å¿«ä»–å’¤å”¾å¢®å¦¥æƒ°æ‰“æ‹–æœ¶æ¥•èˆµé™€é¦±é§å€¬å“å•„å¼ï¨æ‰˜ï¨‚æ“¢æ™«æŸæ¿æ¿¯ç¢ç¸è¨—"
  ],
  [
    "f7a1",
    "é¸å‘‘å˜†å¦å½ˆæ†šæ­Žç˜ç‚­ç¶»èª•å¥ªè„«æŽ¢çœˆè€½è²ªå¡”æ­æ¦»å®•å¸‘æ¹¯ï¨ƒè•©å…Œå°å¤ªæ€ æ…‹æ®†æ±°æ³°ç¬žèƒŽè‹”è·†é‚°é¢±ï¨„æ“‡æ¾¤æ’‘æ”„å…ŽååœŸè¨Žæ…Ÿæ¡¶ï¨…ç—›ç­’çµ±é€šå †æ§Œè…¿è¤ªé€€é ¹å¸å¥—å¦¬æŠ•é€é¬ªæ…ç‰¹é—–å¡å©†å·´æŠŠæ’­æ“ºæ·æ³¢æ´¾çˆ¬ç¶ç ´ç½·èŠ­è·›é —åˆ¤å‚æ¿ç‰ˆç“£è²©è¾¦éˆ‘"
  ],
  [
    "f8a1",
    "é˜ªå…«å­æŒä½©å”„æ‚–æ•—æ²›æµ¿ç‰Œç‹½ç¨—è¦‡è²å½­æ¾Žçƒ¹è†¨æ„Žä¾¿åæ‰ç‰‡ç¯‡ç·¨ç¿©ééž­é¨™è²¶åªå¹³æž°èè©•å å¬–å¹£å»¢å¼Šæ–ƒè‚ºè”½é–‰é™›ä½ˆåŒ…åŒåŒå’†å“ºåœƒå¸ƒæ€–æŠ›æŠ±æ•ï¨†æ³¡æµ¦ç–±ç ²èƒžè„¯è‹žè‘¡è’²è¢è¤’é€‹é‹ªé£½é®‘å¹…æš´æ›ç€‘çˆ†ï¨‡ä¿µå‰½å½ªæ…“æ“æ¨™æ¼‚ç“¢ç¥¨è¡¨è±¹é£‡é£„é©ƒ"
  ],
  [
    "f9a1",
    "å“ç¨Ÿæ¥“è«·è±Šé¢¨é¦®å½¼æŠ«ç–²çš®è¢«é¿é™‚åŒ¹å¼¼å¿…æ³ŒçŒç•¢ç–‹ç­†è‹¾é¦ä¹é€¼ä¸‹ä½•åŽ¦å¤å»ˆæ˜°æ²³ç‘•è·è¦è³€ééœžé°•å£‘å­¸è™è¬”é¶´å¯’æ¨æ‚æ—±æ±—æ¼¢æ¾£ç€šç½•ç¿°é–‘é–’é™éŸ“å‰²è½„å‡½å«å’¸å•£å–Šæª»æ¶µç·˜è‰¦éŠœé™·é¹¹åˆå“ˆç›’è›¤é–¤é—”é™œäº¢ä¼‰å§®å«¦å··æ’æŠ—æ­æ¡æ²†æ¸¯ç¼¸è‚›èˆª"
  ],
  [
    "faa1",
    "ï¨ˆï¨‰é …äº¥å•å’³åž“å¥šå­©å®³æ‡ˆæ¥·æµ·ç€£èŸ¹è§£è©²è«§é‚‚é§­éª¸åŠ¾æ ¸å€–å¹¸æè‡è¡Œäº«å‘åš®ç¦é„•éŸ¿é¤‰é¥—é¦™å™“å¢Ÿè™›è¨±æ†²æ«¶ç»è»’æ­‡éšªé©—å¥•çˆ€èµ«é©ä¿”å³´å¼¦æ‡¸æ™›æ³«ç‚«çŽ„çŽ¹ç¾çœ©ççµƒçµ¢ç¸£èˆ·è¡’ï¨Šè³¢é‰‰é¡¯å­‘ç©´è¡€é å«Œä¿ å”å¤¾å³½æŒ¾æµ¹ç‹¹è„…è„‡èŽ¢é‹é °äº¨å…„åˆ‘åž‹"
  ],
  [
    "fba1",
    "å½¢æ³‚æ»Žç€…çç‚¯ç†’ç©ç‘©èŠèž¢è¡¡é€ˆé‚¢éŽ£é¦¨å…®å½—æƒ æ…§æš³è•™è¹Šé†¯éž‹ä¹Žäº’å‘¼å£•å£ºå¥½å²µå¼§æˆ¶æ‰ˆæ˜Šæ™§æ¯«æµ©æ·æ¹–æ»¸æ¾”æ¿ æ¿©çç‹ç¥ç‘šç“ çš“ç¥œç³Šç¸žèƒ¡èŠ¦è‘«è’¿è™Žè™Ÿè´è­·è±ªéŽ¬é €é¡¥æƒ‘æˆ–é…·å©šæ˜æ··æ¸¾ç¿é­‚å¿½æƒšç¬å“„å¼˜æ±žæ³“æ´ªçƒ˜ç´…è™¹è¨Œé´»åŒ–å’Œå¬…æ¨ºç«ç•µ"
  ],
  [
    "fca1",
    "ç¦ç¦¾èŠ±è¯è©±è­è²¨é´ï¨‹æ“´æ”«ç¢ºç¢»ç©«ä¸¸å–šå¥å®¦å¹»æ‚£æ›æ­¡æ™¥æ¡“æ¸™ç…¥ç’°ç´ˆé‚„é©©é°¥æ´»æ»‘çŒ¾è±é—Šå‡°å¹Œå¾¨ææƒ¶æ„°æ…Œæ™ƒæ™„æ¦¥æ³æ¹Ÿæ»‰æ½¢ç…Œç’œçš‡ç¯ç°§è’è—é‘éšé»ƒåŒ¯å›žå»»å¾Šæ¢æ‚”æ‡·æ™¦æœƒæªœæ·®æ¾®ç°çªç¹ªè†¾èŒ´è›”èª¨è³„åŠƒç²å®–æ©«é„å“®åš†å­æ•ˆæ–…æ›‰æ¢Ÿæ¶æ·†"
  ],
  [
    "fda1",
    "çˆ»è‚´é…µé©ä¾¯å€™åŽšåŽå¼å–‰å—…å¸¿å¾Œæœ½ç…¦çé€…å‹›å‹³å¡¤å£Žç„„ç†ç‡»è–°è¨“æšˆè–¨å–§æš„ç…Šè±å‰å–™æ¯å½™å¾½æ®æš‰ç…‡è«±è¼éº¾ä¼‘æºçƒ‹ç•¦è™§æ¤è­Žé·¸å…‡å‡¶åŒˆæ´¶èƒ¸é»‘æ˜•æ¬£ç‚˜ç—•åƒå±¹ç´‡è¨–æ¬ æ¬½æ­†å¸æ°æ´½ç¿•èˆˆåƒ–å‡žå–œå™«å›å§¬å¬‰å¸Œæ†™æ†˜æˆ±æ™žæ›¦ç†™ç†¹ç†ºçŠ§ç¦§ç¨€ç¾²è©°"
  ]
];
const require$$6 = [
  [
    "0",
    "\0",
    127
  ],
  [
    "a140",
    "ã€€ï¼Œã€ã€‚ï¼Žâ€§ï¼›ï¼šï¼Ÿï¼ï¸°â€¦â€¥ï¹ï¹‘ï¹’Â·ï¹”ï¹•ï¹–ï¹—ï½œâ€“ï¸±â€”ï¸³â•´ï¸´ï¹ï¼ˆï¼‰ï¸µï¸¶ï½›ï½ï¸·ï¸¸ã€”ã€•ï¸¹ï¸ºã€ã€‘ï¸»ï¸¼ã€Šã€‹ï¸½ï¸¾ã€ˆã€‰ï¸¿ï¹€ã€Œã€ï¹ï¹‚ã€Žã€ï¹ƒï¹„ï¹™ï¹š"
  ],
  [
    "a1a1",
    "ï¹›ï¹œï¹ï¹žâ€˜â€™â€œâ€ã€ã€žâ€µâ€²ï¼ƒï¼†ï¼Šâ€»Â§ã€ƒâ—‹â—â–³â–²â—Žâ˜†â˜…â—‡â—†â–¡â– â–½â–¼ãŠ£â„…Â¯ï¿£ï¼¿Ëï¹‰ï¹Šï¹ï¹Žï¹‹ï¹Œï¹Ÿï¹ ï¹¡ï¼‹ï¼Ã—Ã·Â±âˆšï¼œï¼žï¼â‰¦â‰§â‰ âˆžâ‰’â‰¡ï¹¢",
    4,
    "ï½žâˆ©âˆªâŠ¥âˆ âˆŸâŠ¿ã’ã‘âˆ«âˆ®âˆµâˆ´â™€â™‚âŠ•âŠ™â†‘â†“â†â†’â†–â†—â†™â†˜âˆ¥âˆ£ï¼"
  ],
  [
    "a240",
    "ï¼¼âˆ•ï¹¨ï¼„ï¿¥ã€’ï¿ ï¿¡ï¼…ï¼ â„ƒâ„‰ï¹©ï¹ªï¹«ã•ãŽœãŽãŽžãŽãŽ¡ãŽŽãŽã„Â°å…™å…›å…žå…å…¡å…£å—§ç“©ç³Žâ–",
    7,
    "â–â–Žâ–â–Œâ–‹â–Šâ–‰â”¼â”´â”¬â”¤â”œâ–”â”€â”‚â–•â”Œâ”â””â”˜â•­"
  ],
  [
    "a2a1",
    "â•®â•°â•¯â•â•žâ•ªâ•¡â—¢â—£â—¥â—¤â•±â•²â•³ï¼",
    9,
    "â… ",
    9,
    "ã€¡",
    8,
    "åå„å…ï¼¡",
    25,
    "ï½",
    21
  ],
  [
    "a340",
    "ï½—ï½˜ï½™ï½šÎ‘",
    16,
    "Î£",
    6,
    "Î±",
    16,
    "Ïƒ",
    6,
    "ã„…",
    10
  ],
  [
    "a3a1",
    "ã„",
    25,
    "Ë™Ë‰ËŠË‡Ë‹"
  ],
  [
    "a3e1",
    "â‚¬"
  ],
  [
    "a440",
    "ä¸€ä¹™ä¸ä¸ƒä¹ƒä¹äº†äºŒäººå„¿å…¥å…«å‡ åˆ€åˆåŠ›åŒ•ååœåˆä¸‰ä¸‹ä¸ˆä¸Šä¸«ä¸¸å‡¡ä¹…ä¹ˆä¹Ÿä¹žäºŽäº¡å…€åˆƒå‹ºåƒå‰å£åœŸå£«å¤•å¤§å¥³å­å­‘å­“å¯¸å°å°¢å°¸å±±å·å·¥å·±å·²å·³å·¾å¹²å»¾å¼‹å¼“æ‰"
  ],
  [
    "a4a1",
    "ä¸‘ä¸ä¸ä¸­ä¸°ä¸¹ä¹‹å°¹äºˆäº‘äº•äº’äº”äº¢ä»ä»€ä»ƒä»†ä»‡ä»ä»Šä»‹ä»„å…ƒå…å…§å…­å…®å…¬å†—å‡¶åˆ†åˆ‡åˆˆå‹»å‹¾å‹¿åŒ–åŒ¹åˆå‡å…åžåŽ„å‹åŠåå£¬å¤©å¤«å¤ªå¤­å­”å°‘å°¤å°ºå±¯å·´å¹»å»¿å¼”å¼•å¿ƒæˆˆæˆ¶æ‰‹æ‰Žæ”¯æ–‡æ–—æ–¤æ–¹æ—¥æ›°æœˆæœ¨æ¬ æ­¢æ­¹æ¯‹æ¯”æ¯›æ°æ°´ç«çˆªçˆ¶çˆ»ç‰‡ç‰™ç‰›çŠ¬çŽ‹ä¸™"
  ],
  [
    "a540",
    "ä¸–ä¸•ä¸”ä¸˜ä¸»ä¹ä¹ä¹Žä»¥ä»˜ä»”ä»•ä»–ä»—ä»£ä»¤ä»™ä»žå……å…„å†‰å†Šå†¬å‡¹å‡ºå‡¸åˆŠåŠ åŠŸåŒ…åŒ†åŒ—åŒä»ŸåŠå‰å¡å å¯å®åŽ»å¯å¤å³å¬å®å©å¨å¼å¸åµå«å¦åªå²å±å°å¥å­å»å››å›šå¤–"
  ],
  [
    "a5a1",
    "å¤®å¤±å¥´å¥¶å­•å®ƒå°¼å·¨å·§å·¦å¸‚å¸ƒå¹³å¹¼å¼å¼˜å¼—å¿…æˆŠæ‰“æ‰”æ‰’æ‰‘æ–¥æ—¦æœ®æœ¬æœªæœ«æœ­æ­£æ¯æ°‘æ°æ°¸æ±æ±€æ°¾çŠ¯çŽ„çŽ‰ç“œç“¦ç”˜ç”Ÿç”¨ç”©ç”°ç”±ç”²ç”³ç–‹ç™½çš®çš¿ç›®çŸ›çŸ¢çŸ³ç¤ºç¦¾ç©´ç«‹ä¸žä¸Ÿä¹’ä¹“ä¹©äº™äº¤äº¦äº¥ä»¿ä¼‰ä¼™ä¼Šä¼•ä¼ä¼ä¼‘ä¼ä»²ä»¶ä»»ä»°ä»³ä»½ä¼ä¼‹å…‰å…‡å…†å…ˆå…¨"
  ],
  [
    "a640",
    "å…±å†å†°åˆ—åˆ‘åˆ’åˆŽåˆ–åŠ£åŒˆåŒ¡åŒ å°å±å‰ååŒåŠååå‹å„å‘ååˆåƒåŽå†å’å› å›žå›åœ³åœ°åœ¨åœ­åœ¬åœ¯åœ©å¤™å¤šå¤·å¤¸å¦„å¥¸å¦ƒå¥½å¥¹å¦‚å¦å­—å­˜å®‡å®ˆå®…å®‰å¯ºå°–å±¹å·žå¸†å¹¶å¹´"
  ],
  [
    "a6a1",
    "å¼å¼›å¿™å¿–æˆŽæˆŒæˆæˆæ‰£æ‰›æ‰˜æ”¶æ—©æ—¨æ—¬æ—­æ›²æ›³æœ‰æœ½æœ´æœ±æœµæ¬¡æ­¤æ­»æ°–æ±æ±—æ±™æ±Ÿæ± æ±æ±•æ±¡æ±›æ±æ±Žç°ç‰Ÿç‰ç™¾ç«¹ç±³ç³¸ç¼¶ç¾Šç¾½è€è€ƒè€Œè€’è€³è¿è‚‰è‚‹è‚Œè‡£è‡ªè‡³è‡¼èˆŒèˆ›èˆŸè‰®è‰²è‰¾è™«è¡€è¡Œè¡£è¥¿é˜¡ä¸²äº¨ä½ä½ä½‡ä½—ä½žä¼´ä½›ä½•ä¼°ä½ä½‘ä¼½ä¼ºä¼¸ä½ƒä½”ä¼¼ä½†ä½£"
  ],
  [
    "a740",
    "ä½œä½ ä¼¯ä½Žä¼¶ä½™ä½ä½ˆä½šå…Œå…‹å…å…µå†¶å†·åˆ¥åˆ¤åˆ©åˆªåˆ¨åŠ«åŠ©åŠªåŠ¬åŒ£å³åµåå­åžå¾å¦å‘Žå§å‘†å‘ƒå³å‘ˆå‘‚å›å©å‘Šå¹å»å¸å®åµå¶å å¼å‘€å±å«åŸå¬å›ªå›°å›¤å›«åŠå‘å€å"
  ],
  [
    "a7a1",
    "å‡åŽåœ¾åååœ»å£¯å¤¾å¦å¦’å¦¨å¦žå¦£å¦™å¦–å¦å¦¤å¦“å¦Šå¦¥å­å­œå­šå­›å®Œå®‹å®å°¬å±€å±å°¿å°¾å²å²‘å²”å²Œå·«å¸Œåºåº‡åºŠå»·å¼„å¼Ÿå½¤å½¢å½·å½¹å¿˜å¿Œå¿—å¿å¿±å¿«å¿¸å¿ªæˆ’æˆ‘æŠ„æŠ—æŠ–æŠ€æ‰¶æŠ‰æ‰­æŠŠæ‰¼æ‰¾æ‰¹æ‰³æŠ’æ‰¯æŠ˜æ‰®æŠ•æŠ“æŠ‘æŠ†æ”¹æ”»æ”¸æ—±æ›´æŸæŽæææ‘æœæ–æžæ‰æ†æ "
  ],
  [
    "a840",
    "æ“æ—æ­¥æ¯æ±‚æ±žæ²™æ²æ²ˆæ²‰æ²…æ²›æ±ªæ±ºæ²æ±°æ²Œæ±¨æ²–æ²’æ±½æ²ƒæ±²æ±¾æ±´æ²†æ±¶æ²æ²”æ²˜æ²‚ç¶ç¼ç½ç¸ç‰¢ç‰¡ç‰ ç‹„ç‹‚çŽ–ç”¬ç”«ç”·ç”¸çš‚ç›¯çŸ£ç§ç§€ç¦¿ç©¶ç³»ç½•è‚–è‚“è‚è‚˜è‚›è‚šè‚²è‰¯èŠ’"
  ],
  [
    "a8a1",
    "èŠ‹èŠè¦‹è§’è¨€è°·è±†è±•è²èµ¤èµ°è¶³èº«è»Šè¾›è¾°è¿‚è¿†è¿…è¿„å·¡é‚‘é‚¢é‚ªé‚¦é‚£é…‰é‡†é‡Œé˜²é˜®é˜±é˜ªé˜¬ä¸¦ä¹–ä¹³äº‹äº›äºžäº«äº¬ä½¯ä¾ä¾ä½³ä½¿ä½¬ä¾›ä¾‹ä¾†ä¾ƒä½°ä½µä¾ˆä½©ä½»ä¾–ä½¾ä¾ä¾‘ä½ºå…”å…’å…•å…©å…·å…¶å…¸å†½å‡½åˆ»åˆ¸åˆ·åˆºåˆ°åˆ®åˆ¶å‰åŠ¾åŠ»å’å”å“å‘å¦å·å¸å¹å–å”å—å‘³å‘µ"
  ],
  [
    "a940",
    "å’–å‘¸å’•å’€å‘»å‘·å’„å’’å’†å‘¼å’å‘±å‘¶å’Œå’šå‘¢å‘¨å’‹å‘½å’Žå›ºåžƒå·åªå©å¡å¦å¤å¼å¤œå¥‰å¥‡å¥ˆå¥„å¥”å¦¾å¦»å§”å¦¹å¦®å§‘å§†å§å§å§‹å§“å§Šå¦¯å¦³å§’å§…å­Ÿå­¤å­£å®—å®šå®˜å®œå®™å®›å°šå±ˆå±…"
  ],
  [
    "a9a1",
    "å±†å²·å²¡å²¸å²©å²«å²±å²³å¸˜å¸šå¸–å¸•å¸›å¸‘å¹¸åºšåº—åºœåº•åº–å»¶å¼¦å¼§å¼©å¾€å¾å½¿å½¼å¿å¿ å¿½å¿µå¿¿æ€æ€”æ€¯æ€µæ€–æ€ªæ€•æ€¡æ€§æ€©æ€«æ€›æˆ–æˆ•æˆ¿æˆ¾æ‰€æ‰¿æ‹‰æ‹Œæ‹„æŠ¿æ‹‚æŠ¹æ‹’æ‹›æŠ«æ‹“æ‹”æ‹‹æ‹ˆæŠ¨æŠ½æŠ¼æ‹æ‹™æ‹‡æ‹æŠµæ‹šæŠ±æ‹˜æ‹–æ‹—æ‹†æŠ¬æ‹Žæ”¾æ–§æ–¼æ—ºæ˜”æ˜“æ˜Œæ˜†æ˜‚æ˜Žæ˜€æ˜æ˜•æ˜Š"
  ],
  [
    "aa40",
    "æ˜‡æœæœ‹æ­æž‹æž•æ±æžœæ³æ·æž‡æžæž—æ¯æ°æ¿æž‰æ¾æžæµæžšæž“æ¼æªæ²æ¬£æ­¦æ­§æ­¿æ°“æ°›æ³£æ³¨æ³³æ²±æ³Œæ³¥æ²³æ²½æ²¾æ²¼æ³¢æ²«æ³•æ³“æ²¸æ³„æ²¹æ³æ²®æ³—æ³…æ³±æ²¿æ²»æ³¡æ³›æ³Šæ²¬æ³¯æ³œæ³–æ³ "
  ],
  [
    "aaa1",
    "ç‚•ç‚Žç‚’ç‚Šç‚™çˆ¬çˆ­çˆ¸ç‰ˆç‰§ç‰©ç‹€ç‹Žç‹™ç‹—ç‹çŽ©çŽ¨çŽŸçŽ«çŽ¥ç”½ç–ç–™ç–šçš„ç›‚ç›²ç›´çŸ¥çŸ½ç¤¾ç¥€ç¥ç§‰ç§ˆç©ºç©¹ç«ºç³¾ç½”ç¾Œç¾‹è€…è‚ºè‚¥è‚¢è‚±è‚¡è‚«è‚©è‚´è‚ªè‚¯è‡¥è‡¾èˆèŠ³èŠèŠ™èŠ­èŠ½èŠŸèŠ¹èŠ±èŠ¬èŠ¥èŠ¯èŠ¸èŠ£èŠ°èŠ¾èŠ·è™Žè™±åˆè¡¨è»‹è¿Žè¿”è¿‘é‚µé‚¸é‚±é‚¶é‡‡é‡‘é•·é–€é˜œé™€é˜¿é˜»é™„"
  ],
  [
    "ab40",
    "é™‚éš¹é›¨é’éžäºŸäº­äº®ä¿¡ä¾µä¾¯ä¾¿ä¿ ä¿‘ä¿ä¿ä¿ƒä¾¶ä¿˜ä¿Ÿä¿Šä¿—ä¾®ä¿ä¿„ä¿‚ä¿šä¿Žä¿žä¾·å…—å†’å†‘å† å‰Žå‰ƒå‰Šå‰å‰Œå‰‹å‰‡å‹‡å‹‰å‹ƒå‹åŒå—å»åŽšå›å’¬å“€å’¨å“Žå“‰å’¸å’¦å’³å“‡å“‚å’½å’ªå“"
  ],
  [
    "aba1",
    "å“„å“ˆå’¯å’«å’±å’»å’©å’§å’¿å›¿åž‚åž‹åž åž£åž¢åŸŽåž®åž“å¥•å¥‘å¥å¥Žå¥å§œå§˜å§¿å§£å§¨å¨ƒå§¥å§ªå§šå§¦å¨å§»å­©å®£å®¦å®¤å®¢å®¥å°å±Žå±å±å±‹å³™å³’å··å¸å¸¥å¸Ÿå¹½åº åº¦å»ºå¼ˆå¼­å½¥å¾ˆå¾…å¾Šå¾‹å¾‡å¾Œå¾‰æ€’æ€æ€ æ€¥æ€Žæ€¨ææ°æ¨æ¢æ†æƒæ¬æ«æªæ¤æ‰æ‹œæŒ–æŒ‰æ‹¼æ‹­æŒæ‹®æ‹½æŒ‡æ‹±æ‹·"
  ],
  [
    "ac40",
    "æ‹¯æ‹¬æ‹¾æ‹´æŒ‘æŒ‚æ”¿æ•…æ–«æ–½æ—¢æ˜¥æ˜­æ˜ æ˜§æ˜¯æ˜Ÿæ˜¨æ˜±æ˜¤æ›·æŸ¿æŸ“æŸ±æŸ”æŸæŸ¬æž¶æž¯æŸµæŸ©æŸ¯æŸ„æŸ‘æž´æŸšæŸ¥æž¸æŸæŸžæŸ³æž°æŸ™æŸ¢æŸæŸ’æ­ªæ®ƒæ®†æ®µæ¯’æ¯—æ°Ÿæ³‰æ´‹æ´²æ´ªæµæ´¥æ´Œæ´±æ´žæ´—"
  ],
  [
    "aca1",
    "æ´»æ´½æ´¾æ´¶æ´›æ³µæ´¹æ´§æ´¸æ´©æ´®æ´µæ´Žæ´«ç‚«ç‚ºç‚³ç‚¬ç‚¯ç‚­ç‚¸ç‚®ç‚¤çˆ°ç‰²ç‰¯ç‰´ç‹©ç‹ ç‹¡çŽ·çŠçŽ»çŽ²çç€çŽ³ç”šç”­ç•ç•Œç•Žç•‹ç–«ç–¤ç–¥ç–¢ç–£ç™¸çš†çš‡çšˆç›ˆç›†ç›ƒç›…çœç›¹ç›¸çœ‰çœ‹ç›¾ç›¼çœ‡çŸœç ‚ç ”ç Œç ç¥†ç¥‰ç¥ˆç¥‡ç¦¹ç¦ºç§‘ç§’ç§‹ç©¿çªç«¿ç«½ç±½ç´‚ç´…ç´€ç´‰ç´‡ç´„ç´†ç¼¸ç¾Žç¾¿è€„"
  ],
  [
    "ad40",
    "è€è€è€‘è€¶èƒ–èƒ¥èƒšèƒƒèƒ„èƒŒèƒ¡èƒ›èƒŽèƒžèƒ¤èƒè‡´èˆ¢è‹§èŒƒèŒ…è‹£è‹›è‹¦èŒ„è‹¥èŒ‚èŒ‰è‹’è‹—è‹±èŒè‹œè‹”è‹‘è‹žè‹“è‹Ÿè‹¯èŒ†è™è™¹è™»è™ºè¡è¡«è¦è§”è¨ˆè¨‚è¨ƒè²žè² èµ´èµ³è¶´è»è»Œè¿°è¿¦è¿¢è¿ªè¿¥"
  ],
  [
    "ada1",
    "è¿­è¿«è¿¤è¿¨éƒŠéƒŽéƒéƒƒé…‹é…Šé‡é–‚é™é™‹é™Œé™é¢é©éŸ‹éŸ­éŸ³é é¢¨é£›é£Ÿé¦–é¦™ä¹˜äº³å€Œå€å€£ä¿¯å€¦å€¥ä¿¸å€©å€–å€†å€¼å€Ÿå€šå€’å€‘ä¿ºå€€å€”å€¨ä¿±å€¡å€‹å€™å€˜ä¿³ä¿®å€­å€ªä¿¾å€«å€‰å…¼å†¤å†¥å†¢å‡å‡Œå‡†å‡‹å‰–å‰œå‰”å‰›å‰åŒªå¿åŽŸåŽåŸå“¨å”å”å”·å“¼å“¥å“²å”†å“ºå””å“©å“­å“¡å”‰å“®å“ª"
  ],
  [
    "ae40",
    "å“¦å”§å”‡å“½å”åœƒåœ„åŸ‚åŸ”åŸ‹åŸƒå ‰å¤å¥—å¥˜å¥šå¨‘å¨˜å¨œå¨Ÿå¨›å¨“å§¬å¨ å¨£å¨©å¨¥å¨Œå¨‰å­«å±˜å®°å®³å®¶å®´å®®å®µå®¹å®¸å°„å±‘å±•å±å³­å³½å³»å³ªå³¨å³°å³¶å´å³´å·®å¸­å¸«åº«åº­åº§å¼±å¾’å¾‘å¾æ™"
  ],
  [
    "aea1",
    "æ£æ¥ææ•æ­æ©æ¯æ‚„æ‚Ÿæ‚šæ‚æ‚”æ‚Œæ‚…æ‚–æ‰‡æ‹³æŒˆæ‹¿æŽæŒ¾æŒ¯æ•æ‚æ†ææ‰æŒºææŒ½æŒªæŒ«æŒ¨ææŒæ•ˆæ•‰æ–™æ—æ—…æ™‚æ™‰æ™æ™ƒæ™’æ™Œæ™…æ™æ›¸æœ”æœ•æœ—æ ¡æ ¸æ¡ˆæ¡†æ¡“æ ¹æ¡‚æ¡”æ ©æ¢³æ —æ¡Œæ¡‘æ ½æŸ´æ¡æ¡€æ ¼æ¡ƒæ ªæ¡…æ “æ ˜æ¡æ®Šæ®‰æ®·æ°£æ°§æ°¨æ°¦æ°¤æ³°æµªæ¶•æ¶ˆæ¶‡æµ¦æµ¸æµ·æµ™æ¶“"
  ],
  [
    "af40",
    "æµ¬æ¶‰æµ®æµšæµ´æµ©æ¶Œæ¶Šæµ¹æ¶…æµ¥æ¶”çƒŠçƒ˜çƒ¤çƒ™çƒˆçƒçˆ¹ç‰¹ç‹¼ç‹¹ç‹½ç‹¸ç‹·çŽ†ç­ç‰ç®ç çªçžç•”ç•ç•œç•šç•™ç–¾ç—…ç—‡ç–²ç–³ç–½ç–¼ç–¹ç—‚ç–¸çš‹çš°ç›Šç›ç›Žçœ©çœŸçœ çœ¨çŸ©ç °ç §ç ¸ç ç ´ç ·"
  ],
  [
    "afa1",
    "ç ¥ç ­ç  ç Ÿç ²ç¥•ç¥ç¥ ç¥Ÿç¥–ç¥žç¥ç¥—ç¥šç§¤ç§£ç§§ç§Ÿç§¦ç§©ç§˜çª„çªˆç«™ç¬†ç¬‘ç²‰ç´¡ç´—ç´‹ç´Šç´ ç´¢ç´”ç´ç´•ç´šç´œç´ç´™ç´›ç¼ºç½Ÿç¾”ç¿…ç¿è€†è€˜è€•è€™è€—è€½è€¿èƒ±è„‚èƒ°è„…èƒ­èƒ´è„†èƒ¸èƒ³è„ˆèƒ½è„Šèƒ¼èƒ¯è‡­è‡¬èˆ€èˆèˆªèˆ«èˆ¨èˆ¬èŠ»èŒ«è’è”èŠèŒ¸èè‰èŒµèŒ´èèŒ²èŒ¹èŒ¶èŒ—è€èŒ±èŒ¨èƒ"
  ],
  [
    "b040",
    "è™”èšŠèšªèš“èš¤èš©èšŒèš£èšœè¡°è¡·è¢è¢‚è¡½è¡¹è¨˜è¨è¨Žè¨Œè¨•è¨Šè¨—è¨“è¨–è¨è¨‘è±ˆè±ºè±¹è²¡è²¢èµ·èº¬è»’è»”è»è¾±é€é€†è¿·é€€è¿ºè¿´é€ƒè¿½é€…è¿¸é‚•éƒ¡éƒéƒ¢é…’é…é…Œé‡˜é‡é‡—é‡œé‡™é–ƒé™¢é™£é™¡"
  ],
  [
    "b0a1",
    "é™›é™é™¤é™˜é™žéš»é£¢é¦¬éª¨é«˜é¬¥é¬²é¬¼ä¹¾åºå½åœå‡åƒåŒåšå‰å¥å¶åŽå•åµå´å·åå€å¯å­å…œå†•å‡°å‰ªå‰¯å‹’å‹™å‹˜å‹•åŒåŒåŒ™åŒ¿å€åŒ¾åƒæ›¼å•†å•ªå•¦å•„å•žå•¡å•ƒå•Šå”±å•–å•å••å”¯å•¤å”¸å”®å•œå”¬å•£å”³å•å•—åœˆåœ‹åœ‰åŸŸå …å Šå †åŸ åŸ¤åŸºå ‚å µåŸ·åŸ¹å¤ å¥¢å¨¶å©å©‰å©¦å©ªå©€"
  ],
  [
    "b140",
    "å¨¼å©¢å©šå©†å©Šå­°å¯‡å¯…å¯„å¯‚å®¿å¯†å°‰å°ˆå°‡å± å±œå±å´‡å´†å´Žå´›å´–å´¢å´‘å´©å´”å´™å´¤å´§å´—å·¢å¸¸å¸¶å¸³å¸·åº·åº¸åº¶åºµåº¾å¼µå¼·å½—å½¬å½©å½«å¾—å¾™å¾žå¾˜å¾¡å¾ å¾œæ¿æ‚£æ‚‰æ‚ æ‚¨æƒ‹æ‚´æƒ¦æ‚½"
  ],
  [
    "b1a1",
    "æƒ…æ‚»æ‚µæƒœæ‚¼æƒ˜æƒ•æƒ†æƒŸæ‚¸æƒšæƒ‡æˆšæˆ›æ‰ˆæŽ æŽ§æ²æŽ–æŽ¢æŽ¥æ·æ§æŽ˜æŽªæ±æŽ©æŽ‰æŽƒæŽ›æ«æŽ¨æŽ„æŽˆæŽ™æŽ¡æŽ¬æŽ’æŽæŽ€æ»æ©æ¨æºæ•æ•–æ•‘æ•™æ•—å•Ÿæ•æ•˜æ••æ•”æ–œæ–›æ–¬æ—æ—‹æ—Œæ—Žæ™æ™šæ™¤æ™¨æ™¦æ™žæ›¹å‹—æœ›æ¢æ¢¯æ¢¢æ¢“æ¢µæ¡¿æ¡¶æ¢±æ¢§æ¢—æ¢°æ¢ƒæ£„æ¢­æ¢†æ¢…æ¢”æ¢æ¢¨æ¢Ÿæ¢¡æ¢‚æ¬²æ®º"
  ],
  [
    "b240",
    "æ¯«æ¯¬æ°«æ¶Žæ¶¼æ·³æ·™æ¶²æ·¡æ·Œæ·¤æ·»æ·ºæ¸…æ·‡æ·‹æ¶¯æ·‘æ¶®æ·žæ·¹æ¶¸æ··æ·µæ·…æ·’æ¸šæ¶µæ·šæ·«æ·˜æ·ªæ·±æ·®æ·¨æ·†æ·„æ¶ªæ·¬æ¶¿æ·¦çƒ¹ç„‰ç„Šçƒ½çƒ¯çˆ½ç‰½çŠçŒœçŒ›çŒ–çŒ“çŒ™çŽ‡ç…çŠçƒç†ç¾çç“ ç“¶"
  ],
  [
    "b2a1",
    "ç“·ç”œç”¢ç•¥ç•¦ç•¢ç•°ç–ç—”ç—•ç–µç—Šç—çšŽç›”ç›’ç››çœ·çœ¾çœ¼çœ¶çœ¸çœºç¡«ç¡ƒç¡Žç¥¥ç¥¨ç¥­ç§»çª’çª•ç¬ ç¬¨ç¬›ç¬¬ç¬¦ç¬™ç¬žç¬®ç²’ç²—ç²•çµ†çµƒçµ±ç´®ç´¹ç´¼çµ€ç´°ç´³çµ„ç´¯çµ‚ç´²ç´±ç¼½ç¾žç¾šç¿Œç¿Žç¿’è€œèŠè†è„¯è„–è„£è„«è„©è„°è„¤èˆ‚èˆµèˆ·èˆ¶èˆ¹èŽŽèŽžèŽ˜è¸èŽ¢èŽ–èŽ½èŽ«èŽ’èŽŠèŽ“èŽ‰èŽ è·è»è¼"
  ],
  [
    "b340",
    "èŽ†èŽ§è™•å½ªè›‡è›€èš¶è›„èšµè›†è›‹èš±èš¯è›‰è¡“è¢žè¢ˆè¢«è¢’è¢–è¢è¢‹è¦“è¦è¨ªè¨è¨£è¨¥è¨±è¨­è¨Ÿè¨›è¨¢è±‰è±šè²©è²¬è²«è²¨è²ªè²§èµ§èµ¦è¶¾è¶ºè»›è»Ÿé€™é€é€šé€—é€£é€Ÿé€é€é€•é€žé€ é€é€¢é€–é€›é€”"
  ],
  [
    "b3a1",
    "éƒ¨éƒ­éƒ½é…—é‡Žé‡µé‡¦é‡£é‡§é‡­é‡©é–‰é™ªé™µé™³é™¸é™°é™´é™¶é™·é™¬é›€é›ªé›©ç« ç«Ÿé ‚é ƒé­šé³¥é¹µé¹¿éº¥éº»å‚¢å‚å‚…å‚™å‚‘å‚€å‚–å‚˜å‚šæœ€å‡±å‰²å‰´å‰µå‰©å‹žå‹å‹›åšåŽ¥å•»å–€å–§å•¼å–Šå–å–˜å–‚å–œå–ªå–”å–‡å–‹å–ƒå–³å–®å–Ÿå”¾å–²å–šå–»å–¬å–±å•¾å–‰å–«å–™åœå ¯å ªå ´å ¤å °å ±å ¡å å  å£¹å£ºå¥ "
  ],
  [
    "b440",
    "å©·åªšå©¿åª’åª›åª§å­³å­±å¯’å¯Œå¯“å¯å°Šå°‹å°±åµŒåµå´´åµ‡å·½å¹…å¸½å¹€å¹ƒå¹¾å»Šå»å»‚å»„å¼¼å½­å¾©å¾ªå¾¨æƒ‘æƒ¡æ‚²æ‚¶æƒ æ„œæ„£æƒºæ„•æƒ°æƒ»æƒ´æ…¨æƒ±æ„Žæƒ¶æ„‰æ„€æ„’æˆŸæ‰‰æŽ£æŽŒææ€æ©æ‰æ†æ"
  ],
  [
    "b4a1",
    "æ’æ£ææ¡æ–æ­æ®æ¶æ´æªæ›æ‘’æšæ¹æ•žæ•¦æ•¢æ•£æ–‘æ–æ–¯æ™®æ™°æ™´æ™¶æ™¯æš‘æ™ºæ™¾æ™·æ›¾æ›¿æœŸæœæ£ºæ£•æ£ æ£˜æ£—æ¤…æ£Ÿæ£µæ£®æ£§æ£¹æ£’æ£²æ££æ£‹æ£æ¤æ¤’æ¤Žæ£‰æ£šæ¥®æ£»æ¬¾æ¬ºæ¬½æ®˜æ®–æ®¼æ¯¯æ°®æ°¯æ°¬æ¸¯æ¸¸æ¹”æ¸¡æ¸²æ¹§æ¹Šæ¸ æ¸¥æ¸£æ¸›æ¹›æ¹˜æ¸¤æ¹–æ¹®æ¸­æ¸¦æ¹¯æ¸´æ¹æ¸ºæ¸¬æ¹ƒæ¸æ¸¾æ»‹"
  ],
  [
    "b540",
    "æº‰æ¸™æ¹Žæ¹£æ¹„æ¹²æ¹©æ¹Ÿç„™ç„šç„¦ç„°ç„¡ç„¶ç…®ç„œç‰ŒçŠ„çŠ€çŒ¶çŒ¥çŒ´çŒ©çºçªç³ç¢ç¥çµç¶ç´ç¯ç›ç¦ç¨ç”¥ç”¦ç•«ç•ªç—¢ç—›ç—£ç—™ç—˜ç—žç— ç™»ç™¼çš–çš“çš´ç›œççŸ­ç¡ç¡¬ç¡¯ç¨ç¨ˆç¨‹ç¨…ç¨€çª˜"
  ],
  [
    "b5a1",
    "çª—çª–ç«¥ç«£ç­‰ç­–ç­†ç­ç­’ç­”ç­ç­‹ç­ç­‘ç²Ÿç²¥çµžçµçµ¨çµ•ç´«çµ®çµ²çµ¡çµ¦çµ¢çµ°çµ³å–„ç¿”ç¿•è€‹è’è‚…è…•è…”è…‹è…‘è…Žè„¹è…†è„¾è…Œè…“è…´èˆ’èˆœè©èƒè¸èè è…è‹èè¯è±è´è‘—èŠè°èŒèŒè½è²èŠè¸èŽè„èœè‡è”èŸè™›è›Ÿè›™è›­è›”è››è›¤è›è›žè¡—è£è£‚è¢±è¦ƒè¦–è¨»è© è©•è©žè¨¼è©"
  ],
  [
    "b640",
    "è©”è©›è©è©†è¨´è¨ºè¨¶è©–è±¡è²‚è²¯è²¼è²³è²½è³è²»è³€è²´è²·è²¶è²¿è²¸è¶Šè¶…è¶è·Žè·è·‹è·šè·‘è·Œè·›è·†è»»è»¸è»¼è¾œé€®é€µé€±é€¸é€²é€¶é„‚éƒµé„‰éƒ¾é…£é…¥é‡éˆ”éˆ•éˆ£éˆ‰éˆžéˆéˆéˆ‡éˆ‘é–”é–é–‹é–‘"
  ],
  [
    "b6a1",
    "é–“é–’é–ŽéšŠéšŽéš‹é™½éš…éš†éšé™²éš„é›é›…é›„é›†é›‡é›¯é›²éŸŒé …é †é ˆé£§é£ªé£¯é£©é£²é£­é¦®é¦­é»ƒé»é»‘äº‚å‚­å‚µå‚²å‚³åƒ…å‚¾å‚¬å‚·å‚»å‚¯åƒ‡å‰¿å‰·å‰½å‹Ÿå‹¦å‹¤å‹¢å‹£åŒ¯å—Ÿå—¨å—“å—¦å—Žå—œå—‡å—‘å—£å—¤å—¯å—šå—¡å—…å—†å—¥å—‰åœ’åœ“å¡žå¡‘å¡˜å¡—å¡šå¡”å¡«å¡Œå¡­å¡Šå¡¢å¡’å¡‹å¥§å«å«‰å«Œåª¾åª½åª¼"
  ],
  [
    "b740",
    "åª³å«‚åª²åµ©åµ¯å¹Œå¹¹å»‰å»ˆå¼’å½™å¾¬å¾®æ„šæ„æ…ˆæ„Ÿæƒ³æ„›æƒ¹æ„æ„ˆæ…Žæ…Œæ…„æ…æ„¾æ„´æ„§æ„æ„†æ„·æˆ¡æˆ¢æ“æ¾æžæªæ­æ½æ¬ææœæ”ææ¶æ–æ—æ†æ•¬æ–Ÿæ–°æš—æš‰æš‡æšˆæš–æš„æš˜æšæœƒæ¦”æ¥­"
  ],
  [
    "b7a1",
    "æ¥šæ¥·æ¥ æ¥”æ¥µæ¤°æ¦‚æ¥Šæ¥¨æ¥«æ¥žæ¥“æ¥¹æ¦†æ¥æ¥£æ¥›æ­‡æ­²æ¯€æ®¿æ¯“æ¯½æº¢æº¯æ»“æº¶æ»‚æºæºæ»‡æ»…æº¥æº˜æº¼æººæº«æ»‘æº–æºœæ»„æ»”æºªæº§æº´ç…Žç…™ç…©ç…¤ç…‰ç…§ç…œç…¬ç…¦ç…Œç…¥ç…žç…†ç…¨ç…–çˆºç‰’çŒ·ç…çŒ¿çŒ¾ç‘¯ç‘šç‘•ç‘Ÿç‘žç‘ç¿ç‘™ç‘›ç‘œç•¶ç•¸ç˜€ç—°ç˜ç—²ç—±ç—ºç—¿ç—´ç—³ç›žç›Ÿç›ç«ç¦çžç£"
  ],
  [
    "b840",
    "ç¹çªç¬çœç¥ç¨ç¢çŸ®ç¢Žç¢°ç¢—ç¢˜ç¢Œç¢‰ç¡¼ç¢‘ç¢“ç¡¿ç¥ºç¥¿ç¦è¬ç¦½ç¨œç¨šç¨ ç¨”ç¨Ÿç¨žçªŸçª ç­·ç¯€ç­ ç­®ç­§ç²±ç²³ç²µç¶“çµ¹ç¶‘ç¶ç¶çµ›ç½®ç½©ç½ªç½²ç¾©ç¾¨ç¾¤è–è˜è‚†è‚„è…±è…°è…¸è…¥è…®è…³è…«"
  ],
  [
    "b8a1",
    "è…¹è…ºè…¦èˆ…è‰‡è’‚è‘·è½è±è‘µè‘¦è‘«è‘‰è‘¬è‘›è¼èµè‘¡è‘£è‘©è‘­è‘†è™žè™œè™Ÿè›¹èœ“èœˆèœ‡èœ€è›¾è›»èœ‚èœƒèœ†èœŠè¡™è£Ÿè£”è£™è£œè£˜è£è£¡è£Šè£•è£’è¦œè§£è©«è©²è©³è©¦è©©è©°èª‡è©¼è©£èª è©±èª…è©­è©¢è©®è©¬è©¹è©»è¨¾è©¨è±¢è²Šè²‰è³Šè³‡è³ˆè³„è²²è³ƒè³‚è³…è·¡è·Ÿè·¨è·¯è·³è·ºè·ªè·¤è·¦èº²è¼ƒè¼‰è»¾è¼Š"
  ],
  [
    "b940",
    "è¾Ÿè¾²é‹éŠé“é‚é”é€¼é•éé‡ééŽéé‘é€¾éé„’é„—é…¬é…ªé…©é‡‰éˆ·é‰—éˆ¸éˆ½é‰€éˆ¾é‰›é‰‹é‰¤é‰‘éˆ´é‰‰é‰é‰…éˆ¹éˆ¿é‰šé–˜éš˜éš”éš•é›é›‹é›‰é›Šé›·é›»é›¹é›¶é–é´é¶é é ‘é “é Šé ’é Œé£¼é£´"
  ],
  [
    "b9a1",
    "é£½é£¾é¦³é¦±é¦´é«¡é³©éº‚é¼Žé¼“é¼ åƒ§åƒ®åƒ¥åƒ–åƒ­åƒšåƒ•åƒåƒ‘åƒ±åƒŽåƒ©å…¢å‡³åŠƒåŠ‚åŒ±åŽ­å—¾å˜€å˜›å˜—å—½å˜”å˜†å˜‰å˜å˜Žå—·å˜–å˜Ÿå˜ˆå˜å—¶åœ˜åœ–å¡µå¡¾å¢ƒå¢“å¢Šå¡¹å¢…å¡½å£½å¤¥å¤¢å¤¤å¥ªå¥©å«¡å«¦å«©å«—å«–å«˜å«£å­µå¯žå¯§å¯¡å¯¥å¯¦å¯¨å¯¢å¯¤å¯Ÿå°å±¢å¶„å¶‡å¹›å¹£å¹•å¹—å¹”å»“å»–å¼Šå½†å½°å¾¹æ…‡"
  ],
  [
    "ba40",
    "æ„¿æ…‹æ…·æ…¢æ…£æ…Ÿæ…šæ…˜æ…µæˆªæ’‡æ‘˜æ‘”æ’¤æ‘¸æ‘Ÿæ‘ºæ‘‘æ‘§æ´æ‘­æ‘»æ•²æ–¡æ——æ—–æš¢æš¨æšæ¦œæ¦¨æ¦•æ§æ¦®æ§“æ§‹æ¦›æ¦·æ¦»æ¦«æ¦´æ§æ§æ¦­æ§Œæ¦¦æ§ƒæ¦£æ­‰æ­Œæ°³æ¼³æ¼”æ»¾æ¼“æ»´æ¼©æ¼¾æ¼ æ¼¬æ¼æ¼‚æ¼¢"
  ],
  [
    "baa1",
    "æ»¿æ»¯æ¼†æ¼±æ¼¸æ¼²æ¼£æ¼•æ¼«æ¼¯æ¾ˆæ¼ªæ»¬æ¼æ»²æ»Œæ»·ç†”ç†™ç…½ç†Šç†„ç†’çˆ¾çŠ’çŠ–ç„çç‘¤ç‘£ç‘ªç‘°ç‘­ç”„ç–‘ç˜§ç˜ç˜‹ç˜‰ç˜“ç›¡ç›£çž„ç½ç¿ç¡ç£ç¢Ÿç¢§ç¢³ç¢©ç¢£ç¦Žç¦ç¦ç¨®ç¨±çªªçª©ç«­ç«¯ç®¡ç®•ç®‹ç­µç®—ç®ç®”ç®ç®¸ç®‡ç®„ç²¹ç²½ç²¾ç¶»ç¶°ç¶œç¶½ç¶¾ç¶ ç·Šç¶´ç¶²ç¶±ç¶ºç¶¢ç¶¿ç¶µç¶¸ç¶­ç·’ç·‡ç¶¬"
  ],
  [
    "bb40",
    "ç½°ç¿ ç¿¡ç¿Ÿèžèšè‚‡è…è†€è†è†ˆè†Šè…¿è†‚è‡§è‡ºèˆ‡èˆ”èˆžè‰‹è“‰è’¿è“†è“„è’™è’žè’²è’œè“‹è’¸è“€è““è’è’¼è“‘è“Šèœ¿èœœèœ»èœ¢èœ¥èœ´èœ˜è•èœ·èœ©è£³è¤‚è£´è£¹è£¸è£½è£¨è¤šè£¯èª¦èªŒèªžèª£èªèª¡èª“èª¤"
  ],
  [
    "bba1",
    "èªªèª¥èª¨èª˜èª‘èªšèª§è±ªè²è²Œè³“è³‘è³’èµ«è¶™è¶•è·¼è¼”è¼’è¼•è¼“è¾£é é˜éœé£é™éžé¢éé›é„™é„˜é„žé…µé…¸é…·é…´é‰¸éŠ€éŠ…éŠ˜éŠ–é‰»éŠ“éŠœéŠ¨é‰¼éŠ‘é–¡é–¨é–©é–£é–¥é–¤éš™éšœéš›é›Œé›’éœ€é¼éž…éŸ¶é —é ˜é¢¯é¢±é¤ƒé¤…é¤Œé¤‰é§éª¯éª°é«¦é­é­‚é³´é³¶é³³éº¼é¼»é½Šå„„å„€åƒ»åƒµåƒ¹å„‚å„ˆå„‰å„…å‡œ"
  ],
  [
    "bc40",
    "åŠ‡åŠˆåŠ‰åŠåŠŠå‹°åŽ²å˜®å˜»å˜¹å˜²å˜¿å˜´å˜©å™“å™Žå™—å™´å˜¶å˜¯å˜°å¢€å¢Ÿå¢žå¢³å¢œå¢®å¢©å¢¦å¥­å¬‰å«»å¬‹å«µå¬Œå¬ˆå¯®å¯¬å¯©å¯«å±¤å±¥å¶å¶”å¹¢å¹Ÿå¹¡å»¢å»šå»Ÿå»å»£å» å½ˆå½±å¾·å¾µæ…¶æ…§æ…®æ…æ…•æ†‚"
  ],
  [
    "bca1",
    "æ…¼æ…°æ…«æ…¾æ†§æ†æ†«æ†Žæ†¬æ†šæ†¤æ†”æ†®æˆ®æ‘©æ‘¯æ‘¹æ’žæ’²æ’ˆæ’æ’°æ’¥æ’“æ’•æ’©æ’’æ’®æ’­æ’«æ’šæ’¬æ’™æ’¢æ’³æ•µæ•·æ•¸æš®æš«æš´æš±æ¨£æ¨Ÿæ§¨æ¨æ¨žæ¨™æ§½æ¨¡æ¨“æ¨Šæ§³æ¨‚æ¨…æ§­æ¨‘æ­æ­Žæ®¤æ¯…æ¯†æ¼¿æ½¼æ¾„æ½‘æ½¦æ½”æ¾†æ½­æ½›æ½¸æ½®æ¾Žæ½ºæ½°æ½¤æ¾—æ½˜æ»•æ½¯æ½ æ½Ÿç†Ÿç†¬ç†±ç†¨ç‰–çŠ›çŽç—ç‘©ç’‹ç’ƒ"
  ],
  [
    "bd40",
    "ç‘¾ç’€ç•¿ç˜ ç˜©ç˜Ÿç˜¤ç˜¦ç˜¡ç˜¢çššçšºç›¤çžŽçž‡çžŒçž‘çž‹ç£‹ç£…ç¢ºç£Šç¢¾ç£•ç¢¼ç£ç¨¿ç¨¼ç©€ç¨½ç¨·ç¨»çª¯çª®ç®­ç®±ç¯„ç®´ç¯†ç¯‡ç¯ç® ç¯Œç³Šç· ç·´ç·¯ç·»ç·˜ç·¬ç·ç·¨ç·£ç·šç·žç·©ç¶žç·™ç·²ç·¹ç½µç½·ç¾¯"
  ],
  [
    "bda1",
    "ç¿©è€¦è†›è†œè†è† è†šè†˜è”—è”½è”šè“®è”¬è”­è”“è”‘è”£è”¡è””è“¬è”¥è“¿è”†èž‚è´è¶è è¦è¸è¨è™è—èŒè“è¡›è¡è¤è¤‡è¤’è¤“è¤•è¤Šèª¼è«’è«‡è«„èª•è«‹è«¸èª²è«‰è«‚èª¿èª°è«–è«èª¶èª¹è«›è±Œè±Žè±¬è³ è³žè³¦è³¤è³¬è³­è³¢è³£è³œè³ªè³¡èµ­è¶Ÿè¶£è¸«è¸è¸è¸¢è¸è¸©è¸Ÿè¸¡è¸žèººè¼è¼›è¼Ÿè¼©è¼¦è¼ªè¼œè¼ž"
  ],
  [
    "be40",
    "è¼¥é©é®é¨é­é·é„°é„­é„§é„±é†‡é†‰é†‹é†ƒé‹…éŠ»éŠ·é‹ªéŠ¬é‹¤é‹éŠ³éŠ¼é‹’é‹‡é‹°éŠ²é–­é–±éœ„éœ†éœ‡éœ‰é éžéž‹éžé ¡é «é œé¢³é¤Šé¤“é¤’é¤˜é§é§é§Ÿé§›é§‘é§•é§’é§™éª·é«®é«¯é¬§é­…é­„é­·é­¯é´†é´‰"
  ],
  [
    "bea1",
    "é´ƒéº©éº¾é»Žå¢¨é½’å„’å„˜å„”å„å„•å†€å†ªå‡åŠ‘åŠ“å‹³å™™å™«å™¹å™©å™¤å™¸å™ªå™¨å™¥å™±å™¯å™¬å™¢å™¶å£å¢¾å£‡å£…å¥®å¬å¬´å­¸å¯°å°Žå½Šæ†²æ†‘æ†©æ†Šæ‡æ†¶æ†¾æ‡Šæ‡ˆæˆ°æ“…æ“æ“‹æ’»æ’¼æ“šæ“„æ“‡æ“‚æ“æ’¿æ“’æ“”æ’¾æ•´æ›†æ›‰æš¹æ›„æ›‡æš¸æ¨½æ¨¸æ¨ºæ©™æ©«æ©˜æ¨¹æ©„æ©¢æ©¡æ©‹æ©‡æ¨µæ©Ÿæ©ˆæ­™æ­·æ°…æ¿‚æ¾±æ¾¡"
  ],
  [
    "bf40",
    "æ¿ƒæ¾¤æ¿æ¾§æ¾³æ¿€æ¾¹æ¾¶æ¾¦æ¾ æ¾´ç†¾ç‡‰ç‡ç‡’ç‡ˆç‡•ç†¹ç‡Žç‡™ç‡œç‡ƒç‡„ç¨ç’œç’£ç’˜ç’Ÿç’žç“¢ç”Œç”ç˜´ç˜¸ç˜ºç›§ç›¥çž çžžçžŸçž¥ç£¨ç£šç£¬ç£§ç¦¦ç©ç©Žç©†ç©Œç©‹çªºç¯™ç°‘ç¯‰ç¯¤ç¯›ç¯¡ç¯©ç¯¦ç³•ç³–ç¸Š"
  ],
  [
    "bfa1",
    "ç¸‘ç¸ˆç¸›ç¸£ç¸žç¸ç¸‰ç¸ç½¹ç¾²ç¿°ç¿±ç¿®è€¨è†³è†©è†¨è‡»èˆˆè‰˜è‰™è•Šè•™è•ˆè•¨è•©è•ƒè•‰è•­è•ªè•žèžƒèžŸèžžèž¢èžè¡¡è¤ªè¤²è¤¥è¤«è¤¡è¦ªè¦¦è«¦è«ºè««è«±è¬€è«œè«§è«®è«¾è¬è¬‚è«·è«­è«³è«¶è«¼è±«è±­è²“è³´è¹„è¸±è¸´è¹‚è¸¹è¸µè¼»è¼¯è¼¸è¼³è¾¨è¾¦éµé´é¸é²é¼éºé„´é†’éŒ éŒ¶é‹¸éŒ³éŒ¯éŒ¢é‹¼éŒ«éŒ„éŒš"
  ],
  [
    "c040",
    "éŒéŒ¦éŒ¡éŒ•éŒ®éŒ™é–»éš§éš¨éšªé›•éœŽéœ‘éœ–éœéœ“éœé›éœé¦éž˜é °é ¸é »é ·é ­é ¹é ¤é¤é¤¨é¤žé¤›é¤¡é¤šé§­é§¢é§±éª¸éª¼é«»é«­é¬¨é®‘é´•é´£é´¦é´¨é´’é´›é»˜é»”é¾é¾œå„ªå„Ÿå„¡å„²å‹µåšŽåš€åšåš…åš‡"
  ],
  [
    "c0a1",
    "åšå£•å£“å£‘å£Žå¬°å¬ªå¬¤å­ºå°·å±¨å¶¼å¶ºå¶½å¶¸å¹«å½Œå¾½æ‡‰æ‡‚æ‡‡æ‡¦æ‡‹æˆ²æˆ´æ“Žæ“Šæ“˜æ“ æ“°æ“¦æ“¬æ“±æ“¢æ“­æ–‚æ–ƒæ›™æ›–æª€æª”æª„æª¢æªœæ«›æª£æ©¾æª—æªæª æ­œæ®®æ¯šæ°ˆæ¿˜æ¿±æ¿Ÿæ¿ æ¿›æ¿¤æ¿«æ¿¯æ¾€æ¿¬æ¿¡æ¿©æ¿•æ¿®æ¿°ç‡§ç‡Ÿç‡®ç‡¦ç‡¥ç‡­ç‡¬ç‡´ç‡ çˆµç‰†ç°ç²ç’©ç’°ç’¦ç’¨ç™†ç™‚ç™Œç›ªçž³çžªçž°çž¬"
  ],
  [
    "c140",
    "çž§çž­çŸ¯ç£·ç£ºç£´ç£¯ç¤ç¦§ç¦ªç©—çª¿ç°‡ç°ç¯¾ç¯·ç°Œç¯ ç³ ç³œç³žç³¢ç³Ÿç³™ç³ç¸®ç¸¾ç¹†ç¸·ç¸²ç¹ƒç¸«ç¸½ç¸±ç¹…ç¹ç¸´ç¸¹ç¹ˆç¸µç¸¿ç¸¯ç½„ç¿³ç¿¼è±è²è°è¯è³è‡†è‡ƒè†ºè‡‚è‡€è†¿è†½è‡‰è†¾è‡¨èˆ‰è‰±è–ª"
  ],
  [
    "c1a1",
    "è–„è•¾è–œè–‘è–”è–¯è–›è–‡è–¨è–Šè™§èŸ€èŸ‘èž³èŸ’èŸ†èž«èž»èžºèŸˆèŸ‹è¤»è¤¶è¥„è¤¸è¤½è¦¬è¬Žè¬—è¬™è¬›è¬Šè¬ è¬è¬„è¬è±è°¿è±³è³ºè³½è³¼è³¸è³»è¶¨è¹‰è¹‹è¹ˆè¹Šè½„è¼¾è½‚è½…è¼¿é¿é½é‚„é‚é‚‚é‚€é„¹é†£é†žé†œééŽ‚éŒ¨éµéŠé¥é‹éŒ˜é¾é¬é›é°éšé”é—Šé—‹é—Œé—ˆé—†éš±éš¸é›–éœœéœžéž éŸ“é¡†é¢¶é¤µé¨"
  ],
  [
    "c240",
    "é§¿é®®é®«é®ªé®­é´»é´¿éº‹é»é»žé»œé»é»›é¼¾é½‹å¢åš•åš®å£™å£˜å¬¸å½æ‡£æˆ³æ“´æ“²æ“¾æ”†æ“ºæ“»æ“·æ–·æ›œæœ¦æª³æª¬æ«ƒæª»æª¸æ«‚æª®æª¯æ­Ÿæ­¸æ®¯ç€‰ç€‹æ¿¾ç€†æ¿ºç€‘ç€ç‡»ç‡¼ç‡¾ç‡¸ç·çµç’§ç’¿ç”•ç™–ç™˜"
  ],
  [
    "c2a1",
    "ç™’çž½çž¿çž»çž¼ç¤Žç¦®ç©¡ç©¢ç© ç«„ç«…ç°«ç°§ç°ªç°žç°£ç°¡ç³§ç¹”ç¹•ç¹žç¹šç¹¡ç¹’ç¹™ç½ˆç¿¹ç¿»è·è¶è‡è‡èˆŠè—è–©è—è—è—‰è–°è–ºè–¹è–¦èŸ¯èŸ¬èŸ²èŸ è¦†è¦²è§´è¬¨è¬¹è¬¬è¬«è±è´…è¹™è¹£è¹¦è¹¤è¹Ÿè¹•è»€è½‰è½é‚‡é‚ƒé‚ˆé†«é†¬é‡éŽ”éŽŠéŽ–éŽ¢éŽ³éŽ®éŽ¬éŽ°éŽ˜éŽšéŽ—é—”é—–é—é—•é›¢é›œé›™é››é›žéœ¤éž£éž¦"
  ],
  [
    "c340",
    "éž­éŸ¹é¡é¡é¡Œé¡Žé¡“é¢ºé¤¾é¤¿é¤½é¤®é¦¥é¨Žé«é¬ƒé¬†é­é­Žé­é¯Šé¯‰é¯½é¯ˆé¯€éµ‘éµéµ é» é¼•é¼¬å„³åš¥å£žå£Ÿå£¢å¯µé¾å»¬æ‡²æ‡·æ‡¶æ‡µæ”€æ”æ› æ›æ«¥æ«æ«šæ«“ç€›ç€Ÿç€¨ç€šç€ç€•ç€˜çˆ†çˆç‰˜çŠ¢ç¸"
  ],
  [
    "c3a1",
    "çºç’½ç“Šç“£ç–‡ç–†ç™Ÿç™¡çŸ‡ç¤™ç¦±ç©«ç©©ç°¾ç°¿ç°¸ç°½ç°·ç±€ç¹«ç¹­ç¹¹ç¹©ç¹ªç¾…ç¹³ç¾¶ç¾¹ç¾¸è‡˜è—©è—è—ªè—•è—¤è—¥è—·èŸ»è …è èŸ¹èŸ¾è¥ è¥Ÿè¥–è¥žè­è­œè­˜è­‰è­šè­Žè­è­†è­™è´ˆè´Šè¹¼è¹²èº‡è¹¶è¹¬è¹ºè¹´è½”è½Žè¾­é‚Šé‚‹é†±é†®é¡é‘éŸéƒéˆéœéé–é¢éé˜é¤é—é¨é—œéš´é›£éœªéœ§é¡éŸœéŸ»é¡ž"
  ],
  [
    "c440",
    "é¡˜é¡›é¢¼é¥…é¥‰é¨–é¨™é¬é¯¨é¯§é¯–é¯›é¶‰éµ¡éµ²éµªéµ¬éº’éº—éº“éº´å‹¸åš¨åš·åš¶åš´åš¼å£¤å­€å­ƒå­½å¯¶å·‰æ‡¸æ‡ºæ”˜æ””æ”™æ›¦æœ§æ«¬ç€¾ç€°ç€²çˆç»ç“ç™¢ç™¥ç¤¦ç¤ªç¤¬ç¤«ç«‡ç«¶ç±Œç±ƒç±ç³¯ç³°è¾®ç¹½ç¹¼"
  ],
  [
    "c4a1",
    "çº‚ç½Œè€€è‡šè‰¦è—»è—¹è˜‘è—ºè˜†è˜‹è˜‡è˜Šè ”è •è¥¤è¦ºè§¸è­°è­¬è­¦è­¯è­Ÿè­«è´è´èº‰èºèº…èº‚é†´é‡‹é˜éƒé½é—¡éœ°é£„é¥’é¥‘é¦¨é¨«é¨°é¨·é¨µé°“é°é¹¹éºµé»¨é¼¯é½Ÿé½£é½¡å„·å„¸å›å›€å›‚å¤”å±¬å·æ‡¼æ‡¾æ”æ”œæ–•æ›©æ«»æ¬„æ«ºæ®²çŒçˆ›çŠ§ç“–ç“”ç™©çŸ“ç±çºçºŒç¾¼è˜—è˜­è˜šè £è ¢è ¡è Ÿè¥ªè¥¬è¦½è­´"
  ],
  [
    "c540",
    "è­·è­½è´“èºŠèºèº‹è½Ÿè¾¯é†ºé®é³éµéºé¸é²é«é—¢éœ¸éœ¹éœ²éŸ¿é¡§é¡¥é¥—é©…é©ƒé©€é¨¾é«é­”é­‘é°­é°¥é¶¯é¶´é·‚é¶¸éºé»¯é¼™é½œé½¦é½§å„¼å„»å›ˆå›Šå›‰å­¿å·”å·’å½Žæ‡¿æ”¤æ¬Šæ­¡ç‘ç˜çŽ€ç“¤ç–Šç™®ç™¬"
  ],
  [
    "c5a1",
    "ç¦³ç± ç±Ÿè¾è½è‡Ÿè¥²è¥¯è§¼è®€è´–è´—èº‘èº“è½¡é…ˆé‘„é‘‘é‘’éœ½éœ¾éŸƒéŸé¡«é¥•é©•é©é«’é¬šé±‰é°±é°¾é°»é·“é·—é¼´é½¬é½ªé¾”å›Œå·–æˆ€æ”£æ”«æ”ªæ›¬æ¬ç“šç«Šç±¤ç±£ç±¥çº“çº–çº”è‡¢è˜¸è˜¿è ±è®Šé‚é‚é‘£é‘ é‘¤é¨é¡¯é¥œé©šé©›é©—é«“é«”é«‘é±”é±—é±–é·¥éºŸé»´å›‘å£©æ”¬çžç™±ç™²çŸ—ç½ç¾ˆè ¶è ¹è¡¢è®“è®’"
  ],
  [
    "c640",
    "è®–è‰·è´›é‡€é‘ªé‚éˆé„éŸ†é¡°é©Ÿé¬¢é­˜é±Ÿé·¹é·ºé¹¼é¹½é¼‡é½·é½²å»³æ¬–ç£ç±¬ç±®è »è§€èº¡é‡é‘²é‘°é¡±é¥žé«–é¬£é»Œç¤çŸšè®šé‘·éŸ‰é©¢é©¥çºœè®œèºªé‡…é‘½é‘¾é‘¼é±·é±¸é»·è±”é‘¿é¸šçˆ¨é©ªé¬±é¸›é¸žç±²"
  ],
  [
    "c940",
    "ä¹‚ä¹œå‡µåŒšåŽ‚ä¸‡ä¸Œä¹‡äºå›—ï¨Œå±®å½³ä¸å†‡ä¸Žä¸®äº“ä»‚ä»‰ä»ˆå†˜å‹¼å¬åŽ¹åœ å¤ƒå¤¬å°å·¿æ—¡æ®³æ¯Œæ°”çˆ¿ä¸±ä¸¼ä»¨ä»œä»©ä»¡ä»ä»šåˆŒåŒœåŒåœ¢åœ£å¤—å¤¯å®å®„å°’å°»å±´å±³å¸„åº€åº‚å¿‰æˆ‰æ‰æ°•"
  ],
  [
    "c9a1",
    "æ°¶æ±ƒæ°¿æ°»çŠ®çŠ°çŽŠç¦¸è‚Šé˜žä¼Žä¼˜ä¼¬ä»µä¼”ä»±ä¼€ä»·ä¼ˆä¼ä¼‚ä¼…ä¼¢ä¼“ä¼„ä»´ä¼’å†±åˆ“åˆ‰åˆåŠ¦åŒ¢åŒŸååŽŠå‡å›¡å›Ÿåœ®åœªåœ´å¤¼å¦€å¥¼å¦…å¥»å¥¾å¥·å¥¿å­–å°•å°¥å±¼å±ºå±»å±¾å·Ÿå¹µåº„å¼‚å¼šå½´å¿•å¿”å¿æ‰œæ‰žæ‰¤æ‰¡æ‰¦æ‰¢æ‰™æ‰ æ‰šæ‰¥æ—¯æ—®æœ¾æœ¹æœ¸æœ»æœºæœ¿æœ¼æœ³æ°˜æ±†æ±’æ±œæ±æ±Šæ±”æ±‹"
  ],
  [
    "ca40",
    "æ±Œç±ç‰žçŠ´çŠµçŽŽç”ªç™¿ç©µç½‘è‰¸è‰¼èŠ€è‰½è‰¿è™è¥¾é‚™é‚—é‚˜é‚›é‚”é˜¢é˜¤é˜ é˜£ä½–ä¼»ä½¢ä½‰ä½“ä½¤ä¼¾ä½§ä½’ä½Ÿä½ä½˜ä¼­ä¼³ä¼¿ä½¡å†å†¹åˆœåˆžåˆ¡åŠ­åŠ®åŒ‰å£å²åŽŽåŽå°å·åªå‘”å‘…å™åœå¥å˜"
  ],
  [
    "caa1",
    "å½å‘å‘å¨å¤å‘‡å›®å›§å›¥åå…åŒå‰å‹å’å¤†å¥€å¦¦å¦˜å¦ å¦—å¦Žå¦¢å¦å¦å¦§å¦¡å®Žå®’å°¨å°ªå²å²å²ˆå²‹å²‰å²’å²Šå²†å²“å²•å· å¸Šå¸Žåº‹åº‰åºŒåºˆåºå¼…å¼å½¸å½¶å¿’å¿‘å¿å¿­å¿¨å¿®å¿³å¿¡å¿¤å¿£å¿ºå¿¯å¿·å¿»æ€€å¿´æˆºæŠƒæŠŒæŠŽæŠæŠ”æŠ‡æ‰±æ‰»æ‰ºæ‰°æŠæŠˆæ‰·æ‰½æ‰²æ‰´æ”·æ—°æ—´æ—³æ—²æ—µæ…æ‡"
  ],
  [
    "cb40",
    "æ™æ•æŒæˆæææšæ‹æ¯æ°™æ°šæ±¸æ±§æ±«æ²„æ²‹æ²æ±±æ±¯æ±©æ²šæ±­æ²‡æ²•æ²œæ±¦æ±³æ±¥æ±»æ²Žç´çºç‰£çŠ¿çŠ½ç‹ƒç‹†ç‹çŠºç‹…çŽ•çŽ—çŽ“çŽ”çŽ’ç”ºç”¹ç–”ç–•çšç¤½è€´è‚•è‚™è‚è‚’è‚œèŠèŠèŠ…èŠŽèŠ‘èŠ“"
  ],
  [
    "cba1",
    "èŠŠèŠƒèŠ„è±¸è¿‰è¾¿é‚Ÿé‚¡é‚¥é‚žé‚§é‚ é˜°é˜¨é˜¯é˜­ä¸³ä¾˜ä½¼ä¾…ä½½ä¾€ä¾‡ä½¶ä½´ä¾‰ä¾„ä½·ä½Œä¾—ä½ªä¾šä½¹ä¾ä½¸ä¾ä¾œä¾”ä¾žä¾’ä¾‚ä¾•ä½«ä½®å†žå†¼å†¾åˆµåˆ²åˆ³å‰†åˆ±åŠ¼åŒŠåŒ‹åŒ¼åŽ’åŽ”å’‡å‘¿å’å’‘å’‚å’ˆå‘«å‘ºå‘¾å‘¥å‘¬å‘´å‘¦å’å‘¯å‘¡å‘ å’˜å‘£å‘§å‘¤å›·å›¹å¯å²å­å«å±å°å¶åž€åµå»å³å´å¢"
  ],
  [
    "cc40",
    "å¨å½å¤Œå¥…å¦µå¦ºå§å§Žå¦²å§Œå§å¦¶å¦¼å§ƒå§–å¦±å¦½å§€å§ˆå¦´å§‡å­¢å­¥å®“å®•å±„å±‡å²®å²¤å² å²µå²¯å²¨å²¬å²Ÿå²£å²­å²¢å²ªå²§å²å²¥å²¶å²°å²¦å¸—å¸”å¸™å¼¨å¼¢å¼£å¼¤å½”å¾‚å½¾å½½å¿žå¿¥æ€­æ€¦æ€™æ€²æ€‹"
  ],
  [
    "cca1",
    "æ€´æ€Šæ€—æ€³æ€šæ€žæ€¬æ€¢æ€æ€æ€®æ€“æ€‘æ€Œæ€‰æ€œæˆ”æˆ½æŠ­æŠ´æ‹‘æŠ¾æŠªæŠ¶æ‹ŠæŠ®æŠ³æŠ¯æŠ»æŠ©æŠ°æŠ¸æ”½æ–¨æ–»æ˜‰æ—¼æ˜„æ˜’æ˜ˆæ—»æ˜ƒæ˜‹æ˜æ˜…æ—½æ˜‘æ˜æ›¶æœŠæž…æ¬æžŽæž’æ¶æ»æž˜æž†æž„æ´æžæžŒæºæžŸæž‘æž™æžƒæ½æžæ¸æ¹æž”æ¬¥æ®€æ­¾æ¯žæ°æ²“æ³¬æ³«æ³®æ³™æ²¶æ³”æ²­æ³§æ²·æ³æ³‚æ²ºæ³ƒæ³†æ³­æ³²"
  ],
  [
    "cd40",
    "æ³’æ³æ²´æ²Šæ²æ²€æ³žæ³€æ´°æ³æ³‡æ²°æ³¹æ³æ³©æ³‘ç‚”ç‚˜ç‚…ç‚“ç‚†ç‚„ç‚‘ç‚–ç‚‚ç‚šç‚ƒç‰ªç‹–ç‹‹ç‹˜ç‹‰ç‹œç‹’ç‹”ç‹šç‹Œç‹‘çŽ¤çŽ¡çŽ­çŽ¦çŽ¢çŽ çŽ¬çŽç“ç“¨ç”¿ç•€ç”¾ç–Œç–˜çš¯ç›³ç›±ç›°ç›µçŸ¸çŸ¼çŸ¹çŸ»çŸº"
  ],
  [
    "cda1",
    "çŸ·ç¥‚ç¤¿ç§…ç©¸ç©»ç«»ç±µç³½è€µè‚è‚®è‚£è‚¸è‚µè‚­èˆ èŠ è‹€èŠ«èŠšèŠ˜èŠ›èŠµèŠ§èŠ®èŠ¼èŠžèŠºèŠ´èŠ¨èŠ¡èŠ©è‹‚èŠ¤è‹ƒèŠ¶èŠ¢è™°è™¯è™­è™®è±–è¿’è¿‹è¿“è¿è¿–è¿•è¿—é‚²é‚´é‚¯é‚³é‚°é˜¹é˜½é˜¼é˜ºé™ƒä¿ä¿…ä¿“ä¾²ä¿‰ä¿‹ä¿ä¿”ä¿œä¿™ä¾»ä¾³ä¿›ä¿‡ä¿–ä¾ºä¿€ä¾¹ä¿¬å‰„å‰‰å‹€å‹‚åŒ½å¼åŽ—åŽ–åŽ™åŽ˜å’ºå’¡å’­å’¥å“"
  ],
  [
    "ce40",
    "å“ƒèŒå’·å’®å“–å’¶å“…å“†å’ å‘°å’¼å’¢å’¾å‘²å“žå’°åžµåžžåžŸåž¤åžŒåž—åžåž›åž”åž˜åžåž™åž¥åžšåž•å£´å¤å¥“å§¡å§žå§®å¨€å§±å§å§ºå§½å§¼å§¶å§¤å§²å§·å§›å§©å§³å§µå§ å§¾å§´å§­å®¨å±Œå³å³˜å³Œå³—å³‹å³›"
  ],
  [
    "cea1",
    "å³žå³šå³‰å³‡å³Šå³–å³“å³”å³å³ˆå³†å³Žå³Ÿå³¸å·¹å¸¡å¸¢å¸£å¸ å¸¤åº°åº¤åº¢åº›åº£åº¥å¼‡å¼®å½–å¾†æ€·æ€¹æ”æ²æžæ…æ“æ‡æ‰æ›æŒæ€æ‚æŸæ€¤æ„æ˜æ¦æ®æ‰‚æ‰ƒæ‹æŒæŒ‹æ‹µæŒŽæŒƒæ‹«æ‹¹æŒæŒŒæ‹¸æ‹¶æŒ€æŒ“æŒ”æ‹ºæŒ•æ‹»æ‹°æ•æ•ƒæ–ªæ–¿æ˜¶æ˜¡æ˜²æ˜µæ˜œæ˜¦æ˜¢æ˜³æ˜«æ˜ºæ˜æ˜´æ˜¹æ˜®æœæœæŸæŸ²æŸˆæžº"
  ],
  [
    "cf40",
    "æŸœæž»æŸ¸æŸ˜æŸ€æž·æŸ…æŸ«æŸ¤æŸŸæžµæŸæž³æŸ·æŸ¶æŸ®æŸ£æŸ‚æž¹æŸŽæŸ§æŸ°æž²æŸ¼æŸ†æŸ­æŸŒæž®æŸ¦æŸ›æŸºæŸ‰æŸŠæŸƒæŸªæŸ‹æ¬¨æ®‚æ®„æ®¶æ¯–æ¯˜æ¯ æ° æ°¡æ´¨æ´´æ´­æ´Ÿæ´¼æ´¿æ´’æ´Šæ³šæ´³æ´„æ´™æ´ºæ´šæ´‘æ´€æ´æµ‚"
  ],
  [
    "cfa1",
    "æ´æ´˜æ´·æ´ƒæ´æµ€æ´‡æ´ æ´¬æ´ˆæ´¢æ´‰æ´ç‚·ç‚Ÿç‚¾ç‚±ç‚°ç‚¡ç‚´ç‚µç‚©ç‰ç‰‰ç‰Šç‰¬ç‰°ç‰³ç‰®ç‹Šç‹¤ç‹¨ç‹«ç‹Ÿç‹ªç‹¦ç‹£çŽ…çŒç‚çˆç…çŽ¹çŽ¶çŽµçŽ´ç«çŽ¿ç‡çŽ¾çƒç†çŽ¸ç‹ç“¬ç“®ç”®ç•‡ç•ˆç–§ç–ªç™¹ç›„çœˆçœƒçœ„çœ…çœŠç›·ç›»ç›ºçŸ§çŸ¨ç †ç ‘ç ’ç …ç ç ç Žç ‰ç ƒç “ç¥Šç¥Œç¥‹ç¥…ç¥„ç§•ç§ç§ç§–ç§Žçª€"
  ],
  [
    "d040",
    "ç©¾ç«‘ç¬€ç¬ç±ºç±¸ç±¹ç±¿ç²€ç²ç´ƒç´ˆç´ç½˜ç¾‘ç¾ç¾¾è€‡è€Žè€è€”è€·èƒ˜èƒ‡èƒ èƒ‘èƒˆèƒ‚èƒèƒ…èƒ£èƒ™èƒœèƒŠèƒ•èƒ‰èƒèƒ—èƒ¦èƒè‡¿èˆ¡èŠ”è‹™è‹¾è‹¹èŒ‡è‹¨èŒ€è‹•èŒºè‹«è‹–è‹´è‹¬è‹¡è‹²è‹µèŒŒè‹»è‹¶è‹°è‹ª"
  ],
  [
    "d0a1",
    "è‹¤è‹ è‹ºè‹³è‹­è™·è™´è™¼è™³è¡è¡Žè¡§è¡ªè¡©è§“è¨„è¨‡èµ²è¿£è¿¡è¿®è¿ éƒ±é‚½é‚¿éƒ•éƒ…é‚¾éƒ‡éƒ‹éƒˆé‡”é‡“é™”é™é™‘é™“é™Šé™Žå€žå€…å€‡å€“å€¢å€°å€›ä¿µä¿´å€³å€·å€¬ä¿¶ä¿·å€—å€œå€ å€§å€µå€¯å€±å€Žå…šå†”å†“å‡Šå‡„å‡…å‡ˆå‡Žå‰¡å‰šå‰’å‰žå‰Ÿå‰•å‰¢å‹åŒŽåŽžå”¦å“¢å”—å”’å“§å“³å“¤å”šå“¿å”„å”ˆå“«å”‘å”…å“±"
  ],
  [
    "d140",
    "å”Šå“»å“·å“¸å“ å”Žå”ƒå”‹åœåœ‚åŸŒå ²åŸ•åŸ’åžºåŸ†åž½åž¼åž¸åž¶åž¿åŸ‡åŸåž¹åŸå¤Žå¥Šå¨™å¨–å¨­å¨®å¨•å¨å¨—å¨Šå¨žå¨³å­¬å®§å®­å®¬å°ƒå±–å±”å³¬å³¿å³®å³±å³·å´€å³¹å¸©å¸¨åº¨åº®åºªåº¬å¼³å¼°å½§ææšæ§"
  ],
  [
    "d1a1",
    "ææ‚¢æ‚ˆæ‚€æ‚’æ‚æ‚æ‚ƒæ‚•æ‚›æ‚—æ‚‡æ‚œæ‚Žæˆ™æ‰†æ‹²æŒæ–æŒ¬æ„æ…æŒ¶æƒæ¤æŒ¹æ‹æŠæŒ¼æŒ©ææŒ´æ˜æ”æ™æŒ­æ‡æŒ³æšæ‘æŒ¸æ—æ€æˆæ•Šæ•†æ—†æ—ƒæ—„æ—‚æ™Šæ™Ÿæ™‡æ™‘æœ’æœ“æ Ÿæ šæ¡‰æ ²æ ³æ »æ¡‹æ¡æ –æ ±æ œæ µæ «æ ­æ ¯æ¡Žæ¡„æ ´æ æ ’æ ”æ ¦æ ¨æ ®æ¡æ ºæ ¥æ  æ¬¬æ¬¯æ¬­æ¬±æ¬´æ­­è‚‚æ®ˆæ¯¦æ¯¤"
  ],
  [
    "d240",
    "æ¯¨æ¯£æ¯¢æ¯§æ°¥æµºæµ£æµ¤æµ¶æ´æµ¡æ¶’æµ˜æµ¢æµ­æµ¯æ¶‘æ¶æ·¯æµ¿æ¶†æµžæµ§æµ æ¶—æµ°æµ¼æµŸæ¶‚æ¶˜æ´¯æµ¨æ¶‹æµ¾æ¶€æ¶„æ´–æ¶ƒæµ»æµ½æµµæ¶çƒœçƒ“çƒ‘çƒçƒ‹ç¼¹çƒ¢çƒ—çƒ’çƒžçƒ çƒ”çƒçƒ…çƒ†çƒ‡çƒšçƒŽçƒ¡ç‰‚ç‰¸"
  ],
  [
    "d2a1",
    "ç‰·ç‰¶çŒ€ç‹ºç‹´ç‹¾ç‹¶ç‹³ç‹»çŒç“ç™ç¥ç–çŽ¼ç§ç£ç©çœç’ç›ç”ççšç—ç˜ç¨ç“žç“Ÿç“´ç“µç”¡ç•›ç•Ÿç–°ç—ç–»ç—„ç—€ç–¿ç–¶ç–ºçšŠç›‰çœçœ›çœçœ“çœ’çœ£çœ‘çœ•çœ™çœšçœ¢çœ§ç £ç ¬ç ¢ç µç ¯ç ¨ç ®ç «ç ¡ç ©ç ³ç ªç ±ç¥”ç¥›ç¥ç¥œç¥“ç¥’ç¥‘ç§«ç§¬ç§ ç§®ç§­ç§ªç§œç§žç§çª†çª‰çª…çª‹çªŒçªŠçª‡ç«˜ç¬"
  ],
  [
    "d340",
    "ç¬„ç¬“ç¬…ç¬ç¬ˆç¬Šç¬Žç¬‰ç¬’ç²„ç²‘ç²Šç²Œç²ˆç²ç²…ç´žç´ç´‘ç´Žç´˜ç´–ç´“ç´Ÿç´’ç´ç´Œç½œç½¡ç½žç½ ç½ç½›ç¾–ç¾’ç¿ƒç¿‚ç¿€è€–è€¾è€¹èƒºèƒ²èƒ¹èƒµè„èƒ»è„€èˆèˆ¯èˆ¥èŒ³èŒ­è„èŒ™è‘èŒ¥è–èŒ¿èèŒ¦èŒœèŒ¢"
  ],
  [
    "d3a1",
    "è‚èŽèŒ›èŒªèŒˆèŒ¼èèŒ–èŒ¤èŒ èŒ·èŒ¯èŒ©è‡è…èŒè“èŒžèŒ¬è‹èŒ§èˆè™“è™’èš¢èš¨èš–èšèš‘èšžèš‡èš—èš†èš‹èššèš…èš¥èš™èš¡èš§èš•èš˜èšŽèšèšèš”è¡ƒè¡„è¡­è¡µè¡¶è¡²è¢€è¡±è¡¿è¡¯è¢ƒè¡¾è¡´è¡¼è¨’è±‡è±—è±»è²¤è²£èµ¶èµ¸è¶µè¶·è¶¶è»‘è»“è¿¾è¿µé€‚è¿¿è¿»é€„è¿¼è¿¶éƒ–éƒ éƒ™éƒšéƒ£éƒŸéƒ¥éƒ˜éƒ›éƒ—éƒœéƒ¤é…"
  ],
  [
    "d440",
    "é…Žé…é‡•é‡¢é‡šé™œé™Ÿéš¼é££é«Ÿé¬¯ä¹¿å°åªå¡åžå å“å‹åå²åˆååå›åŠå¢å€•å…åŸå©å«å£å¤å†å€å®å³å—å‘å‡å‰«å‰­å‰¬å‰®å‹–å‹“åŒ­åŽœå•µå•¶å”¼å•å•å”´å”ªå•‘å•¢å”¶å”µå”°å•’å•…"
  ],
  [
    "d4a1",
    "å”Œå”²å•¥å•Žå”¹å•ˆå”­å”»å•€å•‹åœŠåœ‡åŸ»å ”åŸ¢åŸ¶åŸœåŸ´å €åŸ­åŸ½å ˆåŸ¸å ‹åŸ³åŸå ‡åŸ®åŸ£åŸ²åŸ¥åŸ¬åŸ¡å ŽåŸ¼å åŸ§å å ŒåŸ±åŸ©åŸ°å å „å¥œå© å©˜å©•å©§å©žå¨¸å¨µå©­å©å©Ÿå©¥å©¬å©“å©¤å©—å©ƒå©å©’å©„å©›å©ˆåªŽå¨¾å©å¨¹å©Œå©°å©©å©‡å©‘å©–å©‚å©œå­²å­®å¯å¯€å±™å´žå´‹å´å´šå´ å´Œå´¨å´å´¦å´¥å´"
  ],
  [
    "d540",
    "å´°å´’å´£å´Ÿå´®å¸¾å¸´åº±åº´åº¹åº²åº³å¼¶å¼¸å¾›å¾–å¾Ÿæ‚Šæ‚æ‚†æ‚¾æ‚°æ‚ºæƒ“æƒ”æƒæƒ¤æƒ™æƒæƒˆæ‚±æƒ›æ‚·æƒŠæ‚¿æƒƒæƒæƒ€æŒ²æ¥æŽŠæŽ‚æ½æŽ½æŽžæŽ­æŽæŽ—æŽ«æŽŽæ¯æŽ‡æŽæ®æŽ¯æµæŽœæ­æŽ®æ¼æŽ¤æŒ»æŽŸ"
  ],
  [
    "d5a1",
    "æ¸æŽ…æŽæŽ‘æŽæ°æ•“æ—æ™¥æ™¡æ™›æ™™æ™œæ™¢æœ˜æ¡¹æ¢‡æ¢æ¢œæ¡­æ¡®æ¢®æ¢«æ¥–æ¡¯æ¢£æ¢¬æ¢©æ¡µæ¡´æ¢²æ¢æ¡·æ¢’æ¡¼æ¡«æ¡²æ¢ªæ¢€æ¡±æ¡¾æ¢›æ¢–æ¢‹æ¢ æ¢‰æ¢¤æ¡¸æ¡»æ¢‘æ¢Œæ¢Šæ¡½æ¬¶æ¬³æ¬·æ¬¸æ®‘æ®æ®æ®Žæ®Œæ°ªæ·€æ¶«æ¶´æ¶³æ¹´æ¶¬æ·©æ·¢æ¶·æ·¶æ·”æ¸€æ·ˆæ· æ·Ÿæ·–æ¶¾æ·¥æ·œæ·æ·›æ·´æ·Šæ¶½æ·­æ·°æ¶ºæ·•æ·‚æ·æ·‰"
  ],
  [
    "d640",
    "æ·æ·²æ·“æ·½æ·—æ·æ·£æ¶»çƒºç„çƒ·ç„—çƒ´ç„Œçƒ°ç„„çƒ³ç„çƒ¼çƒ¿ç„†ç„“ç„€çƒ¸çƒ¶ç„‹ç„‚ç„Žç‰¾ç‰»ç‰¼ç‰¿çŒçŒ—çŒ‡çŒ‘çŒ˜çŒŠçŒˆç‹¿çŒçŒžçŽˆç¶ç¸çµç„çç½ç‡ç€çºç¼ç¿çŒç‹ç´çˆç•¤ç•£ç—Žç—’ç—"
  ],
  [
    "d6a1",
    "ç—‹ç—Œç—‘ç—çšçš‰ç›“çœ¹çœ¯çœ­çœ±çœ²çœ´çœ³çœ½çœ¥çœ»çœµç¡ˆç¡’ç¡‰ç¡ç¡Šç¡Œç ¦ç¡…ç¡ç¥¤ç¥§ç¥©ç¥ªç¥£ç¥«ç¥¡ç¦»ç§ºç§¸ç§¶ç§·çªçª”çªç¬µç­‡ç¬´ç¬¥ç¬°ç¬¢ç¬¤ç¬³ç¬˜ç¬ªç¬ç¬±ç¬«ç¬­ç¬¯ç¬²ç¬¸ç¬šç¬£ç²”ç²˜ç²–ç²£ç´µç´½ç´¸ç´¶ç´ºçµ…ç´¬ç´©çµçµ‡ç´¾ç´¿çµŠç´»ç´¨ç½£ç¾•ç¾œç¾ç¾›ç¿Šç¿‹ç¿ç¿ç¿‘ç¿‡ç¿ç¿‰è€Ÿ"
  ],
  [
    "d740",
    "è€žè€›è‡èƒèˆè„˜è„¥è„™è„›è„­è„Ÿè„¬è„žè„¡è„•è„§è„è„¢èˆ‘èˆ¸èˆ³èˆºèˆ´èˆ²è‰´èŽèŽ£èŽ¨èŽèºè³èŽ¤è´èŽèŽèŽ•èŽ™èµèŽ”èŽ©è½èŽƒèŽŒèŽèŽ›èŽªèŽ‹è¾èŽ¥èŽ¯èŽˆèŽ—èŽ°è¿èŽ¦èŽ‡èŽ®è¶èŽšè™™è™–èš¿èš·"
  ],
  [
    "d7a1",
    "è›‚è›è›…èšºèš°è›ˆèš¹èš³èš¸è›Œèš´èš»èš¼è›ƒèš½èš¾è¡’è¢‰è¢•è¢¨è¢¢è¢ªè¢šè¢‘è¢¡è¢Ÿè¢˜è¢§è¢™è¢›è¢—è¢¤è¢¬è¢Œè¢“è¢Žè¦‚è§–è§™è§•è¨°è¨§è¨¬è¨žè°¹è°»è±œè±è±½è²¥èµ½èµ»èµ¹è¶¼è·‚è¶¹è¶¿è·è»˜è»žè»è»œè»—è» è»¡é€¤é€‹é€‘é€œé€Œé€¡éƒ¯éƒªéƒ°éƒ´éƒ²éƒ³éƒ”éƒ«éƒ¬éƒ©é…–é…˜é…šé…“é…•é‡¬é‡´é‡±é‡³é‡¸é‡¤é‡¹é‡ª"
  ],
  [
    "d840",
    "é‡«é‡·é‡¨é‡®é•ºé–†é–ˆé™¼é™­é™«é™±é™¯éš¿éªé „é£¥é¦—å‚›å‚•å‚”å‚žå‚‹å‚£å‚ƒå‚Œå‚Žå‚å¨å‚œå‚’å‚‚å‚‡å…Ÿå‡”åŒ’åŒ‘åŽ¤åŽ§å–‘å–¨å–¥å–­å•·å™…å–¢å–“å–ˆå–å–µå–å–£å–’å–¤å•½å–Œå–¦å•¿å–•å–¡å–ŽåœŒå ©å ·"
  ],
  [
    "d8a1",
    "å ™å žå §å £å ¨åŸµå¡ˆå ¥å œå ›å ³å ¿å ¶å ®å ¹å ¸å ­å ¬å »å¥¡åª¯åª”åªŸå©ºåª¢åªžå©¸åª¦å©¼åª¥åª¬åª•åª®å¨·åª„åªŠåª—åªƒåª‹åª©å©»å©½åªŒåªœåªåª“åªå¯ªå¯å¯‹å¯”å¯‘å¯Šå¯Žå°Œå°°å´·åµƒåµ«åµåµ‹å´¿å´µåµ‘åµŽåµ•å´³å´ºåµ’å´½å´±åµ™åµ‚å´¹åµ‰å´¸å´¼å´²å´¶åµ€åµ…å¹„å¹å½˜å¾¦å¾¥å¾«æƒ‰æ‚¹æƒŒæƒ¢æƒŽæƒ„æ„”"
  ],
  [
    "d940",
    "æƒ²æ„Šæ„–æ„…æƒµæ„“æƒ¸æƒ¼æƒ¾æƒæ„ƒæ„˜æ„æ„æƒ¿æ„„æ„‹æ‰ŠæŽ”æŽ±æŽ°æŽæ¥æ¨æ¯æƒæ’æ³æŠæ æ¶æ•æ²æµæ‘¡æŸæŽ¾ææœæ„æ˜æ“æ‚æ‡æŒæ‹æˆæ°æ—æ™æ”²æ•§æ•ªæ•¤æ•œæ•¨æ•¥æ–Œæ–æ–žæ–®æ—æ—’"
  ],
  [
    "d9a1",
    "æ™¼æ™¬æ™»æš€æ™±æ™¹æ™ªæ™²æœæ¤Œæ£“æ¤„æ£œæ¤ªæ£¬æ£ªæ£±æ¤æ£–æ£·æ£«æ£¤æ£¶æ¤“æ¤æ£³æ£¡æ¤‡æ£Œæ¤ˆæ¥°æ¢´æ¤‘æ£¯æ£†æ¤”æ£¸æ£æ£½æ£¼æ£¨æ¤‹æ¤Šæ¤—æ£Žæ£ˆæ£æ£žæ£¦æ£´æ£‘æ¤†æ£”æ£©æ¤•æ¤¥æ£‡æ¬¹æ¬»æ¬¿æ¬¼æ®”æ®—æ®™æ®•æ®½æ¯°æ¯²æ¯³æ°°æ·¼æ¹†æ¹‡æ¸Ÿæ¹‰æºˆæ¸¼æ¸½æ¹…æ¹¢æ¸«æ¸¿æ¹æ¹æ¹³æ¸œæ¸³æ¹‹æ¹€æ¹‘æ¸»æ¸ƒæ¸®æ¹ž"
  ],
  [
    "da40",
    "æ¹¨æ¹œæ¹¡æ¸±æ¸¨æ¹ æ¹±æ¹«æ¸¹æ¸¢æ¸°æ¹“æ¹¥æ¸§æ¹¸æ¹¤æ¹·æ¹•æ¹¹æ¹’æ¹¦æ¸µæ¸¶æ¹šç„ ç„žç„¯çƒ»ç„®ç„±ç„£ç„¥ç„¢ç„²ç„Ÿç„¨ç„ºç„›ç‰‹ç‰šçŠˆçŠ‰çŠ†çŠ…çŠ‹çŒ’çŒ‹çŒ°çŒ¢çŒ±çŒ³çŒ§çŒ²çŒ­çŒ¦çŒ£çŒµçŒŒç®ç¬ç°ç«ç–"
  ],
  [
    "daa1",
    "çšç¡ç­ç±ç¤ç£çç©ç ç²ç“»ç”¯ç•¯ç•¬ç—§ç—šç—¡ç—¦ç—ç—Ÿç—¤ç——çš•çš’ç›šç†ç‡ç„çç…çŠçŽç‹çŒçŸžçŸ¬ç¡ ç¡¤ç¡¥ç¡œç¡­ç¡±ç¡ªç¡®ç¡°ç¡©ç¡¨ç¡žç¡¢ç¥´ç¥³ç¥²ç¥°ç¨‚ç¨Šç¨ƒç¨Œç¨„çª™ç«¦ç«¤ç­Šç¬»ç­„ç­ˆç­Œç­Žç­€ç­˜ç­…ç²¢ç²žç²¨ç²¡çµ˜çµ¯çµ£çµ“çµ–çµ§çµªçµçµ­çµœçµ«çµ’çµ”çµ©çµ‘çµŸçµŽç¼¾ç¼¿ç½¥"
  ],
  [
    "db40",
    "ç½¦ç¾¢ç¾ ç¾¡ç¿—è‘èèèƒ¾èƒ”è…ƒè…Šè…’è…è…‡è„½è…è„ºè‡¦è‡®è‡·è‡¸è‡¹èˆ„èˆ¼èˆ½èˆ¿è‰µèŒ»èè¹è£è€è¨è’è§è¤è¼è¶èè†èˆè«è£èŽ¿èèè¥è˜è¿è¡è‹èŽè–èµè‰è‰èèžè‘è†è‚è³"
  ],
  [
    "dba1",
    "è•èºè‡è‘èªè“èƒè¬è®è„è»è—è¢è›è›è¾è›˜è›¢è›¦è›“è›£è›šè›ªè›è›«è›œè›¬è›©è›—è›¨è›‘è¡ˆè¡–è¡•è¢ºè£—è¢¹è¢¸è£€è¢¾è¢¶è¢¼è¢·è¢½è¢²è¤è£‰è¦•è¦˜è¦—è§è§šè§›è©Žè©è¨¹è©™è©€è©—è©˜è©„è©…è©’è©ˆè©‘è©Šè©Œè©è±Ÿè²è²€è²ºè²¾è²°è²¹è²µè¶„è¶€è¶‰è·˜è·“è·è·‡è·–è·œè·è·•è·™è·ˆè·—è·…è»¯è»·è»º"
  ],
  [
    "dc40",
    "è»¹è»¦è»®è»¥è»µè»§è»¨è»¶è»«è»±è»¬è»´è»©é€­é€´é€¯é„†é„¬é„„éƒ¿éƒ¼é„ˆéƒ¹éƒ»é„é„€é„‡é„…é„ƒé…¡é…¤é…Ÿé…¢é… éˆéˆŠéˆ¥éˆƒéˆšéˆ¦éˆéˆŒéˆ€éˆ’é‡¿é‡½éˆ†éˆ„éˆ§éˆ‚éˆœéˆ¤éˆ™éˆ—éˆ…éˆ–é•»é–é–Œé–éš‡é™¾éšˆ"
  ],
  [
    "dca1",
    "éš‰éšƒéš€é›‚é›ˆé›ƒé›±é›°é¬é°é®é ‡é¢©é£«é³¦é»¹äºƒäº„äº¶å‚½å‚¿åƒ†å‚®åƒ„åƒŠå‚´åƒˆåƒ‚å‚°åƒå‚ºå‚±åƒ‹åƒ‰å‚¶å‚¸å‡—å‰ºå‰¸å‰»å‰¼å—ƒå—›å—Œå—å—‹å—Šå—å—€å—”å—„å—©å–¿å—’å–å—å—•å—¢å—–å—ˆå—²å—å—™å—‚åœ”å¡“å¡¨å¡¤å¡å¡å¡‰å¡¯å¡•å¡Žå¡å¡™å¡¥å¡›å ½å¡£å¡±å£¼å«‡å«„å«‹åªºåª¸åª±åªµåª°åª¿å«ˆåª»å«†"
  ],
  [
    "dd40",
    "åª·å«€å«Šåª´åª¶å«åª¹åªå¯–å¯˜å¯™å°Ÿå°³åµ±åµ£åµŠåµ¥åµ²åµ¬åµžåµ¨åµ§åµ¢å·°å¹å¹Žå¹Šå¹å¹‹å»…å»Œå»†å»‹å»‡å½€å¾¯å¾­æƒ·æ…‰æ…Šæ„«æ……æ„¶æ„²æ„®æ…†æ„¯æ…æ„©æ…€æˆ é…¨æˆ£æˆ¥æˆ¤æ…æ±æ«ææ’æ‰æ æ¤"
  ],
  [
    "dda1",
    "æ³æ‘ƒæŸæ•æ˜æ¹æ·æ¢æ£æŒæ¦æ°æ¨æ‘æµæ¯æŠæšæ‘€æ¥æ§æ‹æ§æ›æ®æ¡æŽæ•¯æ–’æ—“æš†æšŒæš•æšæš‹æšŠæš™æš”æ™¸æœ æ¥¦æ¥Ÿæ¤¸æ¥Žæ¥¢æ¥±æ¤¿æ¥…æ¥ªæ¤¹æ¥‚æ¥—æ¥™æ¥ºæ¥ˆæ¥‰æ¤µæ¥¬æ¤³æ¤½æ¥¥æ£°æ¥¸æ¤´æ¥©æ¥€æ¥¯æ¥„æ¥¶æ¥˜æ¥æ¥´æ¥Œæ¤»æ¥‹æ¤·æ¥œæ¥æ¥‘æ¤²æ¥’æ¤¯æ¥»æ¤¼æ­†æ­…æ­ƒæ­‚æ­ˆæ­æ®›ï¨æ¯»æ¯¼"
  ],
  [
    "de40",
    "æ¯¹æ¯·æ¯¸æº›æ»–æ»ˆæºæ»€æºŸæº“æº”æº æº±æº¹æ»†æ»’æº½æ»æºžæ»‰æº·æº°æ»æº¦æ»æº²æº¾æ»ƒæ»œæ»˜æº™æº’æºŽæºæº¤æº¡æº¿æº³æ»æ»Šæº—æº®æº£ç…‡ç…”ç…’ç…£ç… ç…ç…ç…¢ç…²ç…¸ç…ªç…¡ç…‚ç…˜ç…ƒç…‹ç…°ç…Ÿç…ç…“"
  ],
  [
    "dea1",
    "ç…„ç…ç…šç‰çŠçŠŒçŠ‘çŠçŠŽçŒ¼ç‚çŒ»çŒºç€çŠç‰ç‘„ç‘Šç‘‹ç‘’ç‘‘ç‘—ç‘€ç‘ç‘ç‘Žç‘‚ç‘†ç‘ç‘”ç“¡ç“¿ç“¾ç“½ç”ç•¹ç•·æ¦ƒç—¯ç˜ç˜ƒç—·ç—¾ç—¼ç—¹ç—¸ç˜ç—»ç—¶ç—­ç—µç—½çš™çšµç›ç•çŸç ç’ç–çšç©ç§ç”ç™ç­çŸ ç¢‡ç¢šç¢”ç¢ç¢„ç¢•ç¢…ç¢†ç¢¡ç¢ƒç¡¹ç¢™ç¢€ç¢–ç¡»ç¥¼ç¦‚ç¥½ç¥¹ç¨‘ç¨˜ç¨™ç¨’ç¨—ç¨•ç¨¢ç¨“"
  ],
  [
    "df40",
    "ç¨›ç¨çª£çª¢çªžç««ç­¦ç­¤ç­­ç­´ç­©ç­²ç­¥ç­³ç­±ç­°ç­¡ç­¸ç­¶ç­£ç²²ç²´ç²¯ç¶ˆç¶†ç¶€ç¶çµ¿ç¶…çµºç¶Žçµ»ç¶ƒçµ¼ç¶Œç¶”ç¶„çµ½ç¶’ç½­ç½«ç½§ç½¨ç½¬ç¾¦ç¾¥ç¾§ç¿›ç¿œè€¡è…¤è… è…·è…œè…©è…›è…¢è…²æœ¡è…žè…¶è…§è…¯"
  ],
  [
    "dfa1",
    "è…„è…¡èˆè‰‰è‰„è‰€è‰‚è‰…è“±è¿è‘–è‘¶è‘¹è’è’è‘¥è‘‘è‘€è’†è‘§è°è‘è‘½è‘šè‘™è‘´è‘³è‘è”‡è‘žè·èºè´è‘ºè‘ƒè‘¸è²è‘…è©è™è‘‹è¯è‘‚è­è‘Ÿè‘°è¹è‘Žè‘Œè‘’è‘¯è“…è’Žè»è‘‡è¶è³è‘¨è‘¾è‘„è«è‘ è‘”è‘®è‘èœ‹èœ„è›·èœŒè›ºè›–è›µèè›¸èœŽèœ‰èœè›¶èœèœ…è£–è£‹è£è£Žè£žè£›è£šè£Œè£è¦…è¦›è§Ÿè§¥è§¤"
  ],
  [
    "e040",
    "è§¡è§ è§¢è§œè§¦è©¶èª†è©¿è©¡è¨¿è©·èª‚èª„è©µèªƒèªè©´è©ºè°¼è±‹è±Šè±¥è±¤è±¦è²†è²„è²…è³Œèµ¨èµ©è¶‘è¶Œè¶Žè¶è¶è¶“è¶”è¶è¶’è·°è· è·¬è·±è·®è·è·©è·£è·¢è·§è·²è·«è·´è¼†è»¿è¼è¼€è¼…è¼‡è¼ˆè¼‚è¼‹é’é€¿"
  ],
  [
    "e0a1",
    "é„é‰é€½é„é„é„é„‘é„–é„”é„‹é„Žé…®é…¯é‰ˆé‰’éˆ°éˆºé‰¦éˆ³é‰¥é‰žéŠƒéˆ®é‰Šé‰†é‰­é‰¬é‰é‰ é‰§é‰¯éˆ¶é‰¡é‰°éˆ±é‰”é‰£é‰é‰²é‰Žé‰“é‰Œé‰–éˆ²é–Ÿé–œé–žé–›éš’éš“éš‘éš—é›Žé›ºé›½é›¸é›µé³é·é¸é²é é é Žé¢¬é£¶é£¹é¦¯é¦²é¦°é¦µéª­éª«é­›é³ªé³­é³§éº€é»½åƒ¦åƒ”åƒ—åƒ¨åƒ³åƒ›åƒªåƒåƒ¤åƒ“åƒ¬åƒ°åƒ¯åƒ£åƒ "
  ],
  [
    "e140",
    "å‡˜åŠ€åŠå‹©å‹«åŒ°åŽ¬å˜§å˜•å˜Œå˜’å—¼å˜å˜œå˜å˜“å˜‚å—ºå˜å˜„å—¿å—¹å¢‰å¡¼å¢å¢˜å¢†å¢å¡¿å¡´å¢‹å¡ºå¢‡å¢‘å¢Žå¡¶å¢‚å¢ˆå¡»å¢”å¢å£¾å¥«å«œå«®å«¥å«•å«ªå«šå«­å««å«³å«¢å« å«›å«¬å«žå«å«™å«¨å«Ÿå­·å¯ "
  ],
  [
    "e1a1",
    "å¯£å±£å¶‚å¶€åµ½å¶†åµºå¶åµ·å¶Šå¶‰å¶ˆåµ¾åµ¼å¶åµ¹åµ¿å¹˜å¹™å¹“å»˜å»‘å»—å»Žå»œå»•å»™å»’å»”å½„å½ƒå½¯å¾¶æ„¬æ„¨æ…æ…žæ…±æ…³æ…’æ…“æ…²æ…¬æ†€æ…´æ…”æ…ºæ…›æ…¥æ„»æ…ªæ…¡æ…–æˆ©æˆ§æˆ«æ«æ‘æ‘›æ‘æ‘´æ‘¶æ‘²æ‘³æ‘½æ‘µæ‘¦æ’¦æ‘Žæ’‚æ‘žæ‘œæ‘‹æ‘“æ‘ æ‘æ‘¿æ¿æ‘¬æ‘«æ‘™æ‘¥æ‘·æ•³æ– æš¡æš æšŸæœ…æœ„æœ¢æ¦±æ¦¶æ§‰"
  ],
  [
    "e240",
    "æ¦ æ§Žæ¦–æ¦°æ¦¬æ¦¼æ¦‘æ¦™æ¦Žæ¦§æ¦æ¦©æ¦¾æ¦¯æ¦¿æ§„æ¦½æ¦¤æ§”æ¦¹æ§Šæ¦šæ§æ¦³æ¦“æ¦ªæ¦¡æ¦žæ§™æ¦—æ¦æ§‚æ¦µæ¦¥æ§†æ­Šæ­æ­‹æ®žæ®Ÿæ® æ¯ƒæ¯„æ¯¾æ»Žæ»µæ»±æ¼ƒæ¼¥æ»¸æ¼·æ»»æ¼®æ¼‰æ½Žæ¼™æ¼šæ¼§æ¼˜æ¼»æ¼’æ»­æ¼Š"
  ],
  [
    "e2a1",
    "æ¼¶æ½³æ»¹æ»®æ¼­æ½€æ¼°æ¼¼æ¼µæ»«æ¼‡æ¼Žæ½ƒæ¼…æ»½æ»¶æ¼¹æ¼œæ»¼æ¼ºæ¼Ÿæ¼æ¼žæ¼ˆæ¼¡ç†‡ç†ç†‰ç†€ç†…ç†‚ç†ç…»ç††ç†ç†—ç‰„ç‰“çŠ—çŠ•çŠ“çƒçç‘çŒç‘¢ç‘³ç‘±ç‘µç‘²ç‘§ç‘®ç”€ç”‚ç”ƒç•½ç–ç˜–ç˜ˆç˜Œç˜•ç˜‘ç˜Šç˜”çš¸çžç¼çž…çž‚ç®çž€ç¯ç¾çžƒç¢²ç¢ªç¢´ç¢­ç¢¨ç¡¾ç¢«ç¢žç¢¥ç¢ ç¢¬ç¢¢ç¢¤ç¦˜ç¦Šç¦‹ç¦–ç¦•ç¦”ç¦“"
  ],
  [
    "e340",
    "ç¦—ç¦ˆç¦’ç¦ç¨«ç©Šç¨°ç¨¯ç¨¨ç¨¦çª¨çª«çª¬ç«®ç®ˆç®œç®Šç®‘ç®ç®–ç®ç®Œç®›ç®Žç®…ç®˜åŠ„ç®™ç®¤ç®‚ç²»ç²¿ç²¼ç²ºç¶§ç¶·ç·‚ç¶£ç¶ªç·ç·€ç·…ç¶ç·Žç·„ç·†ç·‹ç·Œç¶¯ç¶¹ç¶–ç¶¼ç¶Ÿç¶¦ç¶®ç¶©ç¶¡ç·‰ç½³ç¿¢ç¿£ç¿¥ç¿ž"
  ],
  [
    "e3a1",
    "è€¤èèœè†‰è††è†ƒè†‡è†è†Œè†‹èˆ•è’—è’¤è’¡è’Ÿè’ºè“Žè“‚è’¬è’®è’«è’¹è’´è“è“è’ªè’šè’±è“è’è’§è’»è’¢è’”è“‡è“Œè’›è’©è’¯è’¨è“–è’˜è’¶è“è’ è“—è“”è“’è“›è’°è’‘è™¡èœ³èœ£èœ¨è«è€èœ®èœžèœ¡èœ™èœ›èƒèœ¬èèœ¾è†èœ èœ²èœªèœ­èœ¼èœ’èœºèœ±èœµè‚èœ¦èœ§èœ¸èœ¤èœšèœ°èœ‘è£·è£§è£±è£²è£ºè£¾è£®è£¼è£¶è£»"
  ],
  [
    "e440",
    "è£°è£¬è£«è¦è¦¡è¦Ÿè¦žè§©è§«è§¨èª«èª™èª‹èª’èªèª–è°½è±¨è±©è³•è³è³—è¶–è¸‰è¸‚è·¿è¸è·½è¸Šè¸ƒè¸‡è¸†è¸…è·¾è¸€è¸„è¼è¼‘è¼Žè¼é„£é„œé„ é„¢é„Ÿé„é„šé„¤é„¡é„›é…ºé…²é…¹é…³éŠ¥éŠ¤é‰¶éŠ›é‰ºéŠ éŠ”éŠªéŠ"
  ],
  [
    "e4a1",
    "éŠ¦éŠšéŠ«é‰¹éŠ—é‰¿éŠ£é‹®éŠŽéŠ‚éŠ•éŠ¢é‰½éŠˆéŠ¡éŠŠéŠ†éŠŒéŠ™éŠ§é‰¾éŠ‡éŠ©éŠéŠ‹éˆ­éšžéš¡é›¿é˜é½éºé¾éžƒéž€éž‚é»éž„éžé¿éŸŽéŸé –é¢­é¢®é¤‚é¤€é¤‡é¦é¦œé§ƒé¦¹é¦»é¦ºé§‚é¦½é§‡éª±é«£é«§é¬¾é¬¿é­ é­¡é­Ÿé³±é³²é³µéº§åƒ¿å„ƒå„°åƒ¸å„†å„‡åƒ¶åƒ¾å„‹å„Œåƒ½å„ŠåŠ‹åŠŒå‹±å‹¯å™ˆå™‚å™Œå˜µå™å™Šå™‰å™†å™˜"
  ],
  [
    "e540",
    "å™šå™€å˜³å˜½å˜¬å˜¾å˜¸å˜ªå˜ºåœšå¢«å¢å¢±å¢ å¢£å¢¯å¢¬å¢¥å¢¡å£¿å«¿å«´å«½å«·å«¶å¬ƒå«¸å¬‚å«¹å¬å¬‡å¬…å¬å±§å¶™å¶—å¶Ÿå¶’å¶¢å¶“å¶•å¶ å¶œå¶¡å¶šå¶žå¹©å¹å¹ å¹œç·³å»›å»žå»¡å½‰å¾²æ†‹æ†ƒæ…¹æ†±æ†°æ†¢æ†‰"
  ],
  [
    "e5a1",
    "æ†›æ†“æ†¯æ†­æ†Ÿæ†’æ†ªæ†¡æ†æ…¦æ†³æˆ­æ‘®æ‘°æ’–æ’ æ’…æ’—æ’œæ’æ’‹æ’Šæ’Œæ’£æ’Ÿæ‘¨æ’±æ’˜æ•¶æ•ºæ•¹æ•»æ–²æ–³æšµæš°æš©æš²æš·æšªæš¯æ¨€æ¨†æ¨—æ§¥æ§¸æ¨•æ§±æ§¤æ¨ æ§¿æ§¬æ§¢æ¨›æ¨æ§¾æ¨§æ§²æ§®æ¨”æ§·æ§§æ©€æ¨ˆæ§¦æ§»æ¨æ§¼æ§«æ¨‰æ¨„æ¨˜æ¨¥æ¨æ§¶æ¨¦æ¨‡æ§´æ¨–æ­‘æ®¥æ®£æ®¢æ®¦æ°æ°€æ¯¿æ°‚æ½æ¼¦æ½¾æ¾‡æ¿†æ¾’"
  ],
  [
    "e640",
    "æ¾æ¾‰æ¾Œæ½¢æ½æ¾…æ½šæ¾–æ½¶æ½¬æ¾‚æ½•æ½²æ½’æ½æ½—æ¾”æ¾“æ½æ¼€æ½¡æ½«æ½½æ½§æ¾æ½“æ¾‹æ½©æ½¿æ¾•æ½£æ½·æ½ªæ½»ç†²ç†¯ç†›ç†°ç† ç†šç†©ç†µç†ç†¥ç†žç†¤ç†¡ç†ªç†œç†§ç†³çŠ˜çŠšç˜ç’çžçŸç çç›ç¡çšç™"
  ],
  [
    "e6a1",
    "ç¢ç’‡ç’‰ç’Šç’†ç’ç‘½ç’…ç’ˆç‘¼ç‘¹ç”ˆç”‡ç•¾ç˜¥ç˜žç˜™ç˜ç˜œç˜£ç˜šç˜¨ç˜›çšœçšçšžçš›çžçžçž‰çžˆç£ç¢»ç£ç£Œç£‘ç£Žç£”ç£ˆç£ƒç£„ç£‰ç¦šç¦¡ç¦ ç¦œç¦¢ç¦›æ­¶ç¨¹çª²çª´çª³ç®·ç¯‹ç®¾ç®¬ç¯Žç®¯ç®¹ç¯Šç®µç³…ç³ˆç³Œç³‹ç··ç·›ç·ªç·§ç·—ç·¡ç¸ƒç·ºç·¦ç·¶ç·±ç·°ç·®ç·Ÿç½¶ç¾¬ç¾°ç¾­ç¿­ç¿«ç¿ªç¿¬ç¿¦ç¿¨è¤è§è†£è†Ÿ"
  ],
  [
    "e740",
    "è†žè†•è†¢è†™è†—èˆ–è‰è‰“è‰’è‰è‰Žè‰‘è”¤è”»è”è”€è”©è”Žè”‰è”è”Ÿè”Šè”§è”œè“»è”«è“ºè”ˆè”Œè“´è”ªè“²è”•è“·è“«è“³è“¼è”’è“ªè“©è”–è“¾è”¨è”è”®è”‚è“½è”žè“¶è”±è”¦è“§è“¨è“°è“¯è“¹è”˜è” è”°è”‹è”™è”¯è™¢"
  ],
  [
    "e7a1",
    "è–è£è¤è·èŸ¡è³è˜è”è›è’è¡èšè‘èžè­èªèèŽèŸèè¯è¬èºè®èœè¥èè»èµè¢è§è©è¡šè¤…è¤Œè¤”è¤‹è¤—è¤˜è¤™è¤†è¤–è¤‘è¤Žè¤‰è¦¢è¦¤è¦£è§­è§°è§¬è«è«†èª¸è«“è«‘è«”è«•èª»è«—èª¾è«€è«…è«˜è«ƒèªºèª½è«™è°¾è±è²è³¥è³Ÿè³™è³¨è³šè³è³§è¶ è¶œè¶¡è¶›è¸ è¸£è¸¥è¸¤è¸®è¸•è¸›è¸–è¸‘è¸™è¸¦è¸§"
  ],
  [
    "e840",
    "è¸”è¸’è¸˜è¸“è¸œè¸—è¸šè¼¬è¼¤è¼˜è¼šè¼ è¼£è¼–è¼—é³é°é¯é§é«é„¯é„«é„©é„ªé„²é„¦é„®é†…é††é†Šé†é†‚é†„é†€é‹é‹ƒé‹„é‹€é‹™éŠ¶é‹é‹±é‹Ÿé‹˜é‹©é‹—é‹é‹Œé‹¯é‹‚é‹¨é‹Šé‹ˆé‹Žé‹¦é‹é‹•é‹‰é‹ é‹žé‹§é‹‘é‹“"
  ],
  [
    "e8a1",
    "éŠµé‹¡é‹†éŠ´é•¼é–¬é–«é–®é–°éš¤éš¢é›“éœ…éœˆéœ‚éšéžŠéžŽéžˆéŸéŸé žé é ¦é ©é ¨é  é ›é §é¢²é¤ˆé£ºé¤‘é¤”é¤–é¤—é¤•é§œé§é§é§“é§”é§Žé§‰é§–é§˜é§‹é§—é§Œéª³é«¬é««é«³é«²é«±é­†é­ƒé­§é­´é­±é­¦é­¶é­µé­°é­¨é­¤é­¬é³¼é³ºé³½é³¿é³·é´‡é´€é³¹é³»é´ˆé´…é´„éºƒé»“é¼é¼å„œå„“å„—å„šå„‘å‡žåŒ´å¡å™°å™ å™®"
  ],
  [
    "e940",
    "å™³å™¦å™£å™­å™²å™žå™·åœœåœ›å£ˆå¢½å£‰å¢¿å¢ºå£‚å¢¼å£†å¬—å¬™å¬›å¬¡å¬”å¬“å¬å¬–å¬¨å¬šå¬ å¬žå¯¯å¶¬å¶±å¶©å¶§å¶µå¶°å¶®å¶ªå¶¨å¶²å¶­å¶¯å¶´å¹§å¹¨å¹¦å¹¯å»©å»§å»¦å»¨å»¥å½‹å¾¼æ†æ†¨æ†–æ‡…æ†´æ‡†æ‡æ‡Œæ†º"
  ],
  [
    "e9a1",
    "æ†¿æ†¸æ†Œæ“—æ“–æ“æ“æ“‰æ’½æ’‰æ“ƒæ“›æ“³æ“™æ”³æ•¿æ•¼æ–¢æ›ˆæš¾æ›€æ›Šæ›‹æ›æš½æš»æšºæ›Œæœ£æ¨´æ©¦æ©‰æ©§æ¨²æ©¨æ¨¾æ©æ©­æ©¶æ©›æ©‘æ¨¨æ©šæ¨»æ¨¿æ©æ©ªæ©¤æ©æ©æ©”æ©¯æ©©æ© æ¨¼æ©žæ©–æ©•æ©æ©Žæ©†æ­•æ­”æ­–æ®§æ®ªæ®«æ¯ˆæ¯‡æ°„æ°ƒæ°†æ¾­æ¿‹æ¾£æ¿‡æ¾¼æ¿Žæ¿ˆæ½žæ¿„æ¾½æ¾žæ¿Šæ¾¨ç€„æ¾¥æ¾®æ¾ºæ¾¬æ¾ªæ¿æ¾¿æ¾¸"
  ],
  [
    "ea40",
    "æ¾¢æ¿‰æ¾«æ¿æ¾¯æ¾²æ¾°ç‡…ç‡‚ç†¿ç†¸ç‡–ç‡€ç‡ç‡‹ç‡”ç‡Šç‡‡ç‡ç†½ç‡˜ç†¼ç‡†ç‡šç‡›çŠçŠžç©ç¦ç§ç¬ç¥ç«çªç‘¿ç’šç’ ç’”ç’’ç’•ç’¡ç”‹ç–€ç˜¯ç˜­ç˜±ç˜½ç˜³ç˜¼ç˜µç˜²ç˜°çš»ç›¦çžšçžçž¡çžœçž›çž¢çž£çž•çž™"
  ],
  [
    "eaa1",
    "çž—ç£ç£©ç£¥ç£ªç£žç££ç£›ç£¡ç£¢ç£­ç£Ÿç£ ç¦¤ç©„ç©ˆç©‡çª¶çª¸çªµçª±çª·ç¯žç¯£ç¯§ç¯ç¯•ç¯¥ç¯šç¯¨ç¯¹ç¯”ç¯ªç¯¢ç¯œç¯«ç¯˜ç¯Ÿç³’ç³”ç³—ç³ç³‘ç¸’ç¸¡ç¸—ç¸Œç¸Ÿç¸ ç¸“ç¸Žç¸œç¸•ç¸šç¸¢ç¸‹ç¸ç¸–ç¸ç¸”ç¸¥ç¸¤ç½ƒç½»ç½¼ç½ºç¾±ç¿¯è€ªè€©è¬è†±è†¦è†®è†¹è†µè†«è†°è†¬è†´è†²è†·è†§è‡²è‰•è‰–è‰—è•–è•…è•«è•è•“è•¡è•˜"
  ],
  [
    "eb40",
    "è•€è•†è•¤è•è•¢è•„è•‘è•‡è•£è”¾è•›è•±è•Žè•®è•µè••è•§è• è–Œè•¦è•è•”è•¥è•¬è™£è™¥è™¤èž›èžèž—èž“èž’èžˆèžèž–èž˜è¹èž‡èž£èž…èžèž‘èžèž„èž”èžœèžšèž‰è¤žè¤¦è¤°è¤­è¤®è¤§è¤±è¤¢è¤©è¤£è¤¯è¤¬è¤Ÿè§±è« "
  ],
  [
    "eba1",
    "è«¢è«²è«´è«µè«è¬”è«¤è«Ÿè«°è«ˆè«žè«¡è«¨è«¿è«¯è«»è²‘è²’è²è³µè³®è³±è³°è³³èµ¬èµ®è¶¥è¶§è¸³è¸¾è¸¸è¹€è¹…è¸¶è¸¼è¸½è¹è¸°è¸¿èº½è¼¶è¼®è¼µè¼²è¼¹è¼·è¼´é¶é¹é»é‚†éƒºé„³é„µé„¶é†“é†é†‘é†é†éŒ§éŒžéŒˆéŒŸéŒ†éŒéºéŒ¸éŒ¼éŒ›éŒ£éŒ’éŒé†éŒ­éŒŽéŒé‹‹éŒé‹ºéŒ¥éŒ“é‹¹é‹·éŒ´éŒ‚éŒ¤é‹¿éŒ©éŒ¹éŒµéŒªéŒ”éŒŒ"
  ],
  [
    "ec40",
    "éŒ‹é‹¾éŒ‰éŒ€é‹»éŒ–é–¼é—é–¾é–¹é–ºé–¶é–¿é–µé–½éš©é›”éœ‹éœ’éœéž™éž—éž”éŸ°éŸ¸é µé ¯é ²é¤¤é¤Ÿé¤§é¤©é¦žé§®é§¬é§¥é§¤é§°é§£é§ªé§©é§§éª¹éª¿éª´éª»é«¶é«ºé«¹é«·é¬³é®€é®…é®‡é­¼é­¾é­»é®‚é®“é®’é®é­ºé®•"
  ],
  [
    "eca1",
    "é­½é®ˆé´¥é´—é´ é´žé´”é´©é´é´˜é´¢é´é´™é´Ÿéºˆéº†éº‡éº®éº­é»•é»–é»ºé¼’é¼½å„¦å„¥å„¢å„¤å„ å„©å‹´åš“åšŒåšåš†åš„åšƒå™¾åš‚å™¿åšå£–å£”å£å£’å¬­å¬¥å¬²å¬£å¬¬å¬§å¬¦å¬¯å¬®å­»å¯±å¯²å¶·å¹¬å¹ªå¾¾å¾»æ‡ƒæ†µæ†¼æ‡§æ‡ æ‡¥æ‡¤æ‡¨æ‡žæ“¯æ“©æ“£æ“«æ“¤æ“¨æ–æ–€æ–¶æ—šæ›’æªæª–æªæª¥æª‰æªŸæª›æª¡æªžæª‡æª“æªŽ"
  ],
  [
    "ed40",
    "æª•æªƒæª¨æª¤æª‘æ©¿æª¦æªšæª…æªŒæª’æ­›æ®­æ°‰æ¿Œæ¾©æ¿´æ¿”æ¿£æ¿œæ¿­æ¿§æ¿¦æ¿žæ¿²æ¿æ¿¢æ¿¨ç‡¡ç‡±ç‡¨ç‡²ç‡¤ç‡°ç‡¢ç³ç®ç¯ç’—ç’²ç’«ç’ç’ªç’­ç’±ç’¥ç’¯ç”ç”‘ç”’ç”ç–„ç™ƒç™ˆç™‰ç™‡çš¤ç›©çžµçž«çž²çž·çž¶"
  ],
  [
    "eda1",
    "çž´çž±çž¨çŸ°ç£³ç£½ç¤‚ç£»ç£¼ç£²ç¤…ç£¹ç£¾ç¤„ç¦«ç¦¨ç©œç©›ç©–ç©˜ç©”ç©šçª¾ç«€ç«ç°…ç°ç¯²ç°€ç¯¿ç¯»ç°Žç¯´ç°‹ç¯³ç°‚ç°‰ç°ƒç°ç¯¸ç¯½ç°†ç¯°ç¯±ç°ç°Šç³¨ç¸­ç¸¼ç¹‚ç¸³é¡ˆç¸¸ç¸ªç¹‰ç¹€ç¹‡ç¸©ç¹Œç¸°ç¸»ç¸¶ç¹„ç¸ºç½…ç½¿ç½¾ç½½ç¿´ç¿²è€¬è†»è‡„è‡Œè‡Šè‡…è‡‡è†¼è‡©è‰›è‰šè‰œè–ƒè–€è–è–§è–•è– è–‹è–£è•»è–¤è–šè–ž"
  ],
  [
    "ee40",
    "è•·è•¼è–‰è–¡è•ºè•¸è•—è–Žè––è–†è–è–™è–è–è–¢è–‚è–ˆè–…è•¹è•¶è–˜è–è–Ÿè™¨èž¾èžªèž­èŸ…èž°èž¬èž¹èžµèž¼èž®èŸ‰èŸƒèŸ‚èŸŒèž·èž¯èŸ„èŸŠèž´èž¶èž¿èž¸èž½èŸžèž²è¤µè¤³è¤¼è¤¾è¥è¥’è¤·è¥‚è¦­è¦¯è¦®è§²è§³è¬ž"
  ],
  [
    "eea1",
    "è¬˜è¬–è¬‘è¬…è¬‹è¬¢è¬è¬’è¬•è¬‡è¬è¬ˆè¬†è¬œè¬“è¬šè±è±°è±²è±±è±¯è²•è²”è³¹èµ¯è¹Žè¹è¹“è¹è¹Œè¹‡è½ƒè½€é‚…é¾é„¸é†šé†¢é†›é†™é†Ÿé†¡é†é† éŽ¡éŽƒéŽ¯é¤é–é‡é¼é˜éœé¶é‰éé‘é é­éŽéŒéªé¹é—é•é’éé±é·é»é¡éžé£é§éŽ€éŽé™é—‡é—€é—‰é—ƒé—…é–·éš®éš°éš¬éœ éœŸéœ˜éœéœ™éžšéž¡éžœ"
  ],
  [
    "ef40",
    "éžžéžéŸ•éŸ”éŸ±é¡é¡„é¡Šé¡‰é¡…é¡ƒé¤¥é¤«é¤¬é¤ªé¤³é¤²é¤¯é¤­é¤±é¤°é¦˜é¦£é¦¡é¨‚é§ºé§´é§·é§¹é§¸é§¶é§»é§½é§¾é§¼é¨ƒéª¾é«¾é«½é¬é«¼é­ˆé®šé®¨é®žé®›é®¦é®¡é®¥é®¤é®†é®¢é® é®¯é´³éµéµ§é´¶é´®é´¯é´±é´¸é´°"
  ],
  [
    "efa1",
    "éµ…éµ‚éµƒé´¾é´·éµ€é´½ç¿µé´­éºŠéº‰éºéº°é»ˆé»šé»»é»¿é¼¤é¼£é¼¢é½”é¾ å„±å„­å„®åš˜åšœåš—åššåšåš™å¥°å¬¼å±©å±ªå·€å¹­å¹®æ‡˜æ‡Ÿæ‡­æ‡®æ‡±æ‡ªæ‡°æ‡«æ‡–æ‡©æ“¿æ”„æ“½æ“¸æ”æ”ƒæ“¼æ–”æ—›æ›šæ››æ›˜æ«…æª¹æª½æ«¡æ«†æªºæª¶æª·æ«‡æª´æª­æ­žæ¯‰æ°‹ç€‡ç€Œç€ç€ç€…ç€”ç€Žæ¿¿ç€€æ¿»ç€¦æ¿¼æ¿·ç€Šçˆç‡¿ç‡¹çˆƒç‡½ç¶"
  ],
  [
    "f040",
    "ç’¸ç“€ç’µç“ç’¾ç’¶ç’»ç“‚ç””ç”“ç™œç™¤ç™™ç™ç™“ç™—ç™šçš¦çš½ç›¬çŸ‚çžºç£¿ç¤Œç¤“ç¤”ç¤‰ç¤ç¤’ç¤‘ç¦­ç¦¬ç©Ÿç°œç°©ç°™ç° ç°Ÿç°­ç°ç°¦ç°¨ç°¢ç°¥ç°°ç¹œç¹ç¹–ç¹£ç¹˜ç¹¢ç¹Ÿç¹‘ç¹ ç¹—ç¹“ç¾µç¾³ç¿·ç¿¸èµè‡‘è‡’"
  ],
  [
    "f0a1",
    "è‡è‰Ÿè‰žè–´è—†è—€è—ƒè—‚è–³è–µè–½è—‡è—„è–¿è—‹è—Žè—ˆè—…è–±è–¶è—’è˜¤è–¸è–·è–¾è™©èŸ§èŸ¦èŸ¢èŸ›èŸ«èŸªèŸ¥èŸŸèŸ³èŸ¤èŸ”èŸœèŸ“èŸ­èŸ˜èŸ£èž¤èŸ—èŸ™è èŸ´èŸ¨èŸè¥“è¥‹è¥è¥Œè¥†è¥è¥‘è¥‰è¬ªè¬§è¬£è¬³è¬°è¬µè­‡è¬¯è¬¼è¬¾è¬±è¬¥è¬·è¬¦è¬¶è¬®è¬¤è¬»è¬½è¬ºè±‚è±µè²™è²˜è²—è³¾è´„è´‚è´€è¹œè¹¢è¹ è¹—è¹–è¹žè¹¥è¹§"
  ],
  [
    "f140",
    "è¹›è¹šè¹¡è¹è¹©è¹”è½†è½‡è½ˆè½‹é„¨é„ºé„»é„¾é†¨é†¥é†§é†¯é†ªéŽµéŽŒéŽ’éŽ·éŽ›éŽéŽ‰éŽ§éŽŽéŽªéŽžéŽ¦éŽ•éŽˆéŽ™éŽŸéŽéŽ±éŽ‘éŽ²éŽ¤éŽ¨éŽ´éŽ£éŽ¥é—’é—“é—‘éš³é›—é›šå·‚é›Ÿé›˜é›éœ£éœ¢éœ¥éž¬éž®éž¨éž«éž¤éžª"
  ],
  [
    "f1a1",
    "éž¢éž¥éŸ—éŸ™éŸ–éŸ˜éŸºé¡é¡‘é¡’é¢¸é¥é¤¼é¤ºé¨é¨‹é¨‰é¨é¨„é¨‘é¨Šé¨…é¨‡é¨†é«€é«œé¬ˆé¬„é¬…é¬©é¬µé­Šé­Œé­‹é¯‡é¯†é¯ƒé®¿é¯é®µé®¸é¯“é®¶é¯„é®¹é®½éµœéµ“éµéµŠéµ›éµ‹éµ™éµ–éµŒéµ—éµ’éµ”éµŸéµ˜éµšéºŽéºŒé»Ÿé¼é¼€é¼–é¼¥é¼«é¼ªé¼©é¼¨é½Œé½•å„´å„µåŠ–å‹·åŽ´åš«åš­åš¦åš§åšªåš¬å£šå£å£›å¤’å¬½å¬¾å¬¿å·ƒå¹°"
  ],
  [
    "f240",
    "å¾¿æ‡»æ”‡æ”æ”æ”‰æ”Œæ”Žæ–„æ—žæ—æ›žæ«§æ« æ«Œæ«‘æ«™æ«‹æ«Ÿæ«œæ«æ««æ«æ«æ«žæ­ æ®°æ°Œç€™ç€§ç€ ç€–ç€«ç€¡ç€¢ç€£ç€©ç€—ç€¤ç€œç€ªçˆŒçˆŠçˆ‡çˆ‚çˆ…çŠ¥çŠ¦çŠ¤çŠ£çŠ¡ç“‹ç“…ç’·ç“ƒç”–ç™ çŸ‰çŸŠçŸ„çŸ±ç¤ç¤›"
  ],
  [
    "f2a1",
    "ç¤¡ç¤œç¤—ç¤žç¦°ç©§ç©¨ç°³ç°¼ç°¹ç°¬ç°»ç³¬ç³ªç¹¶ç¹µç¹¸ç¹°ç¹·ç¹¯ç¹ºç¹²ç¹´ç¹¨ç½‹ç½Šç¾ƒç¾†ç¾·ç¿½ç¿¾è¸è‡—è‡•è‰¤è‰¡è‰£è—«è—±è—­è—™è—¡è—¨è—šè——è—¬è—²è—¸è—˜è—Ÿè—£è—œè—‘è—°è—¦è—¯è—žè—¢è €èŸºè ƒèŸ¶èŸ·è ‰è Œè ‹è †èŸ¼è ˆèŸ¿è Šè ‚è¥¢è¥šè¥›è¥—è¥¡è¥œè¥˜è¥è¥™è¦ˆè¦·è¦¶è§¶è­è­ˆè­Šè­€è­“è­–è­”è­‹è­•"
  ],
  [
    "f340",
    "è­‘è­‚è­’è­—è±ƒè±·è±¶è²šè´†è´‡è´‰è¶¬è¶ªè¶­è¶«è¹­è¹¸è¹³è¹ªè¹¯è¹»è»‚è½’è½‘è½è½è½“è¾´é…€é„¿é†°é†­éžé‡éé‚éšéé¹é¬éŒé™éŽ©é¦éŠé”é®é£é•é„éŽé€é’é§é•½é—šé—›é›¡éœ©éœ«éœ¬éœ¨éœ¦"
  ],
  [
    "f3a1",
    "éž³éž·éž¶éŸéŸžéŸŸé¡œé¡™é¡é¡—é¢¿é¢½é¢»é¢¾é¥ˆé¥‡é¥ƒé¦¦é¦§é¨šé¨•é¨¥é¨é¨¤é¨›é¨¢é¨ é¨§é¨£é¨žé¨œé¨”é«‚é¬‹é¬Šé¬Žé¬Œé¬·é¯ªé¯«é¯ é¯žé¯¤é¯¦é¯¢é¯°é¯”é¯—é¯¬é¯œé¯™é¯¥é¯•é¯¡é¯šéµ·é¶é¶Šé¶„é¶ˆéµ±é¶€éµ¸é¶†é¶‹é¶Œéµ½éµ«éµ´éµµéµ°éµ©é¶…éµ³éµ»é¶‚éµ¯éµ¹éµ¿é¶‡éµ¨éº”éº‘é»€é»¼é¼­é½€é½é½é½–é½—é½˜åŒ·åš²"
  ],
  [
    "f440",
    "åšµåš³å££å­…å·†å·‡å»®å»¯å¿€å¿æ‡¹æ”—æ”–æ”•æ”“æ—Ÿæ›¨æ›£æ›¤æ«³æ«°æ«ªæ«¨æ«¹æ«±æ«®æ«¯ç€¼ç€µç€¯ç€·ç€´ç€±ç‚ç€¸ç€¿ç€ºç€¹ç€ç€»ç€³ççˆ“çˆ”çŠ¨ç½ç¼ç’ºçš«çšªçš¾ç›­çŸŒçŸŽçŸçŸçŸ²ç¤¥ç¤£ç¤§ç¤¨ç¤¤ç¤©"
  ],
  [
    "f4a1",
    "ç¦²ç©®ç©¬ç©­ç«·ç±‰ç±ˆç±Šç±‡ç±…ç³®ç¹»ç¹¾çºçº€ç¾ºç¿¿è¹è‡›è‡™èˆ‹è‰¨è‰©è˜¢è—¿è˜è—¾è˜›è˜€è—¶è˜„è˜‰è˜…è˜Œè—½è ™è è ‘è —è “è –è¥£è¥¦è¦¹è§·è­ è­ªè­è­¨è­£è­¥è­§è­­è¶®èº†èºˆèº„è½™è½–è½—è½•è½˜è½šé‚é…ƒé…é†·é†µé†²é†³é‹é“é»é éé”é¾é•éé¨é™ééµé€é·é‡éŽé–é’éºé‰é¸éŠé¿"
  ],
  [
    "f540",
    "é¼éŒé¶é‘é†é—žé— é—Ÿéœ®éœ¯éž¹éž»éŸ½éŸ¾é¡ é¡¢é¡£é¡Ÿé£é£‚é¥é¥Žé¥™é¥Œé¥‹é¥“é¨²é¨´é¨±é¨¬é¨ªé¨¶é¨©é¨®é¨¸é¨­é«‡é«Šé«†é¬é¬’é¬‘é°‹é°ˆé¯·é°…é°’é¯¸é±€é°‡é°Žé°†é°—é°”é°‰é¶Ÿé¶™é¶¤é¶é¶’é¶˜é¶é¶›"
  ],
  [
    "f5a1",
    "é¶ é¶”é¶œé¶ªé¶—é¶¡é¶šé¶¢é¶¨é¶žé¶£é¶¿é¶©é¶–é¶¦é¶§éº™éº›éºšé»¥é»¤é»§é»¦é¼°é¼®é½›é½ é½žé½é½™é¾‘å„ºå„¹åŠ˜åŠ—å›ƒåš½åš¾å­ˆå­‡å·‹å·å»±æ‡½æ”›æ¬‚æ«¼æ¬ƒæ«¸æ¬€çƒç„çŠçˆç‰ç…ç†çˆçˆšçˆ™ç¾ç”—ç™ªçŸç¤­ç¤±ç¤¯ç±”ç±“ç³²çºŠçº‡çºˆçº‹çº†çºç½ç¾»è€°è‡è˜˜è˜ªè˜¦è˜Ÿè˜£è˜œè˜™è˜§è˜®è˜¡è˜ è˜©è˜žè˜¥"
  ],
  [
    "f640",
    "è ©è è ›è  è ¤è œè «è¡Šè¥­è¥©è¥®è¥«è§ºè­¹è­¸è­…è­ºè­»è´è´”è¶¯èºŽèºŒè½žè½›è½é…†é…„é……é†¹é¿é»é¶é©é½é¼é°é¹éªé·é¬é‘€é±é—¥é—¤é—£éœµéœºéž¿éŸ¡é¡¤é£‰é£†é£€é¥˜é¥–é¨¹é¨½é©†é©„é©‚é©é¨º"
  ],
  [
    "f6a1",
    "é¨¿é«é¬•é¬—é¬˜é¬–é¬ºé­’é°«é°é°œé°¬é°£é°¨é°©é°¤é°¡é¶·é¶¶é¶¼é·é·‡é·Šé·é¶¾é·…é·ƒé¶»é¶µé·Žé¶¹é¶ºé¶¬é·ˆé¶±é¶­é·Œé¶³é·é¶²é¹ºéºœé»«é»®é»­é¼›é¼˜é¼šé¼±é½Žé½¥é½¤é¾’äº¹å›†å›…å›‹å¥±å­‹å­Œå·•å·‘å»²æ”¡æ” æ”¦æ”¢æ¬‹æ¬ˆæ¬‰æ°ç•ç–ç—ç’çˆžçˆŸçŠ©ç¿ç“˜ç“•ç“™ç“—ç™­çš­ç¤µç¦´ç©°ç©±ç±—ç±œç±™ç±›ç±š"
  ],
  [
    "f740",
    "ç³´ç³±çº‘ç½ç¾‡è‡žè‰«è˜´è˜µè˜³è˜¬è˜²è˜¶è ¬è ¨è ¦è ªè ¥è¥±è¦¿è¦¾è§»è­¾è®„è®‚è®†è®…è­¿è´•èº•èº”èºšèº’èºèº–èº—è½ è½¢é…‡é‘Œé‘é‘Šé‘‹é‘é‘‡é‘…é‘ˆé‘‰é‘†éœ¿éŸ£é¡ªé¡©é£‹é¥”é¥›é©Žé©“é©”é©Œé©é©ˆé©Š"
  ],
  [
    "f7a1",
    "é©‰é©’é©é«é¬™é¬«é¬»é­–é­•é±†é±ˆé°¿é±„é°¹é°³é±é°¼é°·é°´é°²é°½é°¶é·›é·’é·žé·šé·‹é·é·œé·‘é·Ÿé·©é·™é·˜é·–é·µé·•é·éº¶é»°é¼µé¼³é¼²é½‚é½«é¾•é¾¢å„½åŠ™å£¨å£§å¥²å­å·˜è ¯å½æˆæˆƒæˆ„æ”©æ”¥æ––æ›«æ¬‘æ¬’æ¬æ¯Šç›çšçˆ¢çŽ‚çŽçŽƒç™°çŸ”ç±§ç±¦çº•è‰¬è˜ºè™€è˜¹è˜¼è˜±è˜»è˜¾è °è ²è ®è ³è¥¶è¥´è¥³è§¾"
  ],
  [
    "f840",
    "è®Œè®Žè®‹è®ˆè±…è´™èº˜è½¤è½£é†¼é‘¢é‘•é‘é‘—é‘žéŸ„éŸ…é €é©–é©™é¬žé¬Ÿé¬ é±’é±˜é±é±Šé±é±‹é±•é±™é±Œé±Žé·»é··é·¯é·£é·«é·¸é·¤é·¶é·¡é·®é·¦é·²é·°é·¢é·¬é·´é·³é·¨é·­é»‚é»é»²é»³é¼†é¼œé¼¸é¼·é¼¶é½ƒé½"
  ],
  [
    "f8a1",
    "é½±é½°é½®é½¯å›“å›å­Žå±­æ”­æ›­æ›®æ¬“çŸç¡çç çˆ£ç“›ç“¥çŸ•ç¤¸ç¦·ç¦¶ç±ªçº—ç¾‰è‰­è™ƒè ¸è ·è µè¡‹è®”è®•èºžèºŸèº èºé†¾é†½é‡‚é‘«é‘¨é‘©é›¥é†éƒé‡éŸ‡éŸ¥é©žé«•é­™é±£é±§é±¦é±¢é±žé± é¸‚é·¾é¸‡é¸ƒé¸†é¸…é¸€é¸é¸‰é·¿é·½é¸„éº é¼žé½†é½´é½µé½¶å›”æ”®æ–¸æ¬˜æ¬™æ¬—æ¬šç¢çˆ¦çŠªçŸ˜çŸ™ç¤¹ç±©ç±«ç³¶çºš"
  ],
  [
    "f940",
    "çº˜çº›çº™è‡ è‡¡è™†è™‡è™ˆè¥¹è¥ºè¥¼è¥»è§¿è®˜è®™èº¥èº¤èº£é‘®é‘­é‘¯é‘±é‘³é‰é¡²é¥Ÿé±¨é±®é±­é¸‹é¸é¸é¸é¸’é¸‘éº¡é»µé¼‰é½‡é½¸é½»é½ºé½¹åœžç¦ç±¯è ¼è¶²èº¦é‡ƒé‘´é‘¸é‘¶é‘µé© é±´é±³é±±é±µé¸”é¸“é»¶é¼Š"
  ],
  [
    "f9a1",
    "é¾¤ç¨ç¥ç³·è™ªè ¾è ½è ¿è®žè²œèº©è»‰é‹é¡³é¡´é£Œé¥¡é¦«é©¤é©¦é©§é¬¤é¸•é¸—é½ˆæˆ‡æ¬žçˆ§è™Œèº¨é’‚é’€é’é©©é©¨é¬®é¸™çˆ©è™‹è®Ÿé’ƒé±¹éº·ç™µé©«é±ºé¸ç©çªéº¤é½¾é½‰é¾˜ç¢éŠ¹è£å¢»æ’ç²§å«ºâ•”â•¦â•—â• â•¬â•£â•šâ•©â•â•’â•¤â••â•žâ•ªâ•¡â•˜â•§â•›â•“â•¥â•–â•Ÿâ•«â•¢â•™â•¨â•œâ•‘â•â•­â•®â•°â•¯â–“"
  ]
];
const require$$7 = [
  [
    "8740",
    "ä°ä°²ä˜ƒä–¦ä•¸ð§‰§äµ·ä–³ð§²±ä³¢ð§³…ã®•äœ¶ä„ä±‡ä±€ð¤Š¿ð£˜—ð§’ð¦º‹ð§ƒ’ä±—ðª‘ää—šä²…ð§±¬ä´‡äª¤äš¡ð¦¬£çˆ¥ð¥©”ð¡©£ð£¸†ð£½¡æ™å›»"
  ],
  [
    "8767",
    "ç¶•å¤ð¨®¹ã·´éœ´ð§¯¯å¯›ð¡µžåª¤ã˜¥ð©º°å«‘å®·å³¼æ®è–“ð©¥…ç‘¡ç’ã¡µð¡µ“ð£šžð¦€¡ã»¬"
  ],
  [
    "87a1",
    "ð¥£žã«µç«¼é¾—ð¤…¡ð¨¤ð£‡ªð ªŠð£‰žäŒŠè’„é¾–é¯ä¤°è˜“å¢–éŠéˆ˜ç§ç¨²æ™ æ¨©è¢ç‘Œç¯…æž‚ç¨¬å‰é†ã“¦ç„ð¥¶¹ç“†é¿‡åž³ä¤¯å‘Œä„±ð£šŽå ˜ç©²ð§­¥è®äš®ð¦ºˆä†ð¥¶™ç®®ð¢’¼é¿ˆð¢“ð¢“‰ð¢“Œé¿‰è”„ð£–»ä‚´é¿Šä“¡ðª·¿æ‹ç®é¿‹"
  ],
  [
    "8840",
    "ã‡€",
    4,
    "ð „Œã‡…ð ƒ‘ð ƒã‡†ã‡‡ð ƒ‹ð¡¿¨ã‡ˆð ƒŠã‡‰ã‡Šã‡‹ã‡Œð „Žã‡ã‡ŽÄ€ÃÇÃ€Ä’Ã‰ÄšÃˆÅŒÃ“Ç‘Ã’à¿¿ÃŠÌ„áº¾à¿¿ÃŠÌŒá»€ÃŠÄÃ¡ÇŽÃ É‘Ä“Ã©Ä›Ã¨Ä«Ã­ÇÃ¬ÅÃ³Ç’Ã²Å«ÃºÇ”Ã¹Ç–Ç˜Çš"
  ],
  [
    "88a1",
    "ÇœÃ¼à¿¿ÃªÌ„áº¿à¿¿ÃªÌŒá»ÃªÉ¡âšâ›"
  ],
  [
    "8940",
    "ðªŽ©ð¡……"
  ],
  [
    "8943",
    "æ”Š"
  ],
  [
    "8946",
    "ä¸½æ»éµŽé‡Ÿ"
  ],
  [
    "894c",
    "ð§œµæ’‘ä¼šä¼¨ä¾¨å…–å…´å†œå‡¤åŠ¡åŠ¨åŒ»åŽå‘å˜å›¢å£°å¤„å¤‡å¤²å¤´å­¦å®žå®Ÿå²šåº†æ€»æ–‰æŸ¾æ „æ¡¥æµŽç‚¼ç”µçº¤çº¬çººç»‡ç»ç»Ÿç¼†ç¼·è‰ºè‹è¯è§†è®¾è¯¢è½¦è½§è½®"
  ],
  [
    "89a1",
    "ç‘ç³¼ç·æ¥†ç«‰åˆ§"
  ],
  [
    "89ab",
    "é†Œç¢¸é…žè‚¼"
  ],
  [
    "89b0",
    "è´‹èƒ¶ð §§"
  ],
  [
    "89b5",
    "è‚Ÿé»‡ä³é·‰é¸Œä°¾ð©·¶ð§€Žé¸Šðª„³ã—"
  ],
  [
    "89c1",
    "æºšèˆ¾ç”™"
  ],
  [
    "89c5",
    "ä¤‘é©¬éªé¾™ç¦‡ð¨‘¬ð¡·Šð —ð¢«¦ä¸¤äºäº€äº‡äº¿ä»«ä¼·ã‘Œä¾½ã¹ˆå€ƒå‚ˆã‘½ã’“ã’¥å††å¤…å‡›å‡¼åˆ…äº‰å‰¹åŠåŒ§ã—‡åŽ©ã•‘åŽ°ã•“å‚å£ã•­ã•²ãšå’“å’£å’´å’¹å“å“¯å”˜å”£å”¨ã–˜å”¿ã–¥ã–¿å——ã—…"
  ],
  [
    "8a40",
    "ð§¶„å”¥"
  ],
  [
    "8a43",
    "ð ±‚ð ´•ð¥„«å–ð¢³†ã§¬ð è¹†ð¤¶¸ð©“¥ä“ð¨‚¾çºð¢°¸ã¨´äŸ•ð¨…ð¦§²ð¤·ªæ“ð µ¼ð ¾´ð ³•ð¡ƒ´æ’è¹¾ð º–ð °‹ð ½¤ð¢²©ð¨‰–ð¤““"
  ],
  [
    "8a64",
    "ð µ†ð©©ð¨ƒ©äŸ´ð¤º§ð¢³‚éª²ã©§ð©—´ã¿­ã”†ð¥‹‡ð©Ÿ”ð§£ˆð¢µ„éµ®é •"
  ],
  [
    "8a76",
    "ä™ð¦‚¥æ’´å“£ð¢µŒð¢¯Šð¡·ã§»ð¡¯"
  ],
  [
    "8aa1",
    "ð¦›šð¦œ–ð§¦ æ“ªð¥’ð ±ƒè¹¨ð¢†¡ð¨­Œð œ±"
  ],
  [
    "8aac",
    "ä ‹ð †©ã¿ºå¡³ð¢¶"
  ],
  [
    "8ab2",
    "ð¤—ˆð “¼ð¦‚—ð ½Œð ¶–å•¹ä‚»äŽº"
  ],
  [
    "8abb",
    "äª´ð¢©¦ð¡‚è†ªé£µð ¶œæ¹ã§¾ð¢µè·€åš¡æ‘¼ã¹ƒ"
  ],
  [
    "8ac9",
    "ðª˜ð ¸‰ð¢«ð¢³‰"
  ],
  [
    "8ace",
    "ð¡ƒˆð£§‚ã¦’ã¨†ð¨Š›ã•¸ð¥¹‰ð¢ƒ‡å™’ð ¼±ð¢²²ð©œ ã’¼æ°½ð¤¸»"
  ],
  [
    "8adf",
    "ð§•´ð¢º‹ð¢ˆˆðª™›ð¨³ð ¹ºð °´ð¦ œç¾“ð¡ƒð¢ ƒð¢¤¹ã—»ð¥‡£ð ºŒð ¾ð ºªã¾“ð ¼°ð µ‡ð¡…ð ¹Œ"
  ],
  [
    "8af6",
    "ð º«ð ®©ð µˆð¡ƒ€ð¡„½ã¿¹ð¢š–æ²ð ¾­"
  ],
  [
    "8b40",
    "ð£´ð§˜¹ð¢¯Žð µ¾ð µ¿ð¢±‘ð¢±•ã¨˜ð º˜ð¡ƒ‡ð ¼®ðª˜²ð¦­ð¨³’ð¨¶™ð¨³Šé–ªå“Œè‹„å–¹"
  ],
  [
    "8b55",
    "ð©»ƒé°¦éª¶ð§žð¢·®ç…€è…­èƒ¬å°œð¦•²è„´ãž—åŸð¨‚½é†¶ð »ºð ¸ð ¹·ð »»ã—ð¤·«ã˜‰ð ³–åš¯ð¢žµð¡ƒ‰ð ¸ð ¹¸ð¡¸ð¡…ˆð¨ˆ‡ð¡‘•ð ¹¹ð¤¹ð¢¶¤å©”ð¡€ð¡€žð¡ƒµð¡ƒ¶åžœð ¸‘"
  ],
  [
    "8ba1",
    "ð§š”ð¨‹ð ¾µð ¹»ð¥…¾ãœƒð ¾¶ð¡†€ð¥‹˜ðªŠ½ð¤§šð¡ ºð¤…·ð¨‰¼å¢™å‰¨ã˜šð¥œ½ç®²å­¨ä €ä¬¬é¼§ä§§é°Ÿé®ð¥­´ð£„½å—»ã—²åš‰ä¸¨å¤‚ð¡¯ð¯¡¸é‘ð ‚†ä¹›äº»ã”¾å°£å½‘å¿„ã£ºæ‰Œæ”µæ­ºæ°µæ°ºç¬çˆ«ä¸¬çŠ­ð¤£©ç½’ç¤»ç³¹ç½“ð¦‰ªã“"
  ],
  [
    "8bde",
    "ð¦‹è€‚è‚€ð¦˜’ð¦¥‘åè¡¤è§ð§¢²è® è´é’…é•¸é•¿é—¨ð¨¸éŸ¦é¡µé£Žé£žé¥£ð© é±¼é¸Ÿé»„æ­¯ï¤‡ä¸·ð ‚‡é˜æˆ·é’¢"
  ],
  [
    "8c40",
    "å€»æ·¾ð©±³é¾¦ã·‰è¢ð¤…Žç·å³µä¬ ð¥‡ã•™ð¥´°æ„¢ð¨¨²è¾§é‡¶ç†‘æœ™çŽºð£Šðª„‡ã²‹ð¡¦€ä¬ç£¤ç‚å†®ð¨œä€‰æ©£ðªŠºäˆ£è˜ð ©¯ç¨ªð©¥‡ð¨«ªé•çåŒ¤ð¢¾é´ç›™ð¨§£é¾§çŸäº£ä¿°å‚¼ä¸¯ä¼—é¾¨å´ç¶‹å¢’å£ð¡¶¶åº’åº™å¿‚ð¢œ’æ–‹"
  ],
  [
    "8ca1",
    "ð£¹æ¤™æ©ƒð£±£æ³¿"
  ],
  [
    "8ca7",
    "çˆ€ð¤”…çŽŒã»›ð¤¨“å¬•ç’¹è®ƒð¥²¤ð¥š•çª“ç¯¬ç³ƒç¹¬è‹¸è–—é¾©è¢é¾ªèº¹é¾«è¿è•Ÿé§ éˆ¡é¾¬ð¨¶¹ð¡¿ä±äŠ¢å¨š"
  ],
  [
    "8cc9",
    "é¡¨æ«ä‰¶åœ½"
  ],
  [
    "8cce",
    "è—–ð¤¥»èŠ¿ð§„ä²ð¦µ´åµ»ð¦¬•ð¦¾¾é¾­é¾®å®–é¾¯æ›§ç¹›æ¹—ç§Šã¶ˆä“ƒð£‰–ð¢ž–äŽšä”¶"
  ],
  [
    "8ce6",
    "å³•ð£¬šè«¹å±¸ã´’ð£•‘åµ¸é¾²ç…—ä•˜ð¤ƒ¬ð¡¸£ä±·ã¥¸ã‘Šð †¤ð¦±è«Œä¾´ð ˆ¹å¦¿è…¬é¡–ð©£ºå¼»"
  ],
  [
    "8d40",
    "ð ®Ÿ"
  ],
  [
    "8d42",
    "ð¢‡ð¨¥­ä„‚äš»ð©¹ã¼‡é¾³ðª†µäƒ¸ãŸ–ä›·ð¦±†ä…¼ð¨š²ð§¿ä•­ã£”ð¥’šä•¡ä”›ä¶‰ä±»äµ¶ä—ªã¿ˆð¤¬ã™¡ä“žä’½ä‡­å´¾åµˆåµ–ã·¼ã å¶¤å¶¹ã  ã ¸å¹‚åº½å¼¥å¾ƒã¤ˆã¤”ã¤¿ã¥æƒ—æ„½å³¥ã¦‰æ†·æ†¹æ‡ã¦¸æˆ¬æŠæ‹¥æŒ˜ã§¸åš±"
  ],
  [
    "8da1",
    "ã¨ƒæ¢æ»æ‡æ‘šã©‹æ“€å´•å˜¡é¾Ÿãª—æ–†ãª½æ—¿æ™“ã«²æš’ã¬¢æœ–ã­‚æž¤æ €ã­˜æ¡Šæ¢„ã­²ã­±ã­»æ¤‰æ¥ƒç‰œæ¥¤æ¦Ÿæ¦…ã®¼æ§–ã¯æ©¥æ©´æ©±æª‚ã¯¬æª™ã¯²æª«æªµæ«”æ«¶æ®æ¯æ¯ªæ±µæ²ªã³‹æ´‚æ´†æ´¦æ¶ã³¯æ¶¤æ¶±æ¸•æ¸˜æ¸©æº†ð¨§€æº»æ»¢æ»šé½¿æ»¨æ»©æ¼¤æ¼´ãµ†ð£½æ¾æ¾¾ãµªãµµç†·å²™ã¶Šç€¬ã¶‘çç”ç¯ç¿ç‚‰ð Œ¥äã—±ð »˜"
  ],
  [
    "8e40",
    "ð£»—åž¾ð¦»“ç„¾ð¥Ÿ ã™Žæ¦¢ð¨¯©å­´ç©‰ð¥£¡ð©“™ç©¥ç©½ð¥¦¬çª»çª°ç«‚ç«ƒç‡‘ð¦’ä‡Šç«šç«ç«ªä‡¯å’²ð¥°ç¬‹ç­•ç¬©ð¥ŒŽð¥³¾ç®¢ç­¯èŽœð¥®´ð¦±¿ç¯è¡ç®’ç®¸ð¥´ ã¶­ð¥±¥è’’ç¯ºç°†ç°µð¥³ç±„ç²ƒð¤¢‚ç²¦æ™½ð¤•¸ç³‰ç³‡ç³¦ç±´ç³³ç³µç³Ž"
  ],
  [
    "8ea1",
    "ç¹§ä”ð¦¹„çµð¦»–ç’ç¶‰ç¶«ç„µç¶³ç·’ð¤—ð¦€©ç·¤ã´“ç·µð¡Ÿ¹ç·¥ð¨­ç¸ð¦„¡ð¦…šç¹®çº’äŒ«é‘¬ç¸§ç½€ç½ç½‡ç¤¶ð¦‹é§¡ç¾—ð¦‘ç¾£ð¡™¡ð ¨ä•œð£¦ä”ƒð¨Œºç¿ºð¦’‰è€…è€ˆè€è€¨è€¯ðª‚‡ð¦³ƒè€»è€¼è¡ð¢œ”ä¦‰ð¦˜¦ð£·£ð¦›¨æœ¥è‚§ð¨©ˆè„‡è„šå¢°ð¢›¶æ±¿ð¦’˜ð¤¾¸æ“§ð¡’Šèˆ˜ð¡¡žæ©“ð¤©¥ð¤ª•ä‘ºèˆ©ð ¬ð¦©’ð£µ¾ä¿¹ð¡“½è“¢è¢ð¦¬Šð¤¦§ð£”°ð¡³ð£·¸èŠªæ¤›ð¯¦”ä‡›"
  ],
  [
    "8f40",
    "è•‹è‹èŒšð ¸–ð¡ž´ã›ð£…½ð£•šè‰»è‹¢èŒ˜ð£º‹ð¦¶£ð¦¬…ð¦®—ð£—Žã¶¿èŒå—¬èŽ…ä”‹ð¦¶¥èŽ¬èè“ã‘¾ð¦»”æ©—è•šã’–ð¦¹‚ð¢»¯è‘˜ð¥¯¤è‘±ã·“ä“¤æª§è‘Šð£²µç¥˜è’¨ð¦®–ð¦¹·ð¦¹ƒè“žèèŽ‘ä’ è’“è“¤ð¥²‘ä‰€ð¥³€ä•ƒè”´å«²ð¦º™ä”§è•³ä”–æž¿è˜–"
  ],
  [
    "8fa1",
    "ð¨˜¥ð¨˜»è—ð§‚ˆè˜‚ð¡–‚ð§ƒð¯¦²ä•ªè˜¨ã™ˆð¡¢¢å·ð§Žšè™¾è±ðªƒ¸èŸ®ð¢°§èž±èŸšè å™¡è™¬æ¡–ä˜è¡…è¡†ð§— ð£¶¹ð§—¤è¡žè¢œä™›è¢´è¢µæè£…ç·ð§œè¦‡è¦Šè¦¦è¦©è¦§è¦¼ð¨¨¥è§§ð§¤¤ð§ª½èªœçž“é‡¾èªð§©™ç«©ð§¬ºð£¾äœ“ð§¬¸ç…¼è¬Œè¬Ÿð¥°ð¥•¥è¬¿è­Œè­èª©ð¤©ºè®è®›èª¯ð¡›Ÿä˜•è¡è²›ð§µ”ð§¶ð¯§”ãœ¥ð§µ“è³–ð§¶˜ð§¶½è´’è´ƒð¡¤è³›çœè´‘ð¤³‰ã»èµ·"
  ],
  [
    "9040",
    "è¶©ð¨€‚ð¡€”ð¤¦Šã­¼ð¨†¼ð§„Œç«§èº­èº¶è»ƒé‹”è¼™è¼­ð¨¥ð¨’è¾¥éŒƒðªŠŸð ©è¾³ä¤ªð¨§žð¨”½ð£¶»å»¸ð£‰¢è¿¹ðª€”ð¨š¼ð¨”ð¢Œ¥ã¦€ð¦»—é€·ð¨”¼ð§ª¾é¡ð¨•¬ð¨˜‹é‚¨ð¨œ“éƒ„ð¨›¦é‚®éƒ½é…§ã«°é†©é‡„ç²¬ð¨¤³ð¡º‰éˆŽæ²Ÿé‰é‰¢ð¥–¹éŠ¹ð¨«†ð£²›ð¨¬Œð¥—›"
  ],
  [
    "90a1",
    "ð ´±éŒ¬é«ð¨«¡ð¨¯«ç‚å«ƒð¨«¢ð¨«¥ä¥¥é‰„ð¨¯¬ð¨°¹ð¨¯¿é³é‘›èº¼é–…é–¦é¦é– æ¿¶äŠ¹ð¢™ºð¨›˜ð¡‰¼ð£¸®ä§Ÿæ°œé™»éš–ä…¬éš£ð¦»•æ‡šéš¶ç£µð¨« éš½åŒä¦¡ð¦²¸ð ‰´ð¦ð©‚¯ð©ƒ¥ð¤«‘ð¡¤•ð£ŒŠéœ±è™‚éœ¶ä¨ä”½ä–…ð¤«©çµå­éœ›éœð©‡•é—å­Šð©‡«éŸé¥åƒð£‚·ð£‚¼éž‰éžŸéž±éž¾éŸ€éŸ’éŸ ð¥‘¬éŸ®çœð©³éŸ¿éŸµð©ð§¥ºä«‘é ´é ³é¡‹é¡¦ã¬Žð§…µãµ‘ð ˜°ð¤…œ"
  ],
  [
    "9140",
    "ð¥œ†é£Šé¢·é£ˆé£‡ä«¿ð¦´§ð¡›“å–°é£¡é£¦é£¬é¸é¤¹ð¤¨©ä­²ð©¡—ð©¤…é§µé¨Œé¨»é¨é©˜ð¥œ¥ã›„ð©‚±ð©¯•é« é«¢ð©¬…é«´ä°Žé¬”é¬­ð¨˜€å€´é¬´ð¦¦¨ã£ƒð£½é­é­€ð©´¾å©…ð¡¡£é®Žð¤‰‹é°‚é¯¿é°Œð©¹¨é·”ð©¾·ðª†’ðª†«ðªƒ¡ðª„£ðª‡Ÿéµ¾é¶ƒðª„´é¸Žæ¢ˆ"
  ],
  [
    "91a1",
    "é·„ð¢…›ðª†“ðªˆ ð¡¤»ðªˆ³é´¹ðª‚¹ðªŠ´éºéº•éºžéº¢ä´´éºªéº¯ð¤¤é»ã­ ã§¥ã´ä¼²ãž¾ð¨°«é¼‚é¼ˆä®–é¤ð¦¶¢é¼—é¼–é¼¹åšŸåšŠé½…é¦¸ð©‚‹éŸ²è‘¿é½¢é½©ç«œé¾Žçˆ–ä®¾ð¤¥µð¤¦»ç…·ð¤§¸ð¤ˆð¤©‘çŽžð¨¯šð¡£ºç¦Ÿð¨¥¾ð¨¸¶é©é³ð¨©„é‹¬éŽé‹ð¨¥¬ð¤’¹çˆ—ã»«ç²ç©ƒçƒð¤‘³ð¤¸ç…¾ð¡Ÿ¯ç‚£ð¡¢¾ð£–™ã»‡ð¡¢…ð¥¯ð¡Ÿ¸ãœ¢ð¡›»ð¡ ¹ã›¡ð¡´ð¡£‘ð¥½‹ãœ£ð¡›€å›ð¤¨¥ð¡¾ð¡Š¨"
  ],
  [
    "9240",
    "ð¡†ð¡’¶è”ƒð£š¦è”ƒè‘•ð¤¦”ð§…¥ð£¸±ð¥•œð£»»ð§’ä“´ð£›®ð©¦ð¦¼¦æŸ¹ãœ³ã°•ã·§å¡¬ð¡¤¢æ ä—ð£œ¿ð¤ƒ¡ð¤‚‹ð¤„ð¦°¡å“‹åšžð¦š±åš’ð ¿Ÿð ®¨ð ¸é†ð¨¬“éŽœä»¸å„«ã ™ð¤¶äº¼ð ‘¥ð ¿ä½‹ä¾Šð¥™‘å©¨ð †«ð ‹ã¦™ð ŒŠð ”ãµä¼©ð ‹€ð¨º³ð ‰µè«šð ˆŒäº˜"
  ],
  [
    "92a1",
    "åƒå„ä¾¢ä¼ƒð¤¨Žð£ºŠä½‚å€®å¬å‚ä¿Œä¿¥å˜åƒ¼å…™å…›å…å…žæ¹¶ð£–•ð£¸¹ð£º¿æµ²ð¡¢„ð£º‰å†¨å‡ƒð — ä“ð ’£ð ’’ð ’‘èµºð¨ªœð œŽå‰™åŠ¤ð ¡³å‹¡é®ä™ºç†Œð¤ŽŒð ° ð¤¦¬ð¡ƒ¤æ§‘ð ¸ç‘¹ã»žç’™ç”ç‘–çŽ˜ä®Žð¤ª¼ð¤‚åã–„çˆð¤ƒ‰å–´ð …å“ð ¯†åœé‰é›´é¦åŸåžå¿ã˜¾å£‹åª™ð¨©†ð¡›ºð¡¯ð¡œå¨¬å¦¸éŠå©¾å«å¨’ð¥¥†ð¡§³ð¡¡¡ð¤Š•ã›µæ´…ç‘ƒå¨¡ð¥ºƒ"
  ],
  [
    "9340",
    "åªð¨¯—ð “é ç’Œð¡Œƒç„…ä¥²éˆð¨§»éŽ½ãž å°žå²žå¹žå¹ˆð¡¦–ð¡¥¼ð£«®å»å­ð¡¤ƒð¡¤„ãœð¡¢ ã›ð¡›¾ã›“è„ªð¨©‡ð¡¶ºð£‘²ð¨¦¨å¼Œå¼Žð¡¤§ð¡ž«å©«ð¡œ»å­„è˜”ð§—½è¡ æ¾ð¢¡ ð¢˜«å¿›ãº¸ð¢–¯ð¢–¾ð©‚ˆð¦½³æ‡€ð €¾ð †ð¢˜›æ†™æ†˜æµð¢²›ð¢´‡ð¤›”ð©…"
  ],
  [
    "93a1",
    "æ‘±ð¤™¥ð¢­ªã¨©ð¢¬¢ð£‘ð©£ªð¢¹¸æŒ·ðª‘›æ’¶æŒ±æ‘ð¤§£ð¢µ§æŠ¤ð¢²¡æ»æ•«æ¥²ã¯´ð£‚Žð£Š­ð¤¦‰ð£Š«å”ð£‹ ð¡£™ð©¿æ›Žð£Š‰ð£†³ã« ä†ð¥–„ð¨¬¢ð¥–ð¡›¼ð¥•›ð¥¥ç£®ð£„ƒð¡ ªð£ˆ´ã‘¤ð£ˆð£†‚ð¤‹‰æšŽð¦´¤æ™«ä®“æ˜°ð§¡°ð¡·«æ™£ð£‹’ð£‹¡æ˜žð¥¡²ã£‘ð£ ºð£ž¼ã®™ð£ž¢ð£¾ç“ã®–æžð¤˜ªæ¢¶æ žã¯„æª¾ã¡£ð£Ÿ•ð¤’‡æ¨³æ©’æ«‰æ¬…ð¡¤’æ”‘æ¢˜æ©Œã¯—æ©ºæ­—ð£¿€ð£²šéŽ é‹²ð¨¯ªð¨«‹"
  ],
  [
    "9440",
    "éŠ‰ð¨€žð¨§œé‘§æ¶¥æ¼‹ð¤§¬æµ§ð£½¿ã¶æ¸„ð¤€¼å¨½æ¸Šå¡‡æ´¤ç¡‚ç„»ð¤Œšð¤‰¶çƒ±ç‰çŠ‡çŠ”ð¤žð¤œ¥å…¹ð¤ª¤ð —«ç‘ºð£»¸ð£™Ÿð¤©Šð¤¤—ð¥¿¡ã¼†ãº±ð¤«Ÿð¨°£ð£¼µæ‚§ã»³ç“Œç¼éŽ‡ç·ä’Ÿð¦·ªä•‘ç–ƒã½£ð¤³™ð¤´†ã½˜ç••ç™³ðª—†ã¬™ç‘¨ð¨«Œð¤¦«ð¤¦Žã«»"
  ],
  [
    "94a1",
    "ã·ð¤©Žã»¿ð¤§…ð¤£³é‡ºåœ²é‚ð¨«£ð¡¡¤åƒŸð¥ˆ¡ð¥‡§ç¸ð£ˆ²çœŽçœç»ð¤š—ð£žã©žð¤£°ç¸ç’›ãº¿ð¤ªºð¤«‡äƒˆð¤ª–ð¦†®éŒ‡ð¥–ç žç¢ç¢ˆç£’çç¥™ð§ð¥›£ä„Žç¦›è’–ç¦¥æ¨­ð£»ºç¨ºç§´ä…®ð¡›¦ä„²éˆµç§±ð µŒð¤¦Œð Š™ð£¶ºð¡®ã–—å•«ã•°ãšªð ‡”ð °ç«¢å©™ð¢›µð¥ª¯ð¥ªœå¨ð ‰›ç£°å¨ªð¥¯†ç«¾ä‡¹ç±ç±­äˆ‘ð¥®³ð¥º¼ð¥º¦ç³ð¤§¹ð¡ž°ç²Žç±¼ç²®æª²ç·œç¸‡ç·“ç½Žð¦‰¡"
  ],
  [
    "9540",
    "ð¦…œð§­ˆç¶—ð¥º‚ä‰ªð¦­µð ¤–æŸ–ð Žð£—åŸ„ð¦’ð¦¸ð¤¥¢ç¿ç¬§ð  ¬ð¥«©ð¥µƒç¬Œð¥¸Žé§¦è™…é©£æ¨œð£¿ã§¢ð¤§·ð¦–­é¨Ÿð¦– è’€ð§„§ð¦³‘ä“ªè„·ä‚èƒ†è„‰è…‚ð¦ž´é£ƒð¦©‚è‰¢è‰¥ð¦©‘è‘“ð¦¶§è˜ð§ˆ›åª†ä…¿ð¡¡€å¬«ð¡¢¡å«¤ð¡£˜èš ð¯¦¼ð£¶è ­ð§¢å¨‚"
  ],
  [
    "95a1",
    "è¡®ä½…è¢‡è¢¿è£¦è¥¥è¥ð¥šƒè¥”ð§ž…ð§ž„ð¨¯µð¨¯™ð¨®œð¨§¹ãº­è’£ä›µä›ãŸ²è¨½è¨œð©‘ˆå½éˆ«ð¤Š„æ—”ç„©çƒ„ð¡¡…éµ­è²Ÿè³©ð§·œå¦šçŸƒå§°ä®ã›”è¸ªèº§ð¤°‰è¼°è½Šä‹´æ±˜æ¾»ð¢Œ¡ä¢›æ½¹æº‹ð¡Ÿšé¯©ãšµð¤¤¯é‚»é‚—å•±ä¤†é†»é„ð¨©‹ä¢ð¨«¼é§ð¨°ð¨°»è“¥è¨«é–™é–§é–—é––ð¨´´ç‘…ã»‚ð¤£¿ð¤©‚ð¤ªã»§ð£ˆ¥éšð¨»§ð¨¹¦ð¨¹¥ã»Œð¤§­ð¤©¸ð£¿®ç’ç‘«ã»¼éð©‚°"
  ],
  [
    "9640",
    "æ¡‡ä¨ð©‚“ð¥ŸŸéé¨ð¨¦‰ð¨°¦ð¨¬¯ð¦Ž¾éŠºå¬‘è­©ä¤¼ç¹ð¤ˆ›éž›é±é¤¸ð ¼¦å·ð¨¯…ð¤ª²é Ÿð©“šé‹¶ð©——é‡¥ä“€ð¨­ð¤©§ð¨­¤é£œð¨©…ã¼€éˆªä¤¥è”é¤»é¥ð§¬†ã·½é¦›ä­¯é¦ªé©œð¨­¥ð¥£ˆæªé¨¡å«¾é¨¯ð©£±ä®ð©¥ˆé¦¼ä®½ä®—é½å¡²ð¡Œ‚å ¢ð¤¦¸"
  ],
  [
    "96a1",
    "ð¡“¨ç¡„ð¢œŸð£¶¸æ£…ãµ½é‘˜ã¤§æ…ð¢žð¢¥«æ„‡é±é±“é±»é°µé°é­¿é¯ð©¸­é®Ÿðª‡µðªƒ¾é´¡ä²®ð¤„„é¸˜ä²°é´Œðª†´ðªƒ­ðªƒ³ð©¤¯é¶¥è’½ð¦¸’ð¦¿Ÿð¦®‚è—¼ä”³ð¦¶¤ð¦º„ð¦·°è è—®ð¦¸€ð£Ÿ—ð¦¤ç§¢ð£–œð£™€ä¤­ð¤§žãµ¢é›éŠ¾éˆð Š¿ç¢¹é‰·é‘ä¿¤ã‘€é¤ð¥•ç ½ç¡”ç¢¶ç¡‹ð¡—ð£‡‰ð¤¥ãššä½²æ¿šæ¿™ç€žç€žå”ð¤†µåž»å£³åžŠé´–åŸ—ç„´ã’¯ð¤†¬ç‡«ð¦±€ð¤¾—å¬¨ð¡žµð¨©‰"
  ],
  [
    "9740",
    "æ„Œå«Žå¨‹äŠ¼ð¤’ˆãœ¬ä­»ð¨§¼éŽ»éŽ¸ð¡£–ð ¼è‘²ð¦³€ð¡“ð¤‹ºð¢°¦ð¤å¦”ð£¶·ð¦ç¶¨ð¦…›ð¦‚¤ð¤¦¹ð¤¦‹ð¨§ºé‹¥ç¢ã»©ç’´ð¨­£ð¡¢Ÿã»¡ð¤ª³æ«˜ç³ç»ã»–ð¤¨¾ð¤ª”ð¡Ÿ™ð¤©¦ð Ž§ð¡¤ð¤§¥ç‘ˆð¤¤–ç‚¥ð¤¥¶éŠ„ç¦éŸð “¾éŒ±ð¨«Žð¨¨–éŽ†ð¨¯§ð¥—•ä¤µð¨ª‚ç…«"
  ],
  [
    "97a1",
    "ð¤¥ƒð ³¿åš¤ð ˜šð ¯«ð ²¸å”‚ç§„ð¡Ÿºç·¾ð¡›‚ð¤©ð¡¡’ä”®éãœŠð¨«€ð¤¦­å¦°ð¡¢¿ð¡¢ƒð§’„åª¡ã›¢ð£µ›ãš°é‰Ÿå©¹ð¨ªð¡¡¢é´ã³ð ª´äª–ã¦Šåƒ´ãµ©ãµŒð¡Žœç…µä‹»ð¨ˆ˜æ¸ð©ƒ¤ä“«æµ—ð§¹ç§æ²¯ã³–ð£¿­ð£¸­æ¸‚æ¼Œãµ¯ð µç•‘ãš¼ã“ˆäš€ã»šä¡±å§„é‰®ä¤¾è½ð¨°œð¦¯€å ’åŸˆã›–ð¡‘’çƒ¾ð¤¢ð¤©±ð¢¿£ð¡Š°ð¢Ž½æ¢¹æ¥§ð¡Ž˜ð£“¥ð§¯´ð£›Ÿð¨ªƒð£Ÿ–ð£ºð¤²Ÿæ¨šð£š­ð¦²·è¾ä“Ÿä“Ž"
  ],
  [
    "9840",
    "ð¦´¦ð¦µ‘ð¦²‚ð¦¿žæ¼—ð§„‰èŒ½ð¡œºè­ð¦²€ð§“ð¡Ÿ›å¦‰åª‚ð¡ž³å©¡å©±ð¡¤…ð¤‡¼ãœ­å§¯ð¡œ¼ã›‡ç†ŽéŽæššð¤Š¥å©®å¨«ð¤Š“æ¨«ð£»¹ð§œ¶ð¤‘›ð¤‹Šç„ð¤‰™ð¨§¡ä¾°ð¦´¨å³‚ð¤“Žð§¹ð¤Ž½æ¨Œð¤‰–ð¡Œ„ç‚¦ç„³ð¤©ã¶¥æ³Ÿð¯ ¥ð¤©ç¹¥å§«å´¯ã·³å½œð¤©ð¡ŸŸç¶¤è¦"
  ],
  [
    "98a1",
    "å’…ð£«ºð£Œ€ð ˆ”å¾ð £•ð ˜™ã¿¥ð¡¾žðªŠ¶ç€ƒð©…›åµ°çŽç³“ð¨©™ð© ä¿ˆç¿§ç‹çŒð§«´çŒ¸çŒ¹ð¥›¶ççˆãº©ð§¬˜é¬ç‡µð¤£²ç¡è‡¶ã»ŠçœŒã»‘æ²¢å›½ç™çžçŸã»¢ã»°ã»´ã»ºç““ã¼Žã½“ç•‚ç•­ç•²ç–ã½¼ç—ˆç—œã¿€ç™ã¿—ç™´ã¿œç™ºð¤½œç†ˆå˜£è¦€å¡©ä€çƒä€¹æ¡ä…ã—›çž˜äªä¯å±žçž¾çŸ‹å£²ç ˜ç‚¹ç œä‚¨ç ¹ç¡‡ç¡‘ç¡¦è‘ˆð¥”µç¤³æ ƒç¤²ä„ƒ"
  ],
  [
    "9940",
    "ä„‰ç¦‘ç¦™è¾»ç¨†è¾¼ä…§çª‘ä†²çª¼è‰¹ä‡„ç«ç«›ä‡ä¸¡ç­¢ç­¬ç­»ç°’ç°›ä‰ ä‰ºç±»ç²œäŠŒç²¸äŠ”ç³­è¾“çƒ€ð ³ç·ç·”ç·ç·½ç¾®ç¾´çŠŸäŽ—è€ è€¥ç¬¹è€®è€±è”ã·Œåž´ç‚ è‚·èƒ©ä­è„ŒçŒªè„Žè„’ç• è„”äã¬¹è…–è…™è…š"
  ],
  [
    "99a1",
    "ä“å ºè…¼è†„ä¥è†“ä­è†¥åŸ¯è‡è‡¤è‰”ä’èŠ¦è‰¶è‹Šè‹˜è‹¿ä’°è—é™©æ¦Šè…çƒµè‘¤æƒ£è’ˆä”„è’¾è“¡è“¸è”è”¸è•’ä”»è•¯è•°è— ä•·è™²èš’èš²è›¯é™…èž‹ä˜†ä˜—è¢®è£¿è¤¤è¥‡è¦‘ð§¥§è¨©è¨¸èª”èª´è±‘è³”è³²è´œäž˜å¡Ÿè·ƒäŸ­ä»®è¸ºå—˜å”è¹±å—µèº°ä ·è»Žè»¢è»¤è»­è»²è¾·è¿è¿Šè¿Œé€³é§„ä¢­é£ éˆ“ä¤žéˆ¨é‰˜é‰«éŠ±éŠ®éŠ¿"
  ],
  [
    "9a40",
    "é‹£é‹«é‹³é‹´é‹½éƒéŽ„éŽ­ä¥…ä¥‘éº¿é—åŒéé­é¾ä¥ªé‘”é‘¹é”­é–¢ä¦§é—´é˜³ä§¥æž ä¨¤é€ä¨µéž²éŸ‚å™”ä«¤æƒ¨é¢¹ä¬™é£±å¡„é¤Žé¤™å†´é¤œé¤·é¥‚é¥é¥¢ä­°é§…ä®é¨¼é¬çªƒé­©é®é¯é¯±é¯´ä±­é° ã¯ð¡¯‚éµ‰é°º"
  ],
  [
    "9aa1",
    "é»¾å™é¶“é¶½é·€é·¼é“¶è¾¶é¹»éº¬éº±éº½é»†é“œé»¢é»±é»¸ç«ˆé½„ð ‚”ð Š·ð Ž æ¤šé“ƒå¦¬ð “—å¡€é“ãž¹ð —•ð ˜•ð ™¶ð¡šºå—ç…³ð «‚ð «ð ®¿å‘ªð¯ »ð ¯‹å’žð ¯»ð °»ð ±“ð ±¥ð ±¼æƒ§ð ²å™ºð ²µð ³ð ³­ð µ¯ð ¶²ð ·ˆæ¥•é°¯èž¥ð ¸„ð ¸Žð »—ð ¾ð ¼­ð ¹³å° ð ¾¼å¸‹ð¡œð¡ð¡¶æœžð¡»ð¡‚ˆð¡‚–ã™‡ð¡‚¿ð¡ƒ“ð¡„¯ð¡„»å¤è’­ð¡‹£ð¡µð¡Œ¶è®ð¡•·ð¡˜™ð¡Ÿƒð¡Ÿ‡ä¹¸ç‚»ð¡ ­ð¡¥ª"
  ],
  [
    "9b40",
    "ð¡¨­ð¡©…ð¡°ªð¡±°ð¡²¬ð¡»ˆæ‹ƒð¡»•ð¡¼•ç†˜æ¡•ð¢…æ§©ã›ˆð¢‰¼ð¢—ð¢ºð¢œªð¢¡±ð¢¥è‹½ð¢¥§ð¢¦“ð¢«•è¦¥ð¢«¨è¾ ð¢¬Žéž¸ð¢¬¿é¡‡éª½ð¢±Œ"
  ],
  [
    "9b62",
    "ð¢²ˆð¢²·ð¥¯¨ð¢´ˆð¢´’ð¢¶·ð¢¶•ð¢¹‚ð¢½´ð¢¿Œð£€³ð£¦ð£ŒŸð£žå¾±æ™ˆæš¿ð§©¹ð£•§ð£—³çˆð¤¦ºçŸ—ð£˜šð£œ–çº‡ð †å¢µæœŽ"
  ],
  [
    "9ba1",
    "æ¤˜ð£ª§ð§™—ð¥¿¢ð£¸‘ð£º¹ð§—¾ð¢‚šä£äª¸ð¤„™ð¨ªšð¤‹®ð¤Œð¤€»ð¤Œ´ð¤Ž–ð¤©…ð —Šå‡’ð ˜‘å¦Ÿð¡º¨ã®¾ð£³¿ð¤„ð¤“–åžˆð¤™´ã¦›ð¤œ¯ð¨—¨ð©§‰ã¢ð¢‡ƒè­žð¨­Žé§–ð¤ ’ð¤£»ð¤¨•çˆ‰ð¤«€ð ±¸å¥¥ð¤º¥ð¤¾†ð ¹è»šð¥€¬åŠåœ¿ç…±ð¥Š™ð¥™ð£½Šð¤ª§å–¼ð¥‘†ð¥‘®ð¦­’é‡”ã‘³ð¥”¿ð§˜²ð¥•žäœ˜ð¥•¢ð¥•¦ð¥Ÿ‡ð¤¤¿ð¥¡å¦ã“»ð£Œæƒžð¥¤ƒä¼ð¨¥ˆð¥ª®ð¥®‰ð¥°†ð¡¶åž¡ç…‘æ¾¶ð¦„‚ð§°’é–ð¦†²ð¤¾šè­¢ð¦‚ð¦‘Š"
  ],
  [
    "9c40",
    "åµ›ð¦¯·è¼¶ð¦’„ð¡¤œè«ªð¤§¶ð¦’ˆð£¿¯ð¦”’ä¯€ð¦–¿ð¦šµð¢œ›é‘¥ð¥Ÿ¡æ†•å¨§ð¯£ä¾»åš¹ð¤”¡ð¦›¼ä¹ªð¤¤´é™–æ¶ð¦²½ã˜˜è¥·ð¦ž™ð¦¡®ð¦‘ð¦¡žç‡Ÿð¦£‡ç­‚ð©ƒ€ð ¨‘ð¦¤¦é„„ð¦¤¹ç©…é·°ð¦§ºé¨¦ð¦¨­ã™Ÿð¦‘©ð €¡ç¦ƒð¦¨´ð¦­›å´¬ð£”™èð¦®ä›ð¦²¤ç”»è¡¥ð¦¶®å¢¶"
  ],
  [
    "9ca1",
    "ãœœð¢–ð§‹ð§‡ã±”ð§Š€ð§Š…éŠð¢…ºð§Š‹éŒ°ð§‹¦ð¤§æ°¹é’Ÿð§‘ð »¸è §è£µð¢¤¦ð¨‘³ð¡ž±æº¸ð¤¨ªð¡  ã¦¤ãš¹å°ç§£ä”¿æš¶ð©²­ð©¢¤è¥ƒð§ŸŒð§¡˜å›–äƒŸð¡˜Šã¦¡ð£œ¯ð¨ƒ¨ð¡…ç†­è¦ð§§ð©†¨å©§ä²·ð§‚¯ð¨¦«ð§§½ð§¨Šð§¬‹ð§µ¦ð¤…ºç­ƒç¥¾ð¨€‰æ¾µðª‹Ÿæ¨ƒð¨Œ˜åŽ¢ð¦¸‡éŽ¿æ ¶éð¨…¯ð¨€£ð¦¦µð¡­ð£ˆ¯ð¨ˆå¶…ð¨°°ð¨‚ƒåœ•é £ð¨¥‰å¶«ð¤¦ˆæ–¾æ§•å’ð¤ª¥ð£¾ã°‘æœ¶ð¨‚ð¨ƒ´ð¨„®ð¡¾¡ð¨…"
  ],
  [
    "9d40",
    "ð¨†‰ð¨†¯ð¨ˆšð¨Œ†ð¨Œ¯ð¨ŽŠã—Šð¨‘¨ð¨šªä£ºæ¦ð¨¥–ç ˆé‰•ð¨¦¸ä²ð¨§§äŸð¨§¨ð¨­†ð¨¯”å§¸ð¨°‰è¼‹ð¨¿…ð©ƒ¬ç­‘ð©„ð©„¼ã··ð©…žð¤«Šè¿çŠåš‹ð©“§ð©—©ð©–°ð©–¸ð©œ²ð©£‘ð©¥‰ð©¥ªð©§ƒð©¨¨ð©¬Žð©µšð©¶›çºŸð©»¸ð©¼£ä²¤é•‡ðªŠ“ç†¢ðª‹¿ä¶‘é€’ðª—‹ä¶œð ²œè¾¾å—"
  ],
  [
    "9da1",
    "è¾ºð¢’°è¾¹ð¤ª“ä”‰ç¹¿æ½–æª±ä»ªã“¤ð¨¬¬ð§¢ãœºèº€ð¡Ÿµð¨€¤ð¨­¬ð¨®™ð§¨¾ð¦š¯ã·«ð§™•ð£²·ð¥˜µð¥¥–äºšð¥ºð¦‰˜åš¿ð ¹­è¸Žå­­ð£ºˆð¤²žæžæ‹ð¡Ÿ¶ð¡¡»æ”°å˜­ð¥±Šåšð¥Œ‘ã·†ð©¶˜ä±½å˜¢å˜žç½‰ð¥»˜å¥µð£µ€è°ä¸œð ¿ªð µ‰ð£šºè„—éµžè´˜ç˜»é±…ç™Žçž¹é…å²è…ˆè‹·å˜¥è„²è˜è‚½å—ªç¥¢å™ƒå–ð ºã—Žå˜…å—±æ›±ð¨‹¢ã˜­ç”´å—°å–ºå’—å•²ð ±ð ²–å»ð¥…ˆð ¹¶ð¢±¢"
  ],
  [
    "9e40",
    "ð º¢éº«çµšå—žð¡µæŠé­å’”è³ç‡¶é…¶æ¼æŽ¹æ¾å•©ð¢­ƒé±²ð¢º³å†šã“Ÿð ¶§å†§å‘å”žå”“ç™¦è¸­ð¦¢Šç–±è‚¶è „èž†è£‡è†¶èœð¡ƒä“¬çŒ„ð¤œ†å®èŒ‹ð¦¢“å™»ð¢›´ð§´¯ð¤†£ð§µ³ð¦»ð§Š¶é…°ð¡‡™éˆˆð£³¼ðªš©ð º¬ð »¹ç‰¦ð¡²¢äŽð¤¿‚ð§¿¹ð ¿«äƒº"
  ],
  [
    "9ea1",
    "é±æ”Ÿð¢¶ ä£³ð¤Ÿ ð©µ¼ð ¿¬ð ¸Šæ¢ð§–£ð ¿­"
  ],
  [
    "9ead",
    "ð¦ˆð¡†‡ç†£çºŽéµä¸šä¸„ã•·å¬æ²²å§ãš¬ã§œå½ãš¥ð¤˜˜å¢šð¤­®èˆ­å‘‹åžªð¥ª•ð ¥¹"
  ],
  [
    "9ec5",
    "ã©’ð¢‘¥ç´ð©º¬ä´‰é¯­ð£³¾ð©¼°ä±›ð¤¾©ð©–žð©¿žè‘œð£¶¶ð§Š²ð¦ž³ð£œ æŒ®ç´¥ð£»·ð£¸¬ã¨ªé€ˆå‹Œã¹´ã™ºä—©ð ’Žç™€å«°ð º¶ç¡ºð§¼®å¢§ä‚¿å™¼é®‹åµ´ç™”ðª´éº…ä³¡ç—¹ãŸ»æ„™ð£ƒšð¤²"
  ],
  [
    "9ef5",
    "å™ð¡Š©åž§ð¤¥£ð©¸†åˆ´ð§‚®ã–­æ±Šéµ¼"
  ],
  [
    "9f40",
    "ç±–é¬¹åŸžð¡¬å±“æ““ð©“ð¦Œµð§…¤èš­ð ´¨ð¦´¢ð¤«¢ð µ±"
  ],
  [
    "9f4f",
    "å‡¾ð¡¼å¶Žéœƒð¡·‘éºéŒç¬Ÿé¬‚å³‘ç®£æ‰¨æŒµé«¿ç¯é¬ªç±¾é¬®ç±‚ç²†é°•ç¯¼é¬‰é¼—é°›ð¤¤¾é½šå•³å¯ƒä¿½éº˜ä¿²å‰ ã¸†å‹‘å§å–å¦·å¸’éŸˆé¶«è½œå‘©éž´é¥€éžºåŒ¬æ„°"
  ],
  [
    "9fa1",
    "æ¤¬åšé°Šé´‚ä°»é™æ¦€å‚¦ç•†ð¡­é§šå‰³"
  ],
  [
    "9fae",
    "é…™éšé…œ"
  ],
  [
    "9fb2",
    "é…‘ð¨º—æ¿ð¦´£æ«Šå˜‘é†Žç•ºæŠ…ð ¼çç±°ð¥°¡ð£³½"
  ],
  [
    "9fc1",
    "ð¤¤™ç›–é®ä¸ªð ³”èŽ¾è¡‚"
  ],
  [
    "9fc9",
    "å±Šæ§€åƒ­åºåˆŸå·µä»Žæ°±ð ‡²ä¼¹å’œå“šåŠšè¶‚ã—¾å¼Œã—³"
  ],
  [
    "9fdb",
    "æ­’é…¼é¾¥é®—é ®é¢´éªºéº¨éº„ç…ºç¬”"
  ],
  [
    "9fe7",
    "æ¯ºè ˜ç½¸"
  ],
  [
    "9feb",
    "å˜ ðª™Šè¹·é½“"
  ],
  [
    "9ff0",
    "è·”è¹é¸œè¸æŠ‚ð¨½è¸¨è¹µç«“ð¤©·ç¨¾ç£˜æ³ªè©§ç˜‡"
  ],
  [
    "a040",
    "ð¨©šé¼¦æ³ŽèŸ–ç—ƒðªŠ²ç¡“ð¯¡€è´Œç‹¢ç±è¬­çŒ‚ç“±è³«ð¤ª»è˜¯å¾ºè¢ ä’·"
  ],
  [
    "a055",
    "ð¡ »ð¦¸…"
  ],
  [
    "a058",
    "è©¾ð¢”›"
  ],
  [
    "a05b",
    "æƒ½ç™§é«—éµ„é®é®èŸµ"
  ],
  [
    "a063",
    "è è³·çŒ¬éœ¡é®°ã—–çŠ²ä°‡ç±‘é¥Šð¦…™æ…™ä°„éº–æ…½"
  ],
  [
    "a073",
    "åŸæ…¯æŠ¦æˆ¹æ‹Žã©œæ‡¢åŽªð£µæ¤æ ‚ã—’"
  ],
  [
    "a0a1",
    "åµ—ð¨¯‚è¿šð¨¸¹"
  ],
  [
    "a0a6",
    "åƒ™ð¡µ†ç¤†åŒ²é˜¸ð ¼»ä¥"
  ],
  [
    "a0ae",
    "çŸ¾"
  ],
  [
    "a0b0",
    "ç³‚ð¥¼šç³šç¨­è¦è£çµç”…ç“²è¦”èˆšæœŒè¢ð§’†è›ç“°è„ƒçœ¤è¦‰ð¦ŸŒç•“ð¦»‘èž©èŸŽè‡ˆèžŒè©‰è²­è­ƒçœ«ç“¸è“šã˜µæ¦²è¶¦"
  ],
  [
    "a0d4",
    "è¦©ç‘¨æ¶¹èŸð¤€‘ç“§ã·›ç…¶æ‚¤æ†œã³‘ç…¢æ·"
  ],
  [
    "a0e2",
    "ç½±ð¨¬­ç‰æƒ©ä­¾åˆ ã°˜ð£³‡ð¥»—ð§™–ð¥”±ð¡¥„ð¡‹¾ð©¤ƒð¦·œð§‚­å³ð¦†­ð¨¨ð£™·ð ƒ®ð¦¡†ð¤¼Žä•¢å¬Ÿð¦Œé½éº¦ð¦‰«"
  ],
  [
    "a3c0",
    "â€",
    31,
    "â¡"
  ],
  [
    "c6a1",
    "â‘ ",
    9,
    "â‘´",
    9,
    "â…°",
    9,
    "ä¸¶ä¸¿äº…äº å†‚å†–å†«å‹¹åŒ¸å©åŽ¶å¤Šå®€å·›â¼³å¹¿å»´å½å½¡æ”´æ— ç–’ç™¶è¾µéš¶Â¨Ë†ãƒ½ãƒ¾ã‚ã‚žã€ƒä»ã€…ã€†ã€‡ãƒ¼ï¼»ï¼½âœ½ã",
    23
  ],
  [
    "c740",
    "ã™",
    58,
    "ã‚¡ã‚¢ã‚£ã‚¤"
  ],
  [
    "c7a1",
    "ã‚¥",
    81,
    "Ð",
    5,
    "ÐÐ–",
    4
  ],
  [
    "c840",
    "Ð›",
    26,
    "Ñ‘Ð¶",
    25,
    "â‡§â†¸â†¹ã‡ð ƒŒä¹šð ‚Šåˆ‚ä’‘"
  ],
  [
    "c8a1",
    "é¾°å†ˆé¾±ð§˜‡"
  ],
  [
    "c8cd",
    "ï¿¢ï¿¤ï¼‡ï¼‚ãˆ±â„–â„¡ã‚›ã‚œâº€âº„âº†âº‡âºˆâºŠâºŒâºâº•âºœâºâº¥âº§âºªâº¬âº®âº¶âº¼âº¾â»†â»Šâ»Œâ»â»â»–â»—â»žâ»£"
  ],
  [
    "c8f5",
    "ÊƒÉÉ›É”ÉµÅ“Ã¸Å‹ÊŠÉª"
  ],
  [
    "f9fe",
    "ï¿­"
  ],
  [
    "fa40",
    "ð •‡é‹›ð —Ÿð£¿…è•ŒäŠµç¯å†µã™‰ð¤¥‚ð¨§¤é„ð¡§›è‹®ð£³ˆç ¼æ„æ‹Ÿð¤¤³ð¨¦ªð Š ð¦®³ð¡Œ…ä¾«ð¢“­å€ˆð¦´©ð§ª„ð£˜€ð¤ª±ð¢”“å€©ð ¾å¾¤ð Ž€ð ‡æ»›ð Ÿå½å„ã‘ºå„Žé¡¬ãƒè–ð¤¦¤ð ’‡å… ð£Ž´å…ªð ¯¿ð¢ƒ¼ð ‹¥ð¢”°ð –Žð£ˆ³ð¡¦ƒå®‚è½ð –³ð£²™å†²å†¸"
  ],
  [
    "faa1",
    "é´´å‡‰å‡å‡‘ã³œå‡“ð¤ª¦å†³å‡¢å‚å‡­èæ¤¾ð£œ­å½»åˆ‹åˆ¦åˆ¼åŠµå‰—åŠ”åŠ¹å‹…ç°•è•‚å‹ è˜ð¦¬“åŒ…ð¨«žå•‰æ»™ð£¾€ð ¥”ð£¿¬åŒ³å„ð ¯¢æ³‹ð¡œ¦æ ›ç•æŠãºªã£Œð¡›¨ç‡ä’¢å­å´ð¨š«å¾å¿ð¡––ð¡˜“çŸ¦åŽ“ð¨ª›åŽ åŽ«åŽ®çŽ§ð¥²ã½™çŽœåå…æ±‰ä¹‰åŸ¾å™ãª«ð ®å ð£¿«ð¢¶£å¶ð ±·å“ç¹å”«æ™—æµ›å‘­ð¦­“ð µ´å•å’å’¤äž¦ð¡œð »ã¶´ð µ"
  ],
  [
    "fb40",
    "ð¨¦¼ð¢š˜å•‡ä³­å¯ç—å–†å–©å˜…ð¡£—ð¤€ºä•’ð¤µæš³ð¡‚´å˜·æ›ð£ŠŠæš¤æš­å™å™ç£±å›±éž‡å¾åœ€å›¯å›­ð¨­¦ã˜£ð¡‰å†ð¤†¥æ±®ç‚‹å‚ãš±ð¦±¾åŸ¦ð¡–å ƒð¡‘”ð¤£å ¦ð¤¯µå¡œå¢ªã•¡å£ å£œð¡ˆ¼å£»å¯¿åƒðª…ð¤‰¸é“ã–¡å¤Ÿæ¢¦ã›ƒæ¹™"
  ],
  [
    "fba1",
    "ð¡˜¾å¨¤å•“ð¡š’è”…å§‰ð µŽð¦²ð¦´ªð¡Ÿœå§™ð¡Ÿ»ð¡ž²ð¦¶¦æµ±ð¡ ¨ð¡›•å§¹ð¦¹…åª«å©£ã›¦ð¤¦©å©·ãœˆåª–ç‘¥å«“ð¦¾¡ð¢•”ã¶…ð¡¤‘ãœ²ð¡š¸åºƒå‹å­¶æ–ˆå­¼ð§¨Žä€„ä¡ð ˆ„å¯•æ… ð¡¨´ð¥§Œð –¥å¯³å®ä´å°…ð¡­„å°“çŽå°”ð¡²¥ð¦¬¨å±‰ä£å²…å³©å³¯å¶‹ð¡·¹ð¡¸·å´å´˜åµ†ð¡º¤å²ºå·—è‹¼ã ­ð¤¤ð¢‰ð¢…³èŠ‡ã ¶ã¯‚å¸®æªŠå¹µå¹ºð¤’¼ð ³“åŽ¦äº·å»åŽ¨ð¡±å¸‰å»´ð¨’‚"
  ],
  [
    "fc40",
    "å»¹å»»ã¢ å»¼æ ¾é›å¼ð ‡ð¯¢”ã«žä¢®ð¡Œºå¼ºð¦¢ˆð¢å½˜ð¢‘±å½£éž½ð¦¹®å½²é€ð¨¨¶å¾§å¶¶ãµŸð¥‰ð¡½ªð§ƒ¸ð¢™¨é‡–ð Šžð¨¨©æ€±æš…ð¡¡·ã¥£ã·‡ã˜¹åžð¢ž´ç¥±ã¹€æ‚žæ‚¤æ‚³ð¤¦‚ð¤¦ð§©“ç’¤åƒ¡åª æ…¤è¤æ…‚ð¯¢¦ð¦»’æ†å‡´ð ™–æ†‡å®ªð£¾·"
  ],
  [
    "fca1",
    "ð¢¡Ÿæ‡“ð¨®ð©¥æ‡ã¤²ð¢¦€ð¢£æ€£æ…œæ”žæŽ‹ð „˜æ‹…ð¡°æ‹•ð¢¸æ¬ð¤§Ÿã¨—æ¸æ¸ð¡ŽŽð¡Ÿ¼æ’æ¾Šð¢¸¶é ”ð¤‚Œð¥œæ“¡æ“¥é‘»ã©¦æºã©—æ•æ¼–ð¤¨¨ð¤¨£æ–…æ•­æ•Ÿð£¾æ–µð¤¥€ä¬·æ—‘äƒ˜ð¡ ©æ— æ—£å¿Ÿð£€æ˜˜ð£‡·ð£‡¸æ™„ð£†¤ð£†¥æ™‹ð ¹µæ™§ð¥‡¦æ™³æ™´ð¡¸½ð£ˆ±ð¨—´ð£‡ˆð¥Œ“çŸ…ð¢£·é¦¤æœ‚ð¤Žœð¤¨¡ã¬«æ§ºð£Ÿ‚æžæ§æ¢ð¤‡ð©ƒ­æŸ—ä“©æ ¢æ¹éˆ¼æ ð£¦ð¦¶ æ¡"
  ],
  [
    "fd40",
    "ð£‘¯æ§¡æ¨‹ð¨«Ÿæ¥³æ£ƒð£—æ¤æ¤€ã´²ã¨ð£˜¼ã®€æž¬æ¥¡ð¨©Šä‹¼æ¤¶æ¦˜ã®¡ð ‰è£å‚æ§¹ð£™™ð¢„ªæ©…ð£œƒæªã¯³æž±æ«ˆð©†œã°æ¬ð ¤£æƒžæ¬µæ­´ð¢Ÿæºµð£«›ð Žµð¡¥˜ã€å¡ð£­šæ¯¡ð£»¼æ¯œæ°·ð¢’‹ð¤£±ð¦­‘æ±šèˆ¦æ±¹ð£¶¼ä“…ð£¶½ð¤†¤ð¤¤Œð¤¤€"
  ],
  [
    "fda1",
    "ð£³‰ã›¥ã³«ð ´²é®ƒð£‡¹ð¢’‘ç¾æ ·ð¦´¥ð¦¶¡ð¦·«æ¶–æµœæ¹¼æ¼„ð¤¥¿ð¤‚…ð¦¹²è”³ð¦½´å‡‡æ²œæ¸è®ð¨¬¡æ¸¯ð£¸¯ç‘“ð£¾‚ç§Œæ¹åª‘ð£‹æ¿¸ãœæ¾ð£¸°æ»ºð¡’—ð¤€½ä••é°æ½„æ½œãµŽæ½´ð©…°ã´»æ¾Ÿð¤…„æ¿“ð¤‚‘ð¤…•ð¤€¹ð£¿°ð£¾´ð¤„¿å‡Ÿð¤…–ð¤…—ð¤…€ð¦‡ç‹ç¾ç‚§ç‚çƒŒçƒ•çƒ–çƒŸä„„ã·¨ç†´ç†–ð¤‰·ç„«ç……åªˆç…Šç…®å²œð¤¥ç…é¢ð¤‹ç„¬ð¤‘šð¤¨§ð¤¨¢ç†ºð¨¯¨ç‚½çˆŽ"
  ],
  [
    "fe40",
    "é‘‚çˆ•å¤‘é‘ƒçˆ¤éð¥˜…çˆ®ç‰€ð¤¥´æ¢½ç‰•ç‰—ã¹•ð£„æ æ¼½çŠ‚çŒªçŒ«ð¤ £ð¨ «ä£­ð¨ „çŒ¨çŒ®ççŽªð °ºð¦¨®ç‰ç‘‰ð¤‡¢ð¡›§ð¤¨¤æ˜£ã›…ð¤¦·ð¤¦ð¤§»ç·ç•æ¤ƒð¤¨¦ç¹ð —ƒã»—ç‘œð¢¢­ç‘ ð¨º²ç‘‡ç¤ç‘¶èŽ¹ç‘¬ãœ°ç‘´é±æ¨¬ç’‚ä¥“ð¤ªŒ"
  ],
  [
    "fea1",
    "ð¤…Ÿð¤©¹ð¨®å­†ð¨°ƒð¡¢žç“ˆð¡¦ˆç”Žç“©ç”žð¨»™ð¡©‹å¯—ð¨º¬éŽ…ç•ç•Šç•§ç•®ð¤¾‚ã¼„ð¤´“ç–Žç‘ç–žç–´ç˜‚ç˜¬ç™‘ç™ç™¯ç™¶ð¦µçšè‡¯ãŸ¸ð¦¤‘ð¦¤Žçš¡çš¥çš·ç›Œð¦¾Ÿè‘¢ð¥‚ð¥…½ð¡¸œçœžçœ¦ç€æ’¯ð¥ˆ ç˜ð£Š¬çž¯ð¨¥¤ð¨¥¨ð¡›çŸ´ç ‰ð¡¶ð¤¨’æ£Šç¢¯ç£‡ç£“éš¥ç¤®ð¥— ç£—ç¤´ç¢±ð§˜Œè¾¸è¢„ð¨¬«ð¦‚ƒð¢˜œç¦†è¤€æ¤‚ç¦€ð¥¡—ç¦ð§¬¹ç¤¼ç¦©æ¸ªð§„¦ãº¨ç§†ð©„ç§”"
  ]
];
var dbcsData;
var hasRequiredDbcsData;
function requireDbcsData() {
  if (hasRequiredDbcsData)
    return dbcsData;
  hasRequiredDbcsData = 1;
  dbcsData = {
    // == Japanese/ShiftJIS ====================================================
    // All japanese encodings are based on JIS X set of standards:
    // JIS X 0201 - Single-byte encoding of ASCII + Â¥ + Kana chars at 0xA1-0xDF.
    // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes. 
    //              Has several variations in 1978, 1983, 1990 and 1997.
    // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.
    // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.
    //              2 planes, first is superset of 0208, second - revised 0212.
    //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)
    // Byte encodings are:
    //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte
    //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.
    //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.
    //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.
    //               0x00-0x7F       - lower part of 0201
    //               0x8E, 0xA1-0xDF - upper part of 0201
    //               (0xA1-0xFE)x2   - 0208 plane (94x94).
    //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).
    //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.
    //               Used as-is in ISO2022 family.
    //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII, 
    //                0201-1976 Roman, 0208-1978, 0208-1983.
    //  * ISO2022-JP-1: Adds esc seq for 0212-1990.
    //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.
    //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.
    //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.
    //
    // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.
    //
    // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html
    "shiftjis": {
      type: "_dbcs",
      table: function() {
        return require$$0$1;
      },
      encodeAdd: { "Â¥": 92, "â€¾": 126 },
      encodeSkipVals: [{ from: 60736, to: 63808 }]
    },
    "csshiftjis": "shiftjis",
    "mskanji": "shiftjis",
    "sjis": "shiftjis",
    "windows31j": "shiftjis",
    "ms31j": "shiftjis",
    "xsjis": "shiftjis",
    "windows932": "shiftjis",
    "ms932": "shiftjis",
    "932": "shiftjis",
    "cp932": "shiftjis",
    "eucjp": {
      type: "_dbcs",
      table: function() {
        return require$$1;
      },
      encodeAdd: { "Â¥": 92, "â€¾": 126 }
    },
    // TODO: KDDI extension to Shift_JIS
    // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.
    // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.
    // == Chinese/GBK ==========================================================
    // http://en.wikipedia.org/wiki/GBK
    // We mostly implement W3C recommendation: https://www.w3.org/TR/encoding/#gbk-encoder
    // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936
    "gb2312": "cp936",
    "gb231280": "cp936",
    "gb23121980": "cp936",
    "csgb2312": "cp936",
    "csiso58gb231280": "cp936",
    "euccn": "cp936",
    // Microsoft's CP936 is a subset and approximation of GBK.
    "windows936": "cp936",
    "ms936": "cp936",
    "936": "cp936",
    "cp936": {
      type: "_dbcs",
      table: function() {
        return require$$2$1;
      }
    },
    // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.
    "gbk": {
      type: "_dbcs",
      table: function() {
        return require$$2$1.concat(require$$3);
      }
    },
    "xgbk": "gbk",
    "isoir58": "gbk",
    // GB18030 is an algorithmic extension of GBK.
    // Main source: https://www.w3.org/TR/encoding/#gbk-encoder
    // http://icu-project.org/docs/papers/gb18030.html
    // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml
    // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0
    "gb18030": {
      type: "_dbcs",
      table: function() {
        return require$$2$1.concat(require$$3);
      },
      gb18030: function() {
        return require$$4;
      },
      encodeSkipVals: [128],
      encodeAdd: { "â‚¬": 41699 }
    },
    "chinese": "gb18030",
    // == Korean ===============================================================
    // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.
    "windows949": "cp949",
    "ms949": "cp949",
    "949": "cp949",
    "cp949": {
      type: "_dbcs",
      table: function() {
        return require$$5;
      }
    },
    "cseuckr": "cp949",
    "csksc56011987": "cp949",
    "euckr": "cp949",
    "isoir149": "cp949",
    "korean": "cp949",
    "ksc56011987": "cp949",
    "ksc56011989": "cp949",
    "ksc5601": "cp949",
    // == Big5/Taiwan/Hong Kong ================================================
    // There are lots of tables for Big5 and cp950. Please see the following links for history:
    // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html
    // Variations, in roughly number of defined chars:
    //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT
    //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/
    //  * Big5-2003 (Taiwan standard) almost superset of cp950.
    //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.
    //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard. 
    //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.
    //    Plus, it has 4 combining sequences.
    //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299
    //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.
    //    Implementations are not consistent within browsers; sometimes labeled as just big5.
    //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.
    //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31
    //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.
    //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt
    //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt
    // 
    // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder
    // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.
    "windows950": "cp950",
    "ms950": "cp950",
    "950": "cp950",
    "cp950": {
      type: "_dbcs",
      table: function() {
        return require$$6;
      }
    },
    // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.
    "big5": "big5hkscs",
    "big5hkscs": {
      type: "_dbcs",
      table: function() {
        return require$$6.concat(require$$7);
      },
      encodeSkipVals: [41676]
    },
    "cnbig5": "big5hkscs",
    "csbig5": "big5hkscs",
    "xxbig5": "big5hkscs"
  };
  return dbcsData;
}
var hasRequiredEncodings;
function requireEncodings() {
  if (hasRequiredEncodings)
    return encodings;
  hasRequiredEncodings = 1;
  (function(exports) {
    var modules = [
      requireInternal(),
      requireUtf16(),
      requireUtf7(),
      requireSbcsCodec(),
      requireSbcsData(),
      requireSbcsDataGenerated(),
      requireDbcsCodec(),
      requireDbcsData()
    ];
    for (var i = 0; i < modules.length; i++) {
      var module = modules[i];
      for (var enc in module)
        if (Object.prototype.hasOwnProperty.call(module, enc))
          exports[enc] = module[enc];
    }
  })(encodings);
  return encodings;
}
var streams;
var hasRequiredStreams;
function requireStreams() {
  if (hasRequiredStreams)
    return streams;
  hasRequiredStreams = 1;
  var Buffer2 = require$$0$5.Buffer, Transform = stream.Transform;
  streams = function(iconv) {
    iconv.encodeStream = function encodeStream(encoding3, options) {
      return new IconvLiteEncoderStream(iconv.getEncoder(encoding3, options), options);
    };
    iconv.decodeStream = function decodeStream(encoding3, options) {
      return new IconvLiteDecoderStream(iconv.getDecoder(encoding3, options), options);
    };
    iconv.supportsStreams = true;
    iconv.IconvLiteEncoderStream = IconvLiteEncoderStream;
    iconv.IconvLiteDecoderStream = IconvLiteDecoderStream;
    iconv._collect = IconvLiteDecoderStream.prototype.collect;
  };
  function IconvLiteEncoderStream(conv, options) {
    this.conv = conv;
    options = options || {};
    options.decodeStrings = false;
    Transform.call(this, options);
  }
  IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {
    constructor: { value: IconvLiteEncoderStream }
  });
  IconvLiteEncoderStream.prototype._transform = function(chunk, encoding3, done) {
    if (typeof chunk != "string")
      return done(new Error("Iconv encoding stream needs strings as its input."));
    try {
      var res2 = this.conv.write(chunk);
      if (res2 && res2.length)
        this.push(res2);
      done();
    } catch (e) {
      done(e);
    }
  };
  IconvLiteEncoderStream.prototype._flush = function(done) {
    try {
      var res2 = this.conv.end();
      if (res2 && res2.length)
        this.push(res2);
      done();
    } catch (e) {
      done(e);
    }
  };
  IconvLiteEncoderStream.prototype.collect = function(cb) {
    var chunks = [];
    this.on("error", cb);
    this.on("data", function(chunk) {
      chunks.push(chunk);
    });
    this.on("end", function() {
      cb(null, Buffer2.concat(chunks));
    });
    return this;
  };
  function IconvLiteDecoderStream(conv, options) {
    this.conv = conv;
    options = options || {};
    options.encoding = this.encoding = "utf8";
    Transform.call(this, options);
  }
  IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {
    constructor: { value: IconvLiteDecoderStream }
  });
  IconvLiteDecoderStream.prototype._transform = function(chunk, encoding3, done) {
    if (!Buffer2.isBuffer(chunk))
      return done(new Error("Iconv decoding stream needs buffers as its input."));
    try {
      var res2 = this.conv.write(chunk);
      if (res2 && res2.length)
        this.push(res2, this.encoding);
      done();
    } catch (e) {
      done(e);
    }
  };
  IconvLiteDecoderStream.prototype._flush = function(done) {
    try {
      var res2 = this.conv.end();
      if (res2 && res2.length)
        this.push(res2, this.encoding);
      done();
    } catch (e) {
      done(e);
    }
  };
  IconvLiteDecoderStream.prototype.collect = function(cb) {
    var res2 = "";
    this.on("error", cb);
    this.on("data", function(chunk) {
      res2 += chunk;
    });
    this.on("end", function() {
      cb(null, res2);
    });
    return this;
  };
  return streams;
}
var extendNode;
var hasRequiredExtendNode;
function requireExtendNode() {
  if (hasRequiredExtendNode)
    return extendNode;
  hasRequiredExtendNode = 1;
  var Buffer2 = require$$0$5.Buffer;
  extendNode = function(iconv) {
    var original = void 0;
    iconv.supportsNodeEncodingsExtension = !(Buffer2.from || new Buffer2(0) instanceof Uint8Array);
    iconv.extendNodeEncodings = function extendNodeEncodings() {
      if (original)
        return;
      original = {};
      if (!iconv.supportsNodeEncodingsExtension) {
        console.error("ACTION NEEDED: require('iconv-lite').extendNodeEncodings() is not supported in your version of Node");
        console.error("See more info at https://github.com/ashtuchkin/iconv-lite/wiki/Node-v4-compatibility");
        return;
      }
      var nodeNativeEncodings = {
        "hex": true,
        "utf8": true,
        "utf-8": true,
        "ascii": true,
        "binary": true,
        "base64": true,
        "ucs2": true,
        "ucs-2": true,
        "utf16le": true,
        "utf-16le": true
      };
      Buffer2.isNativeEncoding = function(enc) {
        return enc && nodeNativeEncodings[enc.toLowerCase()];
      };
      var SlowBuffer = require$$0$5.SlowBuffer;
      original.SlowBufferToString = SlowBuffer.prototype.toString;
      SlowBuffer.prototype.toString = function(encoding3, start, end) {
        encoding3 = String(encoding3 || "utf8").toLowerCase();
        if (Buffer2.isNativeEncoding(encoding3))
          return original.SlowBufferToString.call(this, encoding3, start, end);
        if (typeof start == "undefined")
          start = 0;
        if (typeof end == "undefined")
          end = this.length;
        return iconv.decode(this.slice(start, end), encoding3);
      };
      original.SlowBufferWrite = SlowBuffer.prototype.write;
      SlowBuffer.prototype.write = function(string, offset, length, encoding3) {
        if (isFinite(offset)) {
          if (!isFinite(length)) {
            encoding3 = length;
            length = void 0;
          }
        } else {
          var swap = encoding3;
          encoding3 = offset;
          offset = length;
          length = swap;
        }
        offset = +offset || 0;
        var remaining = this.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = +length;
          if (length > remaining) {
            length = remaining;
          }
        }
        encoding3 = String(encoding3 || "utf8").toLowerCase();
        if (Buffer2.isNativeEncoding(encoding3))
          return original.SlowBufferWrite.call(this, string, offset, length, encoding3);
        if (string.length > 0 && (length < 0 || offset < 0))
          throw new RangeError("attempt to write beyond buffer bounds");
        var buf = iconv.encode(string, encoding3);
        if (buf.length < length)
          length = buf.length;
        buf.copy(this, offset, 0, length);
        return length;
      };
      original.BufferIsEncoding = Buffer2.isEncoding;
      Buffer2.isEncoding = function(encoding3) {
        return Buffer2.isNativeEncoding(encoding3) || iconv.encodingExists(encoding3);
      };
      original.BufferByteLength = Buffer2.byteLength;
      Buffer2.byteLength = SlowBuffer.byteLength = function(str, encoding3) {
        encoding3 = String(encoding3 || "utf8").toLowerCase();
        if (Buffer2.isNativeEncoding(encoding3))
          return original.BufferByteLength.call(this, str, encoding3);
        return iconv.encode(str, encoding3).length;
      };
      original.BufferToString = Buffer2.prototype.toString;
      Buffer2.prototype.toString = function(encoding3, start, end) {
        encoding3 = String(encoding3 || "utf8").toLowerCase();
        if (Buffer2.isNativeEncoding(encoding3))
          return original.BufferToString.call(this, encoding3, start, end);
        if (typeof start == "undefined")
          start = 0;
        if (typeof end == "undefined")
          end = this.length;
        return iconv.decode(this.slice(start, end), encoding3);
      };
      original.BufferWrite = Buffer2.prototype.write;
      Buffer2.prototype.write = function(string, offset, length, encoding3) {
        var _offset = offset, _length = length, _encoding = encoding3;
        if (isFinite(offset)) {
          if (!isFinite(length)) {
            encoding3 = length;
            length = void 0;
          }
        } else {
          var swap = encoding3;
          encoding3 = offset;
          offset = length;
          length = swap;
        }
        encoding3 = String(encoding3 || "utf8").toLowerCase();
        if (Buffer2.isNativeEncoding(encoding3))
          return original.BufferWrite.call(this, string, _offset, _length, _encoding);
        offset = +offset || 0;
        var remaining = this.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = +length;
          if (length > remaining) {
            length = remaining;
          }
        }
        if (string.length > 0 && (length < 0 || offset < 0))
          throw new RangeError("attempt to write beyond buffer bounds");
        var buf = iconv.encode(string, encoding3);
        if (buf.length < length)
          length = buf.length;
        buf.copy(this, offset, 0, length);
        return length;
      };
      if (iconv.supportsStreams) {
        var Readable = stream.Readable;
        original.ReadableSetEncoding = Readable.prototype.setEncoding;
        Readable.prototype.setEncoding = function setEncoding(enc, options) {
          this._readableState.decoder = iconv.getDecoder(enc, options);
          this._readableState.encoding = enc;
        };
        Readable.prototype.collect = iconv._collect;
      }
    };
    iconv.undoExtendNodeEncodings = function undoExtendNodeEncodings() {
      if (!iconv.supportsNodeEncodingsExtension)
        return;
      if (!original)
        throw new Error("require('iconv-lite').undoExtendNodeEncodings(): Nothing to undo; extendNodeEncodings() is not called.");
      delete Buffer2.isNativeEncoding;
      var SlowBuffer = require$$0$5.SlowBuffer;
      SlowBuffer.prototype.toString = original.SlowBufferToString;
      SlowBuffer.prototype.write = original.SlowBufferWrite;
      Buffer2.isEncoding = original.BufferIsEncoding;
      Buffer2.byteLength = original.BufferByteLength;
      Buffer2.prototype.toString = original.BufferToString;
      Buffer2.prototype.write = original.BufferWrite;
      if (iconv.supportsStreams) {
        var Readable = stream.Readable;
        Readable.prototype.setEncoding = original.ReadableSetEncoding;
        delete Readable.prototype.collect;
      }
      original = void 0;
    };
  };
  return extendNode;
}
var hasRequiredLib$1;
function requireLib$1() {
  if (hasRequiredLib$1)
    return lib$1.exports;
  hasRequiredLib$1 = 1;
  (function(module) {
    var Buffer2 = requireSafer().Buffer;
    var bomHandling2 = requireBomHandling(), iconv = module.exports;
    iconv.encodings = null;
    iconv.defaultCharUnicode = "ï¿½";
    iconv.defaultCharSingleByte = "?";
    iconv.encode = function encode2(str, encoding3, options) {
      str = "" + (str || "");
      var encoder = iconv.getEncoder(encoding3, options);
      var res2 = encoder.write(str);
      var trail = encoder.end();
      return trail && trail.length > 0 ? Buffer2.concat([res2, trail]) : res2;
    };
    iconv.decode = function decode2(buf, encoding3, options) {
      if (typeof buf === "string") {
        if (!iconv.skipDecodeWarning) {
          console.error("Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding");
          iconv.skipDecodeWarning = true;
        }
        buf = Buffer2.from("" + (buf || ""), "binary");
      }
      var decoder = iconv.getDecoder(encoding3, options);
      var res2 = decoder.write(buf);
      var trail = decoder.end();
      return trail ? res2 + trail : res2;
    };
    iconv.encodingExists = function encodingExists(enc) {
      try {
        iconv.getCodec(enc);
        return true;
      } catch (e) {
        return false;
      }
    };
    iconv.toEncoding = iconv.encode;
    iconv.fromEncoding = iconv.decode;
    iconv._codecDataCache = {};
    iconv.getCodec = function getCodec(encoding3) {
      if (!iconv.encodings)
        iconv.encodings = requireEncodings();
      var enc = iconv._canonicalizeEncoding(encoding3);
      var codecOptions = {};
      while (true) {
        var codec = iconv._codecDataCache[enc];
        if (codec)
          return codec;
        var codecDef = iconv.encodings[enc];
        switch (typeof codecDef) {
          case "string":
            enc = codecDef;
            break;
          case "object":
            for (var key in codecDef)
              codecOptions[key] = codecDef[key];
            if (!codecOptions.encodingName)
              codecOptions.encodingName = enc;
            enc = codecDef.type;
            break;
          case "function":
            if (!codecOptions.encodingName)
              codecOptions.encodingName = enc;
            codec = new codecDef(codecOptions, iconv);
            iconv._codecDataCache[codecOptions.encodingName] = codec;
            return codec;
          default:
            throw new Error("Encoding not recognized: '" + encoding3 + "' (searched as: '" + enc + "')");
        }
      }
    };
    iconv._canonicalizeEncoding = function(encoding3) {
      return ("" + encoding3).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
    };
    iconv.getEncoder = function getEncoder(encoding3, options) {
      var codec = iconv.getCodec(encoding3), encoder = new codec.encoder(options, codec);
      if (codec.bomAware && options && options.addBOM)
        encoder = new bomHandling2.PrependBOM(encoder, options);
      return encoder;
    };
    iconv.getDecoder = function getDecoder(encoding3, options) {
      var codec = iconv.getCodec(encoding3), decoder = new codec.decoder(options, codec);
      if (codec.bomAware && !(options && options.stripBOM === false))
        decoder = new bomHandling2.StripBOM(decoder, options);
      return decoder;
    };
    var nodeVer = typeof process !== "undefined" && process.versions && process.versions.node;
    if (nodeVer) {
      var nodeVerArr = nodeVer.split(".").map(Number);
      if (nodeVerArr[0] > 0 || nodeVerArr[1] >= 10) {
        requireStreams()(iconv);
      }
      requireExtendNode()(iconv);
    }
  })(lib$1);
  return lib$1.exports;
}
/*!
 * unpipe
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var unpipe_1 = unpipe$1;
function hasPipeDataListeners(stream3) {
  var listeners = stream3.listeners("data");
  for (var i = 0; i < listeners.length; i++) {
    if (listeners[i].name === "ondata") {
      return true;
    }
  }
  return false;
}
function unpipe$1(stream3) {
  if (!stream3) {
    throw new TypeError("argument stream is required");
  }
  if (typeof stream3.unpipe === "function") {
    stream3.unpipe();
    return;
  }
  if (!hasPipeDataListeners(stream3)) {
    return;
  }
  var listener2;
  var listeners = stream3.listeners("close");
  for (var i = 0; i < listeners.length; i++) {
    listener2 = listeners[i];
    if (listener2.name !== "cleanup" && listener2.name !== "onclose") {
      continue;
    }
    listener2.call(stream3);
  }
}
/*!
 * raw-body
 * Copyright(c) 2013-2014 Jonathan Ong
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var rawBody;
var hasRequiredRawBody;
function requireRawBody() {
  if (hasRequiredRawBody)
    return rawBody;
  hasRequiredRawBody = 1;
  var asyncHooks2 = tryRequireAsyncHooks2();
  var bytes2 = requireBytes();
  var createError2 = httpErrorsExports;
  var iconv = requireLib$1();
  var unpipe2 = unpipe_1;
  rawBody = getRawBody;
  var ICONV_ENCODING_MESSAGE_REGEXP = /^Encoding not recognized: /;
  function getDecoder(encoding3) {
    if (!encoding3)
      return null;
    try {
      return iconv.getDecoder(encoding3);
    } catch (e) {
      if (!ICONV_ENCODING_MESSAGE_REGEXP.test(e.message))
        throw e;
      throw createError2(415, "specified encoding unsupported", {
        encoding: encoding3,
        type: "encoding.unsupported"
      });
    }
  }
  function getRawBody(stream3, options, callback) {
    var done = callback;
    var opts = options || {};
    if (stream3 === void 0) {
      throw new TypeError("argument stream is required");
    } else if (typeof stream3 !== "object" || stream3 === null || typeof stream3.on !== "function") {
      throw new TypeError("argument stream must be a stream");
    }
    if (options === true || typeof options === "string") {
      opts = {
        encoding: options
      };
    }
    if (typeof options === "function") {
      done = options;
      opts = {};
    }
    if (done !== void 0 && typeof done !== "function") {
      throw new TypeError("argument callback must be a function");
    }
    if (!done && !commonjsGlobal.Promise) {
      throw new TypeError("argument callback is required");
    }
    var encoding3 = opts.encoding !== true ? opts.encoding : "utf-8";
    var limit = bytes2.parse(opts.limit);
    var length = opts.length != null && !isNaN(opts.length) ? parseInt(opts.length, 10) : null;
    if (done) {
      return readStream(stream3, encoding3, length, limit, wrap2(done));
    }
    return new Promise(function executor(resolve3, reject) {
      readStream(stream3, encoding3, length, limit, function onRead(err, buf) {
        if (err)
          return reject(err);
        resolve3(buf);
      });
    });
  }
  function halt(stream3) {
    unpipe2(stream3);
    if (typeof stream3.pause === "function") {
      stream3.pause();
    }
  }
  function readStream(stream3, encoding3, length, limit, callback) {
    var complete = false;
    var sync = true;
    if (limit !== null && length !== null && length > limit) {
      return done(createError2(413, "request entity too large", {
        expected: length,
        length,
        limit,
        type: "entity.too.large"
      }));
    }
    var state2 = stream3._readableState;
    if (stream3._decoder || state2 && (state2.encoding || state2.decoder)) {
      return done(createError2(500, "stream encoding should not be set", {
        type: "stream.encoding.set"
      }));
    }
    if (typeof stream3.readable !== "undefined" && !stream3.readable) {
      return done(createError2(500, "stream is not readable", {
        type: "stream.not.readable"
      }));
    }
    var received = 0;
    var decoder;
    try {
      decoder = getDecoder(encoding3);
    } catch (err) {
      return done(err);
    }
    var buffer = decoder ? "" : [];
    stream3.on("aborted", onAborted);
    stream3.on("close", cleanup);
    stream3.on("data", onData);
    stream3.on("end", onEnd);
    stream3.on("error", onEnd);
    sync = false;
    function done() {
      var args = new Array(arguments.length);
      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }
      complete = true;
      if (sync) {
        process.nextTick(invokeCallback);
      } else {
        invokeCallback();
      }
      function invokeCallback() {
        cleanup();
        if (args[0]) {
          halt(stream3);
        }
        callback.apply(null, args);
      }
    }
    function onAborted() {
      if (complete)
        return;
      done(createError2(400, "request aborted", {
        code: "ECONNABORTED",
        expected: length,
        length,
        received,
        type: "request.aborted"
      }));
    }
    function onData(chunk) {
      if (complete)
        return;
      received += chunk.length;
      if (limit !== null && received > limit) {
        done(createError2(413, "request entity too large", {
          limit,
          received,
          type: "entity.too.large"
        }));
      } else if (decoder) {
        buffer += decoder.write(chunk);
      } else {
        buffer.push(chunk);
      }
    }
    function onEnd(err) {
      if (complete)
        return;
      if (err)
        return done(err);
      if (length !== null && received !== length) {
        done(createError2(400, "request size did not match content length", {
          expected: length,
          length,
          received,
          type: "request.size.invalid"
        }));
      } else {
        var string = decoder ? buffer + (decoder.end() || "") : Buffer.concat(buffer);
        done(null, string);
      }
    }
    function cleanup() {
      buffer = null;
      stream3.removeListener("aborted", onAborted);
      stream3.removeListener("data", onData);
      stream3.removeListener("end", onEnd);
      stream3.removeListener("error", onEnd);
      stream3.removeListener("close", cleanup);
    }
  }
  function tryRequireAsyncHooks2() {
    try {
      return require("async_hooks");
    } catch (e) {
      return {};
    }
  }
  function wrap2(fn) {
    var res2;
    if (asyncHooks2.AsyncResource) {
      res2 = new asyncHooks2.AsyncResource(fn.name || "bound-anonymous-fn");
    }
    if (!res2 || !res2.runInAsyncScope) {
      return fn;
    }
    return res2.runInAsyncScope.bind(res2, fn, null);
  }
  return rawBody;
}
var onFinished$4 = { exports: {} };
/*!
 * ee-first
 * Copyright(c) 2014 Jonathan Ong
 * MIT Licensed
 */
var eeFirst = first$1;
function first$1(stuff, done) {
  if (!Array.isArray(stuff))
    throw new TypeError("arg must be an array of [ee, events...] arrays");
  var cleanups = [];
  for (var i = 0; i < stuff.length; i++) {
    var arr = stuff[i];
    if (!Array.isArray(arr) || arr.length < 2)
      throw new TypeError("each array member must be [ee, events...]");
    var ee2 = arr[0];
    for (var j2 = 1; j2 < arr.length; j2++) {
      var event = arr[j2];
      var fn = listener(event, callback);
      ee2.on(event, fn);
      cleanups.push({
        ee: ee2,
        event,
        fn
      });
    }
  }
  function callback() {
    cleanup();
    done.apply(null, arguments);
  }
  function cleanup() {
    var x2;
    for (var i2 = 0; i2 < cleanups.length; i2++) {
      x2 = cleanups[i2];
      x2.ee.removeListener(x2.event, x2.fn);
    }
  }
  function thunk(fn2) {
    done = fn2;
  }
  thunk.cancel = cleanup;
  return thunk;
}
function listener(event, done) {
  return function onevent(arg1) {
    var args = new Array(arguments.length);
    var ee2 = this;
    var err = event === "error" ? arg1 : null;
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    done(err, ee2, event, args);
  };
}
/*!
 * on-finished
 * Copyright(c) 2013 Jonathan Ong
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */
onFinished$4.exports = onFinished$3;
onFinished$4.exports.isFinished = isFinished$1;
var asyncHooks = tryRequireAsyncHooks();
var first = eeFirst;
var defer$3 = typeof setImmediate === "function" ? setImmediate : function(fn) {
  process.nextTick(fn.bind.apply(fn, arguments));
};
function onFinished$3(msg, listener2) {
  if (isFinished$1(msg) !== false) {
    defer$3(listener2, null, msg);
    return msg;
  }
  attachListener(msg, wrap$2(listener2));
  return msg;
}
function isFinished$1(msg) {
  var socket = msg.socket;
  if (typeof msg.finished === "boolean") {
    return Boolean(msg.finished || socket && !socket.writable);
  }
  if (typeof msg.complete === "boolean") {
    return Boolean(msg.upgrade || !socket || !socket.readable || msg.complete && !msg.readable);
  }
  return void 0;
}
function attachFinishedListener(msg, callback) {
  var eeMsg;
  var eeSocket;
  var finished = false;
  function onFinish(error2) {
    eeMsg.cancel();
    eeSocket.cancel();
    finished = true;
    callback(error2);
  }
  eeMsg = eeSocket = first([[msg, "end", "finish"]], onFinish);
  function onSocket(socket) {
    msg.removeListener("socket", onSocket);
    if (finished)
      return;
    if (eeMsg !== eeSocket)
      return;
    eeSocket = first([[socket, "error", "close"]], onFinish);
  }
  if (msg.socket) {
    onSocket(msg.socket);
    return;
  }
  msg.on("socket", onSocket);
  if (msg.socket === void 0) {
    patchAssignSocket(msg, onSocket);
  }
}
function attachListener(msg, listener2) {
  var attached = msg.__onFinished;
  if (!attached || !attached.queue) {
    attached = msg.__onFinished = createListener(msg);
    attachFinishedListener(msg, attached);
  }
  attached.queue.push(listener2);
}
function createListener(msg) {
  function listener2(err) {
    if (msg.__onFinished === listener2)
      msg.__onFinished = null;
    if (!listener2.queue)
      return;
    var queue = listener2.queue;
    listener2.queue = null;
    for (var i = 0; i < queue.length; i++) {
      queue[i](err, msg);
    }
  }
  listener2.queue = [];
  return listener2;
}
function patchAssignSocket(res2, callback) {
  var assignSocket = res2.assignSocket;
  if (typeof assignSocket !== "function")
    return;
  res2.assignSocket = function _assignSocket(socket) {
    assignSocket.call(this, socket);
    callback(socket);
  };
}
function tryRequireAsyncHooks() {
  try {
    return require("async_hooks");
  } catch (e) {
    return {};
  }
}
function wrap$2(fn) {
  var res2;
  if (asyncHooks.AsyncResource) {
    res2 = new asyncHooks.AsyncResource(fn.name || "bound-anonymous-fn");
  }
  if (!res2 || !res2.runInAsyncScope) {
    return fn;
  }
  return res2.runInAsyncScope.bind(res2, fn, null);
}
var onFinishedExports = onFinished$4.exports;
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var read_1;
var hasRequiredRead;
function requireRead() {
  if (hasRequiredRead)
    return read_1;
  hasRequiredRead = 1;
  var createError2 = httpErrorsExports;
  var destroy2 = destroy_1;
  var getBody = requireRawBody();
  var iconv = requireLib$1();
  var onFinished2 = onFinishedExports;
  var unpipe2 = unpipe_1;
  var zlib$1 = zlib;
  read_1 = read;
  function read(req2, res2, next, parse2, debug2, options) {
    var length;
    var opts = options;
    var stream3;
    req2._body = true;
    var encoding3 = opts.encoding !== null ? opts.encoding : null;
    var verify = opts.verify;
    try {
      stream3 = contentstream(req2, debug2, opts.inflate);
      length = stream3.length;
      stream3.length = void 0;
    } catch (err) {
      return next(err);
    }
    opts.length = length;
    opts.encoding = verify ? null : encoding3;
    if (opts.encoding === null && encoding3 !== null && !iconv.encodingExists(encoding3)) {
      return next(createError2(415, 'unsupported charset "' + encoding3.toUpperCase() + '"', {
        charset: encoding3.toLowerCase(),
        type: "charset.unsupported"
      }));
    }
    debug2("read body");
    getBody(stream3, opts, function(error2, body) {
      if (error2) {
        var _error;
        if (error2.type === "encoding.unsupported") {
          _error = createError2(415, 'unsupported charset "' + encoding3.toUpperCase() + '"', {
            charset: encoding3.toLowerCase(),
            type: "charset.unsupported"
          });
        } else {
          _error = createError2(400, error2);
        }
        if (stream3 !== req2) {
          unpipe2(req2);
          destroy2(stream3, true);
        }
        dump(req2, function onfinished() {
          next(createError2(400, _error));
        });
        return;
      }
      if (verify) {
        try {
          debug2("verify body");
          verify(req2, res2, body, encoding3);
        } catch (err) {
          next(createError2(403, err, {
            body,
            type: err.type || "entity.verify.failed"
          }));
          return;
        }
      }
      var str = body;
      try {
        debug2("parse body");
        str = typeof body !== "string" && encoding3 !== null ? iconv.decode(body, encoding3) : body;
        req2.body = parse2(str);
      } catch (err) {
        next(createError2(400, err, {
          body: str,
          type: err.type || "entity.parse.failed"
        }));
        return;
      }
      next();
    });
  }
  function contentstream(req2, debug2, inflate) {
    var encoding3 = (req2.headers["content-encoding"] || "identity").toLowerCase();
    var length = req2.headers["content-length"];
    var stream3;
    debug2('content-encoding "%s"', encoding3);
    if (inflate === false && encoding3 !== "identity") {
      throw createError2(415, "content encoding unsupported", {
        encoding: encoding3,
        type: "encoding.unsupported"
      });
    }
    switch (encoding3) {
      case "deflate":
        stream3 = zlib$1.createInflate();
        debug2("inflate body");
        req2.pipe(stream3);
        break;
      case "gzip":
        stream3 = zlib$1.createGunzip();
        debug2("gunzip body");
        req2.pipe(stream3);
        break;
      case "identity":
        stream3 = req2;
        stream3.length = length;
        break;
      default:
        throw createError2(415, 'unsupported content encoding "' + encoding3 + '"', {
          encoding: encoding3,
          type: "encoding.unsupported"
        });
    }
    return stream3;
  }
  function dump(req2, callback) {
    if (onFinished2.isFinished(req2)) {
      callback(null);
    } else {
      onFinished2(req2, callback);
      req2.resume();
    }
  }
  return read_1;
}
var typeIs = { exports: {} };
var mediaTyper = {};
/*!
 * media-typer
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */
var paramRegExp = /; *([!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) *= *("(?:[ !\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u0020-\u007e])*"|[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) */g;
var textRegExp = /^[\u0020-\u007e\u0080-\u00ff]+$/;
var tokenRegExp = /^[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+$/;
var qescRegExp = /\\([\u0000-\u007f])/g;
var quoteRegExp = /([\\"])/g;
var subtypeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/;
var typeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/;
var typeRegExp = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;
mediaTyper.format = format$1;
mediaTyper.parse = parse$8;
function format$1(obj) {
  if (!obj || typeof obj !== "object") {
    throw new TypeError("argument obj is required");
  }
  var parameters = obj.parameters;
  var subtype = obj.subtype;
  var suffix = obj.suffix;
  var type3 = obj.type;
  if (!type3 || !typeNameRegExp.test(type3)) {
    throw new TypeError("invalid type");
  }
  if (!subtype || !subtypeNameRegExp.test(subtype)) {
    throw new TypeError("invalid subtype");
  }
  var string = type3 + "/" + subtype;
  if (suffix) {
    if (!typeNameRegExp.test(suffix)) {
      throw new TypeError("invalid suffix");
    }
    string += "+" + suffix;
  }
  if (parameters && typeof parameters === "object") {
    var param3;
    var params = Object.keys(parameters).sort();
    for (var i = 0; i < params.length; i++) {
      param3 = params[i];
      if (!tokenRegExp.test(param3)) {
        throw new TypeError("invalid parameter name");
      }
      string += "; " + param3 + "=" + qstring$1(parameters[param3]);
    }
  }
  return string;
}
function parse$8(string) {
  if (!string) {
    throw new TypeError("argument string is required");
  }
  if (typeof string === "object") {
    string = getcontenttype(string);
  }
  if (typeof string !== "string") {
    throw new TypeError("argument string is required to be a string");
  }
  var index2 = string.indexOf(";");
  var type3 = index2 !== -1 ? string.substr(0, index2) : string;
  var key;
  var match2;
  var obj = splitType(type3);
  var params = {};
  var value;
  paramRegExp.lastIndex = index2;
  while (match2 = paramRegExp.exec(string)) {
    if (match2.index !== index2) {
      throw new TypeError("invalid parameter format");
    }
    index2 += match2[0].length;
    key = match2[1].toLowerCase();
    value = match2[2];
    if (value[0] === '"') {
      value = value.substr(1, value.length - 2).replace(qescRegExp, "$1");
    }
    params[key] = value;
  }
  if (index2 !== -1 && index2 !== string.length) {
    throw new TypeError("invalid parameter format");
  }
  obj.parameters = params;
  return obj;
}
function getcontenttype(obj) {
  if (typeof obj.getHeader === "function") {
    return obj.getHeader("content-type");
  }
  if (typeof obj.headers === "object") {
    return obj.headers && obj.headers["content-type"];
  }
}
function qstring$1(val) {
  var str = String(val);
  if (tokenRegExp.test(str)) {
    return str;
  }
  if (str.length > 0 && !textRegExp.test(str)) {
    throw new TypeError("invalid parameter value");
  }
  return '"' + str.replace(quoteRegExp, "\\$1") + '"';
}
function splitType(string) {
  var match2 = typeRegExp.exec(string.toLowerCase());
  if (!match2) {
    throw new TypeError("invalid media type");
  }
  var type3 = match2[1];
  var subtype = match2[2];
  var suffix;
  var index2 = subtype.lastIndexOf("+");
  if (index2 !== -1) {
    suffix = subtype.substr(index2 + 1);
    subtype = subtype.substr(0, index2);
  }
  var obj = {
    type: type3,
    subtype,
    suffix
  };
  return obj;
}
var mimeTypes = {};
const require$$0 = {
  "application/1d-interleaved-parityfec": {
    source: "iana"
  },
  "application/3gpdash-qoe-report+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/3gpp-ims+xml": {
    source: "iana",
    compressible: true
  },
  "application/3gpphal+json": {
    source: "iana",
    compressible: true
  },
  "application/3gpphalforms+json": {
    source: "iana",
    compressible: true
  },
  "application/a2l": {
    source: "iana"
  },
  "application/ace+cbor": {
    source: "iana"
  },
  "application/activemessage": {
    source: "iana"
  },
  "application/activity+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-costmap+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-costmapfilter+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-directory+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-endpointcost+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-endpointcostparams+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-endpointprop+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-endpointpropparams+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-error+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-networkmap+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-networkmapfilter+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-updatestreamcontrol+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-updatestreamparams+json": {
    source: "iana",
    compressible: true
  },
  "application/aml": {
    source: "iana"
  },
  "application/andrew-inset": {
    source: "iana",
    extensions: [
      "ez"
    ]
  },
  "application/applefile": {
    source: "iana"
  },
  "application/applixware": {
    source: "apache",
    extensions: [
      "aw"
    ]
  },
  "application/at+jwt": {
    source: "iana"
  },
  "application/atf": {
    source: "iana"
  },
  "application/atfx": {
    source: "iana"
  },
  "application/atom+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "atom"
    ]
  },
  "application/atomcat+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "atomcat"
    ]
  },
  "application/atomdeleted+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "atomdeleted"
    ]
  },
  "application/atomicmail": {
    source: "iana"
  },
  "application/atomsvc+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "atomsvc"
    ]
  },
  "application/atsc-dwd+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "dwd"
    ]
  },
  "application/atsc-dynamic-event-message": {
    source: "iana"
  },
  "application/atsc-held+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "held"
    ]
  },
  "application/atsc-rdt+json": {
    source: "iana",
    compressible: true
  },
  "application/atsc-rsat+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rsat"
    ]
  },
  "application/atxml": {
    source: "iana"
  },
  "application/auth-policy+xml": {
    source: "iana",
    compressible: true
  },
  "application/bacnet-xdd+zip": {
    source: "iana",
    compressible: false
  },
  "application/batch-smtp": {
    source: "iana"
  },
  "application/bdoc": {
    compressible: false,
    extensions: [
      "bdoc"
    ]
  },
  "application/beep+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/calendar+json": {
    source: "iana",
    compressible: true
  },
  "application/calendar+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xcs"
    ]
  },
  "application/call-completion": {
    source: "iana"
  },
  "application/cals-1840": {
    source: "iana"
  },
  "application/captive+json": {
    source: "iana",
    compressible: true
  },
  "application/cbor": {
    source: "iana"
  },
  "application/cbor-seq": {
    source: "iana"
  },
  "application/cccex": {
    source: "iana"
  },
  "application/ccmp+xml": {
    source: "iana",
    compressible: true
  },
  "application/ccxml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "ccxml"
    ]
  },
  "application/cdfx+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "cdfx"
    ]
  },
  "application/cdmi-capability": {
    source: "iana",
    extensions: [
      "cdmia"
    ]
  },
  "application/cdmi-container": {
    source: "iana",
    extensions: [
      "cdmic"
    ]
  },
  "application/cdmi-domain": {
    source: "iana",
    extensions: [
      "cdmid"
    ]
  },
  "application/cdmi-object": {
    source: "iana",
    extensions: [
      "cdmio"
    ]
  },
  "application/cdmi-queue": {
    source: "iana",
    extensions: [
      "cdmiq"
    ]
  },
  "application/cdni": {
    source: "iana"
  },
  "application/cea": {
    source: "iana"
  },
  "application/cea-2018+xml": {
    source: "iana",
    compressible: true
  },
  "application/cellml+xml": {
    source: "iana",
    compressible: true
  },
  "application/cfw": {
    source: "iana"
  },
  "application/city+json": {
    source: "iana",
    compressible: true
  },
  "application/clr": {
    source: "iana"
  },
  "application/clue+xml": {
    source: "iana",
    compressible: true
  },
  "application/clue_info+xml": {
    source: "iana",
    compressible: true
  },
  "application/cms": {
    source: "iana"
  },
  "application/cnrp+xml": {
    source: "iana",
    compressible: true
  },
  "application/coap-group+json": {
    source: "iana",
    compressible: true
  },
  "application/coap-payload": {
    source: "iana"
  },
  "application/commonground": {
    source: "iana"
  },
  "application/conference-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/cose": {
    source: "iana"
  },
  "application/cose-key": {
    source: "iana"
  },
  "application/cose-key-set": {
    source: "iana"
  },
  "application/cpl+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "cpl"
    ]
  },
  "application/csrattrs": {
    source: "iana"
  },
  "application/csta+xml": {
    source: "iana",
    compressible: true
  },
  "application/cstadata+xml": {
    source: "iana",
    compressible: true
  },
  "application/csvm+json": {
    source: "iana",
    compressible: true
  },
  "application/cu-seeme": {
    source: "apache",
    extensions: [
      "cu"
    ]
  },
  "application/cwt": {
    source: "iana"
  },
  "application/cybercash": {
    source: "iana"
  },
  "application/dart": {
    compressible: true
  },
  "application/dash+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mpd"
    ]
  },
  "application/dash-patch+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mpp"
    ]
  },
  "application/dashdelta": {
    source: "iana"
  },
  "application/davmount+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "davmount"
    ]
  },
  "application/dca-rft": {
    source: "iana"
  },
  "application/dcd": {
    source: "iana"
  },
  "application/dec-dx": {
    source: "iana"
  },
  "application/dialog-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/dicom": {
    source: "iana"
  },
  "application/dicom+json": {
    source: "iana",
    compressible: true
  },
  "application/dicom+xml": {
    source: "iana",
    compressible: true
  },
  "application/dii": {
    source: "iana"
  },
  "application/dit": {
    source: "iana"
  },
  "application/dns": {
    source: "iana"
  },
  "application/dns+json": {
    source: "iana",
    compressible: true
  },
  "application/dns-message": {
    source: "iana"
  },
  "application/docbook+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "dbk"
    ]
  },
  "application/dots+cbor": {
    source: "iana"
  },
  "application/dskpp+xml": {
    source: "iana",
    compressible: true
  },
  "application/dssc+der": {
    source: "iana",
    extensions: [
      "dssc"
    ]
  },
  "application/dssc+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xdssc"
    ]
  },
  "application/dvcs": {
    source: "iana"
  },
  "application/ecmascript": {
    source: "iana",
    compressible: true,
    extensions: [
      "es",
      "ecma"
    ]
  },
  "application/edi-consent": {
    source: "iana"
  },
  "application/edi-x12": {
    source: "iana",
    compressible: false
  },
  "application/edifact": {
    source: "iana",
    compressible: false
  },
  "application/efi": {
    source: "iana"
  },
  "application/elm+json": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/elm+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.cap+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/emergencycalldata.comment+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.control+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.deviceinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.ecall.msd": {
    source: "iana"
  },
  "application/emergencycalldata.providerinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.serviceinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.subscriberinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.veds+xml": {
    source: "iana",
    compressible: true
  },
  "application/emma+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "emma"
    ]
  },
  "application/emotionml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "emotionml"
    ]
  },
  "application/encaprtp": {
    source: "iana"
  },
  "application/epp+xml": {
    source: "iana",
    compressible: true
  },
  "application/epub+zip": {
    source: "iana",
    compressible: false,
    extensions: [
      "epub"
    ]
  },
  "application/eshop": {
    source: "iana"
  },
  "application/exi": {
    source: "iana",
    extensions: [
      "exi"
    ]
  },
  "application/expect-ct-report+json": {
    source: "iana",
    compressible: true
  },
  "application/express": {
    source: "iana",
    extensions: [
      "exp"
    ]
  },
  "application/fastinfoset": {
    source: "iana"
  },
  "application/fastsoap": {
    source: "iana"
  },
  "application/fdt+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "fdt"
    ]
  },
  "application/fhir+json": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/fhir+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/fido.trusted-apps+json": {
    compressible: true
  },
  "application/fits": {
    source: "iana"
  },
  "application/flexfec": {
    source: "iana"
  },
  "application/font-sfnt": {
    source: "iana"
  },
  "application/font-tdpfr": {
    source: "iana",
    extensions: [
      "pfr"
    ]
  },
  "application/font-woff": {
    source: "iana",
    compressible: false
  },
  "application/framework-attributes+xml": {
    source: "iana",
    compressible: true
  },
  "application/geo+json": {
    source: "iana",
    compressible: true,
    extensions: [
      "geojson"
    ]
  },
  "application/geo+json-seq": {
    source: "iana"
  },
  "application/geopackage+sqlite3": {
    source: "iana"
  },
  "application/geoxacml+xml": {
    source: "iana",
    compressible: true
  },
  "application/gltf-buffer": {
    source: "iana"
  },
  "application/gml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "gml"
    ]
  },
  "application/gpx+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "gpx"
    ]
  },
  "application/gxf": {
    source: "apache",
    extensions: [
      "gxf"
    ]
  },
  "application/gzip": {
    source: "iana",
    compressible: false,
    extensions: [
      "gz"
    ]
  },
  "application/h224": {
    source: "iana"
  },
  "application/held+xml": {
    source: "iana",
    compressible: true
  },
  "application/hjson": {
    extensions: [
      "hjson"
    ]
  },
  "application/http": {
    source: "iana"
  },
  "application/hyperstudio": {
    source: "iana",
    extensions: [
      "stk"
    ]
  },
  "application/ibe-key-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/ibe-pkg-reply+xml": {
    source: "iana",
    compressible: true
  },
  "application/ibe-pp-data": {
    source: "iana"
  },
  "application/iges": {
    source: "iana"
  },
  "application/im-iscomposing+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/index": {
    source: "iana"
  },
  "application/index.cmd": {
    source: "iana"
  },
  "application/index.obj": {
    source: "iana"
  },
  "application/index.response": {
    source: "iana"
  },
  "application/index.vnd": {
    source: "iana"
  },
  "application/inkml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "ink",
      "inkml"
    ]
  },
  "application/iotp": {
    source: "iana"
  },
  "application/ipfix": {
    source: "iana",
    extensions: [
      "ipfix"
    ]
  },
  "application/ipp": {
    source: "iana"
  },
  "application/isup": {
    source: "iana"
  },
  "application/its+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "its"
    ]
  },
  "application/java-archive": {
    source: "apache",
    compressible: false,
    extensions: [
      "jar",
      "war",
      "ear"
    ]
  },
  "application/java-serialized-object": {
    source: "apache",
    compressible: false,
    extensions: [
      "ser"
    ]
  },
  "application/java-vm": {
    source: "apache",
    compressible: false,
    extensions: [
      "class"
    ]
  },
  "application/javascript": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "js",
      "mjs"
    ]
  },
  "application/jf2feed+json": {
    source: "iana",
    compressible: true
  },
  "application/jose": {
    source: "iana"
  },
  "application/jose+json": {
    source: "iana",
    compressible: true
  },
  "application/jrd+json": {
    source: "iana",
    compressible: true
  },
  "application/jscalendar+json": {
    source: "iana",
    compressible: true
  },
  "application/json": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "json",
      "map"
    ]
  },
  "application/json-patch+json": {
    source: "iana",
    compressible: true
  },
  "application/json-seq": {
    source: "iana"
  },
  "application/json5": {
    extensions: [
      "json5"
    ]
  },
  "application/jsonml+json": {
    source: "apache",
    compressible: true,
    extensions: [
      "jsonml"
    ]
  },
  "application/jwk+json": {
    source: "iana",
    compressible: true
  },
  "application/jwk-set+json": {
    source: "iana",
    compressible: true
  },
  "application/jwt": {
    source: "iana"
  },
  "application/kpml-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/kpml-response+xml": {
    source: "iana",
    compressible: true
  },
  "application/ld+json": {
    source: "iana",
    compressible: true,
    extensions: [
      "jsonld"
    ]
  },
  "application/lgr+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "lgr"
    ]
  },
  "application/link-format": {
    source: "iana"
  },
  "application/load-control+xml": {
    source: "iana",
    compressible: true
  },
  "application/lost+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "lostxml"
    ]
  },
  "application/lostsync+xml": {
    source: "iana",
    compressible: true
  },
  "application/lpf+zip": {
    source: "iana",
    compressible: false
  },
  "application/lxf": {
    source: "iana"
  },
  "application/mac-binhex40": {
    source: "iana",
    extensions: [
      "hqx"
    ]
  },
  "application/mac-compactpro": {
    source: "apache",
    extensions: [
      "cpt"
    ]
  },
  "application/macwriteii": {
    source: "iana"
  },
  "application/mads+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mads"
    ]
  },
  "application/manifest+json": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "webmanifest"
    ]
  },
  "application/marc": {
    source: "iana",
    extensions: [
      "mrc"
    ]
  },
  "application/marcxml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mrcx"
    ]
  },
  "application/mathematica": {
    source: "iana",
    extensions: [
      "ma",
      "nb",
      "mb"
    ]
  },
  "application/mathml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mathml"
    ]
  },
  "application/mathml-content+xml": {
    source: "iana",
    compressible: true
  },
  "application/mathml-presentation+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-associated-procedure-description+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-deregister+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-envelope+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-msk+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-msk-response+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-protection-description+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-reception-report+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-register+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-register-response+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-schedule+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-user-service-description+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbox": {
    source: "iana",
    extensions: [
      "mbox"
    ]
  },
  "application/media-policy-dataset+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mpf"
    ]
  },
  "application/media_control+xml": {
    source: "iana",
    compressible: true
  },
  "application/mediaservercontrol+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mscml"
    ]
  },
  "application/merge-patch+json": {
    source: "iana",
    compressible: true
  },
  "application/metalink+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "metalink"
    ]
  },
  "application/metalink4+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "meta4"
    ]
  },
  "application/mets+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mets"
    ]
  },
  "application/mf4": {
    source: "iana"
  },
  "application/mikey": {
    source: "iana"
  },
  "application/mipc": {
    source: "iana"
  },
  "application/missing-blocks+cbor-seq": {
    source: "iana"
  },
  "application/mmt-aei+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "maei"
    ]
  },
  "application/mmt-usd+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "musd"
    ]
  },
  "application/mods+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mods"
    ]
  },
  "application/moss-keys": {
    source: "iana"
  },
  "application/moss-signature": {
    source: "iana"
  },
  "application/mosskey-data": {
    source: "iana"
  },
  "application/mosskey-request": {
    source: "iana"
  },
  "application/mp21": {
    source: "iana",
    extensions: [
      "m21",
      "mp21"
    ]
  },
  "application/mp4": {
    source: "iana",
    extensions: [
      "mp4s",
      "m4p"
    ]
  },
  "application/mpeg4-generic": {
    source: "iana"
  },
  "application/mpeg4-iod": {
    source: "iana"
  },
  "application/mpeg4-iod-xmt": {
    source: "iana"
  },
  "application/mrb-consumer+xml": {
    source: "iana",
    compressible: true
  },
  "application/mrb-publish+xml": {
    source: "iana",
    compressible: true
  },
  "application/msc-ivr+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/msc-mixer+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/msword": {
    source: "iana",
    compressible: false,
    extensions: [
      "doc",
      "dot"
    ]
  },
  "application/mud+json": {
    source: "iana",
    compressible: true
  },
  "application/multipart-core": {
    source: "iana"
  },
  "application/mxf": {
    source: "iana",
    extensions: [
      "mxf"
    ]
  },
  "application/n-quads": {
    source: "iana",
    extensions: [
      "nq"
    ]
  },
  "application/n-triples": {
    source: "iana",
    extensions: [
      "nt"
    ]
  },
  "application/nasdata": {
    source: "iana"
  },
  "application/news-checkgroups": {
    source: "iana",
    charset: "US-ASCII"
  },
  "application/news-groupinfo": {
    source: "iana",
    charset: "US-ASCII"
  },
  "application/news-transmission": {
    source: "iana"
  },
  "application/nlsml+xml": {
    source: "iana",
    compressible: true
  },
  "application/node": {
    source: "iana",
    extensions: [
      "cjs"
    ]
  },
  "application/nss": {
    source: "iana"
  },
  "application/oauth-authz-req+jwt": {
    source: "iana"
  },
  "application/oblivious-dns-message": {
    source: "iana"
  },
  "application/ocsp-request": {
    source: "iana"
  },
  "application/ocsp-response": {
    source: "iana"
  },
  "application/octet-stream": {
    source: "iana",
    compressible: false,
    extensions: [
      "bin",
      "dms",
      "lrf",
      "mar",
      "so",
      "dist",
      "distz",
      "pkg",
      "bpk",
      "dump",
      "elc",
      "deploy",
      "exe",
      "dll",
      "deb",
      "dmg",
      "iso",
      "img",
      "msi",
      "msp",
      "msm",
      "buffer"
    ]
  },
  "application/oda": {
    source: "iana",
    extensions: [
      "oda"
    ]
  },
  "application/odm+xml": {
    source: "iana",
    compressible: true
  },
  "application/odx": {
    source: "iana"
  },
  "application/oebps-package+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "opf"
    ]
  },
  "application/ogg": {
    source: "iana",
    compressible: false,
    extensions: [
      "ogx"
    ]
  },
  "application/omdoc+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "omdoc"
    ]
  },
  "application/onenote": {
    source: "apache",
    extensions: [
      "onetoc",
      "onetoc2",
      "onetmp",
      "onepkg"
    ]
  },
  "application/opc-nodeset+xml": {
    source: "iana",
    compressible: true
  },
  "application/oscore": {
    source: "iana"
  },
  "application/oxps": {
    source: "iana",
    extensions: [
      "oxps"
    ]
  },
  "application/p21": {
    source: "iana"
  },
  "application/p21+zip": {
    source: "iana",
    compressible: false
  },
  "application/p2p-overlay+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "relo"
    ]
  },
  "application/parityfec": {
    source: "iana"
  },
  "application/passport": {
    source: "iana"
  },
  "application/patch-ops-error+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xer"
    ]
  },
  "application/pdf": {
    source: "iana",
    compressible: false,
    extensions: [
      "pdf"
    ]
  },
  "application/pdx": {
    source: "iana"
  },
  "application/pem-certificate-chain": {
    source: "iana"
  },
  "application/pgp-encrypted": {
    source: "iana",
    compressible: false,
    extensions: [
      "pgp"
    ]
  },
  "application/pgp-keys": {
    source: "iana",
    extensions: [
      "asc"
    ]
  },
  "application/pgp-signature": {
    source: "iana",
    extensions: [
      "asc",
      "sig"
    ]
  },
  "application/pics-rules": {
    source: "apache",
    extensions: [
      "prf"
    ]
  },
  "application/pidf+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/pidf-diff+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/pkcs10": {
    source: "iana",
    extensions: [
      "p10"
    ]
  },
  "application/pkcs12": {
    source: "iana"
  },
  "application/pkcs7-mime": {
    source: "iana",
    extensions: [
      "p7m",
      "p7c"
    ]
  },
  "application/pkcs7-signature": {
    source: "iana",
    extensions: [
      "p7s"
    ]
  },
  "application/pkcs8": {
    source: "iana",
    extensions: [
      "p8"
    ]
  },
  "application/pkcs8-encrypted": {
    source: "iana"
  },
  "application/pkix-attr-cert": {
    source: "iana",
    extensions: [
      "ac"
    ]
  },
  "application/pkix-cert": {
    source: "iana",
    extensions: [
      "cer"
    ]
  },
  "application/pkix-crl": {
    source: "iana",
    extensions: [
      "crl"
    ]
  },
  "application/pkix-pkipath": {
    source: "iana",
    extensions: [
      "pkipath"
    ]
  },
  "application/pkixcmp": {
    source: "iana",
    extensions: [
      "pki"
    ]
  },
  "application/pls+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "pls"
    ]
  },
  "application/poc-settings+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/postscript": {
    source: "iana",
    compressible: true,
    extensions: [
      "ai",
      "eps",
      "ps"
    ]
  },
  "application/ppsp-tracker+json": {
    source: "iana",
    compressible: true
  },
  "application/problem+json": {
    source: "iana",
    compressible: true
  },
  "application/problem+xml": {
    source: "iana",
    compressible: true
  },
  "application/provenance+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "provx"
    ]
  },
  "application/prs.alvestrand.titrax-sheet": {
    source: "iana"
  },
  "application/prs.cww": {
    source: "iana",
    extensions: [
      "cww"
    ]
  },
  "application/prs.cyn": {
    source: "iana",
    charset: "7-BIT"
  },
  "application/prs.hpub+zip": {
    source: "iana",
    compressible: false
  },
  "application/prs.nprend": {
    source: "iana"
  },
  "application/prs.plucker": {
    source: "iana"
  },
  "application/prs.rdf-xml-crypt": {
    source: "iana"
  },
  "application/prs.xsf+xml": {
    source: "iana",
    compressible: true
  },
  "application/pskc+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "pskcxml"
    ]
  },
  "application/pvd+json": {
    source: "iana",
    compressible: true
  },
  "application/qsig": {
    source: "iana"
  },
  "application/raml+yaml": {
    compressible: true,
    extensions: [
      "raml"
    ]
  },
  "application/raptorfec": {
    source: "iana"
  },
  "application/rdap+json": {
    source: "iana",
    compressible: true
  },
  "application/rdf+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rdf",
      "owl"
    ]
  },
  "application/reginfo+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rif"
    ]
  },
  "application/relax-ng-compact-syntax": {
    source: "iana",
    extensions: [
      "rnc"
    ]
  },
  "application/remote-printing": {
    source: "iana"
  },
  "application/reputon+json": {
    source: "iana",
    compressible: true
  },
  "application/resource-lists+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rl"
    ]
  },
  "application/resource-lists-diff+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rld"
    ]
  },
  "application/rfc+xml": {
    source: "iana",
    compressible: true
  },
  "application/riscos": {
    source: "iana"
  },
  "application/rlmi+xml": {
    source: "iana",
    compressible: true
  },
  "application/rls-services+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rs"
    ]
  },
  "application/route-apd+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rapd"
    ]
  },
  "application/route-s-tsid+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "sls"
    ]
  },
  "application/route-usd+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rusd"
    ]
  },
  "application/rpki-ghostbusters": {
    source: "iana",
    extensions: [
      "gbr"
    ]
  },
  "application/rpki-manifest": {
    source: "iana",
    extensions: [
      "mft"
    ]
  },
  "application/rpki-publication": {
    source: "iana"
  },
  "application/rpki-roa": {
    source: "iana",
    extensions: [
      "roa"
    ]
  },
  "application/rpki-updown": {
    source: "iana"
  },
  "application/rsd+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "rsd"
    ]
  },
  "application/rss+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "rss"
    ]
  },
  "application/rtf": {
    source: "iana",
    compressible: true,
    extensions: [
      "rtf"
    ]
  },
  "application/rtploopback": {
    source: "iana"
  },
  "application/rtx": {
    source: "iana"
  },
  "application/samlassertion+xml": {
    source: "iana",
    compressible: true
  },
  "application/samlmetadata+xml": {
    source: "iana",
    compressible: true
  },
  "application/sarif+json": {
    source: "iana",
    compressible: true
  },
  "application/sarif-external-properties+json": {
    source: "iana",
    compressible: true
  },
  "application/sbe": {
    source: "iana"
  },
  "application/sbml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "sbml"
    ]
  },
  "application/scaip+xml": {
    source: "iana",
    compressible: true
  },
  "application/scim+json": {
    source: "iana",
    compressible: true
  },
  "application/scvp-cv-request": {
    source: "iana",
    extensions: [
      "scq"
    ]
  },
  "application/scvp-cv-response": {
    source: "iana",
    extensions: [
      "scs"
    ]
  },
  "application/scvp-vp-request": {
    source: "iana",
    extensions: [
      "spq"
    ]
  },
  "application/scvp-vp-response": {
    source: "iana",
    extensions: [
      "spp"
    ]
  },
  "application/sdp": {
    source: "iana",
    extensions: [
      "sdp"
    ]
  },
  "application/secevent+jwt": {
    source: "iana"
  },
  "application/senml+cbor": {
    source: "iana"
  },
  "application/senml+json": {
    source: "iana",
    compressible: true
  },
  "application/senml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "senmlx"
    ]
  },
  "application/senml-etch+cbor": {
    source: "iana"
  },
  "application/senml-etch+json": {
    source: "iana",
    compressible: true
  },
  "application/senml-exi": {
    source: "iana"
  },
  "application/sensml+cbor": {
    source: "iana"
  },
  "application/sensml+json": {
    source: "iana",
    compressible: true
  },
  "application/sensml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "sensmlx"
    ]
  },
  "application/sensml-exi": {
    source: "iana"
  },
  "application/sep+xml": {
    source: "iana",
    compressible: true
  },
  "application/sep-exi": {
    source: "iana"
  },
  "application/session-info": {
    source: "iana"
  },
  "application/set-payment": {
    source: "iana"
  },
  "application/set-payment-initiation": {
    source: "iana",
    extensions: [
      "setpay"
    ]
  },
  "application/set-registration": {
    source: "iana"
  },
  "application/set-registration-initiation": {
    source: "iana",
    extensions: [
      "setreg"
    ]
  },
  "application/sgml": {
    source: "iana"
  },
  "application/sgml-open-catalog": {
    source: "iana"
  },
  "application/shf+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "shf"
    ]
  },
  "application/sieve": {
    source: "iana",
    extensions: [
      "siv",
      "sieve"
    ]
  },
  "application/simple-filter+xml": {
    source: "iana",
    compressible: true
  },
  "application/simple-message-summary": {
    source: "iana"
  },
  "application/simplesymbolcontainer": {
    source: "iana"
  },
  "application/sipc": {
    source: "iana"
  },
  "application/slate": {
    source: "iana"
  },
  "application/smil": {
    source: "iana"
  },
  "application/smil+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "smi",
      "smil"
    ]
  },
  "application/smpte336m": {
    source: "iana"
  },
  "application/soap+fastinfoset": {
    source: "iana"
  },
  "application/soap+xml": {
    source: "iana",
    compressible: true
  },
  "application/sparql-query": {
    source: "iana",
    extensions: [
      "rq"
    ]
  },
  "application/sparql-results+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "srx"
    ]
  },
  "application/spdx+json": {
    source: "iana",
    compressible: true
  },
  "application/spirits-event+xml": {
    source: "iana",
    compressible: true
  },
  "application/sql": {
    source: "iana"
  },
  "application/srgs": {
    source: "iana",
    extensions: [
      "gram"
    ]
  },
  "application/srgs+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "grxml"
    ]
  },
  "application/sru+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "sru"
    ]
  },
  "application/ssdl+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "ssdl"
    ]
  },
  "application/ssml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "ssml"
    ]
  },
  "application/stix+json": {
    source: "iana",
    compressible: true
  },
  "application/swid+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "swidtag"
    ]
  },
  "application/tamp-apex-update": {
    source: "iana"
  },
  "application/tamp-apex-update-confirm": {
    source: "iana"
  },
  "application/tamp-community-update": {
    source: "iana"
  },
  "application/tamp-community-update-confirm": {
    source: "iana"
  },
  "application/tamp-error": {
    source: "iana"
  },
  "application/tamp-sequence-adjust": {
    source: "iana"
  },
  "application/tamp-sequence-adjust-confirm": {
    source: "iana"
  },
  "application/tamp-status-query": {
    source: "iana"
  },
  "application/tamp-status-response": {
    source: "iana"
  },
  "application/tamp-update": {
    source: "iana"
  },
  "application/tamp-update-confirm": {
    source: "iana"
  },
  "application/tar": {
    compressible: true
  },
  "application/taxii+json": {
    source: "iana",
    compressible: true
  },
  "application/td+json": {
    source: "iana",
    compressible: true
  },
  "application/tei+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "tei",
      "teicorpus"
    ]
  },
  "application/tetra_isi": {
    source: "iana"
  },
  "application/thraud+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "tfi"
    ]
  },
  "application/timestamp-query": {
    source: "iana"
  },
  "application/timestamp-reply": {
    source: "iana"
  },
  "application/timestamped-data": {
    source: "iana",
    extensions: [
      "tsd"
    ]
  },
  "application/tlsrpt+gzip": {
    source: "iana"
  },
  "application/tlsrpt+json": {
    source: "iana",
    compressible: true
  },
  "application/tnauthlist": {
    source: "iana"
  },
  "application/token-introspection+jwt": {
    source: "iana"
  },
  "application/toml": {
    compressible: true,
    extensions: [
      "toml"
    ]
  },
  "application/trickle-ice-sdpfrag": {
    source: "iana"
  },
  "application/trig": {
    source: "iana",
    extensions: [
      "trig"
    ]
  },
  "application/ttml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "ttml"
    ]
  },
  "application/tve-trigger": {
    source: "iana"
  },
  "application/tzif": {
    source: "iana"
  },
  "application/tzif-leap": {
    source: "iana"
  },
  "application/ubjson": {
    compressible: false,
    extensions: [
      "ubj"
    ]
  },
  "application/ulpfec": {
    source: "iana"
  },
  "application/urc-grpsheet+xml": {
    source: "iana",
    compressible: true
  },
  "application/urc-ressheet+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rsheet"
    ]
  },
  "application/urc-targetdesc+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "td"
    ]
  },
  "application/urc-uisocketdesc+xml": {
    source: "iana",
    compressible: true
  },
  "application/vcard+json": {
    source: "iana",
    compressible: true
  },
  "application/vcard+xml": {
    source: "iana",
    compressible: true
  },
  "application/vemmi": {
    source: "iana"
  },
  "application/vividence.scriptfile": {
    source: "apache"
  },
  "application/vnd.1000minds.decision-model+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "1km"
    ]
  },
  "application/vnd.3gpp-prose+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp-prose-pc3ch+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp-v2x-local-service-information": {
    source: "iana"
  },
  "application/vnd.3gpp.5gnas": {
    source: "iana"
  },
  "application/vnd.3gpp.access-transfer-events+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.bsf+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.gmop+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.gtpc": {
    source: "iana"
  },
  "application/vnd.3gpp.interworking-data": {
    source: "iana"
  },
  "application/vnd.3gpp.lpp": {
    source: "iana"
  },
  "application/vnd.3gpp.mc-signalling-ear": {
    source: "iana"
  },
  "application/vnd.3gpp.mcdata-affiliation-command+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcdata-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcdata-payload": {
    source: "iana"
  },
  "application/vnd.3gpp.mcdata-service-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcdata-signalling": {
    source: "iana"
  },
  "application/vnd.3gpp.mcdata-ue-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcdata-user-profile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-affiliation-command+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-floor-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-location-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-service-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-signed+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-ue-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-ue-init-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-user-profile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-location-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-service-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-transmission-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-ue-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-user-profile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mid-call+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.ngap": {
    source: "iana"
  },
  "application/vnd.3gpp.pfcp": {
    source: "iana"
  },
  "application/vnd.3gpp.pic-bw-large": {
    source: "iana",
    extensions: [
      "plb"
    ]
  },
  "application/vnd.3gpp.pic-bw-small": {
    source: "iana",
    extensions: [
      "psb"
    ]
  },
  "application/vnd.3gpp.pic-bw-var": {
    source: "iana",
    extensions: [
      "pvb"
    ]
  },
  "application/vnd.3gpp.s1ap": {
    source: "iana"
  },
  "application/vnd.3gpp.sms": {
    source: "iana"
  },
  "application/vnd.3gpp.sms+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.srvcc-ext+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.srvcc-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.state-and-event-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.ussd+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp2.bcmcsinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp2.sms": {
    source: "iana"
  },
  "application/vnd.3gpp2.tcap": {
    source: "iana",
    extensions: [
      "tcap"
    ]
  },
  "application/vnd.3lightssoftware.imagescal": {
    source: "iana"
  },
  "application/vnd.3m.post-it-notes": {
    source: "iana",
    extensions: [
      "pwn"
    ]
  },
  "application/vnd.accpac.simply.aso": {
    source: "iana",
    extensions: [
      "aso"
    ]
  },
  "application/vnd.accpac.simply.imp": {
    source: "iana",
    extensions: [
      "imp"
    ]
  },
  "application/vnd.acucobol": {
    source: "iana",
    extensions: [
      "acu"
    ]
  },
  "application/vnd.acucorp": {
    source: "iana",
    extensions: [
      "atc",
      "acutc"
    ]
  },
  "application/vnd.adobe.air-application-installer-package+zip": {
    source: "apache",
    compressible: false,
    extensions: [
      "air"
    ]
  },
  "application/vnd.adobe.flash.movie": {
    source: "iana"
  },
  "application/vnd.adobe.formscentral.fcdt": {
    source: "iana",
    extensions: [
      "fcdt"
    ]
  },
  "application/vnd.adobe.fxp": {
    source: "iana",
    extensions: [
      "fxp",
      "fxpl"
    ]
  },
  "application/vnd.adobe.partial-upload": {
    source: "iana"
  },
  "application/vnd.adobe.xdp+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xdp"
    ]
  },
  "application/vnd.adobe.xfdf": {
    source: "iana",
    extensions: [
      "xfdf"
    ]
  },
  "application/vnd.aether.imp": {
    source: "iana"
  },
  "application/vnd.afpc.afplinedata": {
    source: "iana"
  },
  "application/vnd.afpc.afplinedata-pagedef": {
    source: "iana"
  },
  "application/vnd.afpc.cmoca-cmresource": {
    source: "iana"
  },
  "application/vnd.afpc.foca-charset": {
    source: "iana"
  },
  "application/vnd.afpc.foca-codedfont": {
    source: "iana"
  },
  "application/vnd.afpc.foca-codepage": {
    source: "iana"
  },
  "application/vnd.afpc.modca": {
    source: "iana"
  },
  "application/vnd.afpc.modca-cmtable": {
    source: "iana"
  },
  "application/vnd.afpc.modca-formdef": {
    source: "iana"
  },
  "application/vnd.afpc.modca-mediummap": {
    source: "iana"
  },
  "application/vnd.afpc.modca-objectcontainer": {
    source: "iana"
  },
  "application/vnd.afpc.modca-overlay": {
    source: "iana"
  },
  "application/vnd.afpc.modca-pagesegment": {
    source: "iana"
  },
  "application/vnd.age": {
    source: "iana",
    extensions: [
      "age"
    ]
  },
  "application/vnd.ah-barcode": {
    source: "iana"
  },
  "application/vnd.ahead.space": {
    source: "iana",
    extensions: [
      "ahead"
    ]
  },
  "application/vnd.airzip.filesecure.azf": {
    source: "iana",
    extensions: [
      "azf"
    ]
  },
  "application/vnd.airzip.filesecure.azs": {
    source: "iana",
    extensions: [
      "azs"
    ]
  },
  "application/vnd.amadeus+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.amazon.ebook": {
    source: "apache",
    extensions: [
      "azw"
    ]
  },
  "application/vnd.amazon.mobi8-ebook": {
    source: "iana"
  },
  "application/vnd.americandynamics.acc": {
    source: "iana",
    extensions: [
      "acc"
    ]
  },
  "application/vnd.amiga.ami": {
    source: "iana",
    extensions: [
      "ami"
    ]
  },
  "application/vnd.amundsen.maze+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.android.ota": {
    source: "iana"
  },
  "application/vnd.android.package-archive": {
    source: "apache",
    compressible: false,
    extensions: [
      "apk"
    ]
  },
  "application/vnd.anki": {
    source: "iana"
  },
  "application/vnd.anser-web-certificate-issue-initiation": {
    source: "iana",
    extensions: [
      "cii"
    ]
  },
  "application/vnd.anser-web-funds-transfer-initiation": {
    source: "apache",
    extensions: [
      "fti"
    ]
  },
  "application/vnd.antix.game-component": {
    source: "iana",
    extensions: [
      "atx"
    ]
  },
  "application/vnd.apache.arrow.file": {
    source: "iana"
  },
  "application/vnd.apache.arrow.stream": {
    source: "iana"
  },
  "application/vnd.apache.thrift.binary": {
    source: "iana"
  },
  "application/vnd.apache.thrift.compact": {
    source: "iana"
  },
  "application/vnd.apache.thrift.json": {
    source: "iana"
  },
  "application/vnd.api+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.aplextor.warrp+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.apothekende.reservation+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.apple.installer+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mpkg"
    ]
  },
  "application/vnd.apple.keynote": {
    source: "iana",
    extensions: [
      "key"
    ]
  },
  "application/vnd.apple.mpegurl": {
    source: "iana",
    extensions: [
      "m3u8"
    ]
  },
  "application/vnd.apple.numbers": {
    source: "iana",
    extensions: [
      "numbers"
    ]
  },
  "application/vnd.apple.pages": {
    source: "iana",
    extensions: [
      "pages"
    ]
  },
  "application/vnd.apple.pkpass": {
    compressible: false,
    extensions: [
      "pkpass"
    ]
  },
  "application/vnd.arastra.swi": {
    source: "iana"
  },
  "application/vnd.aristanetworks.swi": {
    source: "iana",
    extensions: [
      "swi"
    ]
  },
  "application/vnd.artisan+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.artsquare": {
    source: "iana"
  },
  "application/vnd.astraea-software.iota": {
    source: "iana",
    extensions: [
      "iota"
    ]
  },
  "application/vnd.audiograph": {
    source: "iana",
    extensions: [
      "aep"
    ]
  },
  "application/vnd.autopackage": {
    source: "iana"
  },
  "application/vnd.avalon+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.avistar+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.balsamiq.bmml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "bmml"
    ]
  },
  "application/vnd.balsamiq.bmpr": {
    source: "iana"
  },
  "application/vnd.banana-accounting": {
    source: "iana"
  },
  "application/vnd.bbf.usp.error": {
    source: "iana"
  },
  "application/vnd.bbf.usp.msg": {
    source: "iana"
  },
  "application/vnd.bbf.usp.msg+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.bekitzur-stech+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.bint.med-content": {
    source: "iana"
  },
  "application/vnd.biopax.rdf+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.blink-idb-value-wrapper": {
    source: "iana"
  },
  "application/vnd.blueice.multipass": {
    source: "iana",
    extensions: [
      "mpm"
    ]
  },
  "application/vnd.bluetooth.ep.oob": {
    source: "iana"
  },
  "application/vnd.bluetooth.le.oob": {
    source: "iana"
  },
  "application/vnd.bmi": {
    source: "iana",
    extensions: [
      "bmi"
    ]
  },
  "application/vnd.bpf": {
    source: "iana"
  },
  "application/vnd.bpf3": {
    source: "iana"
  },
  "application/vnd.businessobjects": {
    source: "iana",
    extensions: [
      "rep"
    ]
  },
  "application/vnd.byu.uapi+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cab-jscript": {
    source: "iana"
  },
  "application/vnd.canon-cpdl": {
    source: "iana"
  },
  "application/vnd.canon-lips": {
    source: "iana"
  },
  "application/vnd.capasystems-pg+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cendio.thinlinc.clientconf": {
    source: "iana"
  },
  "application/vnd.century-systems.tcp_stream": {
    source: "iana"
  },
  "application/vnd.chemdraw+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "cdxml"
    ]
  },
  "application/vnd.chess-pgn": {
    source: "iana"
  },
  "application/vnd.chipnuts.karaoke-mmd": {
    source: "iana",
    extensions: [
      "mmd"
    ]
  },
  "application/vnd.ciedi": {
    source: "iana"
  },
  "application/vnd.cinderella": {
    source: "iana",
    extensions: [
      "cdy"
    ]
  },
  "application/vnd.cirpack.isdn-ext": {
    source: "iana"
  },
  "application/vnd.citationstyles.style+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "csl"
    ]
  },
  "application/vnd.claymore": {
    source: "iana",
    extensions: [
      "cla"
    ]
  },
  "application/vnd.cloanto.rp9": {
    source: "iana",
    extensions: [
      "rp9"
    ]
  },
  "application/vnd.clonk.c4group": {
    source: "iana",
    extensions: [
      "c4g",
      "c4d",
      "c4f",
      "c4p",
      "c4u"
    ]
  },
  "application/vnd.cluetrust.cartomobile-config": {
    source: "iana",
    extensions: [
      "c11amc"
    ]
  },
  "application/vnd.cluetrust.cartomobile-config-pkg": {
    source: "iana",
    extensions: [
      "c11amz"
    ]
  },
  "application/vnd.coffeescript": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.document": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.document-template": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.presentation": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.presentation-template": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.spreadsheet": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.spreadsheet-template": {
    source: "iana"
  },
  "application/vnd.collection+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.collection.doc+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.collection.next+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.comicbook+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.comicbook-rar": {
    source: "iana"
  },
  "application/vnd.commerce-battelle": {
    source: "iana"
  },
  "application/vnd.commonspace": {
    source: "iana",
    extensions: [
      "csp"
    ]
  },
  "application/vnd.contact.cmsg": {
    source: "iana",
    extensions: [
      "cdbcmsg"
    ]
  },
  "application/vnd.coreos.ignition+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cosmocaller": {
    source: "iana",
    extensions: [
      "cmc"
    ]
  },
  "application/vnd.crick.clicker": {
    source: "iana",
    extensions: [
      "clkx"
    ]
  },
  "application/vnd.crick.clicker.keyboard": {
    source: "iana",
    extensions: [
      "clkk"
    ]
  },
  "application/vnd.crick.clicker.palette": {
    source: "iana",
    extensions: [
      "clkp"
    ]
  },
  "application/vnd.crick.clicker.template": {
    source: "iana",
    extensions: [
      "clkt"
    ]
  },
  "application/vnd.crick.clicker.wordbank": {
    source: "iana",
    extensions: [
      "clkw"
    ]
  },
  "application/vnd.criticaltools.wbs+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "wbs"
    ]
  },
  "application/vnd.cryptii.pipe+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.crypto-shade-file": {
    source: "iana"
  },
  "application/vnd.cryptomator.encrypted": {
    source: "iana"
  },
  "application/vnd.cryptomator.vault": {
    source: "iana"
  },
  "application/vnd.ctc-posml": {
    source: "iana",
    extensions: [
      "pml"
    ]
  },
  "application/vnd.ctct.ws+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cups-pdf": {
    source: "iana"
  },
  "application/vnd.cups-postscript": {
    source: "iana"
  },
  "application/vnd.cups-ppd": {
    source: "iana",
    extensions: [
      "ppd"
    ]
  },
  "application/vnd.cups-raster": {
    source: "iana"
  },
  "application/vnd.cups-raw": {
    source: "iana"
  },
  "application/vnd.curl": {
    source: "iana"
  },
  "application/vnd.curl.car": {
    source: "apache",
    extensions: [
      "car"
    ]
  },
  "application/vnd.curl.pcurl": {
    source: "apache",
    extensions: [
      "pcurl"
    ]
  },
  "application/vnd.cyan.dean.root+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cybank": {
    source: "iana"
  },
  "application/vnd.cyclonedx+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cyclonedx+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.d2l.coursepackage1p0+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.d3m-dataset": {
    source: "iana"
  },
  "application/vnd.d3m-problem": {
    source: "iana"
  },
  "application/vnd.dart": {
    source: "iana",
    compressible: true,
    extensions: [
      "dart"
    ]
  },
  "application/vnd.data-vision.rdz": {
    source: "iana",
    extensions: [
      "rdz"
    ]
  },
  "application/vnd.datapackage+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dataresource+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dbf": {
    source: "iana",
    extensions: [
      "dbf"
    ]
  },
  "application/vnd.debian.binary-package": {
    source: "iana"
  },
  "application/vnd.dece.data": {
    source: "iana",
    extensions: [
      "uvf",
      "uvvf",
      "uvd",
      "uvvd"
    ]
  },
  "application/vnd.dece.ttml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "uvt",
      "uvvt"
    ]
  },
  "application/vnd.dece.unspecified": {
    source: "iana",
    extensions: [
      "uvx",
      "uvvx"
    ]
  },
  "application/vnd.dece.zip": {
    source: "iana",
    extensions: [
      "uvz",
      "uvvz"
    ]
  },
  "application/vnd.denovo.fcselayout-link": {
    source: "iana",
    extensions: [
      "fe_launch"
    ]
  },
  "application/vnd.desmume.movie": {
    source: "iana"
  },
  "application/vnd.dir-bi.plate-dl-nosuffix": {
    source: "iana"
  },
  "application/vnd.dm.delegation+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dna": {
    source: "iana",
    extensions: [
      "dna"
    ]
  },
  "application/vnd.document+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dolby.mlp": {
    source: "apache",
    extensions: [
      "mlp"
    ]
  },
  "application/vnd.dolby.mobile.1": {
    source: "iana"
  },
  "application/vnd.dolby.mobile.2": {
    source: "iana"
  },
  "application/vnd.doremir.scorecloud-binary-document": {
    source: "iana"
  },
  "application/vnd.dpgraph": {
    source: "iana",
    extensions: [
      "dpg"
    ]
  },
  "application/vnd.dreamfactory": {
    source: "iana",
    extensions: [
      "dfac"
    ]
  },
  "application/vnd.drive+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ds-keypoint": {
    source: "apache",
    extensions: [
      "kpxx"
    ]
  },
  "application/vnd.dtg.local": {
    source: "iana"
  },
  "application/vnd.dtg.local.flash": {
    source: "iana"
  },
  "application/vnd.dtg.local.html": {
    source: "iana"
  },
  "application/vnd.dvb.ait": {
    source: "iana",
    extensions: [
      "ait"
    ]
  },
  "application/vnd.dvb.dvbisl+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.dvbj": {
    source: "iana"
  },
  "application/vnd.dvb.esgcontainer": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcdftnotifaccess": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcesgaccess": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcesgaccess2": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcesgpdd": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcroaming": {
    source: "iana"
  },
  "application/vnd.dvb.iptv.alfec-base": {
    source: "iana"
  },
  "application/vnd.dvb.iptv.alfec-enhancement": {
    source: "iana"
  },
  "application/vnd.dvb.notif-aggregate-root+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-container+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-generic+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-ia-msglist+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-ia-registration-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-ia-registration-response+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-init+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.pfr": {
    source: "iana"
  },
  "application/vnd.dvb.service": {
    source: "iana",
    extensions: [
      "svc"
    ]
  },
  "application/vnd.dxr": {
    source: "iana"
  },
  "application/vnd.dynageo": {
    source: "iana",
    extensions: [
      "geo"
    ]
  },
  "application/vnd.dzr": {
    source: "iana"
  },
  "application/vnd.easykaraoke.cdgdownload": {
    source: "iana"
  },
  "application/vnd.ecdis-update": {
    source: "iana"
  },
  "application/vnd.ecip.rlp": {
    source: "iana"
  },
  "application/vnd.eclipse.ditto+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ecowin.chart": {
    source: "iana",
    extensions: [
      "mag"
    ]
  },
  "application/vnd.ecowin.filerequest": {
    source: "iana"
  },
  "application/vnd.ecowin.fileupdate": {
    source: "iana"
  },
  "application/vnd.ecowin.series": {
    source: "iana"
  },
  "application/vnd.ecowin.seriesrequest": {
    source: "iana"
  },
  "application/vnd.ecowin.seriesupdate": {
    source: "iana"
  },
  "application/vnd.efi.img": {
    source: "iana"
  },
  "application/vnd.efi.iso": {
    source: "iana"
  },
  "application/vnd.emclient.accessrequest+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.enliven": {
    source: "iana",
    extensions: [
      "nml"
    ]
  },
  "application/vnd.enphase.envoy": {
    source: "iana"
  },
  "application/vnd.eprints.data+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.epson.esf": {
    source: "iana",
    extensions: [
      "esf"
    ]
  },
  "application/vnd.epson.msf": {
    source: "iana",
    extensions: [
      "msf"
    ]
  },
  "application/vnd.epson.quickanime": {
    source: "iana",
    extensions: [
      "qam"
    ]
  },
  "application/vnd.epson.salt": {
    source: "iana",
    extensions: [
      "slt"
    ]
  },
  "application/vnd.epson.ssf": {
    source: "iana",
    extensions: [
      "ssf"
    ]
  },
  "application/vnd.ericsson.quickcall": {
    source: "iana"
  },
  "application/vnd.espass-espass+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.eszigno3+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "es3",
      "et3"
    ]
  },
  "application/vnd.etsi.aoc+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.asic-e+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.etsi.asic-s+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.etsi.cug+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvcommand+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvdiscovery+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvprofile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvsad-bc+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvsad-cod+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvsad-npvr+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvservice+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvsync+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvueprofile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.mcid+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.mheg5": {
    source: "iana"
  },
  "application/vnd.etsi.overload-control-policy-dataset+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.pstn+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.sci+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.simservs+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.timestamp-token": {
    source: "iana"
  },
  "application/vnd.etsi.tsl+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.tsl.der": {
    source: "iana"
  },
  "application/vnd.eu.kasparian.car+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.eudora.data": {
    source: "iana"
  },
  "application/vnd.evolv.ecig.profile": {
    source: "iana"
  },
  "application/vnd.evolv.ecig.settings": {
    source: "iana"
  },
  "application/vnd.evolv.ecig.theme": {
    source: "iana"
  },
  "application/vnd.exstream-empower+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.exstream-package": {
    source: "iana"
  },
  "application/vnd.ezpix-album": {
    source: "iana",
    extensions: [
      "ez2"
    ]
  },
  "application/vnd.ezpix-package": {
    source: "iana",
    extensions: [
      "ez3"
    ]
  },
  "application/vnd.f-secure.mobile": {
    source: "iana"
  },
  "application/vnd.familysearch.gedcom+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.fastcopy-disk-image": {
    source: "iana"
  },
  "application/vnd.fdf": {
    source: "iana",
    extensions: [
      "fdf"
    ]
  },
  "application/vnd.fdsn.mseed": {
    source: "iana",
    extensions: [
      "mseed"
    ]
  },
  "application/vnd.fdsn.seed": {
    source: "iana",
    extensions: [
      "seed",
      "dataless"
    ]
  },
  "application/vnd.ffsns": {
    source: "iana"
  },
  "application/vnd.ficlab.flb+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.filmit.zfc": {
    source: "iana"
  },
  "application/vnd.fints": {
    source: "iana"
  },
  "application/vnd.firemonkeys.cloudcell": {
    source: "iana"
  },
  "application/vnd.flographit": {
    source: "iana",
    extensions: [
      "gph"
    ]
  },
  "application/vnd.fluxtime.clip": {
    source: "iana",
    extensions: [
      "ftc"
    ]
  },
  "application/vnd.font-fontforge-sfd": {
    source: "iana"
  },
  "application/vnd.framemaker": {
    source: "iana",
    extensions: [
      "fm",
      "frame",
      "maker",
      "book"
    ]
  },
  "application/vnd.frogans.fnc": {
    source: "iana",
    extensions: [
      "fnc"
    ]
  },
  "application/vnd.frogans.ltf": {
    source: "iana",
    extensions: [
      "ltf"
    ]
  },
  "application/vnd.fsc.weblaunch": {
    source: "iana",
    extensions: [
      "fsc"
    ]
  },
  "application/vnd.fujifilm.fb.docuworks": {
    source: "iana"
  },
  "application/vnd.fujifilm.fb.docuworks.binder": {
    source: "iana"
  },
  "application/vnd.fujifilm.fb.docuworks.container": {
    source: "iana"
  },
  "application/vnd.fujifilm.fb.jfi+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.fujitsu.oasys": {
    source: "iana",
    extensions: [
      "oas"
    ]
  },
  "application/vnd.fujitsu.oasys2": {
    source: "iana",
    extensions: [
      "oa2"
    ]
  },
  "application/vnd.fujitsu.oasys3": {
    source: "iana",
    extensions: [
      "oa3"
    ]
  },
  "application/vnd.fujitsu.oasysgp": {
    source: "iana",
    extensions: [
      "fg5"
    ]
  },
  "application/vnd.fujitsu.oasysprs": {
    source: "iana",
    extensions: [
      "bh2"
    ]
  },
  "application/vnd.fujixerox.art-ex": {
    source: "iana"
  },
  "application/vnd.fujixerox.art4": {
    source: "iana"
  },
  "application/vnd.fujixerox.ddd": {
    source: "iana",
    extensions: [
      "ddd"
    ]
  },
  "application/vnd.fujixerox.docuworks": {
    source: "iana",
    extensions: [
      "xdw"
    ]
  },
  "application/vnd.fujixerox.docuworks.binder": {
    source: "iana",
    extensions: [
      "xbd"
    ]
  },
  "application/vnd.fujixerox.docuworks.container": {
    source: "iana"
  },
  "application/vnd.fujixerox.hbpl": {
    source: "iana"
  },
  "application/vnd.fut-misnet": {
    source: "iana"
  },
  "application/vnd.futoin+cbor": {
    source: "iana"
  },
  "application/vnd.futoin+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.fuzzysheet": {
    source: "iana",
    extensions: [
      "fzs"
    ]
  },
  "application/vnd.genomatix.tuxedo": {
    source: "iana",
    extensions: [
      "txd"
    ]
  },
  "application/vnd.gentics.grd+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.geo+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.geocube+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.geogebra.file": {
    source: "iana",
    extensions: [
      "ggb"
    ]
  },
  "application/vnd.geogebra.slides": {
    source: "iana"
  },
  "application/vnd.geogebra.tool": {
    source: "iana",
    extensions: [
      "ggt"
    ]
  },
  "application/vnd.geometry-explorer": {
    source: "iana",
    extensions: [
      "gex",
      "gre"
    ]
  },
  "application/vnd.geonext": {
    source: "iana",
    extensions: [
      "gxt"
    ]
  },
  "application/vnd.geoplan": {
    source: "iana",
    extensions: [
      "g2w"
    ]
  },
  "application/vnd.geospace": {
    source: "iana",
    extensions: [
      "g3w"
    ]
  },
  "application/vnd.gerber": {
    source: "iana"
  },
  "application/vnd.globalplatform.card-content-mgt": {
    source: "iana"
  },
  "application/vnd.globalplatform.card-content-mgt-response": {
    source: "iana"
  },
  "application/vnd.gmx": {
    source: "iana",
    extensions: [
      "gmx"
    ]
  },
  "application/vnd.google-apps.document": {
    compressible: false,
    extensions: [
      "gdoc"
    ]
  },
  "application/vnd.google-apps.presentation": {
    compressible: false,
    extensions: [
      "gslides"
    ]
  },
  "application/vnd.google-apps.spreadsheet": {
    compressible: false,
    extensions: [
      "gsheet"
    ]
  },
  "application/vnd.google-earth.kml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "kml"
    ]
  },
  "application/vnd.google-earth.kmz": {
    source: "iana",
    compressible: false,
    extensions: [
      "kmz"
    ]
  },
  "application/vnd.gov.sk.e-form+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.gov.sk.e-form+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.gov.sk.xmldatacontainer+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.grafeq": {
    source: "iana",
    extensions: [
      "gqf",
      "gqs"
    ]
  },
  "application/vnd.gridmp": {
    source: "iana"
  },
  "application/vnd.groove-account": {
    source: "iana",
    extensions: [
      "gac"
    ]
  },
  "application/vnd.groove-help": {
    source: "iana",
    extensions: [
      "ghf"
    ]
  },
  "application/vnd.groove-identity-message": {
    source: "iana",
    extensions: [
      "gim"
    ]
  },
  "application/vnd.groove-injector": {
    source: "iana",
    extensions: [
      "grv"
    ]
  },
  "application/vnd.groove-tool-message": {
    source: "iana",
    extensions: [
      "gtm"
    ]
  },
  "application/vnd.groove-tool-template": {
    source: "iana",
    extensions: [
      "tpl"
    ]
  },
  "application/vnd.groove-vcard": {
    source: "iana",
    extensions: [
      "vcg"
    ]
  },
  "application/vnd.hal+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hal+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "hal"
    ]
  },
  "application/vnd.handheld-entertainment+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "zmm"
    ]
  },
  "application/vnd.hbci": {
    source: "iana",
    extensions: [
      "hbci"
    ]
  },
  "application/vnd.hc+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hcl-bireports": {
    source: "iana"
  },
  "application/vnd.hdt": {
    source: "iana"
  },
  "application/vnd.heroku+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hhe.lesson-player": {
    source: "iana",
    extensions: [
      "les"
    ]
  },
  "application/vnd.hl7cda+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/vnd.hl7v2+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/vnd.hp-hpgl": {
    source: "iana",
    extensions: [
      "hpgl"
    ]
  },
  "application/vnd.hp-hpid": {
    source: "iana",
    extensions: [
      "hpid"
    ]
  },
  "application/vnd.hp-hps": {
    source: "iana",
    extensions: [
      "hps"
    ]
  },
  "application/vnd.hp-jlyt": {
    source: "iana",
    extensions: [
      "jlt"
    ]
  },
  "application/vnd.hp-pcl": {
    source: "iana",
    extensions: [
      "pcl"
    ]
  },
  "application/vnd.hp-pclxl": {
    source: "iana",
    extensions: [
      "pclxl"
    ]
  },
  "application/vnd.httphone": {
    source: "iana"
  },
  "application/vnd.hydrostatix.sof-data": {
    source: "iana",
    extensions: [
      "sfd-hdstx"
    ]
  },
  "application/vnd.hyper+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hyper-item+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hyperdrive+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hzn-3d-crossword": {
    source: "iana"
  },
  "application/vnd.ibm.afplinedata": {
    source: "iana"
  },
  "application/vnd.ibm.electronic-media": {
    source: "iana"
  },
  "application/vnd.ibm.minipay": {
    source: "iana",
    extensions: [
      "mpy"
    ]
  },
  "application/vnd.ibm.modcap": {
    source: "iana",
    extensions: [
      "afp",
      "listafp",
      "list3820"
    ]
  },
  "application/vnd.ibm.rights-management": {
    source: "iana",
    extensions: [
      "irm"
    ]
  },
  "application/vnd.ibm.secure-container": {
    source: "iana",
    extensions: [
      "sc"
    ]
  },
  "application/vnd.iccprofile": {
    source: "iana",
    extensions: [
      "icc",
      "icm"
    ]
  },
  "application/vnd.ieee.1905": {
    source: "iana"
  },
  "application/vnd.igloader": {
    source: "iana",
    extensions: [
      "igl"
    ]
  },
  "application/vnd.imagemeter.folder+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.imagemeter.image+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.immervision-ivp": {
    source: "iana",
    extensions: [
      "ivp"
    ]
  },
  "application/vnd.immervision-ivu": {
    source: "iana",
    extensions: [
      "ivu"
    ]
  },
  "application/vnd.ims.imsccv1p1": {
    source: "iana"
  },
  "application/vnd.ims.imsccv1p2": {
    source: "iana"
  },
  "application/vnd.ims.imsccv1p3": {
    source: "iana"
  },
  "application/vnd.ims.lis.v2.result+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ims.lti.v2.toolproxy+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ims.lti.v2.toolproxy.id+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ims.lti.v2.toolsettings+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ims.lti.v2.toolsettings.simple+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.informedcontrol.rms+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.informix-visionary": {
    source: "iana"
  },
  "application/vnd.infotech.project": {
    source: "iana"
  },
  "application/vnd.infotech.project+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.innopath.wamp.notification": {
    source: "iana"
  },
  "application/vnd.insors.igm": {
    source: "iana",
    extensions: [
      "igm"
    ]
  },
  "application/vnd.intercon.formnet": {
    source: "iana",
    extensions: [
      "xpw",
      "xpx"
    ]
  },
  "application/vnd.intergeo": {
    source: "iana",
    extensions: [
      "i2g"
    ]
  },
  "application/vnd.intertrust.digibox": {
    source: "iana"
  },
  "application/vnd.intertrust.nncp": {
    source: "iana"
  },
  "application/vnd.intu.qbo": {
    source: "iana",
    extensions: [
      "qbo"
    ]
  },
  "application/vnd.intu.qfx": {
    source: "iana",
    extensions: [
      "qfx"
    ]
  },
  "application/vnd.iptc.g2.catalogitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.conceptitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.knowledgeitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.newsitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.newsmessage+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.packageitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.planningitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ipunplugged.rcprofile": {
    source: "iana",
    extensions: [
      "rcprofile"
    ]
  },
  "application/vnd.irepository.package+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "irp"
    ]
  },
  "application/vnd.is-xpr": {
    source: "iana",
    extensions: [
      "xpr"
    ]
  },
  "application/vnd.isac.fcs": {
    source: "iana",
    extensions: [
      "fcs"
    ]
  },
  "application/vnd.iso11783-10+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.jam": {
    source: "iana",
    extensions: [
      "jam"
    ]
  },
  "application/vnd.japannet-directory-service": {
    source: "iana"
  },
  "application/vnd.japannet-jpnstore-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-payment-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-registration": {
    source: "iana"
  },
  "application/vnd.japannet-registration-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-setstore-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-verification": {
    source: "iana"
  },
  "application/vnd.japannet-verification-wakeup": {
    source: "iana"
  },
  "application/vnd.jcp.javame.midlet-rms": {
    source: "iana",
    extensions: [
      "rms"
    ]
  },
  "application/vnd.jisp": {
    source: "iana",
    extensions: [
      "jisp"
    ]
  },
  "application/vnd.joost.joda-archive": {
    source: "iana",
    extensions: [
      "joda"
    ]
  },
  "application/vnd.jsk.isdn-ngn": {
    source: "iana"
  },
  "application/vnd.kahootz": {
    source: "iana",
    extensions: [
      "ktz",
      "ktr"
    ]
  },
  "application/vnd.kde.karbon": {
    source: "iana",
    extensions: [
      "karbon"
    ]
  },
  "application/vnd.kde.kchart": {
    source: "iana",
    extensions: [
      "chrt"
    ]
  },
  "application/vnd.kde.kformula": {
    source: "iana",
    extensions: [
      "kfo"
    ]
  },
  "application/vnd.kde.kivio": {
    source: "iana",
    extensions: [
      "flw"
    ]
  },
  "application/vnd.kde.kontour": {
    source: "iana",
    extensions: [
      "kon"
    ]
  },
  "application/vnd.kde.kpresenter": {
    source: "iana",
    extensions: [
      "kpr",
      "kpt"
    ]
  },
  "application/vnd.kde.kspread": {
    source: "iana",
    extensions: [
      "ksp"
    ]
  },
  "application/vnd.kde.kword": {
    source: "iana",
    extensions: [
      "kwd",
      "kwt"
    ]
  },
  "application/vnd.kenameaapp": {
    source: "iana",
    extensions: [
      "htke"
    ]
  },
  "application/vnd.kidspiration": {
    source: "iana",
    extensions: [
      "kia"
    ]
  },
  "application/vnd.kinar": {
    source: "iana",
    extensions: [
      "kne",
      "knp"
    ]
  },
  "application/vnd.koan": {
    source: "iana",
    extensions: [
      "skp",
      "skd",
      "skt",
      "skm"
    ]
  },
  "application/vnd.kodak-descriptor": {
    source: "iana",
    extensions: [
      "sse"
    ]
  },
  "application/vnd.las": {
    source: "iana"
  },
  "application/vnd.las.las+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.las.las+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "lasxml"
    ]
  },
  "application/vnd.laszip": {
    source: "iana"
  },
  "application/vnd.leap+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.liberty-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.llamagraphics.life-balance.desktop": {
    source: "iana",
    extensions: [
      "lbd"
    ]
  },
  "application/vnd.llamagraphics.life-balance.exchange+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "lbe"
    ]
  },
  "application/vnd.logipipe.circuit+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.loom": {
    source: "iana"
  },
  "application/vnd.lotus-1-2-3": {
    source: "iana",
    extensions: [
      "123"
    ]
  },
  "application/vnd.lotus-approach": {
    source: "iana",
    extensions: [
      "apr"
    ]
  },
  "application/vnd.lotus-freelance": {
    source: "iana",
    extensions: [
      "pre"
    ]
  },
  "application/vnd.lotus-notes": {
    source: "iana",
    extensions: [
      "nsf"
    ]
  },
  "application/vnd.lotus-organizer": {
    source: "iana",
    extensions: [
      "org"
    ]
  },
  "application/vnd.lotus-screencam": {
    source: "iana",
    extensions: [
      "scm"
    ]
  },
  "application/vnd.lotus-wordpro": {
    source: "iana",
    extensions: [
      "lwp"
    ]
  },
  "application/vnd.macports.portpkg": {
    source: "iana",
    extensions: [
      "portpkg"
    ]
  },
  "application/vnd.mapbox-vector-tile": {
    source: "iana",
    extensions: [
      "mvt"
    ]
  },
  "application/vnd.marlin.drm.actiontoken+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.marlin.drm.conftoken+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.marlin.drm.license+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.marlin.drm.mdcf": {
    source: "iana"
  },
  "application/vnd.mason+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.maxar.archive.3tz+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.maxmind.maxmind-db": {
    source: "iana"
  },
  "application/vnd.mcd": {
    source: "iana",
    extensions: [
      "mcd"
    ]
  },
  "application/vnd.medcalcdata": {
    source: "iana",
    extensions: [
      "mc1"
    ]
  },
  "application/vnd.mediastation.cdkey": {
    source: "iana",
    extensions: [
      "cdkey"
    ]
  },
  "application/vnd.meridian-slingshot": {
    source: "iana"
  },
  "application/vnd.mfer": {
    source: "iana",
    extensions: [
      "mwf"
    ]
  },
  "application/vnd.mfmp": {
    source: "iana",
    extensions: [
      "mfm"
    ]
  },
  "application/vnd.micro+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.micrografx.flo": {
    source: "iana",
    extensions: [
      "flo"
    ]
  },
  "application/vnd.micrografx.igx": {
    source: "iana",
    extensions: [
      "igx"
    ]
  },
  "application/vnd.microsoft.portable-executable": {
    source: "iana"
  },
  "application/vnd.microsoft.windows.thumbnail-cache": {
    source: "iana"
  },
  "application/vnd.miele+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.mif": {
    source: "iana",
    extensions: [
      "mif"
    ]
  },
  "application/vnd.minisoft-hp3000-save": {
    source: "iana"
  },
  "application/vnd.mitsubishi.misty-guard.trustweb": {
    source: "iana"
  },
  "application/vnd.mobius.daf": {
    source: "iana",
    extensions: [
      "daf"
    ]
  },
  "application/vnd.mobius.dis": {
    source: "iana",
    extensions: [
      "dis"
    ]
  },
  "application/vnd.mobius.mbk": {
    source: "iana",
    extensions: [
      "mbk"
    ]
  },
  "application/vnd.mobius.mqy": {
    source: "iana",
    extensions: [
      "mqy"
    ]
  },
  "application/vnd.mobius.msl": {
    source: "iana",
    extensions: [
      "msl"
    ]
  },
  "application/vnd.mobius.plc": {
    source: "iana",
    extensions: [
      "plc"
    ]
  },
  "application/vnd.mobius.txf": {
    source: "iana",
    extensions: [
      "txf"
    ]
  },
  "application/vnd.mophun.application": {
    source: "iana",
    extensions: [
      "mpn"
    ]
  },
  "application/vnd.mophun.certificate": {
    source: "iana",
    extensions: [
      "mpc"
    ]
  },
  "application/vnd.motorola.flexsuite": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.adsi": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.fis": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.gotap": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.kmr": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.ttc": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.wem": {
    source: "iana"
  },
  "application/vnd.motorola.iprm": {
    source: "iana"
  },
  "application/vnd.mozilla.xul+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xul"
    ]
  },
  "application/vnd.ms-3mfdocument": {
    source: "iana"
  },
  "application/vnd.ms-artgalry": {
    source: "iana",
    extensions: [
      "cil"
    ]
  },
  "application/vnd.ms-asf": {
    source: "iana"
  },
  "application/vnd.ms-cab-compressed": {
    source: "iana",
    extensions: [
      "cab"
    ]
  },
  "application/vnd.ms-color.iccprofile": {
    source: "apache"
  },
  "application/vnd.ms-excel": {
    source: "iana",
    compressible: false,
    extensions: [
      "xls",
      "xlm",
      "xla",
      "xlc",
      "xlt",
      "xlw"
    ]
  },
  "application/vnd.ms-excel.addin.macroenabled.12": {
    source: "iana",
    extensions: [
      "xlam"
    ]
  },
  "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
    source: "iana",
    extensions: [
      "xlsb"
    ]
  },
  "application/vnd.ms-excel.sheet.macroenabled.12": {
    source: "iana",
    extensions: [
      "xlsm"
    ]
  },
  "application/vnd.ms-excel.template.macroenabled.12": {
    source: "iana",
    extensions: [
      "xltm"
    ]
  },
  "application/vnd.ms-fontobject": {
    source: "iana",
    compressible: true,
    extensions: [
      "eot"
    ]
  },
  "application/vnd.ms-htmlhelp": {
    source: "iana",
    extensions: [
      "chm"
    ]
  },
  "application/vnd.ms-ims": {
    source: "iana",
    extensions: [
      "ims"
    ]
  },
  "application/vnd.ms-lrm": {
    source: "iana",
    extensions: [
      "lrm"
    ]
  },
  "application/vnd.ms-office.activex+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ms-officetheme": {
    source: "iana",
    extensions: [
      "thmx"
    ]
  },
  "application/vnd.ms-opentype": {
    source: "apache",
    compressible: true
  },
  "application/vnd.ms-outlook": {
    compressible: false,
    extensions: [
      "msg"
    ]
  },
  "application/vnd.ms-package.obfuscated-opentype": {
    source: "apache"
  },
  "application/vnd.ms-pki.seccat": {
    source: "apache",
    extensions: [
      "cat"
    ]
  },
  "application/vnd.ms-pki.stl": {
    source: "apache",
    extensions: [
      "stl"
    ]
  },
  "application/vnd.ms-playready.initiator+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ms-powerpoint": {
    source: "iana",
    compressible: false,
    extensions: [
      "ppt",
      "pps",
      "pot"
    ]
  },
  "application/vnd.ms-powerpoint.addin.macroenabled.12": {
    source: "iana",
    extensions: [
      "ppam"
    ]
  },
  "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
    source: "iana",
    extensions: [
      "pptm"
    ]
  },
  "application/vnd.ms-powerpoint.slide.macroenabled.12": {
    source: "iana",
    extensions: [
      "sldm"
    ]
  },
  "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
    source: "iana",
    extensions: [
      "ppsm"
    ]
  },
  "application/vnd.ms-powerpoint.template.macroenabled.12": {
    source: "iana",
    extensions: [
      "potm"
    ]
  },
  "application/vnd.ms-printdevicecapabilities+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ms-printing.printticket+xml": {
    source: "apache",
    compressible: true
  },
  "application/vnd.ms-printschematicket+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ms-project": {
    source: "iana",
    extensions: [
      "mpp",
      "mpt"
    ]
  },
  "application/vnd.ms-tnef": {
    source: "iana"
  },
  "application/vnd.ms-windows.devicepairing": {
    source: "iana"
  },
  "application/vnd.ms-windows.nwprinting.oob": {
    source: "iana"
  },
  "application/vnd.ms-windows.printerpairing": {
    source: "iana"
  },
  "application/vnd.ms-windows.wsd.oob": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.lic-chlg-req": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.lic-resp": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.meter-chlg-req": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.meter-resp": {
    source: "iana"
  },
  "application/vnd.ms-word.document.macroenabled.12": {
    source: "iana",
    extensions: [
      "docm"
    ]
  },
  "application/vnd.ms-word.template.macroenabled.12": {
    source: "iana",
    extensions: [
      "dotm"
    ]
  },
  "application/vnd.ms-works": {
    source: "iana",
    extensions: [
      "wps",
      "wks",
      "wcm",
      "wdb"
    ]
  },
  "application/vnd.ms-wpl": {
    source: "iana",
    extensions: [
      "wpl"
    ]
  },
  "application/vnd.ms-xpsdocument": {
    source: "iana",
    compressible: false,
    extensions: [
      "xps"
    ]
  },
  "application/vnd.msa-disk-image": {
    source: "iana"
  },
  "application/vnd.mseq": {
    source: "iana",
    extensions: [
      "mseq"
    ]
  },
  "application/vnd.msign": {
    source: "iana"
  },
  "application/vnd.multiad.creator": {
    source: "iana"
  },
  "application/vnd.multiad.creator.cif": {
    source: "iana"
  },
  "application/vnd.music-niff": {
    source: "iana"
  },
  "application/vnd.musician": {
    source: "iana",
    extensions: [
      "mus"
    ]
  },
  "application/vnd.muvee.style": {
    source: "iana",
    extensions: [
      "msty"
    ]
  },
  "application/vnd.mynfc": {
    source: "iana",
    extensions: [
      "taglet"
    ]
  },
  "application/vnd.nacamar.ybrid+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ncd.control": {
    source: "iana"
  },
  "application/vnd.ncd.reference": {
    source: "iana"
  },
  "application/vnd.nearst.inv+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nebumind.line": {
    source: "iana"
  },
  "application/vnd.nervana": {
    source: "iana"
  },
  "application/vnd.netfpx": {
    source: "iana"
  },
  "application/vnd.neurolanguage.nlu": {
    source: "iana",
    extensions: [
      "nlu"
    ]
  },
  "application/vnd.nimn": {
    source: "iana"
  },
  "application/vnd.nintendo.nitro.rom": {
    source: "iana"
  },
  "application/vnd.nintendo.snes.rom": {
    source: "iana"
  },
  "application/vnd.nitf": {
    source: "iana",
    extensions: [
      "ntf",
      "nitf"
    ]
  },
  "application/vnd.noblenet-directory": {
    source: "iana",
    extensions: [
      "nnd"
    ]
  },
  "application/vnd.noblenet-sealer": {
    source: "iana",
    extensions: [
      "nns"
    ]
  },
  "application/vnd.noblenet-web": {
    source: "iana",
    extensions: [
      "nnw"
    ]
  },
  "application/vnd.nokia.catalogs": {
    source: "iana"
  },
  "application/vnd.nokia.conml+wbxml": {
    source: "iana"
  },
  "application/vnd.nokia.conml+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nokia.iptv.config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nokia.isds-radio-presets": {
    source: "iana"
  },
  "application/vnd.nokia.landmark+wbxml": {
    source: "iana"
  },
  "application/vnd.nokia.landmark+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nokia.landmarkcollection+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nokia.n-gage.ac+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "ac"
    ]
  },
  "application/vnd.nokia.n-gage.data": {
    source: "iana",
    extensions: [
      "ngdat"
    ]
  },
  "application/vnd.nokia.n-gage.symbian.install": {
    source: "iana",
    extensions: [
      "n-gage"
    ]
  },
  "application/vnd.nokia.ncd": {
    source: "iana"
  },
  "application/vnd.nokia.pcd+wbxml": {
    source: "iana"
  },
  "application/vnd.nokia.pcd+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nokia.radio-preset": {
    source: "iana",
    extensions: [
      "rpst"
    ]
  },
  "application/vnd.nokia.radio-presets": {
    source: "iana",
    extensions: [
      "rpss"
    ]
  },
  "application/vnd.novadigm.edm": {
    source: "iana",
    extensions: [
      "edm"
    ]
  },
  "application/vnd.novadigm.edx": {
    source: "iana",
    extensions: [
      "edx"
    ]
  },
  "application/vnd.novadigm.ext": {
    source: "iana",
    extensions: [
      "ext"
    ]
  },
  "application/vnd.ntt-local.content-share": {
    source: "iana"
  },
  "application/vnd.ntt-local.file-transfer": {
    source: "iana"
  },
  "application/vnd.ntt-local.ogw_remote-access": {
    source: "iana"
  },
  "application/vnd.ntt-local.sip-ta_remote": {
    source: "iana"
  },
  "application/vnd.ntt-local.sip-ta_tcp_stream": {
    source: "iana"
  },
  "application/vnd.oasis.opendocument.chart": {
    source: "iana",
    extensions: [
      "odc"
    ]
  },
  "application/vnd.oasis.opendocument.chart-template": {
    source: "iana",
    extensions: [
      "otc"
    ]
  },
  "application/vnd.oasis.opendocument.database": {
    source: "iana",
    extensions: [
      "odb"
    ]
  },
  "application/vnd.oasis.opendocument.formula": {
    source: "iana",
    extensions: [
      "odf"
    ]
  },
  "application/vnd.oasis.opendocument.formula-template": {
    source: "iana",
    extensions: [
      "odft"
    ]
  },
  "application/vnd.oasis.opendocument.graphics": {
    source: "iana",
    compressible: false,
    extensions: [
      "odg"
    ]
  },
  "application/vnd.oasis.opendocument.graphics-template": {
    source: "iana",
    extensions: [
      "otg"
    ]
  },
  "application/vnd.oasis.opendocument.image": {
    source: "iana",
    extensions: [
      "odi"
    ]
  },
  "application/vnd.oasis.opendocument.image-template": {
    source: "iana",
    extensions: [
      "oti"
    ]
  },
  "application/vnd.oasis.opendocument.presentation": {
    source: "iana",
    compressible: false,
    extensions: [
      "odp"
    ]
  },
  "application/vnd.oasis.opendocument.presentation-template": {
    source: "iana",
    extensions: [
      "otp"
    ]
  },
  "application/vnd.oasis.opendocument.spreadsheet": {
    source: "iana",
    compressible: false,
    extensions: [
      "ods"
    ]
  },
  "application/vnd.oasis.opendocument.spreadsheet-template": {
    source: "iana",
    extensions: [
      "ots"
    ]
  },
  "application/vnd.oasis.opendocument.text": {
    source: "iana",
    compressible: false,
    extensions: [
      "odt"
    ]
  },
  "application/vnd.oasis.opendocument.text-master": {
    source: "iana",
    extensions: [
      "odm"
    ]
  },
  "application/vnd.oasis.opendocument.text-template": {
    source: "iana",
    extensions: [
      "ott"
    ]
  },
  "application/vnd.oasis.opendocument.text-web": {
    source: "iana",
    extensions: [
      "oth"
    ]
  },
  "application/vnd.obn": {
    source: "iana"
  },
  "application/vnd.ocf+cbor": {
    source: "iana"
  },
  "application/vnd.oci.image.manifest.v1+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oftn.l10n+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.contentaccessdownload+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.contentaccessstreaming+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.cspg-hexbinary": {
    source: "iana"
  },
  "application/vnd.oipf.dae.svg+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.dae.xhtml+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.mippvcontrolmessage+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.pae.gem": {
    source: "iana"
  },
  "application/vnd.oipf.spdiscovery+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.spdlist+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.ueprofile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.userprofile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.olpc-sugar": {
    source: "iana",
    extensions: [
      "xo"
    ]
  },
  "application/vnd.oma-scws-config": {
    source: "iana"
  },
  "application/vnd.oma-scws-http-request": {
    source: "iana"
  },
  "application/vnd.oma-scws-http-response": {
    source: "iana"
  },
  "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.drm-trigger+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.imd+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.ltkm": {
    source: "iana"
  },
  "application/vnd.oma.bcast.notification+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.provisioningtrigger": {
    source: "iana"
  },
  "application/vnd.oma.bcast.sgboot": {
    source: "iana"
  },
  "application/vnd.oma.bcast.sgdd+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.sgdu": {
    source: "iana"
  },
  "application/vnd.oma.bcast.simple-symbol-container": {
    source: "iana"
  },
  "application/vnd.oma.bcast.smartcard-trigger+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.sprov+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.stkm": {
    source: "iana"
  },
  "application/vnd.oma.cab-address-book+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.cab-feature-handler+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.cab-pcc+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.cab-subs-invite+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.cab-user-prefs+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.dcd": {
    source: "iana"
  },
  "application/vnd.oma.dcdc": {
    source: "iana"
  },
  "application/vnd.oma.dd2+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "dd2"
    ]
  },
  "application/vnd.oma.drm.risd+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.group-usage-list+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.lwm2m+cbor": {
    source: "iana"
  },
  "application/vnd.oma.lwm2m+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.lwm2m+tlv": {
    source: "iana"
  },
  "application/vnd.oma.pal+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.poc.detailed-progress-report+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.poc.final-report+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.poc.groups+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.poc.invocation-descriptor+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.poc.optimized-progress-report+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.push": {
    source: "iana"
  },
  "application/vnd.oma.scidm.messages+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.xcap-directory+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.omads-email+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/vnd.omads-file+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/vnd.omads-folder+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/vnd.omaloc-supl-init": {
    source: "iana"
  },
  "application/vnd.onepager": {
    source: "iana"
  },
  "application/vnd.onepagertamp": {
    source: "iana"
  },
  "application/vnd.onepagertamx": {
    source: "iana"
  },
  "application/vnd.onepagertat": {
    source: "iana"
  },
  "application/vnd.onepagertatp": {
    source: "iana"
  },
  "application/vnd.onepagertatx": {
    source: "iana"
  },
  "application/vnd.openblox.game+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "obgx"
    ]
  },
  "application/vnd.openblox.game-binary": {
    source: "iana"
  },
  "application/vnd.openeye.oeb": {
    source: "iana"
  },
  "application/vnd.openofficeorg.extension": {
    source: "apache",
    extensions: [
      "oxt"
    ]
  },
  "application/vnd.openstreetmap.data+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "osm"
    ]
  },
  "application/vnd.opentimestamps.ots": {
    source: "iana"
  },
  "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawing+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
    source: "iana",
    compressible: false,
    extensions: [
      "pptx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slide": {
    source: "iana",
    extensions: [
      "sldx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
    source: "iana",
    extensions: [
      "ppsx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.template": {
    source: "iana",
    extensions: [
      "potx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
    source: "iana",
    compressible: false,
    extensions: [
      "xlsx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
    source: "iana",
    extensions: [
      "xltx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.theme+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.vmldrawing": {
    source: "iana"
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
    source: "iana",
    compressible: false,
    extensions: [
      "docx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
    source: "iana",
    extensions: [
      "dotx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-package.core-properties+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-package.relationships+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oracle.resource+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.orange.indata": {
    source: "iana"
  },
  "application/vnd.osa.netdeploy": {
    source: "iana"
  },
  "application/vnd.osgeo.mapguide.package": {
    source: "iana",
    extensions: [
      "mgp"
    ]
  },
  "application/vnd.osgi.bundle": {
    source: "iana"
  },
  "application/vnd.osgi.dp": {
    source: "iana",
    extensions: [
      "dp"
    ]
  },
  "application/vnd.osgi.subsystem": {
    source: "iana",
    extensions: [
      "esa"
    ]
  },
  "application/vnd.otps.ct-kip+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oxli.countgraph": {
    source: "iana"
  },
  "application/vnd.pagerduty+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.palm": {
    source: "iana",
    extensions: [
      "pdb",
      "pqa",
      "oprc"
    ]
  },
  "application/vnd.panoply": {
    source: "iana"
  },
  "application/vnd.paos.xml": {
    source: "iana"
  },
  "application/vnd.patentdive": {
    source: "iana"
  },
  "application/vnd.patientecommsdoc": {
    source: "iana"
  },
  "application/vnd.pawaafile": {
    source: "iana",
    extensions: [
      "paw"
    ]
  },
  "application/vnd.pcos": {
    source: "iana"
  },
  "application/vnd.pg.format": {
    source: "iana",
    extensions: [
      "str"
    ]
  },
  "application/vnd.pg.osasli": {
    source: "iana",
    extensions: [
      "ei6"
    ]
  },
  "application/vnd.piaccess.application-licence": {
    source: "iana"
  },
  "application/vnd.picsel": {
    source: "iana",
    extensions: [
      "efif"
    ]
  },
  "application/vnd.pmi.widget": {
    source: "iana",
    extensions: [
      "wg"
    ]
  },
  "application/vnd.poc.group-advertisement+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.pocketlearn": {
    source: "iana",
    extensions: [
      "plf"
    ]
  },
  "application/vnd.powerbuilder6": {
    source: "iana",
    extensions: [
      "pbd"
    ]
  },
  "application/vnd.powerbuilder6-s": {
    source: "iana"
  },
  "application/vnd.powerbuilder7": {
    source: "iana"
  },
  "application/vnd.powerbuilder7-s": {
    source: "iana"
  },
  "application/vnd.powerbuilder75": {
    source: "iana"
  },
  "application/vnd.powerbuilder75-s": {
    source: "iana"
  },
  "application/vnd.preminet": {
    source: "iana"
  },
  "application/vnd.previewsystems.box": {
    source: "iana",
    extensions: [
      "box"
    ]
  },
  "application/vnd.proteus.magazine": {
    source: "iana",
    extensions: [
      "mgz"
    ]
  },
  "application/vnd.psfs": {
    source: "iana"
  },
  "application/vnd.publishare-delta-tree": {
    source: "iana",
    extensions: [
      "qps"
    ]
  },
  "application/vnd.pvi.ptid1": {
    source: "iana",
    extensions: [
      "ptid"
    ]
  },
  "application/vnd.pwg-multiplexed": {
    source: "iana"
  },
  "application/vnd.pwg-xhtml-print+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.qualcomm.brew-app-res": {
    source: "iana"
  },
  "application/vnd.quarantainenet": {
    source: "iana"
  },
  "application/vnd.quark.quarkxpress": {
    source: "iana",
    extensions: [
      "qxd",
      "qxt",
      "qwd",
      "qwt",
      "qxl",
      "qxb"
    ]
  },
  "application/vnd.quobject-quoxdocument": {
    source: "iana"
  },
  "application/vnd.radisys.moml+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-audit+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-audit-conf+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-audit-conn+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-audit-dialog+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-audit-stream+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-conf+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-base+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-fax-detect+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-group+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-speech+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-transform+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.rainstor.data": {
    source: "iana"
  },
  "application/vnd.rapid": {
    source: "iana"
  },
  "application/vnd.rar": {
    source: "iana",
    extensions: [
      "rar"
    ]
  },
  "application/vnd.realvnc.bed": {
    source: "iana",
    extensions: [
      "bed"
    ]
  },
  "application/vnd.recordare.musicxml": {
    source: "iana",
    extensions: [
      "mxl"
    ]
  },
  "application/vnd.recordare.musicxml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "musicxml"
    ]
  },
  "application/vnd.renlearn.rlprint": {
    source: "iana"
  },
  "application/vnd.resilient.logic": {
    source: "iana"
  },
  "application/vnd.restful+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.rig.cryptonote": {
    source: "iana",
    extensions: [
      "cryptonote"
    ]
  },
  "application/vnd.rim.cod": {
    source: "apache",
    extensions: [
      "cod"
    ]
  },
  "application/vnd.rn-realmedia": {
    source: "apache",
    extensions: [
      "rm"
    ]
  },
  "application/vnd.rn-realmedia-vbr": {
    source: "apache",
    extensions: [
      "rmvb"
    ]
  },
  "application/vnd.route66.link66+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "link66"
    ]
  },
  "application/vnd.rs-274x": {
    source: "iana"
  },
  "application/vnd.ruckus.download": {
    source: "iana"
  },
  "application/vnd.s3sms": {
    source: "iana"
  },
  "application/vnd.sailingtracker.track": {
    source: "iana",
    extensions: [
      "st"
    ]
  },
  "application/vnd.sar": {
    source: "iana"
  },
  "application/vnd.sbm.cid": {
    source: "iana"
  },
  "application/vnd.sbm.mid2": {
    source: "iana"
  },
  "application/vnd.scribus": {
    source: "iana"
  },
  "application/vnd.sealed.3df": {
    source: "iana"
  },
  "application/vnd.sealed.csf": {
    source: "iana"
  },
  "application/vnd.sealed.doc": {
    source: "iana"
  },
  "application/vnd.sealed.eml": {
    source: "iana"
  },
  "application/vnd.sealed.mht": {
    source: "iana"
  },
  "application/vnd.sealed.net": {
    source: "iana"
  },
  "application/vnd.sealed.ppt": {
    source: "iana"
  },
  "application/vnd.sealed.tiff": {
    source: "iana"
  },
  "application/vnd.sealed.xls": {
    source: "iana"
  },
  "application/vnd.sealedmedia.softseal.html": {
    source: "iana"
  },
  "application/vnd.sealedmedia.softseal.pdf": {
    source: "iana"
  },
  "application/vnd.seemail": {
    source: "iana",
    extensions: [
      "see"
    ]
  },
  "application/vnd.seis+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.sema": {
    source: "iana",
    extensions: [
      "sema"
    ]
  },
  "application/vnd.semd": {
    source: "iana",
    extensions: [
      "semd"
    ]
  },
  "application/vnd.semf": {
    source: "iana",
    extensions: [
      "semf"
    ]
  },
  "application/vnd.shade-save-file": {
    source: "iana"
  },
  "application/vnd.shana.informed.formdata": {
    source: "iana",
    extensions: [
      "ifm"
    ]
  },
  "application/vnd.shana.informed.formtemplate": {
    source: "iana",
    extensions: [
      "itp"
    ]
  },
  "application/vnd.shana.informed.interchange": {
    source: "iana",
    extensions: [
      "iif"
    ]
  },
  "application/vnd.shana.informed.package": {
    source: "iana",
    extensions: [
      "ipk"
    ]
  },
  "application/vnd.shootproof+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.shopkick+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.shp": {
    source: "iana"
  },
  "application/vnd.shx": {
    source: "iana"
  },
  "application/vnd.sigrok.session": {
    source: "iana"
  },
  "application/vnd.simtech-mindmapper": {
    source: "iana",
    extensions: [
      "twd",
      "twds"
    ]
  },
  "application/vnd.siren+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.smaf": {
    source: "iana",
    extensions: [
      "mmf"
    ]
  },
  "application/vnd.smart.notebook": {
    source: "iana"
  },
  "application/vnd.smart.teacher": {
    source: "iana",
    extensions: [
      "teacher"
    ]
  },
  "application/vnd.snesdev-page-table": {
    source: "iana"
  },
  "application/vnd.software602.filler.form+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "fo"
    ]
  },
  "application/vnd.software602.filler.form-xml-zip": {
    source: "iana"
  },
  "application/vnd.solent.sdkm+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "sdkm",
      "sdkd"
    ]
  },
  "application/vnd.spotfire.dxp": {
    source: "iana",
    extensions: [
      "dxp"
    ]
  },
  "application/vnd.spotfire.sfs": {
    source: "iana",
    extensions: [
      "sfs"
    ]
  },
  "application/vnd.sqlite3": {
    source: "iana"
  },
  "application/vnd.sss-cod": {
    source: "iana"
  },
  "application/vnd.sss-dtf": {
    source: "iana"
  },
  "application/vnd.sss-ntf": {
    source: "iana"
  },
  "application/vnd.stardivision.calc": {
    source: "apache",
    extensions: [
      "sdc"
    ]
  },
  "application/vnd.stardivision.draw": {
    source: "apache",
    extensions: [
      "sda"
    ]
  },
  "application/vnd.stardivision.impress": {
    source: "apache",
    extensions: [
      "sdd"
    ]
  },
  "application/vnd.stardivision.math": {
    source: "apache",
    extensions: [
      "smf"
    ]
  },
  "application/vnd.stardivision.writer": {
    source: "apache",
    extensions: [
      "sdw",
      "vor"
    ]
  },
  "application/vnd.stardivision.writer-global": {
    source: "apache",
    extensions: [
      "sgl"
    ]
  },
  "application/vnd.stepmania.package": {
    source: "iana",
    extensions: [
      "smzip"
    ]
  },
  "application/vnd.stepmania.stepchart": {
    source: "iana",
    extensions: [
      "sm"
    ]
  },
  "application/vnd.street-stream": {
    source: "iana"
  },
  "application/vnd.sun.wadl+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "wadl"
    ]
  },
  "application/vnd.sun.xml.calc": {
    source: "apache",
    extensions: [
      "sxc"
    ]
  },
  "application/vnd.sun.xml.calc.template": {
    source: "apache",
    extensions: [
      "stc"
    ]
  },
  "application/vnd.sun.xml.draw": {
    source: "apache",
    extensions: [
      "sxd"
    ]
  },
  "application/vnd.sun.xml.draw.template": {
    source: "apache",
    extensions: [
      "std"
    ]
  },
  "application/vnd.sun.xml.impress": {
    source: "apache",
    extensions: [
      "sxi"
    ]
  },
  "application/vnd.sun.xml.impress.template": {
    source: "apache",
    extensions: [
      "sti"
    ]
  },
  "application/vnd.sun.xml.math": {
    source: "apache",
    extensions: [
      "sxm"
    ]
  },
  "application/vnd.sun.xml.writer": {
    source: "apache",
    extensions: [
      "sxw"
    ]
  },
  "application/vnd.sun.xml.writer.global": {
    source: "apache",
    extensions: [
      "sxg"
    ]
  },
  "application/vnd.sun.xml.writer.template": {
    source: "apache",
    extensions: [
      "stw"
    ]
  },
  "application/vnd.sus-calendar": {
    source: "iana",
    extensions: [
      "sus",
      "susp"
    ]
  },
  "application/vnd.svd": {
    source: "iana",
    extensions: [
      "svd"
    ]
  },
  "application/vnd.swiftview-ics": {
    source: "iana"
  },
  "application/vnd.sycle+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.syft+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.symbian.install": {
    source: "apache",
    extensions: [
      "sis",
      "sisx"
    ]
  },
  "application/vnd.syncml+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "xsm"
    ]
  },
  "application/vnd.syncml.dm+wbxml": {
    source: "iana",
    charset: "UTF-8",
    extensions: [
      "bdm"
    ]
  },
  "application/vnd.syncml.dm+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "xdm"
    ]
  },
  "application/vnd.syncml.dm.notification": {
    source: "iana"
  },
  "application/vnd.syncml.dmddf+wbxml": {
    source: "iana"
  },
  "application/vnd.syncml.dmddf+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "ddf"
    ]
  },
  "application/vnd.syncml.dmtnds+wbxml": {
    source: "iana"
  },
  "application/vnd.syncml.dmtnds+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/vnd.syncml.ds.notification": {
    source: "iana"
  },
  "application/vnd.tableschema+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.tao.intent-module-archive": {
    source: "iana",
    extensions: [
      "tao"
    ]
  },
  "application/vnd.tcpdump.pcap": {
    source: "iana",
    extensions: [
      "pcap",
      "cap",
      "dmp"
    ]
  },
  "application/vnd.think-cell.ppttc+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.tmd.mediaflex.api+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.tml": {
    source: "iana"
  },
  "application/vnd.tmobile-livetv": {
    source: "iana",
    extensions: [
      "tmo"
    ]
  },
  "application/vnd.tri.onesource": {
    source: "iana"
  },
  "application/vnd.trid.tpt": {
    source: "iana",
    extensions: [
      "tpt"
    ]
  },
  "application/vnd.triscape.mxs": {
    source: "iana",
    extensions: [
      "mxs"
    ]
  },
  "application/vnd.trueapp": {
    source: "iana",
    extensions: [
      "tra"
    ]
  },
  "application/vnd.truedoc": {
    source: "iana"
  },
  "application/vnd.ubisoft.webplayer": {
    source: "iana"
  },
  "application/vnd.ufdl": {
    source: "iana",
    extensions: [
      "ufd",
      "ufdl"
    ]
  },
  "application/vnd.uiq.theme": {
    source: "iana",
    extensions: [
      "utz"
    ]
  },
  "application/vnd.umajin": {
    source: "iana",
    extensions: [
      "umj"
    ]
  },
  "application/vnd.unity": {
    source: "iana",
    extensions: [
      "unityweb"
    ]
  },
  "application/vnd.uoml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "uoml"
    ]
  },
  "application/vnd.uplanet.alert": {
    source: "iana"
  },
  "application/vnd.uplanet.alert-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.bearer-choice": {
    source: "iana"
  },
  "application/vnd.uplanet.bearer-choice-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.cacheop": {
    source: "iana"
  },
  "application/vnd.uplanet.cacheop-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.channel": {
    source: "iana"
  },
  "application/vnd.uplanet.channel-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.list": {
    source: "iana"
  },
  "application/vnd.uplanet.list-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.listcmd": {
    source: "iana"
  },
  "application/vnd.uplanet.listcmd-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.signal": {
    source: "iana"
  },
  "application/vnd.uri-map": {
    source: "iana"
  },
  "application/vnd.valve.source.material": {
    source: "iana"
  },
  "application/vnd.vcx": {
    source: "iana",
    extensions: [
      "vcx"
    ]
  },
  "application/vnd.vd-study": {
    source: "iana"
  },
  "application/vnd.vectorworks": {
    source: "iana"
  },
  "application/vnd.vel+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.verimatrix.vcas": {
    source: "iana"
  },
  "application/vnd.veritone.aion+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.veryant.thin": {
    source: "iana"
  },
  "application/vnd.ves.encrypted": {
    source: "iana"
  },
  "application/vnd.vidsoft.vidconference": {
    source: "iana"
  },
  "application/vnd.visio": {
    source: "iana",
    extensions: [
      "vsd",
      "vst",
      "vss",
      "vsw"
    ]
  },
  "application/vnd.visionary": {
    source: "iana",
    extensions: [
      "vis"
    ]
  },
  "application/vnd.vividence.scriptfile": {
    source: "iana"
  },
  "application/vnd.vsf": {
    source: "iana",
    extensions: [
      "vsf"
    ]
  },
  "application/vnd.wap.sic": {
    source: "iana"
  },
  "application/vnd.wap.slc": {
    source: "iana"
  },
  "application/vnd.wap.wbxml": {
    source: "iana",
    charset: "UTF-8",
    extensions: [
      "wbxml"
    ]
  },
  "application/vnd.wap.wmlc": {
    source: "iana",
    extensions: [
      "wmlc"
    ]
  },
  "application/vnd.wap.wmlscriptc": {
    source: "iana",
    extensions: [
      "wmlsc"
    ]
  },
  "application/vnd.webturbo": {
    source: "iana",
    extensions: [
      "wtb"
    ]
  },
  "application/vnd.wfa.dpp": {
    source: "iana"
  },
  "application/vnd.wfa.p2p": {
    source: "iana"
  },
  "application/vnd.wfa.wsc": {
    source: "iana"
  },
  "application/vnd.windows.devicepairing": {
    source: "iana"
  },
  "application/vnd.wmc": {
    source: "iana"
  },
  "application/vnd.wmf.bootstrap": {
    source: "iana"
  },
  "application/vnd.wolfram.mathematica": {
    source: "iana"
  },
  "application/vnd.wolfram.mathematica.package": {
    source: "iana"
  },
  "application/vnd.wolfram.player": {
    source: "iana",
    extensions: [
      "nbp"
    ]
  },
  "application/vnd.wordperfect": {
    source: "iana",
    extensions: [
      "wpd"
    ]
  },
  "application/vnd.wqd": {
    source: "iana",
    extensions: [
      "wqd"
    ]
  },
  "application/vnd.wrq-hp3000-labelled": {
    source: "iana"
  },
  "application/vnd.wt.stf": {
    source: "iana",
    extensions: [
      "stf"
    ]
  },
  "application/vnd.wv.csp+wbxml": {
    source: "iana"
  },
  "application/vnd.wv.csp+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.wv.ssp+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.xacml+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.xara": {
    source: "iana",
    extensions: [
      "xar"
    ]
  },
  "application/vnd.xfdl": {
    source: "iana",
    extensions: [
      "xfdl"
    ]
  },
  "application/vnd.xfdl.webform": {
    source: "iana"
  },
  "application/vnd.xmi+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.xmpie.cpkg": {
    source: "iana"
  },
  "application/vnd.xmpie.dpkg": {
    source: "iana"
  },
  "application/vnd.xmpie.plan": {
    source: "iana"
  },
  "application/vnd.xmpie.ppkg": {
    source: "iana"
  },
  "application/vnd.xmpie.xlim": {
    source: "iana"
  },
  "application/vnd.yamaha.hv-dic": {
    source: "iana",
    extensions: [
      "hvd"
    ]
  },
  "application/vnd.yamaha.hv-script": {
    source: "iana",
    extensions: [
      "hvs"
    ]
  },
  "application/vnd.yamaha.hv-voice": {
    source: "iana",
    extensions: [
      "hvp"
    ]
  },
  "application/vnd.yamaha.openscoreformat": {
    source: "iana",
    extensions: [
      "osf"
    ]
  },
  "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "osfpvg"
    ]
  },
  "application/vnd.yamaha.remote-setup": {
    source: "iana"
  },
  "application/vnd.yamaha.smaf-audio": {
    source: "iana",
    extensions: [
      "saf"
    ]
  },
  "application/vnd.yamaha.smaf-phrase": {
    source: "iana",
    extensions: [
      "spf"
    ]
  },
  "application/vnd.yamaha.through-ngn": {
    source: "iana"
  },
  "application/vnd.yamaha.tunnel-udpencap": {
    source: "iana"
  },
  "application/vnd.yaoweme": {
    source: "iana"
  },
  "application/vnd.yellowriver-custom-menu": {
    source: "iana",
    extensions: [
      "cmp"
    ]
  },
  "application/vnd.youtube.yt": {
    source: "iana"
  },
  "application/vnd.zul": {
    source: "iana",
    extensions: [
      "zir",
      "zirz"
    ]
  },
  "application/vnd.zzazz.deck+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "zaz"
    ]
  },
  "application/voicexml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "vxml"
    ]
  },
  "application/voucher-cms+json": {
    source: "iana",
    compressible: true
  },
  "application/vq-rtcpxr": {
    source: "iana"
  },
  "application/wasm": {
    source: "iana",
    compressible: true,
    extensions: [
      "wasm"
    ]
  },
  "application/watcherinfo+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "wif"
    ]
  },
  "application/webpush-options+json": {
    source: "iana",
    compressible: true
  },
  "application/whoispp-query": {
    source: "iana"
  },
  "application/whoispp-response": {
    source: "iana"
  },
  "application/widget": {
    source: "iana",
    extensions: [
      "wgt"
    ]
  },
  "application/winhlp": {
    source: "apache",
    extensions: [
      "hlp"
    ]
  },
  "application/wita": {
    source: "iana"
  },
  "application/wordperfect5.1": {
    source: "iana"
  },
  "application/wsdl+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "wsdl"
    ]
  },
  "application/wspolicy+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "wspolicy"
    ]
  },
  "application/x-7z-compressed": {
    source: "apache",
    compressible: false,
    extensions: [
      "7z"
    ]
  },
  "application/x-abiword": {
    source: "apache",
    extensions: [
      "abw"
    ]
  },
  "application/x-ace-compressed": {
    source: "apache",
    extensions: [
      "ace"
    ]
  },
  "application/x-amf": {
    source: "apache"
  },
  "application/x-apple-diskimage": {
    source: "apache",
    extensions: [
      "dmg"
    ]
  },
  "application/x-arj": {
    compressible: false,
    extensions: [
      "arj"
    ]
  },
  "application/x-authorware-bin": {
    source: "apache",
    extensions: [
      "aab",
      "x32",
      "u32",
      "vox"
    ]
  },
  "application/x-authorware-map": {
    source: "apache",
    extensions: [
      "aam"
    ]
  },
  "application/x-authorware-seg": {
    source: "apache",
    extensions: [
      "aas"
    ]
  },
  "application/x-bcpio": {
    source: "apache",
    extensions: [
      "bcpio"
    ]
  },
  "application/x-bdoc": {
    compressible: false,
    extensions: [
      "bdoc"
    ]
  },
  "application/x-bittorrent": {
    source: "apache",
    extensions: [
      "torrent"
    ]
  },
  "application/x-blorb": {
    source: "apache",
    extensions: [
      "blb",
      "blorb"
    ]
  },
  "application/x-bzip": {
    source: "apache",
    compressible: false,
    extensions: [
      "bz"
    ]
  },
  "application/x-bzip2": {
    source: "apache",
    compressible: false,
    extensions: [
      "bz2",
      "boz"
    ]
  },
  "application/x-cbr": {
    source: "apache",
    extensions: [
      "cbr",
      "cba",
      "cbt",
      "cbz",
      "cb7"
    ]
  },
  "application/x-cdlink": {
    source: "apache",
    extensions: [
      "vcd"
    ]
  },
  "application/x-cfs-compressed": {
    source: "apache",
    extensions: [
      "cfs"
    ]
  },
  "application/x-chat": {
    source: "apache",
    extensions: [
      "chat"
    ]
  },
  "application/x-chess-pgn": {
    source: "apache",
    extensions: [
      "pgn"
    ]
  },
  "application/x-chrome-extension": {
    extensions: [
      "crx"
    ]
  },
  "application/x-cocoa": {
    source: "nginx",
    extensions: [
      "cco"
    ]
  },
  "application/x-compress": {
    source: "apache"
  },
  "application/x-conference": {
    source: "apache",
    extensions: [
      "nsc"
    ]
  },
  "application/x-cpio": {
    source: "apache",
    extensions: [
      "cpio"
    ]
  },
  "application/x-csh": {
    source: "apache",
    extensions: [
      "csh"
    ]
  },
  "application/x-deb": {
    compressible: false
  },
  "application/x-debian-package": {
    source: "apache",
    extensions: [
      "deb",
      "udeb"
    ]
  },
  "application/x-dgc-compressed": {
    source: "apache",
    extensions: [
      "dgc"
    ]
  },
  "application/x-director": {
    source: "apache",
    extensions: [
      "dir",
      "dcr",
      "dxr",
      "cst",
      "cct",
      "cxt",
      "w3d",
      "fgd",
      "swa"
    ]
  },
  "application/x-doom": {
    source: "apache",
    extensions: [
      "wad"
    ]
  },
  "application/x-dtbncx+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "ncx"
    ]
  },
  "application/x-dtbook+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "dtb"
    ]
  },
  "application/x-dtbresource+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "res"
    ]
  },
  "application/x-dvi": {
    source: "apache",
    compressible: false,
    extensions: [
      "dvi"
    ]
  },
  "application/x-envoy": {
    source: "apache",
    extensions: [
      "evy"
    ]
  },
  "application/x-eva": {
    source: "apache",
    extensions: [
      "eva"
    ]
  },
  "application/x-font-bdf": {
    source: "apache",
    extensions: [
      "bdf"
    ]
  },
  "application/x-font-dos": {
    source: "apache"
  },
  "application/x-font-framemaker": {
    source: "apache"
  },
  "application/x-font-ghostscript": {
    source: "apache",
    extensions: [
      "gsf"
    ]
  },
  "application/x-font-libgrx": {
    source: "apache"
  },
  "application/x-font-linux-psf": {
    source: "apache",
    extensions: [
      "psf"
    ]
  },
  "application/x-font-pcf": {
    source: "apache",
    extensions: [
      "pcf"
    ]
  },
  "application/x-font-snf": {
    source: "apache",
    extensions: [
      "snf"
    ]
  },
  "application/x-font-speedo": {
    source: "apache"
  },
  "application/x-font-sunos-news": {
    source: "apache"
  },
  "application/x-font-type1": {
    source: "apache",
    extensions: [
      "pfa",
      "pfb",
      "pfm",
      "afm"
    ]
  },
  "application/x-font-vfont": {
    source: "apache"
  },
  "application/x-freearc": {
    source: "apache",
    extensions: [
      "arc"
    ]
  },
  "application/x-futuresplash": {
    source: "apache",
    extensions: [
      "spl"
    ]
  },
  "application/x-gca-compressed": {
    source: "apache",
    extensions: [
      "gca"
    ]
  },
  "application/x-glulx": {
    source: "apache",
    extensions: [
      "ulx"
    ]
  },
  "application/x-gnumeric": {
    source: "apache",
    extensions: [
      "gnumeric"
    ]
  },
  "application/x-gramps-xml": {
    source: "apache",
    extensions: [
      "gramps"
    ]
  },
  "application/x-gtar": {
    source: "apache",
    extensions: [
      "gtar"
    ]
  },
  "application/x-gzip": {
    source: "apache"
  },
  "application/x-hdf": {
    source: "apache",
    extensions: [
      "hdf"
    ]
  },
  "application/x-httpd-php": {
    compressible: true,
    extensions: [
      "php"
    ]
  },
  "application/x-install-instructions": {
    source: "apache",
    extensions: [
      "install"
    ]
  },
  "application/x-iso9660-image": {
    source: "apache",
    extensions: [
      "iso"
    ]
  },
  "application/x-iwork-keynote-sffkey": {
    extensions: [
      "key"
    ]
  },
  "application/x-iwork-numbers-sffnumbers": {
    extensions: [
      "numbers"
    ]
  },
  "application/x-iwork-pages-sffpages": {
    extensions: [
      "pages"
    ]
  },
  "application/x-java-archive-diff": {
    source: "nginx",
    extensions: [
      "jardiff"
    ]
  },
  "application/x-java-jnlp-file": {
    source: "apache",
    compressible: false,
    extensions: [
      "jnlp"
    ]
  },
  "application/x-javascript": {
    compressible: true
  },
  "application/x-keepass2": {
    extensions: [
      "kdbx"
    ]
  },
  "application/x-latex": {
    source: "apache",
    compressible: false,
    extensions: [
      "latex"
    ]
  },
  "application/x-lua-bytecode": {
    extensions: [
      "luac"
    ]
  },
  "application/x-lzh-compressed": {
    source: "apache",
    extensions: [
      "lzh",
      "lha"
    ]
  },
  "application/x-makeself": {
    source: "nginx",
    extensions: [
      "run"
    ]
  },
  "application/x-mie": {
    source: "apache",
    extensions: [
      "mie"
    ]
  },
  "application/x-mobipocket-ebook": {
    source: "apache",
    extensions: [
      "prc",
      "mobi"
    ]
  },
  "application/x-mpegurl": {
    compressible: false
  },
  "application/x-ms-application": {
    source: "apache",
    extensions: [
      "application"
    ]
  },
  "application/x-ms-shortcut": {
    source: "apache",
    extensions: [
      "lnk"
    ]
  },
  "application/x-ms-wmd": {
    source: "apache",
    extensions: [
      "wmd"
    ]
  },
  "application/x-ms-wmz": {
    source: "apache",
    extensions: [
      "wmz"
    ]
  },
  "application/x-ms-xbap": {
    source: "apache",
    extensions: [
      "xbap"
    ]
  },
  "application/x-msaccess": {
    source: "apache",
    extensions: [
      "mdb"
    ]
  },
  "application/x-msbinder": {
    source: "apache",
    extensions: [
      "obd"
    ]
  },
  "application/x-mscardfile": {
    source: "apache",
    extensions: [
      "crd"
    ]
  },
  "application/x-msclip": {
    source: "apache",
    extensions: [
      "clp"
    ]
  },
  "application/x-msdos-program": {
    extensions: [
      "exe"
    ]
  },
  "application/x-msdownload": {
    source: "apache",
    extensions: [
      "exe",
      "dll",
      "com",
      "bat",
      "msi"
    ]
  },
  "application/x-msmediaview": {
    source: "apache",
    extensions: [
      "mvb",
      "m13",
      "m14"
    ]
  },
  "application/x-msmetafile": {
    source: "apache",
    extensions: [
      "wmf",
      "wmz",
      "emf",
      "emz"
    ]
  },
  "application/x-msmoney": {
    source: "apache",
    extensions: [
      "mny"
    ]
  },
  "application/x-mspublisher": {
    source: "apache",
    extensions: [
      "pub"
    ]
  },
  "application/x-msschedule": {
    source: "apache",
    extensions: [
      "scd"
    ]
  },
  "application/x-msterminal": {
    source: "apache",
    extensions: [
      "trm"
    ]
  },
  "application/x-mswrite": {
    source: "apache",
    extensions: [
      "wri"
    ]
  },
  "application/x-netcdf": {
    source: "apache",
    extensions: [
      "nc",
      "cdf"
    ]
  },
  "application/x-ns-proxy-autoconfig": {
    compressible: true,
    extensions: [
      "pac"
    ]
  },
  "application/x-nzb": {
    source: "apache",
    extensions: [
      "nzb"
    ]
  },
  "application/x-perl": {
    source: "nginx",
    extensions: [
      "pl",
      "pm"
    ]
  },
  "application/x-pilot": {
    source: "nginx",
    extensions: [
      "prc",
      "pdb"
    ]
  },
  "application/x-pkcs12": {
    source: "apache",
    compressible: false,
    extensions: [
      "p12",
      "pfx"
    ]
  },
  "application/x-pkcs7-certificates": {
    source: "apache",
    extensions: [
      "p7b",
      "spc"
    ]
  },
  "application/x-pkcs7-certreqresp": {
    source: "apache",
    extensions: [
      "p7r"
    ]
  },
  "application/x-pki-message": {
    source: "iana"
  },
  "application/x-rar-compressed": {
    source: "apache",
    compressible: false,
    extensions: [
      "rar"
    ]
  },
  "application/x-redhat-package-manager": {
    source: "nginx",
    extensions: [
      "rpm"
    ]
  },
  "application/x-research-info-systems": {
    source: "apache",
    extensions: [
      "ris"
    ]
  },
  "application/x-sea": {
    source: "nginx",
    extensions: [
      "sea"
    ]
  },
  "application/x-sh": {
    source: "apache",
    compressible: true,
    extensions: [
      "sh"
    ]
  },
  "application/x-shar": {
    source: "apache",
    extensions: [
      "shar"
    ]
  },
  "application/x-shockwave-flash": {
    source: "apache",
    compressible: false,
    extensions: [
      "swf"
    ]
  },
  "application/x-silverlight-app": {
    source: "apache",
    extensions: [
      "xap"
    ]
  },
  "application/x-sql": {
    source: "apache",
    extensions: [
      "sql"
    ]
  },
  "application/x-stuffit": {
    source: "apache",
    compressible: false,
    extensions: [
      "sit"
    ]
  },
  "application/x-stuffitx": {
    source: "apache",
    extensions: [
      "sitx"
    ]
  },
  "application/x-subrip": {
    source: "apache",
    extensions: [
      "srt"
    ]
  },
  "application/x-sv4cpio": {
    source: "apache",
    extensions: [
      "sv4cpio"
    ]
  },
  "application/x-sv4crc": {
    source: "apache",
    extensions: [
      "sv4crc"
    ]
  },
  "application/x-t3vm-image": {
    source: "apache",
    extensions: [
      "t3"
    ]
  },
  "application/x-tads": {
    source: "apache",
    extensions: [
      "gam"
    ]
  },
  "application/x-tar": {
    source: "apache",
    compressible: true,
    extensions: [
      "tar"
    ]
  },
  "application/x-tcl": {
    source: "apache",
    extensions: [
      "tcl",
      "tk"
    ]
  },
  "application/x-tex": {
    source: "apache",
    extensions: [
      "tex"
    ]
  },
  "application/x-tex-tfm": {
    source: "apache",
    extensions: [
      "tfm"
    ]
  },
  "application/x-texinfo": {
    source: "apache",
    extensions: [
      "texinfo",
      "texi"
    ]
  },
  "application/x-tgif": {
    source: "apache",
    extensions: [
      "obj"
    ]
  },
  "application/x-ustar": {
    source: "apache",
    extensions: [
      "ustar"
    ]
  },
  "application/x-virtualbox-hdd": {
    compressible: true,
    extensions: [
      "hdd"
    ]
  },
  "application/x-virtualbox-ova": {
    compressible: true,
    extensions: [
      "ova"
    ]
  },
  "application/x-virtualbox-ovf": {
    compressible: true,
    extensions: [
      "ovf"
    ]
  },
  "application/x-virtualbox-vbox": {
    compressible: true,
    extensions: [
      "vbox"
    ]
  },
  "application/x-virtualbox-vbox-extpack": {
    compressible: false,
    extensions: [
      "vbox-extpack"
    ]
  },
  "application/x-virtualbox-vdi": {
    compressible: true,
    extensions: [
      "vdi"
    ]
  },
  "application/x-virtualbox-vhd": {
    compressible: true,
    extensions: [
      "vhd"
    ]
  },
  "application/x-virtualbox-vmdk": {
    compressible: true,
    extensions: [
      "vmdk"
    ]
  },
  "application/x-wais-source": {
    source: "apache",
    extensions: [
      "src"
    ]
  },
  "application/x-web-app-manifest+json": {
    compressible: true,
    extensions: [
      "webapp"
    ]
  },
  "application/x-www-form-urlencoded": {
    source: "iana",
    compressible: true
  },
  "application/x-x509-ca-cert": {
    source: "iana",
    extensions: [
      "der",
      "crt",
      "pem"
    ]
  },
  "application/x-x509-ca-ra-cert": {
    source: "iana"
  },
  "application/x-x509-next-ca-cert": {
    source: "iana"
  },
  "application/x-xfig": {
    source: "apache",
    extensions: [
      "fig"
    ]
  },
  "application/x-xliff+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "xlf"
    ]
  },
  "application/x-xpinstall": {
    source: "apache",
    compressible: false,
    extensions: [
      "xpi"
    ]
  },
  "application/x-xz": {
    source: "apache",
    extensions: [
      "xz"
    ]
  },
  "application/x-zmachine": {
    source: "apache",
    extensions: [
      "z1",
      "z2",
      "z3",
      "z4",
      "z5",
      "z6",
      "z7",
      "z8"
    ]
  },
  "application/x400-bp": {
    source: "iana"
  },
  "application/xacml+xml": {
    source: "iana",
    compressible: true
  },
  "application/xaml+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "xaml"
    ]
  },
  "application/xcap-att+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xav"
    ]
  },
  "application/xcap-caps+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xca"
    ]
  },
  "application/xcap-diff+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xdf"
    ]
  },
  "application/xcap-el+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xel"
    ]
  },
  "application/xcap-error+xml": {
    source: "iana",
    compressible: true
  },
  "application/xcap-ns+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xns"
    ]
  },
  "application/xcon-conference-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/xcon-conference-info-diff+xml": {
    source: "iana",
    compressible: true
  },
  "application/xenc+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xenc"
    ]
  },
  "application/xhtml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xhtml",
      "xht"
    ]
  },
  "application/xhtml-voice+xml": {
    source: "apache",
    compressible: true
  },
  "application/xliff+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xlf"
    ]
  },
  "application/xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xml",
      "xsl",
      "xsd",
      "rng"
    ]
  },
  "application/xml-dtd": {
    source: "iana",
    compressible: true,
    extensions: [
      "dtd"
    ]
  },
  "application/xml-external-parsed-entity": {
    source: "iana"
  },
  "application/xml-patch+xml": {
    source: "iana",
    compressible: true
  },
  "application/xmpp+xml": {
    source: "iana",
    compressible: true
  },
  "application/xop+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xop"
    ]
  },
  "application/xproc+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "xpl"
    ]
  },
  "application/xslt+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xsl",
      "xslt"
    ]
  },
  "application/xspf+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "xspf"
    ]
  },
  "application/xv+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mxml",
      "xhvml",
      "xvml",
      "xvm"
    ]
  },
  "application/yang": {
    source: "iana",
    extensions: [
      "yang"
    ]
  },
  "application/yang-data+json": {
    source: "iana",
    compressible: true
  },
  "application/yang-data+xml": {
    source: "iana",
    compressible: true
  },
  "application/yang-patch+json": {
    source: "iana",
    compressible: true
  },
  "application/yang-patch+xml": {
    source: "iana",
    compressible: true
  },
  "application/yin+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "yin"
    ]
  },
  "application/zip": {
    source: "iana",
    compressible: false,
    extensions: [
      "zip"
    ]
  },
  "application/zlib": {
    source: "iana"
  },
  "application/zstd": {
    source: "iana"
  },
  "audio/1d-interleaved-parityfec": {
    source: "iana"
  },
  "audio/32kadpcm": {
    source: "iana"
  },
  "audio/3gpp": {
    source: "iana",
    compressible: false,
    extensions: [
      "3gpp"
    ]
  },
  "audio/3gpp2": {
    source: "iana"
  },
  "audio/aac": {
    source: "iana"
  },
  "audio/ac3": {
    source: "iana"
  },
  "audio/adpcm": {
    source: "apache",
    extensions: [
      "adp"
    ]
  },
  "audio/amr": {
    source: "iana",
    extensions: [
      "amr"
    ]
  },
  "audio/amr-wb": {
    source: "iana"
  },
  "audio/amr-wb+": {
    source: "iana"
  },
  "audio/aptx": {
    source: "iana"
  },
  "audio/asc": {
    source: "iana"
  },
  "audio/atrac-advanced-lossless": {
    source: "iana"
  },
  "audio/atrac-x": {
    source: "iana"
  },
  "audio/atrac3": {
    source: "iana"
  },
  "audio/basic": {
    source: "iana",
    compressible: false,
    extensions: [
      "au",
      "snd"
    ]
  },
  "audio/bv16": {
    source: "iana"
  },
  "audio/bv32": {
    source: "iana"
  },
  "audio/clearmode": {
    source: "iana"
  },
  "audio/cn": {
    source: "iana"
  },
  "audio/dat12": {
    source: "iana"
  },
  "audio/dls": {
    source: "iana"
  },
  "audio/dsr-es201108": {
    source: "iana"
  },
  "audio/dsr-es202050": {
    source: "iana"
  },
  "audio/dsr-es202211": {
    source: "iana"
  },
  "audio/dsr-es202212": {
    source: "iana"
  },
  "audio/dv": {
    source: "iana"
  },
  "audio/dvi4": {
    source: "iana"
  },
  "audio/eac3": {
    source: "iana"
  },
  "audio/encaprtp": {
    source: "iana"
  },
  "audio/evrc": {
    source: "iana"
  },
  "audio/evrc-qcp": {
    source: "iana"
  },
  "audio/evrc0": {
    source: "iana"
  },
  "audio/evrc1": {
    source: "iana"
  },
  "audio/evrcb": {
    source: "iana"
  },
  "audio/evrcb0": {
    source: "iana"
  },
  "audio/evrcb1": {
    source: "iana"
  },
  "audio/evrcnw": {
    source: "iana"
  },
  "audio/evrcnw0": {
    source: "iana"
  },
  "audio/evrcnw1": {
    source: "iana"
  },
  "audio/evrcwb": {
    source: "iana"
  },
  "audio/evrcwb0": {
    source: "iana"
  },
  "audio/evrcwb1": {
    source: "iana"
  },
  "audio/evs": {
    source: "iana"
  },
  "audio/flexfec": {
    source: "iana"
  },
  "audio/fwdred": {
    source: "iana"
  },
  "audio/g711-0": {
    source: "iana"
  },
  "audio/g719": {
    source: "iana"
  },
  "audio/g722": {
    source: "iana"
  },
  "audio/g7221": {
    source: "iana"
  },
  "audio/g723": {
    source: "iana"
  },
  "audio/g726-16": {
    source: "iana"
  },
  "audio/g726-24": {
    source: "iana"
  },
  "audio/g726-32": {
    source: "iana"
  },
  "audio/g726-40": {
    source: "iana"
  },
  "audio/g728": {
    source: "iana"
  },
  "audio/g729": {
    source: "iana"
  },
  "audio/g7291": {
    source: "iana"
  },
  "audio/g729d": {
    source: "iana"
  },
  "audio/g729e": {
    source: "iana"
  },
  "audio/gsm": {
    source: "iana"
  },
  "audio/gsm-efr": {
    source: "iana"
  },
  "audio/gsm-hr-08": {
    source: "iana"
  },
  "audio/ilbc": {
    source: "iana"
  },
  "audio/ip-mr_v2.5": {
    source: "iana"
  },
  "audio/isac": {
    source: "apache"
  },
  "audio/l16": {
    source: "iana"
  },
  "audio/l20": {
    source: "iana"
  },
  "audio/l24": {
    source: "iana",
    compressible: false
  },
  "audio/l8": {
    source: "iana"
  },
  "audio/lpc": {
    source: "iana"
  },
  "audio/melp": {
    source: "iana"
  },
  "audio/melp1200": {
    source: "iana"
  },
  "audio/melp2400": {
    source: "iana"
  },
  "audio/melp600": {
    source: "iana"
  },
  "audio/mhas": {
    source: "iana"
  },
  "audio/midi": {
    source: "apache",
    extensions: [
      "mid",
      "midi",
      "kar",
      "rmi"
    ]
  },
  "audio/mobile-xmf": {
    source: "iana",
    extensions: [
      "mxmf"
    ]
  },
  "audio/mp3": {
    compressible: false,
    extensions: [
      "mp3"
    ]
  },
  "audio/mp4": {
    source: "iana",
    compressible: false,
    extensions: [
      "m4a",
      "mp4a"
    ]
  },
  "audio/mp4a-latm": {
    source: "iana"
  },
  "audio/mpa": {
    source: "iana"
  },
  "audio/mpa-robust": {
    source: "iana"
  },
  "audio/mpeg": {
    source: "iana",
    compressible: false,
    extensions: [
      "mpga",
      "mp2",
      "mp2a",
      "mp3",
      "m2a",
      "m3a"
    ]
  },
  "audio/mpeg4-generic": {
    source: "iana"
  },
  "audio/musepack": {
    source: "apache"
  },
  "audio/ogg": {
    source: "iana",
    compressible: false,
    extensions: [
      "oga",
      "ogg",
      "spx",
      "opus"
    ]
  },
  "audio/opus": {
    source: "iana"
  },
  "audio/parityfec": {
    source: "iana"
  },
  "audio/pcma": {
    source: "iana"
  },
  "audio/pcma-wb": {
    source: "iana"
  },
  "audio/pcmu": {
    source: "iana"
  },
  "audio/pcmu-wb": {
    source: "iana"
  },
  "audio/prs.sid": {
    source: "iana"
  },
  "audio/qcelp": {
    source: "iana"
  },
  "audio/raptorfec": {
    source: "iana"
  },
  "audio/red": {
    source: "iana"
  },
  "audio/rtp-enc-aescm128": {
    source: "iana"
  },
  "audio/rtp-midi": {
    source: "iana"
  },
  "audio/rtploopback": {
    source: "iana"
  },
  "audio/rtx": {
    source: "iana"
  },
  "audio/s3m": {
    source: "apache",
    extensions: [
      "s3m"
    ]
  },
  "audio/scip": {
    source: "iana"
  },
  "audio/silk": {
    source: "apache",
    extensions: [
      "sil"
    ]
  },
  "audio/smv": {
    source: "iana"
  },
  "audio/smv-qcp": {
    source: "iana"
  },
  "audio/smv0": {
    source: "iana"
  },
  "audio/sofa": {
    source: "iana"
  },
  "audio/sp-midi": {
    source: "iana"
  },
  "audio/speex": {
    source: "iana"
  },
  "audio/t140c": {
    source: "iana"
  },
  "audio/t38": {
    source: "iana"
  },
  "audio/telephone-event": {
    source: "iana"
  },
  "audio/tetra_acelp": {
    source: "iana"
  },
  "audio/tetra_acelp_bb": {
    source: "iana"
  },
  "audio/tone": {
    source: "iana"
  },
  "audio/tsvcis": {
    source: "iana"
  },
  "audio/uemclip": {
    source: "iana"
  },
  "audio/ulpfec": {
    source: "iana"
  },
  "audio/usac": {
    source: "iana"
  },
  "audio/vdvi": {
    source: "iana"
  },
  "audio/vmr-wb": {
    source: "iana"
  },
  "audio/vnd.3gpp.iufp": {
    source: "iana"
  },
  "audio/vnd.4sb": {
    source: "iana"
  },
  "audio/vnd.audiokoz": {
    source: "iana"
  },
  "audio/vnd.celp": {
    source: "iana"
  },
  "audio/vnd.cisco.nse": {
    source: "iana"
  },
  "audio/vnd.cmles.radio-events": {
    source: "iana"
  },
  "audio/vnd.cns.anp1": {
    source: "iana"
  },
  "audio/vnd.cns.inf1": {
    source: "iana"
  },
  "audio/vnd.dece.audio": {
    source: "iana",
    extensions: [
      "uva",
      "uvva"
    ]
  },
  "audio/vnd.digital-winds": {
    source: "iana",
    extensions: [
      "eol"
    ]
  },
  "audio/vnd.dlna.adts": {
    source: "iana"
  },
  "audio/vnd.dolby.heaac.1": {
    source: "iana"
  },
  "audio/vnd.dolby.heaac.2": {
    source: "iana"
  },
  "audio/vnd.dolby.mlp": {
    source: "iana"
  },
  "audio/vnd.dolby.mps": {
    source: "iana"
  },
  "audio/vnd.dolby.pl2": {
    source: "iana"
  },
  "audio/vnd.dolby.pl2x": {
    source: "iana"
  },
  "audio/vnd.dolby.pl2z": {
    source: "iana"
  },
  "audio/vnd.dolby.pulse.1": {
    source: "iana"
  },
  "audio/vnd.dra": {
    source: "iana",
    extensions: [
      "dra"
    ]
  },
  "audio/vnd.dts": {
    source: "iana",
    extensions: [
      "dts"
    ]
  },
  "audio/vnd.dts.hd": {
    source: "iana",
    extensions: [
      "dtshd"
    ]
  },
  "audio/vnd.dts.uhd": {
    source: "iana"
  },
  "audio/vnd.dvb.file": {
    source: "iana"
  },
  "audio/vnd.everad.plj": {
    source: "iana"
  },
  "audio/vnd.hns.audio": {
    source: "iana"
  },
  "audio/vnd.lucent.voice": {
    source: "iana",
    extensions: [
      "lvp"
    ]
  },
  "audio/vnd.ms-playready.media.pya": {
    source: "iana",
    extensions: [
      "pya"
    ]
  },
  "audio/vnd.nokia.mobile-xmf": {
    source: "iana"
  },
  "audio/vnd.nortel.vbk": {
    source: "iana"
  },
  "audio/vnd.nuera.ecelp4800": {
    source: "iana",
    extensions: [
      "ecelp4800"
    ]
  },
  "audio/vnd.nuera.ecelp7470": {
    source: "iana",
    extensions: [
      "ecelp7470"
    ]
  },
  "audio/vnd.nuera.ecelp9600": {
    source: "iana",
    extensions: [
      "ecelp9600"
    ]
  },
  "audio/vnd.octel.sbc": {
    source: "iana"
  },
  "audio/vnd.presonus.multitrack": {
    source: "iana"
  },
  "audio/vnd.qcelp": {
    source: "iana"
  },
  "audio/vnd.rhetorex.32kadpcm": {
    source: "iana"
  },
  "audio/vnd.rip": {
    source: "iana",
    extensions: [
      "rip"
    ]
  },
  "audio/vnd.rn-realaudio": {
    compressible: false
  },
  "audio/vnd.sealedmedia.softseal.mpeg": {
    source: "iana"
  },
  "audio/vnd.vmx.cvsd": {
    source: "iana"
  },
  "audio/vnd.wave": {
    compressible: false
  },
  "audio/vorbis": {
    source: "iana",
    compressible: false
  },
  "audio/vorbis-config": {
    source: "iana"
  },
  "audio/wav": {
    compressible: false,
    extensions: [
      "wav"
    ]
  },
  "audio/wave": {
    compressible: false,
    extensions: [
      "wav"
    ]
  },
  "audio/webm": {
    source: "apache",
    compressible: false,
    extensions: [
      "weba"
    ]
  },
  "audio/x-aac": {
    source: "apache",
    compressible: false,
    extensions: [
      "aac"
    ]
  },
  "audio/x-aiff": {
    source: "apache",
    extensions: [
      "aif",
      "aiff",
      "aifc"
    ]
  },
  "audio/x-caf": {
    source: "apache",
    compressible: false,
    extensions: [
      "caf"
    ]
  },
  "audio/x-flac": {
    source: "apache",
    extensions: [
      "flac"
    ]
  },
  "audio/x-m4a": {
    source: "nginx",
    extensions: [
      "m4a"
    ]
  },
  "audio/x-matroska": {
    source: "apache",
    extensions: [
      "mka"
    ]
  },
  "audio/x-mpegurl": {
    source: "apache",
    extensions: [
      "m3u"
    ]
  },
  "audio/x-ms-wax": {
    source: "apache",
    extensions: [
      "wax"
    ]
  },
  "audio/x-ms-wma": {
    source: "apache",
    extensions: [
      "wma"
    ]
  },
  "audio/x-pn-realaudio": {
    source: "apache",
    extensions: [
      "ram",
      "ra"
    ]
  },
  "audio/x-pn-realaudio-plugin": {
    source: "apache",
    extensions: [
      "rmp"
    ]
  },
  "audio/x-realaudio": {
    source: "nginx",
    extensions: [
      "ra"
    ]
  },
  "audio/x-tta": {
    source: "apache"
  },
  "audio/x-wav": {
    source: "apache",
    extensions: [
      "wav"
    ]
  },
  "audio/xm": {
    source: "apache",
    extensions: [
      "xm"
    ]
  },
  "chemical/x-cdx": {
    source: "apache",
    extensions: [
      "cdx"
    ]
  },
  "chemical/x-cif": {
    source: "apache",
    extensions: [
      "cif"
    ]
  },
  "chemical/x-cmdf": {
    source: "apache",
    extensions: [
      "cmdf"
    ]
  },
  "chemical/x-cml": {
    source: "apache",
    extensions: [
      "cml"
    ]
  },
  "chemical/x-csml": {
    source: "apache",
    extensions: [
      "csml"
    ]
  },
  "chemical/x-pdb": {
    source: "apache"
  },
  "chemical/x-xyz": {
    source: "apache",
    extensions: [
      "xyz"
    ]
  },
  "font/collection": {
    source: "iana",
    extensions: [
      "ttc"
    ]
  },
  "font/otf": {
    source: "iana",
    compressible: true,
    extensions: [
      "otf"
    ]
  },
  "font/sfnt": {
    source: "iana"
  },
  "font/ttf": {
    source: "iana",
    compressible: true,
    extensions: [
      "ttf"
    ]
  },
  "font/woff": {
    source: "iana",
    extensions: [
      "woff"
    ]
  },
  "font/woff2": {
    source: "iana",
    extensions: [
      "woff2"
    ]
  },
  "image/aces": {
    source: "iana",
    extensions: [
      "exr"
    ]
  },
  "image/apng": {
    compressible: false,
    extensions: [
      "apng"
    ]
  },
  "image/avci": {
    source: "iana",
    extensions: [
      "avci"
    ]
  },
  "image/avcs": {
    source: "iana",
    extensions: [
      "avcs"
    ]
  },
  "image/avif": {
    source: "iana",
    compressible: false,
    extensions: [
      "avif"
    ]
  },
  "image/bmp": {
    source: "iana",
    compressible: true,
    extensions: [
      "bmp"
    ]
  },
  "image/cgm": {
    source: "iana",
    extensions: [
      "cgm"
    ]
  },
  "image/dicom-rle": {
    source: "iana",
    extensions: [
      "drle"
    ]
  },
  "image/emf": {
    source: "iana",
    extensions: [
      "emf"
    ]
  },
  "image/fits": {
    source: "iana",
    extensions: [
      "fits"
    ]
  },
  "image/g3fax": {
    source: "iana",
    extensions: [
      "g3"
    ]
  },
  "image/gif": {
    source: "iana",
    compressible: false,
    extensions: [
      "gif"
    ]
  },
  "image/heic": {
    source: "iana",
    extensions: [
      "heic"
    ]
  },
  "image/heic-sequence": {
    source: "iana",
    extensions: [
      "heics"
    ]
  },
  "image/heif": {
    source: "iana",
    extensions: [
      "heif"
    ]
  },
  "image/heif-sequence": {
    source: "iana",
    extensions: [
      "heifs"
    ]
  },
  "image/hej2k": {
    source: "iana",
    extensions: [
      "hej2"
    ]
  },
  "image/hsj2": {
    source: "iana",
    extensions: [
      "hsj2"
    ]
  },
  "image/ief": {
    source: "iana",
    extensions: [
      "ief"
    ]
  },
  "image/jls": {
    source: "iana",
    extensions: [
      "jls"
    ]
  },
  "image/jp2": {
    source: "iana",
    compressible: false,
    extensions: [
      "jp2",
      "jpg2"
    ]
  },
  "image/jpeg": {
    source: "iana",
    compressible: false,
    extensions: [
      "jpeg",
      "jpg",
      "jpe"
    ]
  },
  "image/jph": {
    source: "iana",
    extensions: [
      "jph"
    ]
  },
  "image/jphc": {
    source: "iana",
    extensions: [
      "jhc"
    ]
  },
  "image/jpm": {
    source: "iana",
    compressible: false,
    extensions: [
      "jpm"
    ]
  },
  "image/jpx": {
    source: "iana",
    compressible: false,
    extensions: [
      "jpx",
      "jpf"
    ]
  },
  "image/jxr": {
    source: "iana",
    extensions: [
      "jxr"
    ]
  },
  "image/jxra": {
    source: "iana",
    extensions: [
      "jxra"
    ]
  },
  "image/jxrs": {
    source: "iana",
    extensions: [
      "jxrs"
    ]
  },
  "image/jxs": {
    source: "iana",
    extensions: [
      "jxs"
    ]
  },
  "image/jxsc": {
    source: "iana",
    extensions: [
      "jxsc"
    ]
  },
  "image/jxsi": {
    source: "iana",
    extensions: [
      "jxsi"
    ]
  },
  "image/jxss": {
    source: "iana",
    extensions: [
      "jxss"
    ]
  },
  "image/ktx": {
    source: "iana",
    extensions: [
      "ktx"
    ]
  },
  "image/ktx2": {
    source: "iana",
    extensions: [
      "ktx2"
    ]
  },
  "image/naplps": {
    source: "iana"
  },
  "image/pjpeg": {
    compressible: false
  },
  "image/png": {
    source: "iana",
    compressible: false,
    extensions: [
      "png"
    ]
  },
  "image/prs.btif": {
    source: "iana",
    extensions: [
      "btif"
    ]
  },
  "image/prs.pti": {
    source: "iana",
    extensions: [
      "pti"
    ]
  },
  "image/pwg-raster": {
    source: "iana"
  },
  "image/sgi": {
    source: "apache",
    extensions: [
      "sgi"
    ]
  },
  "image/svg+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "svg",
      "svgz"
    ]
  },
  "image/t38": {
    source: "iana",
    extensions: [
      "t38"
    ]
  },
  "image/tiff": {
    source: "iana",
    compressible: false,
    extensions: [
      "tif",
      "tiff"
    ]
  },
  "image/tiff-fx": {
    source: "iana",
    extensions: [
      "tfx"
    ]
  },
  "image/vnd.adobe.photoshop": {
    source: "iana",
    compressible: true,
    extensions: [
      "psd"
    ]
  },
  "image/vnd.airzip.accelerator.azv": {
    source: "iana",
    extensions: [
      "azv"
    ]
  },
  "image/vnd.cns.inf2": {
    source: "iana"
  },
  "image/vnd.dece.graphic": {
    source: "iana",
    extensions: [
      "uvi",
      "uvvi",
      "uvg",
      "uvvg"
    ]
  },
  "image/vnd.djvu": {
    source: "iana",
    extensions: [
      "djvu",
      "djv"
    ]
  },
  "image/vnd.dvb.subtitle": {
    source: "iana",
    extensions: [
      "sub"
    ]
  },
  "image/vnd.dwg": {
    source: "iana",
    extensions: [
      "dwg"
    ]
  },
  "image/vnd.dxf": {
    source: "iana",
    extensions: [
      "dxf"
    ]
  },
  "image/vnd.fastbidsheet": {
    source: "iana",
    extensions: [
      "fbs"
    ]
  },
  "image/vnd.fpx": {
    source: "iana",
    extensions: [
      "fpx"
    ]
  },
  "image/vnd.fst": {
    source: "iana",
    extensions: [
      "fst"
    ]
  },
  "image/vnd.fujixerox.edmics-mmr": {
    source: "iana",
    extensions: [
      "mmr"
    ]
  },
  "image/vnd.fujixerox.edmics-rlc": {
    source: "iana",
    extensions: [
      "rlc"
    ]
  },
  "image/vnd.globalgraphics.pgb": {
    source: "iana"
  },
  "image/vnd.microsoft.icon": {
    source: "iana",
    compressible: true,
    extensions: [
      "ico"
    ]
  },
  "image/vnd.mix": {
    source: "iana"
  },
  "image/vnd.mozilla.apng": {
    source: "iana"
  },
  "image/vnd.ms-dds": {
    compressible: true,
    extensions: [
      "dds"
    ]
  },
  "image/vnd.ms-modi": {
    source: "iana",
    extensions: [
      "mdi"
    ]
  },
  "image/vnd.ms-photo": {
    source: "apache",
    extensions: [
      "wdp"
    ]
  },
  "image/vnd.net-fpx": {
    source: "iana",
    extensions: [
      "npx"
    ]
  },
  "image/vnd.pco.b16": {
    source: "iana",
    extensions: [
      "b16"
    ]
  },
  "image/vnd.radiance": {
    source: "iana"
  },
  "image/vnd.sealed.png": {
    source: "iana"
  },
  "image/vnd.sealedmedia.softseal.gif": {
    source: "iana"
  },
  "image/vnd.sealedmedia.softseal.jpg": {
    source: "iana"
  },
  "image/vnd.svf": {
    source: "iana"
  },
  "image/vnd.tencent.tap": {
    source: "iana",
    extensions: [
      "tap"
    ]
  },
  "image/vnd.valve.source.texture": {
    source: "iana",
    extensions: [
      "vtf"
    ]
  },
  "image/vnd.wap.wbmp": {
    source: "iana",
    extensions: [
      "wbmp"
    ]
  },
  "image/vnd.xiff": {
    source: "iana",
    extensions: [
      "xif"
    ]
  },
  "image/vnd.zbrush.pcx": {
    source: "iana",
    extensions: [
      "pcx"
    ]
  },
  "image/webp": {
    source: "apache",
    extensions: [
      "webp"
    ]
  },
  "image/wmf": {
    source: "iana",
    extensions: [
      "wmf"
    ]
  },
  "image/x-3ds": {
    source: "apache",
    extensions: [
      "3ds"
    ]
  },
  "image/x-cmu-raster": {
    source: "apache",
    extensions: [
      "ras"
    ]
  },
  "image/x-cmx": {
    source: "apache",
    extensions: [
      "cmx"
    ]
  },
  "image/x-freehand": {
    source: "apache",
    extensions: [
      "fh",
      "fhc",
      "fh4",
      "fh5",
      "fh7"
    ]
  },
  "image/x-icon": {
    source: "apache",
    compressible: true,
    extensions: [
      "ico"
    ]
  },
  "image/x-jng": {
    source: "nginx",
    extensions: [
      "jng"
    ]
  },
  "image/x-mrsid-image": {
    source: "apache",
    extensions: [
      "sid"
    ]
  },
  "image/x-ms-bmp": {
    source: "nginx",
    compressible: true,
    extensions: [
      "bmp"
    ]
  },
  "image/x-pcx": {
    source: "apache",
    extensions: [
      "pcx"
    ]
  },
  "image/x-pict": {
    source: "apache",
    extensions: [
      "pic",
      "pct"
    ]
  },
  "image/x-portable-anymap": {
    source: "apache",
    extensions: [
      "pnm"
    ]
  },
  "image/x-portable-bitmap": {
    source: "apache",
    extensions: [
      "pbm"
    ]
  },
  "image/x-portable-graymap": {
    source: "apache",
    extensions: [
      "pgm"
    ]
  },
  "image/x-portable-pixmap": {
    source: "apache",
    extensions: [
      "ppm"
    ]
  },
  "image/x-rgb": {
    source: "apache",
    extensions: [
      "rgb"
    ]
  },
  "image/x-tga": {
    source: "apache",
    extensions: [
      "tga"
    ]
  },
  "image/x-xbitmap": {
    source: "apache",
    extensions: [
      "xbm"
    ]
  },
  "image/x-xcf": {
    compressible: false
  },
  "image/x-xpixmap": {
    source: "apache",
    extensions: [
      "xpm"
    ]
  },
  "image/x-xwindowdump": {
    source: "apache",
    extensions: [
      "xwd"
    ]
  },
  "message/cpim": {
    source: "iana"
  },
  "message/delivery-status": {
    source: "iana"
  },
  "message/disposition-notification": {
    source: "iana",
    extensions: [
      "disposition-notification"
    ]
  },
  "message/external-body": {
    source: "iana"
  },
  "message/feedback-report": {
    source: "iana"
  },
  "message/global": {
    source: "iana",
    extensions: [
      "u8msg"
    ]
  },
  "message/global-delivery-status": {
    source: "iana",
    extensions: [
      "u8dsn"
    ]
  },
  "message/global-disposition-notification": {
    source: "iana",
    extensions: [
      "u8mdn"
    ]
  },
  "message/global-headers": {
    source: "iana",
    extensions: [
      "u8hdr"
    ]
  },
  "message/http": {
    source: "iana",
    compressible: false
  },
  "message/imdn+xml": {
    source: "iana",
    compressible: true
  },
  "message/news": {
    source: "iana"
  },
  "message/partial": {
    source: "iana",
    compressible: false
  },
  "message/rfc822": {
    source: "iana",
    compressible: true,
    extensions: [
      "eml",
      "mime"
    ]
  },
  "message/s-http": {
    source: "iana"
  },
  "message/sip": {
    source: "iana"
  },
  "message/sipfrag": {
    source: "iana"
  },
  "message/tracking-status": {
    source: "iana"
  },
  "message/vnd.si.simp": {
    source: "iana"
  },
  "message/vnd.wfa.wsc": {
    source: "iana",
    extensions: [
      "wsc"
    ]
  },
  "model/3mf": {
    source: "iana",
    extensions: [
      "3mf"
    ]
  },
  "model/e57": {
    source: "iana"
  },
  "model/gltf+json": {
    source: "iana",
    compressible: true,
    extensions: [
      "gltf"
    ]
  },
  "model/gltf-binary": {
    source: "iana",
    compressible: true,
    extensions: [
      "glb"
    ]
  },
  "model/iges": {
    source: "iana",
    compressible: false,
    extensions: [
      "igs",
      "iges"
    ]
  },
  "model/mesh": {
    source: "iana",
    compressible: false,
    extensions: [
      "msh",
      "mesh",
      "silo"
    ]
  },
  "model/mtl": {
    source: "iana",
    extensions: [
      "mtl"
    ]
  },
  "model/obj": {
    source: "iana",
    extensions: [
      "obj"
    ]
  },
  "model/step": {
    source: "iana"
  },
  "model/step+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "stpx"
    ]
  },
  "model/step+zip": {
    source: "iana",
    compressible: false,
    extensions: [
      "stpz"
    ]
  },
  "model/step-xml+zip": {
    source: "iana",
    compressible: false,
    extensions: [
      "stpxz"
    ]
  },
  "model/stl": {
    source: "iana",
    extensions: [
      "stl"
    ]
  },
  "model/vnd.collada+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "dae"
    ]
  },
  "model/vnd.dwf": {
    source: "iana",
    extensions: [
      "dwf"
    ]
  },
  "model/vnd.flatland.3dml": {
    source: "iana"
  },
  "model/vnd.gdl": {
    source: "iana",
    extensions: [
      "gdl"
    ]
  },
  "model/vnd.gs-gdl": {
    source: "apache"
  },
  "model/vnd.gs.gdl": {
    source: "iana"
  },
  "model/vnd.gtw": {
    source: "iana",
    extensions: [
      "gtw"
    ]
  },
  "model/vnd.moml+xml": {
    source: "iana",
    compressible: true
  },
  "model/vnd.mts": {
    source: "iana",
    extensions: [
      "mts"
    ]
  },
  "model/vnd.opengex": {
    source: "iana",
    extensions: [
      "ogex"
    ]
  },
  "model/vnd.parasolid.transmit.binary": {
    source: "iana",
    extensions: [
      "x_b"
    ]
  },
  "model/vnd.parasolid.transmit.text": {
    source: "iana",
    extensions: [
      "x_t"
    ]
  },
  "model/vnd.pytha.pyox": {
    source: "iana"
  },
  "model/vnd.rosette.annotated-data-model": {
    source: "iana"
  },
  "model/vnd.sap.vds": {
    source: "iana",
    extensions: [
      "vds"
    ]
  },
  "model/vnd.usdz+zip": {
    source: "iana",
    compressible: false,
    extensions: [
      "usdz"
    ]
  },
  "model/vnd.valve.source.compiled-map": {
    source: "iana",
    extensions: [
      "bsp"
    ]
  },
  "model/vnd.vtu": {
    source: "iana",
    extensions: [
      "vtu"
    ]
  },
  "model/vrml": {
    source: "iana",
    compressible: false,
    extensions: [
      "wrl",
      "vrml"
    ]
  },
  "model/x3d+binary": {
    source: "apache",
    compressible: false,
    extensions: [
      "x3db",
      "x3dbz"
    ]
  },
  "model/x3d+fastinfoset": {
    source: "iana",
    extensions: [
      "x3db"
    ]
  },
  "model/x3d+vrml": {
    source: "apache",
    compressible: false,
    extensions: [
      "x3dv",
      "x3dvz"
    ]
  },
  "model/x3d+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "x3d",
      "x3dz"
    ]
  },
  "model/x3d-vrml": {
    source: "iana",
    extensions: [
      "x3dv"
    ]
  },
  "multipart/alternative": {
    source: "iana",
    compressible: false
  },
  "multipart/appledouble": {
    source: "iana"
  },
  "multipart/byteranges": {
    source: "iana"
  },
  "multipart/digest": {
    source: "iana"
  },
  "multipart/encrypted": {
    source: "iana",
    compressible: false
  },
  "multipart/form-data": {
    source: "iana",
    compressible: false
  },
  "multipart/header-set": {
    source: "iana"
  },
  "multipart/mixed": {
    source: "iana"
  },
  "multipart/multilingual": {
    source: "iana"
  },
  "multipart/parallel": {
    source: "iana"
  },
  "multipart/related": {
    source: "iana",
    compressible: false
  },
  "multipart/report": {
    source: "iana"
  },
  "multipart/signed": {
    source: "iana",
    compressible: false
  },
  "multipart/vnd.bint.med-plus": {
    source: "iana"
  },
  "multipart/voice-message": {
    source: "iana"
  },
  "multipart/x-mixed-replace": {
    source: "iana"
  },
  "text/1d-interleaved-parityfec": {
    source: "iana"
  },
  "text/cache-manifest": {
    source: "iana",
    compressible: true,
    extensions: [
      "appcache",
      "manifest"
    ]
  },
  "text/calendar": {
    source: "iana",
    extensions: [
      "ics",
      "ifb"
    ]
  },
  "text/calender": {
    compressible: true
  },
  "text/cmd": {
    compressible: true
  },
  "text/coffeescript": {
    extensions: [
      "coffee",
      "litcoffee"
    ]
  },
  "text/cql": {
    source: "iana"
  },
  "text/cql-expression": {
    source: "iana"
  },
  "text/cql-identifier": {
    source: "iana"
  },
  "text/css": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "css"
    ]
  },
  "text/csv": {
    source: "iana",
    compressible: true,
    extensions: [
      "csv"
    ]
  },
  "text/csv-schema": {
    source: "iana"
  },
  "text/directory": {
    source: "iana"
  },
  "text/dns": {
    source: "iana"
  },
  "text/ecmascript": {
    source: "iana"
  },
  "text/encaprtp": {
    source: "iana"
  },
  "text/enriched": {
    source: "iana"
  },
  "text/fhirpath": {
    source: "iana"
  },
  "text/flexfec": {
    source: "iana"
  },
  "text/fwdred": {
    source: "iana"
  },
  "text/gff3": {
    source: "iana"
  },
  "text/grammar-ref-list": {
    source: "iana"
  },
  "text/html": {
    source: "iana",
    compressible: true,
    extensions: [
      "html",
      "htm",
      "shtml"
    ]
  },
  "text/jade": {
    extensions: [
      "jade"
    ]
  },
  "text/javascript": {
    source: "iana",
    compressible: true
  },
  "text/jcr-cnd": {
    source: "iana"
  },
  "text/jsx": {
    compressible: true,
    extensions: [
      "jsx"
    ]
  },
  "text/less": {
    compressible: true,
    extensions: [
      "less"
    ]
  },
  "text/markdown": {
    source: "iana",
    compressible: true,
    extensions: [
      "markdown",
      "md"
    ]
  },
  "text/mathml": {
    source: "nginx",
    extensions: [
      "mml"
    ]
  },
  "text/mdx": {
    compressible: true,
    extensions: [
      "mdx"
    ]
  },
  "text/mizar": {
    source: "iana"
  },
  "text/n3": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "n3"
    ]
  },
  "text/parameters": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/parityfec": {
    source: "iana"
  },
  "text/plain": {
    source: "iana",
    compressible: true,
    extensions: [
      "txt",
      "text",
      "conf",
      "def",
      "list",
      "log",
      "in",
      "ini"
    ]
  },
  "text/provenance-notation": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/prs.fallenstein.rst": {
    source: "iana"
  },
  "text/prs.lines.tag": {
    source: "iana",
    extensions: [
      "dsc"
    ]
  },
  "text/prs.prop.logic": {
    source: "iana"
  },
  "text/raptorfec": {
    source: "iana"
  },
  "text/red": {
    source: "iana"
  },
  "text/rfc822-headers": {
    source: "iana"
  },
  "text/richtext": {
    source: "iana",
    compressible: true,
    extensions: [
      "rtx"
    ]
  },
  "text/rtf": {
    source: "iana",
    compressible: true,
    extensions: [
      "rtf"
    ]
  },
  "text/rtp-enc-aescm128": {
    source: "iana"
  },
  "text/rtploopback": {
    source: "iana"
  },
  "text/rtx": {
    source: "iana"
  },
  "text/sgml": {
    source: "iana",
    extensions: [
      "sgml",
      "sgm"
    ]
  },
  "text/shaclc": {
    source: "iana"
  },
  "text/shex": {
    source: "iana",
    extensions: [
      "shex"
    ]
  },
  "text/slim": {
    extensions: [
      "slim",
      "slm"
    ]
  },
  "text/spdx": {
    source: "iana",
    extensions: [
      "spdx"
    ]
  },
  "text/strings": {
    source: "iana"
  },
  "text/stylus": {
    extensions: [
      "stylus",
      "styl"
    ]
  },
  "text/t140": {
    source: "iana"
  },
  "text/tab-separated-values": {
    source: "iana",
    compressible: true,
    extensions: [
      "tsv"
    ]
  },
  "text/troff": {
    source: "iana",
    extensions: [
      "t",
      "tr",
      "roff",
      "man",
      "me",
      "ms"
    ]
  },
  "text/turtle": {
    source: "iana",
    charset: "UTF-8",
    extensions: [
      "ttl"
    ]
  },
  "text/ulpfec": {
    source: "iana"
  },
  "text/uri-list": {
    source: "iana",
    compressible: true,
    extensions: [
      "uri",
      "uris",
      "urls"
    ]
  },
  "text/vcard": {
    source: "iana",
    compressible: true,
    extensions: [
      "vcard"
    ]
  },
  "text/vnd.a": {
    source: "iana"
  },
  "text/vnd.abc": {
    source: "iana"
  },
  "text/vnd.ascii-art": {
    source: "iana"
  },
  "text/vnd.curl": {
    source: "iana",
    extensions: [
      "curl"
    ]
  },
  "text/vnd.curl.dcurl": {
    source: "apache",
    extensions: [
      "dcurl"
    ]
  },
  "text/vnd.curl.mcurl": {
    source: "apache",
    extensions: [
      "mcurl"
    ]
  },
  "text/vnd.curl.scurl": {
    source: "apache",
    extensions: [
      "scurl"
    ]
  },
  "text/vnd.debian.copyright": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/vnd.dmclientscript": {
    source: "iana"
  },
  "text/vnd.dvb.subtitle": {
    source: "iana",
    extensions: [
      "sub"
    ]
  },
  "text/vnd.esmertec.theme-descriptor": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/vnd.familysearch.gedcom": {
    source: "iana",
    extensions: [
      "ged"
    ]
  },
  "text/vnd.ficlab.flt": {
    source: "iana"
  },
  "text/vnd.fly": {
    source: "iana",
    extensions: [
      "fly"
    ]
  },
  "text/vnd.fmi.flexstor": {
    source: "iana",
    extensions: [
      "flx"
    ]
  },
  "text/vnd.gml": {
    source: "iana"
  },
  "text/vnd.graphviz": {
    source: "iana",
    extensions: [
      "gv"
    ]
  },
  "text/vnd.hans": {
    source: "iana"
  },
  "text/vnd.hgl": {
    source: "iana"
  },
  "text/vnd.in3d.3dml": {
    source: "iana",
    extensions: [
      "3dml"
    ]
  },
  "text/vnd.in3d.spot": {
    source: "iana",
    extensions: [
      "spot"
    ]
  },
  "text/vnd.iptc.newsml": {
    source: "iana"
  },
  "text/vnd.iptc.nitf": {
    source: "iana"
  },
  "text/vnd.latex-z": {
    source: "iana"
  },
  "text/vnd.motorola.reflex": {
    source: "iana"
  },
  "text/vnd.ms-mediapackage": {
    source: "iana"
  },
  "text/vnd.net2phone.commcenter.command": {
    source: "iana"
  },
  "text/vnd.radisys.msml-basic-layout": {
    source: "iana"
  },
  "text/vnd.senx.warpscript": {
    source: "iana"
  },
  "text/vnd.si.uricatalogue": {
    source: "iana"
  },
  "text/vnd.sosi": {
    source: "iana"
  },
  "text/vnd.sun.j2me.app-descriptor": {
    source: "iana",
    charset: "UTF-8",
    extensions: [
      "jad"
    ]
  },
  "text/vnd.trolltech.linguist": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/vnd.wap.si": {
    source: "iana"
  },
  "text/vnd.wap.sl": {
    source: "iana"
  },
  "text/vnd.wap.wml": {
    source: "iana",
    extensions: [
      "wml"
    ]
  },
  "text/vnd.wap.wmlscript": {
    source: "iana",
    extensions: [
      "wmls"
    ]
  },
  "text/vtt": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "vtt"
    ]
  },
  "text/x-asm": {
    source: "apache",
    extensions: [
      "s",
      "asm"
    ]
  },
  "text/x-c": {
    source: "apache",
    extensions: [
      "c",
      "cc",
      "cxx",
      "cpp",
      "h",
      "hh",
      "dic"
    ]
  },
  "text/x-component": {
    source: "nginx",
    extensions: [
      "htc"
    ]
  },
  "text/x-fortran": {
    source: "apache",
    extensions: [
      "f",
      "for",
      "f77",
      "f90"
    ]
  },
  "text/x-gwt-rpc": {
    compressible: true
  },
  "text/x-handlebars-template": {
    extensions: [
      "hbs"
    ]
  },
  "text/x-java-source": {
    source: "apache",
    extensions: [
      "java"
    ]
  },
  "text/x-jquery-tmpl": {
    compressible: true
  },
  "text/x-lua": {
    extensions: [
      "lua"
    ]
  },
  "text/x-markdown": {
    compressible: true,
    extensions: [
      "mkd"
    ]
  },
  "text/x-nfo": {
    source: "apache",
    extensions: [
      "nfo"
    ]
  },
  "text/x-opml": {
    source: "apache",
    extensions: [
      "opml"
    ]
  },
  "text/x-org": {
    compressible: true,
    extensions: [
      "org"
    ]
  },
  "text/x-pascal": {
    source: "apache",
    extensions: [
      "p",
      "pas"
    ]
  },
  "text/x-processing": {
    compressible: true,
    extensions: [
      "pde"
    ]
  },
  "text/x-sass": {
    extensions: [
      "sass"
    ]
  },
  "text/x-scss": {
    extensions: [
      "scss"
    ]
  },
  "text/x-setext": {
    source: "apache",
    extensions: [
      "etx"
    ]
  },
  "text/x-sfv": {
    source: "apache",
    extensions: [
      "sfv"
    ]
  },
  "text/x-suse-ymp": {
    compressible: true,
    extensions: [
      "ymp"
    ]
  },
  "text/x-uuencode": {
    source: "apache",
    extensions: [
      "uu"
    ]
  },
  "text/x-vcalendar": {
    source: "apache",
    extensions: [
      "vcs"
    ]
  },
  "text/x-vcard": {
    source: "apache",
    extensions: [
      "vcf"
    ]
  },
  "text/xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xml"
    ]
  },
  "text/xml-external-parsed-entity": {
    source: "iana"
  },
  "text/yaml": {
    compressible: true,
    extensions: [
      "yaml",
      "yml"
    ]
  },
  "video/1d-interleaved-parityfec": {
    source: "iana"
  },
  "video/3gpp": {
    source: "iana",
    extensions: [
      "3gp",
      "3gpp"
    ]
  },
  "video/3gpp-tt": {
    source: "iana"
  },
  "video/3gpp2": {
    source: "iana",
    extensions: [
      "3g2"
    ]
  },
  "video/av1": {
    source: "iana"
  },
  "video/bmpeg": {
    source: "iana"
  },
  "video/bt656": {
    source: "iana"
  },
  "video/celb": {
    source: "iana"
  },
  "video/dv": {
    source: "iana"
  },
  "video/encaprtp": {
    source: "iana"
  },
  "video/ffv1": {
    source: "iana"
  },
  "video/flexfec": {
    source: "iana"
  },
  "video/h261": {
    source: "iana",
    extensions: [
      "h261"
    ]
  },
  "video/h263": {
    source: "iana",
    extensions: [
      "h263"
    ]
  },
  "video/h263-1998": {
    source: "iana"
  },
  "video/h263-2000": {
    source: "iana"
  },
  "video/h264": {
    source: "iana",
    extensions: [
      "h264"
    ]
  },
  "video/h264-rcdo": {
    source: "iana"
  },
  "video/h264-svc": {
    source: "iana"
  },
  "video/h265": {
    source: "iana"
  },
  "video/iso.segment": {
    source: "iana",
    extensions: [
      "m4s"
    ]
  },
  "video/jpeg": {
    source: "iana",
    extensions: [
      "jpgv"
    ]
  },
  "video/jpeg2000": {
    source: "iana"
  },
  "video/jpm": {
    source: "apache",
    extensions: [
      "jpm",
      "jpgm"
    ]
  },
  "video/jxsv": {
    source: "iana"
  },
  "video/mj2": {
    source: "iana",
    extensions: [
      "mj2",
      "mjp2"
    ]
  },
  "video/mp1s": {
    source: "iana"
  },
  "video/mp2p": {
    source: "iana"
  },
  "video/mp2t": {
    source: "iana",
    extensions: [
      "ts"
    ]
  },
  "video/mp4": {
    source: "iana",
    compressible: false,
    extensions: [
      "mp4",
      "mp4v",
      "mpg4"
    ]
  },
  "video/mp4v-es": {
    source: "iana"
  },
  "video/mpeg": {
    source: "iana",
    compressible: false,
    extensions: [
      "mpeg",
      "mpg",
      "mpe",
      "m1v",
      "m2v"
    ]
  },
  "video/mpeg4-generic": {
    source: "iana"
  },
  "video/mpv": {
    source: "iana"
  },
  "video/nv": {
    source: "iana"
  },
  "video/ogg": {
    source: "iana",
    compressible: false,
    extensions: [
      "ogv"
    ]
  },
  "video/parityfec": {
    source: "iana"
  },
  "video/pointer": {
    source: "iana"
  },
  "video/quicktime": {
    source: "iana",
    compressible: false,
    extensions: [
      "qt",
      "mov"
    ]
  },
  "video/raptorfec": {
    source: "iana"
  },
  "video/raw": {
    source: "iana"
  },
  "video/rtp-enc-aescm128": {
    source: "iana"
  },
  "video/rtploopback": {
    source: "iana"
  },
  "video/rtx": {
    source: "iana"
  },
  "video/scip": {
    source: "iana"
  },
  "video/smpte291": {
    source: "iana"
  },
  "video/smpte292m": {
    source: "iana"
  },
  "video/ulpfec": {
    source: "iana"
  },
  "video/vc1": {
    source: "iana"
  },
  "video/vc2": {
    source: "iana"
  },
  "video/vnd.cctv": {
    source: "iana"
  },
  "video/vnd.dece.hd": {
    source: "iana",
    extensions: [
      "uvh",
      "uvvh"
    ]
  },
  "video/vnd.dece.mobile": {
    source: "iana",
    extensions: [
      "uvm",
      "uvvm"
    ]
  },
  "video/vnd.dece.mp4": {
    source: "iana"
  },
  "video/vnd.dece.pd": {
    source: "iana",
    extensions: [
      "uvp",
      "uvvp"
    ]
  },
  "video/vnd.dece.sd": {
    source: "iana",
    extensions: [
      "uvs",
      "uvvs"
    ]
  },
  "video/vnd.dece.video": {
    source: "iana",
    extensions: [
      "uvv",
      "uvvv"
    ]
  },
  "video/vnd.directv.mpeg": {
    source: "iana"
  },
  "video/vnd.directv.mpeg-tts": {
    source: "iana"
  },
  "video/vnd.dlna.mpeg-tts": {
    source: "iana"
  },
  "video/vnd.dvb.file": {
    source: "iana",
    extensions: [
      "dvb"
    ]
  },
  "video/vnd.fvt": {
    source: "iana",
    extensions: [
      "fvt"
    ]
  },
  "video/vnd.hns.video": {
    source: "iana"
  },
  "video/vnd.iptvforum.1dparityfec-1010": {
    source: "iana"
  },
  "video/vnd.iptvforum.1dparityfec-2005": {
    source: "iana"
  },
  "video/vnd.iptvforum.2dparityfec-1010": {
    source: "iana"
  },
  "video/vnd.iptvforum.2dparityfec-2005": {
    source: "iana"
  },
  "video/vnd.iptvforum.ttsavc": {
    source: "iana"
  },
  "video/vnd.iptvforum.ttsmpeg2": {
    source: "iana"
  },
  "video/vnd.motorola.video": {
    source: "iana"
  },
  "video/vnd.motorola.videop": {
    source: "iana"
  },
  "video/vnd.mpegurl": {
    source: "iana",
    extensions: [
      "mxu",
      "m4u"
    ]
  },
  "video/vnd.ms-playready.media.pyv": {
    source: "iana",
    extensions: [
      "pyv"
    ]
  },
  "video/vnd.nokia.interleaved-multimedia": {
    source: "iana"
  },
  "video/vnd.nokia.mp4vr": {
    source: "iana"
  },
  "video/vnd.nokia.videovoip": {
    source: "iana"
  },
  "video/vnd.objectvideo": {
    source: "iana"
  },
  "video/vnd.radgamettools.bink": {
    source: "iana"
  },
  "video/vnd.radgamettools.smacker": {
    source: "iana"
  },
  "video/vnd.sealed.mpeg1": {
    source: "iana"
  },
  "video/vnd.sealed.mpeg4": {
    source: "iana"
  },
  "video/vnd.sealed.swf": {
    source: "iana"
  },
  "video/vnd.sealedmedia.softseal.mov": {
    source: "iana"
  },
  "video/vnd.uvvu.mp4": {
    source: "iana",
    extensions: [
      "uvu",
      "uvvu"
    ]
  },
  "video/vnd.vivo": {
    source: "iana",
    extensions: [
      "viv"
    ]
  },
  "video/vnd.youtube.yt": {
    source: "iana"
  },
  "video/vp8": {
    source: "iana"
  },
  "video/vp9": {
    source: "iana"
  },
  "video/webm": {
    source: "apache",
    compressible: false,
    extensions: [
      "webm"
    ]
  },
  "video/x-f4v": {
    source: "apache",
    extensions: [
      "f4v"
    ]
  },
  "video/x-fli": {
    source: "apache",
    extensions: [
      "fli"
    ]
  },
  "video/x-flv": {
    source: "apache",
    compressible: false,
    extensions: [
      "flv"
    ]
  },
  "video/x-m4v": {
    source: "apache",
    extensions: [
      "m4v"
    ]
  },
  "video/x-matroska": {
    source: "apache",
    compressible: false,
    extensions: [
      "mkv",
      "mk3d",
      "mks"
    ]
  },
  "video/x-mng": {
    source: "apache",
    extensions: [
      "mng"
    ]
  },
  "video/x-ms-asf": {
    source: "apache",
    extensions: [
      "asf",
      "asx"
    ]
  },
  "video/x-ms-vob": {
    source: "apache",
    extensions: [
      "vob"
    ]
  },
  "video/x-ms-wm": {
    source: "apache",
    extensions: [
      "wm"
    ]
  },
  "video/x-ms-wmv": {
    source: "apache",
    compressible: false,
    extensions: [
      "wmv"
    ]
  },
  "video/x-ms-wmx": {
    source: "apache",
    extensions: [
      "wmx"
    ]
  },
  "video/x-ms-wvx": {
    source: "apache",
    extensions: [
      "wvx"
    ]
  },
  "video/x-msvideo": {
    source: "apache",
    extensions: [
      "avi"
    ]
  },
  "video/x-sgi-movie": {
    source: "apache",
    extensions: [
      "movie"
    ]
  },
  "video/x-smv": {
    source: "apache",
    extensions: [
      "smv"
    ]
  },
  "x-conference/x-cooltalk": {
    source: "apache",
    extensions: [
      "ice"
    ]
  },
  "x-shader/x-fragment": {
    compressible: true
  },
  "x-shader/x-vertex": {
    compressible: true
  }
};
/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var mimeDb = require$$0;
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
(function(exports) {
  var db = mimeDb;
  var extname2 = path$4.extname;
  var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
  var TEXT_TYPE_REGEXP = /^text\//i;
  exports.charset = charset3;
  exports.charsets = { lookup: charset3 };
  exports.contentType = contentType3;
  exports.extension = extension;
  exports.extensions = /* @__PURE__ */ Object.create(null);
  exports.lookup = lookup2;
  exports.types = /* @__PURE__ */ Object.create(null);
  populateMaps(exports.extensions, exports.types);
  function charset3(type3) {
    if (!type3 || typeof type3 !== "string") {
      return false;
    }
    var match2 = EXTRACT_TYPE_REGEXP.exec(type3);
    var mime2 = match2 && db[match2[1].toLowerCase()];
    if (mime2 && mime2.charset) {
      return mime2.charset;
    }
    if (match2 && TEXT_TYPE_REGEXP.test(match2[1])) {
      return "UTF-8";
    }
    return false;
  }
  function contentType3(str) {
    if (!str || typeof str !== "string") {
      return false;
    }
    var mime2 = str.indexOf("/") === -1 ? exports.lookup(str) : str;
    if (!mime2) {
      return false;
    }
    if (mime2.indexOf("charset") === -1) {
      var charset4 = exports.charset(mime2);
      if (charset4)
        mime2 += "; charset=" + charset4.toLowerCase();
    }
    return mime2;
  }
  function extension(type3) {
    if (!type3 || typeof type3 !== "string") {
      return false;
    }
    var match2 = EXTRACT_TYPE_REGEXP.exec(type3);
    var exts = match2 && exports.extensions[match2[1].toLowerCase()];
    if (!exts || !exts.length) {
      return false;
    }
    return exts[0];
  }
  function lookup2(path3) {
    if (!path3 || typeof path3 !== "string") {
      return false;
    }
    var extension2 = extname2("x." + path3).toLowerCase().substr(1);
    if (!extension2) {
      return false;
    }
    return exports.types[extension2] || false;
  }
  function populateMaps(extensions, types) {
    var preference = ["nginx", "apache", void 0, "iana"];
    Object.keys(db).forEach(function forEachMimeType(type3) {
      var mime2 = db[type3];
      var exts = mime2.extensions;
      if (!exts || !exts.length) {
        return;
      }
      extensions[type3] = exts;
      for (var i = 0; i < exts.length; i++) {
        var extension2 = exts[i];
        if (types[extension2]) {
          var from = preference.indexOf(db[types[extension2]].source);
          var to = preference.indexOf(mime2.source);
          if (types[extension2] !== "application/octet-stream" && (from > to || from === to && types[extension2].substr(0, 12) === "application/")) {
            continue;
          }
        }
        types[extension2] = type3;
      }
    });
  }
})(mimeTypes);
/*!
 * type-is
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var typer = mediaTyper;
var mime$5 = mimeTypes;
typeIs.exports = typeofrequest;
typeIs.exports.is = typeis$1;
typeIs.exports.hasBody = hasbody;
typeIs.exports.normalize = normalize$1;
typeIs.exports.match = mimeMatch;
function typeis$1(value, types_) {
  var i;
  var types = types_;
  var val = tryNormalizeType(value);
  if (!val) {
    return false;
  }
  if (types && !Array.isArray(types)) {
    types = new Array(arguments.length - 1);
    for (i = 0; i < types.length; i++) {
      types[i] = arguments[i + 1];
    }
  }
  if (!types || !types.length) {
    return val;
  }
  var type3;
  for (i = 0; i < types.length; i++) {
    if (mimeMatch(normalize$1(type3 = types[i]), val)) {
      return type3[0] === "+" || type3.indexOf("*") !== -1 ? val : type3;
    }
  }
  return false;
}
function hasbody(req2) {
  return req2.headers["transfer-encoding"] !== void 0 || !isNaN(req2.headers["content-length"]);
}
function typeofrequest(req2, types_) {
  var types = types_;
  if (!hasbody(req2)) {
    return null;
  }
  if (arguments.length > 2) {
    types = new Array(arguments.length - 1);
    for (var i = 0; i < types.length; i++) {
      types[i] = arguments[i + 1];
    }
  }
  var value = req2.headers["content-type"];
  return typeis$1(value, types);
}
function normalize$1(type3) {
  if (typeof type3 !== "string") {
    return false;
  }
  switch (type3) {
    case "urlencoded":
      return "application/x-www-form-urlencoded";
    case "multipart":
      return "multipart/*";
  }
  if (type3[0] === "+") {
    return "*/*" + type3;
  }
  return type3.indexOf("/") === -1 ? mime$5.lookup(type3) : type3;
}
function mimeMatch(expected, actual) {
  if (expected === false) {
    return false;
  }
  var actualParts = actual.split("/");
  var expectedParts = expected.split("/");
  if (actualParts.length !== 2 || expectedParts.length !== 2) {
    return false;
  }
  if (expectedParts[0] !== "*" && expectedParts[0] !== actualParts[0]) {
    return false;
  }
  if (expectedParts[1].substr(0, 2) === "*+") {
    return expectedParts[1].length <= actualParts[1].length + 1 && expectedParts[1].substr(1) === actualParts[1].substr(1 - expectedParts[1].length);
  }
  if (expectedParts[1] !== "*" && expectedParts[1] !== actualParts[1]) {
    return false;
  }
  return true;
}
function normalizeType$1(value) {
  var type3 = typer.parse(value);
  type3.parameters = void 0;
  return typer.format(type3);
}
function tryNormalizeType(value) {
  if (!value) {
    return null;
  }
  try {
    return normalizeType$1(value);
  } catch (err) {
    return null;
  }
}
var typeIsExports = typeIs.exports;
/*!
 * body-parser
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var json_1;
var hasRequiredJson;
function requireJson() {
  if (hasRequiredJson)
    return json_1;
  hasRequiredJson = 1;
  var bytes2 = requireBytes();
  var contentType$1 = contentType;
  var createError2 = httpErrorsExports;
  var debug2 = requireSrc$1()("body-parser:json");
  var read = requireRead();
  var typeis2 = typeIsExports;
  json_1 = json2;
  var FIRST_CHAR_REGEXP = /^[\x20\x09\x0a\x0d]*([^\x20\x09\x0a\x0d])/;
  var JSON_SYNTAX_CHAR = "#";
  var JSON_SYNTAX_REGEXP = /#+/g;
  function json2(options) {
    var opts = options || {};
    var limit = typeof opts.limit !== "number" ? bytes2.parse(opts.limit || "100kb") : opts.limit;
    var inflate = opts.inflate !== false;
    var reviver = opts.reviver;
    var strict = opts.strict !== false;
    var type3 = opts.type || "application/json";
    var verify = opts.verify || false;
    if (verify !== false && typeof verify !== "function") {
      throw new TypeError("option verify must be function");
    }
    var shouldParse = typeof type3 !== "function" ? typeChecker(type3) : type3;
    function parse2(body) {
      if (body.length === 0) {
        return {};
      }
      if (strict) {
        var first2 = firstchar(body);
        if (first2 !== "{" && first2 !== "[") {
          debug2("strict violation");
          throw createStrictSyntaxError(body, first2);
        }
      }
      try {
        debug2("parse json");
        return JSON.parse(body, reviver);
      } catch (e) {
        throw normalizeJsonSyntaxError(e, {
          message: e.message,
          stack: e.stack
        });
      }
    }
    return function jsonParser(req2, res2, next) {
      if (req2._body) {
        debug2("body already parsed");
        next();
        return;
      }
      req2.body = req2.body || {};
      if (!typeis2.hasBody(req2)) {
        debug2("skip empty body");
        next();
        return;
      }
      debug2("content-type %j", req2.headers["content-type"]);
      if (!shouldParse(req2)) {
        debug2("skip parsing");
        next();
        return;
      }
      var charset3 = getCharset(req2) || "utf-8";
      if (charset3.slice(0, 4) !== "utf-") {
        debug2("invalid charset");
        next(createError2(415, 'unsupported charset "' + charset3.toUpperCase() + '"', {
          charset: charset3,
          type: "charset.unsupported"
        }));
        return;
      }
      read(req2, res2, next, parse2, debug2, {
        encoding: charset3,
        inflate,
        limit,
        verify
      });
    };
  }
  function createStrictSyntaxError(str, char) {
    var index2 = str.indexOf(char);
    var partial = "";
    if (index2 !== -1) {
      partial = str.substring(0, index2) + JSON_SYNTAX_CHAR;
      for (var i = index2 + 1; i < str.length; i++) {
        partial += JSON_SYNTAX_CHAR;
      }
    }
    try {
      JSON.parse(partial);
      throw new SyntaxError("strict violation");
    } catch (e) {
      return normalizeJsonSyntaxError(e, {
        message: e.message.replace(JSON_SYNTAX_REGEXP, function(placeholder) {
          return str.substring(index2, index2 + placeholder.length);
        }),
        stack: e.stack
      });
    }
  }
  function firstchar(str) {
    var match2 = FIRST_CHAR_REGEXP.exec(str);
    return match2 ? match2[1] : void 0;
  }
  function getCharset(req2) {
    try {
      return (contentType$1.parse(req2).parameters.charset || "").toLowerCase();
    } catch (e) {
      return void 0;
    }
  }
  function normalizeJsonSyntaxError(error2, obj) {
    var keys2 = Object.getOwnPropertyNames(error2);
    for (var i = 0; i < keys2.length; i++) {
      var key = keys2[i];
      if (key !== "stack" && key !== "message") {
        delete error2[key];
      }
    }
    error2.stack = obj.stack.replace(error2.message, obj.message);
    error2.message = obj.message;
    return error2;
  }
  function typeChecker(type3) {
    return function checkType(req2) {
      return Boolean(typeis2(req2, type3));
    };
  }
  return json_1;
}
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var raw_1;
var hasRequiredRaw;
function requireRaw() {
  if (hasRequiredRaw)
    return raw_1;
  hasRequiredRaw = 1;
  var bytes2 = requireBytes();
  var debug2 = requireSrc$1()("body-parser:raw");
  var read = requireRead();
  var typeis2 = typeIsExports;
  raw_1 = raw;
  function raw(options) {
    var opts = options || {};
    var inflate = opts.inflate !== false;
    var limit = typeof opts.limit !== "number" ? bytes2.parse(opts.limit || "100kb") : opts.limit;
    var type3 = opts.type || "application/octet-stream";
    var verify = opts.verify || false;
    if (verify !== false && typeof verify !== "function") {
      throw new TypeError("option verify must be function");
    }
    var shouldParse = typeof type3 !== "function" ? typeChecker(type3) : type3;
    function parse2(buf) {
      return buf;
    }
    return function rawParser(req2, res2, next) {
      if (req2._body) {
        debug2("body already parsed");
        next();
        return;
      }
      req2.body = req2.body || {};
      if (!typeis2.hasBody(req2)) {
        debug2("skip empty body");
        next();
        return;
      }
      debug2("content-type %j", req2.headers["content-type"]);
      if (!shouldParse(req2)) {
        debug2("skip parsing");
        next();
        return;
      }
      read(req2, res2, next, parse2, debug2, {
        encoding: null,
        inflate,
        limit,
        verify
      });
    };
  }
  function typeChecker(type3) {
    return function checkType(req2) {
      return Boolean(typeis2(req2, type3));
    };
  }
  return raw_1;
}
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var text_1;
var hasRequiredText;
function requireText() {
  if (hasRequiredText)
    return text_1;
  hasRequiredText = 1;
  var bytes2 = requireBytes();
  var contentType$1 = contentType;
  var debug2 = requireSrc$1()("body-parser:text");
  var read = requireRead();
  var typeis2 = typeIsExports;
  text_1 = text;
  function text(options) {
    var opts = options || {};
    var defaultCharset = opts.defaultCharset || "utf-8";
    var inflate = opts.inflate !== false;
    var limit = typeof opts.limit !== "number" ? bytes2.parse(opts.limit || "100kb") : opts.limit;
    var type3 = opts.type || "text/plain";
    var verify = opts.verify || false;
    if (verify !== false && typeof verify !== "function") {
      throw new TypeError("option verify must be function");
    }
    var shouldParse = typeof type3 !== "function" ? typeChecker(type3) : type3;
    function parse2(buf) {
      return buf;
    }
    return function textParser(req2, res2, next) {
      if (req2._body) {
        debug2("body already parsed");
        next();
        return;
      }
      req2.body = req2.body || {};
      if (!typeis2.hasBody(req2)) {
        debug2("skip empty body");
        next();
        return;
      }
      debug2("content-type %j", req2.headers["content-type"]);
      if (!shouldParse(req2)) {
        debug2("skip parsing");
        next();
        return;
      }
      var charset3 = getCharset(req2) || defaultCharset;
      read(req2, res2, next, parse2, debug2, {
        encoding: charset3,
        inflate,
        limit,
        verify
      });
    };
  }
  function getCharset(req2) {
    try {
      return (contentType$1.parse(req2).parameters.charset || "").toLowerCase();
    } catch (e) {
      return void 0;
    }
  }
  function typeChecker(type3) {
    return function checkType(req2) {
      return Boolean(typeis2(req2, type3));
    };
  }
  return text_1;
}
var esErrors;
var hasRequiredEsErrors;
function requireEsErrors() {
  if (hasRequiredEsErrors)
    return esErrors;
  hasRequiredEsErrors = 1;
  esErrors = Error;
  return esErrors;
}
var _eval;
var hasRequired_eval;
function require_eval() {
  if (hasRequired_eval)
    return _eval;
  hasRequired_eval = 1;
  _eval = EvalError;
  return _eval;
}
var range;
var hasRequiredRange;
function requireRange() {
  if (hasRequiredRange)
    return range;
  hasRequiredRange = 1;
  range = RangeError;
  return range;
}
var ref;
var hasRequiredRef;
function requireRef() {
  if (hasRequiredRef)
    return ref;
  hasRequiredRef = 1;
  ref = ReferenceError;
  return ref;
}
var syntax;
var hasRequiredSyntax;
function requireSyntax() {
  if (hasRequiredSyntax)
    return syntax;
  hasRequiredSyntax = 1;
  syntax = SyntaxError;
  return syntax;
}
var type;
var hasRequiredType;
function requireType() {
  if (hasRequiredType)
    return type;
  hasRequiredType = 1;
  type = TypeError;
  return type;
}
var uri;
var hasRequiredUri;
function requireUri() {
  if (hasRequiredUri)
    return uri;
  hasRequiredUri = 1;
  uri = URIError;
  return uri;
}
var shams;
var hasRequiredShams;
function requireShams() {
  if (hasRequiredShams)
    return shams;
  hasRequiredShams = 1;
  shams = function hasSymbols2() {
    if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
      return false;
    }
    if (typeof Symbol.iterator === "symbol") {
      return true;
    }
    var obj = {};
    var sym = Symbol("test");
    var symObj = Object(sym);
    if (typeof sym === "string") {
      return false;
    }
    if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
      return false;
    }
    if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
      return false;
    }
    var symVal = 42;
    obj[sym] = symVal;
    for (sym in obj) {
      return false;
    }
    if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
      return false;
    }
    if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
      return false;
    }
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) {
      return false;
    }
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
      return false;
    }
    if (typeof Object.getOwnPropertyDescriptor === "function") {
      var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
      if (descriptor.value !== symVal || descriptor.enumerable !== true) {
        return false;
      }
    }
    return true;
  };
  return shams;
}
var hasSymbols;
var hasRequiredHasSymbols;
function requireHasSymbols() {
  if (hasRequiredHasSymbols)
    return hasSymbols;
  hasRequiredHasSymbols = 1;
  var origSymbol = typeof Symbol !== "undefined" && Symbol;
  var hasSymbolSham = requireShams();
  hasSymbols = function hasNativeSymbols() {
    if (typeof origSymbol !== "function") {
      return false;
    }
    if (typeof Symbol !== "function") {
      return false;
    }
    if (typeof origSymbol("foo") !== "symbol") {
      return false;
    }
    if (typeof Symbol("bar") !== "symbol") {
      return false;
    }
    return hasSymbolSham();
  };
  return hasSymbols;
}
var hasProto;
var hasRequiredHasProto;
function requireHasProto() {
  if (hasRequiredHasProto)
    return hasProto;
  hasRequiredHasProto = 1;
  var test = {
    __proto__: null,
    foo: {}
  };
  var $Object = Object;
  hasProto = function hasProto2() {
    return { __proto__: test }.foo === test.foo && !(test instanceof $Object);
  };
  return hasProto;
}
var implementation;
var hasRequiredImplementation;
function requireImplementation() {
  if (hasRequiredImplementation)
    return implementation;
  hasRequiredImplementation = 1;
  var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
  var toStr = Object.prototype.toString;
  var max = Math.max;
  var funcType = "[object Function]";
  var concatty = function concatty2(a, b2) {
    var arr = [];
    for (var i = 0; i < a.length; i += 1) {
      arr[i] = a[i];
    }
    for (var j2 = 0; j2 < b2.length; j2 += 1) {
      arr[j2 + a.length] = b2[j2];
    }
    return arr;
  };
  var slicy = function slicy2(arrLike, offset) {
    var arr = [];
    for (var i = offset || 0, j2 = 0; i < arrLike.length; i += 1, j2 += 1) {
      arr[j2] = arrLike[i];
    }
    return arr;
  };
  var joiny = function(arr, joiner) {
    var str = "";
    for (var i = 0; i < arr.length; i += 1) {
      str += arr[i];
      if (i + 1 < arr.length) {
        str += joiner;
      }
    }
    return str;
  };
  implementation = function bind2(that) {
    var target = this;
    if (typeof target !== "function" || toStr.apply(target) !== funcType) {
      throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);
    var bound;
    var binder = function() {
      if (this instanceof bound) {
        var result = target.apply(
          this,
          concatty(args, arguments)
        );
        if (Object(result) === result) {
          return result;
        }
        return this;
      }
      return target.apply(
        that,
        concatty(args, arguments)
      );
    };
    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
      boundArgs[i] = "$" + i;
    }
    bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
    if (target.prototype) {
      var Empty = function Empty2() {
      };
      Empty.prototype = target.prototype;
      bound.prototype = new Empty();
      Empty.prototype = null;
    }
    return bound;
  };
  return implementation;
}
var functionBind;
var hasRequiredFunctionBind;
function requireFunctionBind() {
  if (hasRequiredFunctionBind)
    return functionBind;
  hasRequiredFunctionBind = 1;
  var implementation2 = requireImplementation();
  functionBind = Function.prototype.bind || implementation2;
  return functionBind;
}
var hasown;
var hasRequiredHasown;
function requireHasown() {
  if (hasRequiredHasown)
    return hasown;
  hasRequiredHasown = 1;
  var call = Function.prototype.call;
  var $hasOwn = Object.prototype.hasOwnProperty;
  var bind2 = requireFunctionBind();
  hasown = bind2.call(call, $hasOwn);
  return hasown;
}
var getIntrinsic;
var hasRequiredGetIntrinsic;
function requireGetIntrinsic() {
  if (hasRequiredGetIntrinsic)
    return getIntrinsic;
  hasRequiredGetIntrinsic = 1;
  var undefined$1;
  var $Error = requireEsErrors();
  var $EvalError = require_eval();
  var $RangeError = requireRange();
  var $ReferenceError = requireRef();
  var $SyntaxError = requireSyntax();
  var $TypeError = requireType();
  var $URIError = requireUri();
  var $Function = Function;
  var getEvalledConstructor = function(expressionSyntax) {
    try {
      return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
    } catch (e) {
    }
  };
  var $gOPD = Object.getOwnPropertyDescriptor;
  if ($gOPD) {
    try {
      $gOPD({}, "");
    } catch (e) {
      $gOPD = null;
    }
  }
  var throwTypeError = function() {
    throw new $TypeError();
  };
  var ThrowTypeError = $gOPD ? function() {
    try {
      arguments.callee;
      return throwTypeError;
    } catch (calleeThrows) {
      try {
        return $gOPD(arguments, "callee").get;
      } catch (gOPDthrows) {
        return throwTypeError;
      }
    }
  }() : throwTypeError;
  var hasSymbols2 = requireHasSymbols()();
  var hasProto2 = requireHasProto()();
  var getProto = Object.getPrototypeOf || (hasProto2 ? function(x2) {
    return x2.__proto__;
  } : null);
  var needsEval = {};
  var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined$1 : getProto(Uint8Array);
  var INTRINSICS = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
    "%ArrayIteratorPrototype%": hasSymbols2 && getProto ? getProto([][Symbol.iterator]()) : undefined$1,
    "%AsyncFromSyncIteratorPrototype%": undefined$1,
    "%AsyncFunction%": needsEval,
    "%AsyncGenerator%": needsEval,
    "%AsyncGeneratorFunction%": needsEval,
    "%AsyncIteratorPrototype%": needsEval,
    "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
    "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
    "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined$1 : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined$1 : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": $Error,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": $EvalError,
    "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
    "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
    "%Function%": $Function,
    "%GeneratorFunction%": needsEval,
    "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
    "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
    "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": hasSymbols2 && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
    "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
    "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
    "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols2 || !getProto ? undefined$1 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": Object,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
    "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
    "%RangeError%": $RangeError,
    "%ReferenceError%": $ReferenceError,
    "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
    "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols2 || !getProto ? undefined$1 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": hasSymbols2 && getProto ? getProto(""[Symbol.iterator]()) : undefined$1,
    "%Symbol%": hasSymbols2 ? Symbol : undefined$1,
    "%SyntaxError%": $SyntaxError,
    "%ThrowTypeError%": ThrowTypeError,
    "%TypedArray%": TypedArray,
    "%TypeError%": $TypeError,
    "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
    "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
    "%URIError%": $URIError,
    "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
    "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
    "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet
  };
  if (getProto) {
    try {
      null.error;
    } catch (e) {
      var errorProto = getProto(getProto(e));
      INTRINSICS["%Error.prototype%"] = errorProto;
    }
  }
  var doEval = function doEval2(name) {
    var value;
    if (name === "%AsyncFunction%") {
      value = getEvalledConstructor("async function () {}");
    } else if (name === "%GeneratorFunction%") {
      value = getEvalledConstructor("function* () {}");
    } else if (name === "%AsyncGeneratorFunction%") {
      value = getEvalledConstructor("async function* () {}");
    } else if (name === "%AsyncGenerator%") {
      var fn = doEval2("%AsyncGeneratorFunction%");
      if (fn) {
        value = fn.prototype;
      }
    } else if (name === "%AsyncIteratorPrototype%") {
      var gen = doEval2("%AsyncGenerator%");
      if (gen && getProto) {
        value = getProto(gen.prototype);
      }
    }
    INTRINSICS[name] = value;
    return value;
  };
  var LEGACY_ALIASES = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  };
  var bind2 = requireFunctionBind();
  var hasOwn = requireHasown();
  var $concat = bind2.call(Function.call, Array.prototype.concat);
  var $spliceApply = bind2.call(Function.apply, Array.prototype.splice);
  var $replace = bind2.call(Function.call, String.prototype.replace);
  var $strSlice = bind2.call(Function.call, String.prototype.slice);
  var $exec = bind2.call(Function.call, RegExp.prototype.exec);
  var rePropName2 = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
  var reEscapeChar2 = /\\(\\)?/g;
  var stringToPath2 = function stringToPath3(string) {
    var first2 = $strSlice(string, 0, 1);
    var last2 = $strSlice(string, -1);
    if (first2 === "%" && last2 !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
    } else if (last2 === "%" && first2 !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
    }
    var result = [];
    $replace(string, rePropName2, function(match2, number, quote, subString) {
      result[result.length] = quote ? $replace(subString, reEscapeChar2, "$1") : number || match2;
    });
    return result;
  };
  var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
    var intrinsicName = name;
    var alias;
    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
      alias = LEGACY_ALIASES[intrinsicName];
      intrinsicName = "%" + alias[0] + "%";
    }
    if (hasOwn(INTRINSICS, intrinsicName)) {
      var value = INTRINSICS[intrinsicName];
      if (value === needsEval) {
        value = doEval(intrinsicName);
      }
      if (typeof value === "undefined" && !allowMissing) {
        throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
      }
      return {
        alias,
        name: intrinsicName,
        value
      };
    }
    throw new $SyntaxError("intrinsic " + name + " does not exist!");
  };
  getIntrinsic = function GetIntrinsic(name, allowMissing) {
    if (typeof name !== "string" || name.length === 0) {
      throw new $TypeError("intrinsic name must be a non-empty string");
    }
    if (arguments.length > 1 && typeof allowMissing !== "boolean") {
      throw new $TypeError('"allowMissing" argument must be a boolean');
    }
    if ($exec(/^%?[^%]*%?$/, name) === null) {
      throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    }
    var parts = stringToPath2(name);
    var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
    var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
    var intrinsicRealName = intrinsic.name;
    var value = intrinsic.value;
    var skipFurtherCaching = false;
    var alias = intrinsic.alias;
    if (alias) {
      intrinsicBaseName = alias[0];
      $spliceApply(parts, $concat([0, 1], alias));
    }
    for (var i = 1, isOwn = true; i < parts.length; i += 1) {
      var part = parts[i];
      var first2 = $strSlice(part, 0, 1);
      var last2 = $strSlice(part, -1);
      if ((first2 === '"' || first2 === "'" || first2 === "`" || (last2 === '"' || last2 === "'" || last2 === "`")) && first2 !== last2) {
        throw new $SyntaxError("property names with quotes must have matching quotes");
      }
      if (part === "constructor" || !isOwn) {
        skipFurtherCaching = true;
      }
      intrinsicBaseName += "." + part;
      intrinsicRealName = "%" + intrinsicBaseName + "%";
      if (hasOwn(INTRINSICS, intrinsicRealName)) {
        value = INTRINSICS[intrinsicRealName];
      } else if (value != null) {
        if (!(part in value)) {
          if (!allowMissing) {
            throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
          }
          return void 0;
        }
        if ($gOPD && i + 1 >= parts.length) {
          var desc = $gOPD(value, part);
          isOwn = !!desc;
          if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
            value = desc.get;
          } else {
            value = value[part];
          }
        } else {
          isOwn = hasOwn(value, part);
          value = value[part];
        }
        if (isOwn && !skipFurtherCaching) {
          INTRINSICS[intrinsicRealName] = value;
        }
      }
    }
    return value;
  };
  return getIntrinsic;
}
var callBind = { exports: {} };
var esDefineProperty;
var hasRequiredEsDefineProperty;
function requireEsDefineProperty() {
  if (hasRequiredEsDefineProperty)
    return esDefineProperty;
  hasRequiredEsDefineProperty = 1;
  var GetIntrinsic = requireGetIntrinsic();
  var $defineProperty = GetIntrinsic("%Object.defineProperty%", true) || false;
  if ($defineProperty) {
    try {
      $defineProperty({}, "a", { value: 1 });
    } catch (e) {
      $defineProperty = false;
    }
  }
  esDefineProperty = $defineProperty;
  return esDefineProperty;
}
var gopd;
var hasRequiredGopd;
function requireGopd() {
  if (hasRequiredGopd)
    return gopd;
  hasRequiredGopd = 1;
  var GetIntrinsic = requireGetIntrinsic();
  var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
  if ($gOPD) {
    try {
      $gOPD([], "length");
    } catch (e) {
      $gOPD = null;
    }
  }
  gopd = $gOPD;
  return gopd;
}
var defineDataProperty;
var hasRequiredDefineDataProperty;
function requireDefineDataProperty() {
  if (hasRequiredDefineDataProperty)
    return defineDataProperty;
  hasRequiredDefineDataProperty = 1;
  var $defineProperty = requireEsDefineProperty();
  var $SyntaxError = requireSyntax();
  var $TypeError = requireType();
  var gopd2 = requireGopd();
  defineDataProperty = function defineDataProperty2(obj, property2, value) {
    if (!obj || typeof obj !== "object" && typeof obj !== "function") {
      throw new $TypeError("`obj` must be an object or a function`");
    }
    if (typeof property2 !== "string" && typeof property2 !== "symbol") {
      throw new $TypeError("`property` must be a string or a symbol`");
    }
    if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
      throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
    }
    if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
      throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
    }
    if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
      throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
    }
    if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
      throw new $TypeError("`loose`, if provided, must be a boolean");
    }
    var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
    var nonWritable = arguments.length > 4 ? arguments[4] : null;
    var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
    var loose = arguments.length > 6 ? arguments[6] : false;
    var desc = !!gopd2 && gopd2(obj, property2);
    if ($defineProperty) {
      $defineProperty(obj, property2, {
        configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
        enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
        value,
        writable: nonWritable === null && desc ? desc.writable : !nonWritable
      });
    } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
      obj[property2] = value;
    } else {
      throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
    }
  };
  return defineDataProperty;
}
var hasPropertyDescriptors_1;
var hasRequiredHasPropertyDescriptors;
function requireHasPropertyDescriptors() {
  if (hasRequiredHasPropertyDescriptors)
    return hasPropertyDescriptors_1;
  hasRequiredHasPropertyDescriptors = 1;
  var $defineProperty = requireEsDefineProperty();
  var hasPropertyDescriptors = function hasPropertyDescriptors2() {
    return !!$defineProperty;
  };
  hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
    if (!$defineProperty) {
      return null;
    }
    try {
      return $defineProperty([], "length", { value: 1 }).length !== 1;
    } catch (e) {
      return true;
    }
  };
  hasPropertyDescriptors_1 = hasPropertyDescriptors;
  return hasPropertyDescriptors_1;
}
var setFunctionLength;
var hasRequiredSetFunctionLength;
function requireSetFunctionLength() {
  if (hasRequiredSetFunctionLength)
    return setFunctionLength;
  hasRequiredSetFunctionLength = 1;
  var GetIntrinsic = requireGetIntrinsic();
  var define = requireDefineDataProperty();
  var hasDescriptors = requireHasPropertyDescriptors()();
  var gOPD = requireGopd();
  var $TypeError = requireType();
  var $floor = GetIntrinsic("%Math.floor%");
  setFunctionLength = function setFunctionLength2(fn, length) {
    if (typeof fn !== "function") {
      throw new $TypeError("`fn` is not a function");
    }
    if (typeof length !== "number" || length < 0 || length > 4294967295 || $floor(length) !== length) {
      throw new $TypeError("`length` must be a positive 32-bit integer");
    }
    var loose = arguments.length > 2 && !!arguments[2];
    var functionLengthIsConfigurable = true;
    var functionLengthIsWritable = true;
    if ("length" in fn && gOPD) {
      var desc = gOPD(fn, "length");
      if (desc && !desc.configurable) {
        functionLengthIsConfigurable = false;
      }
      if (desc && !desc.writable) {
        functionLengthIsWritable = false;
      }
    }
    if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
      if (hasDescriptors) {
        define(
          /** @type {Parameters<define>[0]} */
          fn,
          "length",
          length,
          true,
          true
        );
      } else {
        define(
          /** @type {Parameters<define>[0]} */
          fn,
          "length",
          length
        );
      }
    }
    return fn;
  };
  return setFunctionLength;
}
var hasRequiredCallBind;
function requireCallBind() {
  if (hasRequiredCallBind)
    return callBind.exports;
  hasRequiredCallBind = 1;
  (function(module) {
    var bind2 = requireFunctionBind();
    var GetIntrinsic = requireGetIntrinsic();
    var setFunctionLength2 = requireSetFunctionLength();
    var $TypeError = requireType();
    var $apply = GetIntrinsic("%Function.prototype.apply%");
    var $call = GetIntrinsic("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind2.call($call, $apply);
    var $defineProperty = requireEsDefineProperty();
    var $max = GetIntrinsic("%Math.max%");
    module.exports = function callBind2(originalFunction) {
      if (typeof originalFunction !== "function") {
        throw new $TypeError("a function is required");
      }
      var func = $reflectApply(bind2, $call, arguments);
      return setFunctionLength2(
        func,
        1 + $max(0, originalFunction.length - (arguments.length - 1)),
        true
      );
    };
    var applyBind = function applyBind2() {
      return $reflectApply(bind2, $apply, arguments);
    };
    if ($defineProperty) {
      $defineProperty(module.exports, "apply", { value: applyBind });
    } else {
      module.exports.apply = applyBind;
    }
  })(callBind);
  return callBind.exports;
}
var callBound;
var hasRequiredCallBound;
function requireCallBound() {
  if (hasRequiredCallBound)
    return callBound;
  hasRequiredCallBound = 1;
  var GetIntrinsic = requireGetIntrinsic();
  var callBind2 = requireCallBind();
  var $indexOf = callBind2(GetIntrinsic("String.prototype.indexOf"));
  callBound = function callBoundIntrinsic(name, allowMissing) {
    var intrinsic = GetIntrinsic(name, !!allowMissing);
    if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
      return callBind2(intrinsic);
    }
    return intrinsic;
  };
  return callBound;
}
var util_inspect;
var hasRequiredUtil_inspect;
function requireUtil_inspect() {
  if (hasRequiredUtil_inspect)
    return util_inspect;
  hasRequiredUtil_inspect = 1;
  util_inspect = require$$1$1.inspect;
  return util_inspect;
}
var objectInspect;
var hasRequiredObjectInspect;
function requireObjectInspect() {
  if (hasRequiredObjectInspect)
    return objectInspect;
  hasRequiredObjectInspect = 1;
  var hasMap = typeof Map === "function" && Map.prototype;
  var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
  var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
  var mapForEach = hasMap && Map.prototype.forEach;
  var hasSet = typeof Set === "function" && Set.prototype;
  var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
  var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
  var setForEach = hasSet && Set.prototype.forEach;
  var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
  var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
  var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
  var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
  var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
  var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
  var booleanValueOf = Boolean.prototype.valueOf;
  var objectToString2 = Object.prototype.toString;
  var functionToString = Function.prototype.toString;
  var $match = String.prototype.match;
  var $slice = String.prototype.slice;
  var $replace = String.prototype.replace;
  var $toUpperCase = String.prototype.toUpperCase;
  var $toLowerCase = String.prototype.toLowerCase;
  var $test = RegExp.prototype.test;
  var $concat = Array.prototype.concat;
  var $join = Array.prototype.join;
  var $arrSlice = Array.prototype.slice;
  var $floor = Math.floor;
  var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
  var gOPS = Object.getOwnPropertySymbols;
  var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
  var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
  var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
  var isEnumerable = Object.prototype.propertyIsEnumerable;
  var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O2) {
    return O2.__proto__;
  } : null);
  function addNumericSeparator(num, str) {
    if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
      return str;
    }
    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof num === "number") {
      var int = num < 0 ? -$floor(-num) : $floor(num);
      if (int !== num) {
        var intStr = String(int);
        var dec = $slice.call(str, intStr.length + 1);
        return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
      }
    }
    return $replace.call(str, sepRegex, "$&_");
  }
  var utilInspect = requireUtil_inspect();
  var inspectCustom = utilInspect.custom;
  var inspectSymbol = isSymbol2(inspectCustom) ? inspectCustom : null;
  objectInspect = function inspect_(obj, options, depth, seen) {
    var opts = options || {};
    if (has(opts, "quoteStyle") && (opts.quoteStyle !== "single" && opts.quoteStyle !== "double")) {
      throw new TypeError('option "quoteStyle" must be "single" or "double"');
    }
    if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
      throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    }
    var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
    if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
      throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
    }
    if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
      throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    }
    if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
      throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    }
    var numericSeparator = opts.numericSeparator;
    if (typeof obj === "undefined") {
      return "undefined";
    }
    if (obj === null) {
      return "null";
    }
    if (typeof obj === "boolean") {
      return obj ? "true" : "false";
    }
    if (typeof obj === "string") {
      return inspectString(obj, opts);
    }
    if (typeof obj === "number") {
      if (obj === 0) {
        return Infinity / obj > 0 ? "0" : "-0";
      }
      var str = String(obj);
      return numericSeparator ? addNumericSeparator(obj, str) : str;
    }
    if (typeof obj === "bigint") {
      var bigIntStr = String(obj) + "n";
      return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
    }
    var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
    if (typeof depth === "undefined") {
      depth = 0;
    }
    if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
      return isArray2(obj) ? "[Array]" : "[Object]";
    }
    var indent = getIndent(opts, depth);
    if (typeof seen === "undefined") {
      seen = [];
    } else if (indexOf(seen, obj) >= 0) {
      return "[Circular]";
    }
    function inspect(value, from, noIndent) {
      if (from) {
        seen = $arrSlice.call(seen);
        seen.push(from);
      }
      if (noIndent) {
        var newOpts = {
          depth: opts.depth
        };
        if (has(opts, "quoteStyle")) {
          newOpts.quoteStyle = opts.quoteStyle;
        }
        return inspect_(value, newOpts, depth + 1, seen);
      }
      return inspect_(value, opts, depth + 1, seen);
    }
    if (typeof obj === "function" && !isRegExp2(obj)) {
      var name = nameOf(obj);
      var keys2 = arrObjKeys(obj, inspect);
      return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys2.length > 0 ? " { " + $join.call(keys2, ", ") + " }" : "");
    }
    if (isSymbol2(obj)) {
      var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
      return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
    }
    if (isElement(obj)) {
      var s2 = "<" + $toLowerCase.call(String(obj.nodeName));
      var attrs = obj.attributes || [];
      for (var i = 0; i < attrs.length; i++) {
        s2 += " " + attrs[i].name + "=" + wrapQuotes(quote(attrs[i].value), "double", opts);
      }
      s2 += ">";
      if (obj.childNodes && obj.childNodes.length) {
        s2 += "...";
      }
      s2 += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
      return s2;
    }
    if (isArray2(obj)) {
      if (obj.length === 0) {
        return "[]";
      }
      var xs = arrObjKeys(obj, inspect);
      if (indent && !singleLineValues(xs)) {
        return "[" + indentedJoin(xs, indent) + "]";
      }
      return "[ " + $join.call(xs, ", ") + " ]";
    }
    if (isError(obj)) {
      var parts = arrObjKeys(obj, inspect);
      if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
        return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect(obj.cause), parts), ", ") + " }";
      }
      if (parts.length === 0) {
        return "[" + String(obj) + "]";
      }
      return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
    }
    if (typeof obj === "object" && customInspect) {
      if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
        return utilInspect(obj, { depth: maxDepth - depth });
      } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
        return obj.inspect();
      }
    }
    if (isMap2(obj)) {
      var mapParts = [];
      if (mapForEach) {
        mapForEach.call(obj, function(value, key) {
          mapParts.push(inspect(key, obj, true) + " => " + inspect(value, obj));
        });
      }
      return collectionOf("Map", mapSize.call(obj), mapParts, indent);
    }
    if (isSet2(obj)) {
      var setParts = [];
      if (setForEach) {
        setForEach.call(obj, function(value) {
          setParts.push(inspect(value, obj));
        });
      }
      return collectionOf("Set", setSize.call(obj), setParts, indent);
    }
    if (isWeakMap(obj)) {
      return weakCollectionOf("WeakMap");
    }
    if (isWeakSet(obj)) {
      return weakCollectionOf("WeakSet");
    }
    if (isWeakRef(obj)) {
      return weakCollectionOf("WeakRef");
    }
    if (isNumber2(obj)) {
      return markBoxed(inspect(Number(obj)));
    }
    if (isBigInt(obj)) {
      return markBoxed(inspect(bigIntValueOf.call(obj)));
    }
    if (isBoolean2(obj)) {
      return markBoxed(booleanValueOf.call(obj));
    }
    if (isString2(obj)) {
      return markBoxed(inspect(String(obj)));
    }
    if (typeof window !== "undefined" && obj === window) {
      return "{ [object Window] }";
    }
    if (obj === commonjsGlobal) {
      return "{ [object globalThis] }";
    }
    if (!isDate2(obj) && !isRegExp2(obj)) {
      var ys = arrObjKeys(obj, inspect);
      var isPlainObject2 = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
      var protoTag = obj instanceof Object ? "" : "null prototype";
      var stringTag2 = !isPlainObject2 && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
      var constructorTag = isPlainObject2 || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
      var tag = constructorTag + (stringTag2 || protoTag ? "[" + $join.call($concat.call([], stringTag2 || [], protoTag || []), ": ") + "] " : "");
      if (ys.length === 0) {
        return tag + "{}";
      }
      if (indent) {
        return tag + "{" + indentedJoin(ys, indent) + "}";
      }
      return tag + "{ " + $join.call(ys, ", ") + " }";
    }
    return String(obj);
  };
  function wrapQuotes(s2, defaultStyle, opts) {
    var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
    return quoteChar + s2 + quoteChar;
  }
  function quote(s2) {
    return $replace.call(String(s2), /"/g, "&quot;");
  }
  function isArray2(obj) {
    return toStr(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
  }
  function isDate2(obj) {
    return toStr(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
  }
  function isRegExp2(obj) {
    return toStr(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
  }
  function isError(obj) {
    return toStr(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
  }
  function isString2(obj) {
    return toStr(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
  }
  function isNumber2(obj) {
    return toStr(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
  }
  function isBoolean2(obj) {
    return toStr(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
  }
  function isSymbol2(obj) {
    if (hasShammedSymbols) {
      return obj && typeof obj === "object" && obj instanceof Symbol;
    }
    if (typeof obj === "symbol") {
      return true;
    }
    if (!obj || typeof obj !== "object" || !symToString) {
      return false;
    }
    try {
      symToString.call(obj);
      return true;
    } catch (e) {
    }
    return false;
  }
  function isBigInt(obj) {
    if (!obj || typeof obj !== "object" || !bigIntValueOf) {
      return false;
    }
    try {
      bigIntValueOf.call(obj);
      return true;
    } catch (e) {
    }
    return false;
  }
  var hasOwn = Object.prototype.hasOwnProperty || function(key) {
    return key in this;
  };
  function has(obj, key) {
    return hasOwn.call(obj, key);
  }
  function toStr(obj) {
    return objectToString2.call(obj);
  }
  function nameOf(f2) {
    if (f2.name) {
      return f2.name;
    }
    var m2 = $match.call(functionToString.call(f2), /^function\s*([\w$]+)/);
    if (m2) {
      return m2[1];
    }
    return null;
  }
  function indexOf(xs, x2) {
    if (xs.indexOf) {
      return xs.indexOf(x2);
    }
    for (var i = 0, l = xs.length; i < l; i++) {
      if (xs[i] === x2) {
        return i;
      }
    }
    return -1;
  }
  function isMap2(x2) {
    if (!mapSize || !x2 || typeof x2 !== "object") {
      return false;
    }
    try {
      mapSize.call(x2);
      try {
        setSize.call(x2);
      } catch (s2) {
        return true;
      }
      return x2 instanceof Map;
    } catch (e) {
    }
    return false;
  }
  function isWeakMap(x2) {
    if (!weakMapHas || !x2 || typeof x2 !== "object") {
      return false;
    }
    try {
      weakMapHas.call(x2, weakMapHas);
      try {
        weakSetHas.call(x2, weakSetHas);
      } catch (s2) {
        return true;
      }
      return x2 instanceof WeakMap;
    } catch (e) {
    }
    return false;
  }
  function isWeakRef(x2) {
    if (!weakRefDeref || !x2 || typeof x2 !== "object") {
      return false;
    }
    try {
      weakRefDeref.call(x2);
      return true;
    } catch (e) {
    }
    return false;
  }
  function isSet2(x2) {
    if (!setSize || !x2 || typeof x2 !== "object") {
      return false;
    }
    try {
      setSize.call(x2);
      try {
        mapSize.call(x2);
      } catch (m2) {
        return true;
      }
      return x2 instanceof Set;
    } catch (e) {
    }
    return false;
  }
  function isWeakSet(x2) {
    if (!weakSetHas || !x2 || typeof x2 !== "object") {
      return false;
    }
    try {
      weakSetHas.call(x2, weakSetHas);
      try {
        weakMapHas.call(x2, weakMapHas);
      } catch (s2) {
        return true;
      }
      return x2 instanceof WeakSet;
    } catch (e) {
    }
    return false;
  }
  function isElement(x2) {
    if (!x2 || typeof x2 !== "object") {
      return false;
    }
    if (typeof HTMLElement !== "undefined" && x2 instanceof HTMLElement) {
      return true;
    }
    return typeof x2.nodeName === "string" && typeof x2.getAttribute === "function";
  }
  function inspectString(str, opts) {
    if (str.length > opts.maxStringLength) {
      var remaining = str.length - opts.maxStringLength;
      var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
      return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
    }
    var s2 = $replace.call($replace.call(str, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
    return wrapQuotes(s2, "single", opts);
  }
  function lowbyte(c2) {
    var n = c2.charCodeAt(0);
    var x2 = {
      8: "b",
      9: "t",
      10: "n",
      12: "f",
      13: "r"
    }[n];
    if (x2) {
      return "\\" + x2;
    }
    return "\\x" + (n < 16 ? "0" : "") + $toUpperCase.call(n.toString(16));
  }
  function markBoxed(str) {
    return "Object(" + str + ")";
  }
  function weakCollectionOf(type3) {
    return type3 + " { ? }";
  }
  function collectionOf(type3, size, entries, indent) {
    var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
    return type3 + " (" + size + ") {" + joinedEntries + "}";
  }
  function singleLineValues(xs) {
    for (var i = 0; i < xs.length; i++) {
      if (indexOf(xs[i], "\n") >= 0) {
        return false;
      }
    }
    return true;
  }
  function getIndent(opts, depth) {
    var baseIndent;
    if (opts.indent === "	") {
      baseIndent = "	";
    } else if (typeof opts.indent === "number" && opts.indent > 0) {
      baseIndent = $join.call(Array(opts.indent + 1), " ");
    } else {
      return null;
    }
    return {
      base: baseIndent,
      prev: $join.call(Array(depth + 1), baseIndent)
    };
  }
  function indentedJoin(xs, indent) {
    if (xs.length === 0) {
      return "";
    }
    var lineJoiner = "\n" + indent.prev + indent.base;
    return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
  }
  function arrObjKeys(obj, inspect) {
    var isArr = isArray2(obj);
    var xs = [];
    if (isArr) {
      xs.length = obj.length;
      for (var i = 0; i < obj.length; i++) {
        xs[i] = has(obj, i) ? inspect(obj[i], obj) : "";
      }
    }
    var syms = typeof gOPS === "function" ? gOPS(obj) : [];
    var symMap;
    if (hasShammedSymbols) {
      symMap = {};
      for (var k2 = 0; k2 < syms.length; k2++) {
        symMap["$" + syms[k2]] = syms[k2];
      }
    }
    for (var key in obj) {
      if (!has(obj, key)) {
        continue;
      }
      if (isArr && String(Number(key)) === key && key < obj.length) {
        continue;
      }
      if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
        continue;
      } else if ($test.call(/[^\w$]/, key)) {
        xs.push(inspect(key, obj) + ": " + inspect(obj[key], obj));
      } else {
        xs.push(key + ": " + inspect(obj[key], obj));
      }
    }
    if (typeof gOPS === "function") {
      for (var j2 = 0; j2 < syms.length; j2++) {
        if (isEnumerable.call(obj, syms[j2])) {
          xs.push("[" + inspect(syms[j2]) + "]: " + inspect(obj[syms[j2]], obj));
        }
      }
    }
    return xs;
  }
  return objectInspect;
}
var sideChannel;
var hasRequiredSideChannel;
function requireSideChannel() {
  if (hasRequiredSideChannel)
    return sideChannel;
  hasRequiredSideChannel = 1;
  var GetIntrinsic = requireGetIntrinsic();
  var callBound2 = requireCallBound();
  var inspect = requireObjectInspect();
  var $TypeError = requireType();
  var $WeakMap = GetIntrinsic("%WeakMap%", true);
  var $Map = GetIntrinsic("%Map%", true);
  var $weakMapGet = callBound2("WeakMap.prototype.get", true);
  var $weakMapSet = callBound2("WeakMap.prototype.set", true);
  var $weakMapHas = callBound2("WeakMap.prototype.has", true);
  var $mapGet = callBound2("Map.prototype.get", true);
  var $mapSet = callBound2("Map.prototype.set", true);
  var $mapHas = callBound2("Map.prototype.has", true);
  var listGetNode = function(list, key) {
    var prev = list;
    var curr;
    for (; (curr = prev.next) !== null; prev = curr) {
      if (curr.key === key) {
        prev.next = curr.next;
        curr.next = /** @type {NonNullable<typeof list.next>} */
        list.next;
        list.next = curr;
        return curr;
      }
    }
  };
  var listGet = function(objects, key) {
    var node2 = listGetNode(objects, key);
    return node2 && node2.value;
  };
  var listSet = function(objects, key, value) {
    var node2 = listGetNode(objects, key);
    if (node2) {
      node2.value = value;
    } else {
      objects.next = /** @type {import('.').ListNode<typeof value>} */
      {
        // eslint-disable-line no-param-reassign, no-extra-parens
        key,
        next: objects.next,
        value
      };
    }
  };
  var listHas = function(objects, key) {
    return !!listGetNode(objects, key);
  };
  sideChannel = function getSideChannel() {
    var $wm;
    var $m;
    var $o;
    var channel = {
      assert: function(key) {
        if (!channel.has(key)) {
          throw new $TypeError("Side channel does not contain " + inspect(key));
        }
      },
      get: function(key) {
        if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
          if ($wm) {
            return $weakMapGet($wm, key);
          }
        } else if ($Map) {
          if ($m) {
            return $mapGet($m, key);
          }
        } else {
          if ($o) {
            return listGet($o, key);
          }
        }
      },
      has: function(key) {
        if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
          if ($wm) {
            return $weakMapHas($wm, key);
          }
        } else if ($Map) {
          if ($m) {
            return $mapHas($m, key);
          }
        } else {
          if ($o) {
            return listHas($o, key);
          }
        }
        return false;
      },
      set: function(key, value) {
        if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
          if (!$wm) {
            $wm = new $WeakMap();
          }
          $weakMapSet($wm, key, value);
        } else if ($Map) {
          if (!$m) {
            $m = new $Map();
          }
          $mapSet($m, key, value);
        } else {
          if (!$o) {
            $o = { key: {}, next: null };
          }
          listSet($o, key, value);
        }
      }
    };
    return channel;
  };
  return sideChannel;
}
var formats;
var hasRequiredFormats;
function requireFormats() {
  if (hasRequiredFormats)
    return formats;
  hasRequiredFormats = 1;
  var replace = String.prototype.replace;
  var percentTwenties = /%20/g;
  var Format = {
    RFC1738: "RFC1738",
    RFC3986: "RFC3986"
  };
  formats = {
    "default": Format.RFC3986,
    formatters: {
      RFC1738: function(value) {
        return replace.call(value, percentTwenties, "+");
      },
      RFC3986: function(value) {
        return String(value);
      }
    },
    RFC1738: Format.RFC1738,
    RFC3986: Format.RFC3986
  };
  return formats;
}
var utils$3;
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils)
    return utils$3;
  hasRequiredUtils = 1;
  var formats2 = requireFormats();
  var has = Object.prototype.hasOwnProperty;
  var isArray2 = Array.isArray;
  var hexTable = function() {
    var array = [];
    for (var i = 0; i < 256; ++i) {
      array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
    }
    return array;
  }();
  var compactQueue = function compactQueue2(queue) {
    while (queue.length > 1) {
      var item = queue.pop();
      var obj = item.obj[item.prop];
      if (isArray2(obj)) {
        var compacted = [];
        for (var j2 = 0; j2 < obj.length; ++j2) {
          if (typeof obj[j2] !== "undefined") {
            compacted.push(obj[j2]);
          }
        }
        item.obj[item.prop] = compacted;
      }
    }
  };
  var arrayToObject2 = function arrayToObject3(source, options) {
    var obj = options && options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
    for (var i = 0; i < source.length; ++i) {
      if (typeof source[i] !== "undefined") {
        obj[i] = source[i];
      }
    }
    return obj;
  };
  var merge2 = function merge3(target, source, options) {
    if (!source) {
      return target;
    }
    if (typeof source !== "object") {
      if (isArray2(target)) {
        target.push(source);
      } else if (target && typeof target === "object") {
        if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) {
          target[source] = true;
        }
      } else {
        return [target, source];
      }
      return target;
    }
    if (!target || typeof target !== "object") {
      return [target].concat(source);
    }
    var mergeTarget = target;
    if (isArray2(target) && !isArray2(source)) {
      mergeTarget = arrayToObject2(target, options);
    }
    if (isArray2(target) && isArray2(source)) {
      source.forEach(function(item, i) {
        if (has.call(target, i)) {
          var targetItem = target[i];
          if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
            target[i] = merge3(targetItem, item, options);
          } else {
            target.push(item);
          }
        } else {
          target[i] = item;
        }
      });
      return target;
    }
    return Object.keys(source).reduce(function(acc, key) {
      var value = source[key];
      if (has.call(acc, key)) {
        acc[key] = merge3(acc[key], value, options);
      } else {
        acc[key] = value;
      }
      return acc;
    }, mergeTarget);
  };
  var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function(acc, key) {
      acc[key] = source[key];
      return acc;
    }, target);
  };
  var decode2 = function(str, decoder, charset3) {
    var strWithoutPlus = str.replace(/\+/g, " ");
    if (charset3 === "iso-8859-1") {
      return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    }
    try {
      return decodeURIComponent(strWithoutPlus);
    } catch (e) {
      return strWithoutPlus;
    }
  };
  var encode2 = function encode3(str, defaultEncoder, charset3, kind, format2) {
    if (str.length === 0) {
      return str;
    }
    var string = str;
    if (typeof str === "symbol") {
      string = Symbol.prototype.toString.call(str);
    } else if (typeof str !== "string") {
      string = String(str);
    }
    if (charset3 === "iso-8859-1") {
      return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
        return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
      });
    }
    var out = "";
    for (var i = 0; i < string.length; ++i) {
      var c2 = string.charCodeAt(i);
      if (c2 === 45 || c2 === 46 || c2 === 95 || c2 === 126 || c2 >= 48 && c2 <= 57 || c2 >= 65 && c2 <= 90 || c2 >= 97 && c2 <= 122 || format2 === formats2.RFC1738 && (c2 === 40 || c2 === 41)) {
        out += string.charAt(i);
        continue;
      }
      if (c2 < 128) {
        out = out + hexTable[c2];
        continue;
      }
      if (c2 < 2048) {
        out = out + (hexTable[192 | c2 >> 6] + hexTable[128 | c2 & 63]);
        continue;
      }
      if (c2 < 55296 || c2 >= 57344) {
        out = out + (hexTable[224 | c2 >> 12] + hexTable[128 | c2 >> 6 & 63] + hexTable[128 | c2 & 63]);
        continue;
      }
      i += 1;
      c2 = 65536 + ((c2 & 1023) << 10 | string.charCodeAt(i) & 1023);
      out += hexTable[240 | c2 >> 18] + hexTable[128 | c2 >> 12 & 63] + hexTable[128 | c2 >> 6 & 63] + hexTable[128 | c2 & 63];
    }
    return out;
  };
  var compact2 = function compact3(value) {
    var queue = [{ obj: { o: value }, prop: "o" }];
    var refs = [];
    for (var i = 0; i < queue.length; ++i) {
      var item = queue[i];
      var obj = item.obj[item.prop];
      var keys2 = Object.keys(obj);
      for (var j2 = 0; j2 < keys2.length; ++j2) {
        var key = keys2[j2];
        var val = obj[key];
        if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
          queue.push({ obj, prop: key });
          refs.push(val);
        }
      }
    }
    compactQueue(queue);
    return value;
  };
  var isRegExp2 = function isRegExp3(obj) {
    return Object.prototype.toString.call(obj) === "[object RegExp]";
  };
  var isBuffer2 = function isBuffer3(obj) {
    if (!obj || typeof obj !== "object") {
      return false;
    }
    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
  };
  var combine = function combine2(a, b2) {
    return [].concat(a, b2);
  };
  var maybeMap = function maybeMap2(val, fn) {
    if (isArray2(val)) {
      var mapped = [];
      for (var i = 0; i < val.length; i += 1) {
        mapped.push(fn(val[i]));
      }
      return mapped;
    }
    return fn(val);
  };
  utils$3 = {
    arrayToObject: arrayToObject2,
    assign,
    combine,
    compact: compact2,
    decode: decode2,
    encode: encode2,
    isBuffer: isBuffer2,
    isRegExp: isRegExp2,
    maybeMap,
    merge: merge2
  };
  return utils$3;
}
var stringify_1;
var hasRequiredStringify;
function requireStringify() {
  if (hasRequiredStringify)
    return stringify_1;
  hasRequiredStringify = 1;
  var getSideChannel = requireSideChannel();
  var utils2 = requireUtils();
  var formats2 = requireFormats();
  var has = Object.prototype.hasOwnProperty;
  var arrayPrefixGenerators = {
    brackets: function brackets(prefix) {
      return prefix + "[]";
    },
    comma: "comma",
    indices: function indices(prefix, key) {
      return prefix + "[" + key + "]";
    },
    repeat: function repeat(prefix) {
      return prefix;
    }
  };
  var isArray2 = Array.isArray;
  var split = String.prototype.split;
  var push = Array.prototype.push;
  var pushToArray = function(arr, valueOrArray) {
    push.apply(arr, isArray2(valueOrArray) ? valueOrArray : [valueOrArray]);
  };
  var toISO = Date.prototype.toISOString;
  var defaultFormat = formats2["default"];
  var defaults2 = {
    addQueryPrefix: false,
    allowDots: false,
    charset: "utf-8",
    charsetSentinel: false,
    delimiter: "&",
    encode: true,
    encoder: utils2.encode,
    encodeValuesOnly: false,
    format: defaultFormat,
    formatter: formats2.formatters[defaultFormat],
    // deprecated
    indices: false,
    serializeDate: function serializeDate(date) {
      return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
  };
  var isNonNullishPrimitive = function isNonNullishPrimitive2(v2) {
    return typeof v2 === "string" || typeof v2 === "number" || typeof v2 === "boolean" || typeof v2 === "symbol" || typeof v2 === "bigint";
  };
  var sentinel = {};
  var stringify2 = function stringify3(object, prefix, generateArrayPrefix, commaRoundTrip, strictNullHandling, skipNulls, encoder, filter3, sort, allowDots, serializeDate, format2, formatter, encodeValuesOnly, charset3, sideChannel2) {
    var obj = object;
    var tmpSc = sideChannel2;
    var step = 0;
    var findFlag = false;
    while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
      var pos = tmpSc.get(object);
      step += 1;
      if (typeof pos !== "undefined") {
        if (pos === step) {
          throw new RangeError("Cyclic object value");
        } else {
          findFlag = true;
        }
      }
      if (typeof tmpSc.get(sentinel) === "undefined") {
        step = 0;
      }
    }
    if (typeof filter3 === "function") {
      obj = filter3(prefix, obj);
    } else if (obj instanceof Date) {
      obj = serializeDate(obj);
    } else if (generateArrayPrefix === "comma" && isArray2(obj)) {
      obj = utils2.maybeMap(obj, function(value2) {
        if (value2 instanceof Date) {
          return serializeDate(value2);
        }
        return value2;
      });
    }
    if (obj === null) {
      if (strictNullHandling) {
        return encoder && !encodeValuesOnly ? encoder(prefix, defaults2.encoder, charset3, "key", format2) : prefix;
      }
      obj = "";
    }
    if (isNonNullishPrimitive(obj) || utils2.isBuffer(obj)) {
      if (encoder) {
        var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults2.encoder, charset3, "key", format2);
        if (generateArrayPrefix === "comma" && encodeValuesOnly) {
          var valuesArray = split.call(String(obj), ",");
          var valuesJoined = "";
          for (var i = 0; i < valuesArray.length; ++i) {
            valuesJoined += (i === 0 ? "" : ",") + formatter(encoder(valuesArray[i], defaults2.encoder, charset3, "value", format2));
          }
          return [formatter(keyValue) + (commaRoundTrip && isArray2(obj) && valuesArray.length === 1 ? "[]" : "") + "=" + valuesJoined];
        }
        return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults2.encoder, charset3, "value", format2))];
      }
      return [formatter(prefix) + "=" + formatter(String(obj))];
    }
    var values2 = [];
    if (typeof obj === "undefined") {
      return values2;
    }
    var objKeys;
    if (generateArrayPrefix === "comma" && isArray2(obj)) {
      objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
    } else if (isArray2(filter3)) {
      objKeys = filter3;
    } else {
      var keys2 = Object.keys(obj);
      objKeys = sort ? keys2.sort(sort) : keys2;
    }
    var adjustedPrefix = commaRoundTrip && isArray2(obj) && obj.length === 1 ? prefix + "[]" : prefix;
    for (var j2 = 0; j2 < objKeys.length; ++j2) {
      var key = objKeys[j2];
      var value = typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key];
      if (skipNulls && value === null) {
        continue;
      }
      var keyPrefix = isArray2(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, key) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + key : "[" + key + "]");
      sideChannel2.set(object, step);
      var valueSideChannel = getSideChannel();
      valueSideChannel.set(sentinel, sideChannel2);
      pushToArray(values2, stringify3(
        value,
        keyPrefix,
        generateArrayPrefix,
        commaRoundTrip,
        strictNullHandling,
        skipNulls,
        encoder,
        filter3,
        sort,
        allowDots,
        serializeDate,
        format2,
        formatter,
        encodeValuesOnly,
        charset3,
        valueSideChannel
      ));
    }
    return values2;
  };
  var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
    if (!opts) {
      return defaults2;
    }
    if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
      throw new TypeError("Encoder has to be a function.");
    }
    var charset3 = opts.charset || defaults2.charset;
    if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
      throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    }
    var format2 = formats2["default"];
    if (typeof opts.format !== "undefined") {
      if (!has.call(formats2.formatters, opts.format)) {
        throw new TypeError("Unknown format option provided.");
      }
      format2 = opts.format;
    }
    var formatter = formats2.formatters[format2];
    var filter3 = defaults2.filter;
    if (typeof opts.filter === "function" || isArray2(opts.filter)) {
      filter3 = opts.filter;
    }
    return {
      addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults2.addQueryPrefix,
      allowDots: typeof opts.allowDots === "undefined" ? defaults2.allowDots : !!opts.allowDots,
      charset: charset3,
      charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults2.charsetSentinel,
      delimiter: typeof opts.delimiter === "undefined" ? defaults2.delimiter : opts.delimiter,
      encode: typeof opts.encode === "boolean" ? opts.encode : defaults2.encode,
      encoder: typeof opts.encoder === "function" ? opts.encoder : defaults2.encoder,
      encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults2.encodeValuesOnly,
      filter: filter3,
      format: format2,
      formatter,
      serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults2.serializeDate,
      skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults2.skipNulls,
      sort: typeof opts.sort === "function" ? opts.sort : null,
      strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults2.strictNullHandling
    };
  };
  stringify_1 = function(object, opts) {
    var obj = object;
    var options = normalizeStringifyOptions(opts);
    var objKeys;
    var filter3;
    if (typeof options.filter === "function") {
      filter3 = options.filter;
      obj = filter3("", obj);
    } else if (isArray2(options.filter)) {
      filter3 = options.filter;
      objKeys = filter3;
    }
    var keys2 = [];
    if (typeof obj !== "object" || obj === null) {
      return "";
    }
    var arrayFormat;
    if (opts && opts.arrayFormat in arrayPrefixGenerators) {
      arrayFormat = opts.arrayFormat;
    } else if (opts && "indices" in opts) {
      arrayFormat = opts.indices ? "indices" : "repeat";
    } else {
      arrayFormat = "indices";
    }
    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
    if (opts && "commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
      throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
    }
    var commaRoundTrip = generateArrayPrefix === "comma" && opts && opts.commaRoundTrip;
    if (!objKeys) {
      objKeys = Object.keys(obj);
    }
    if (options.sort) {
      objKeys.sort(options.sort);
    }
    var sideChannel2 = getSideChannel();
    for (var i = 0; i < objKeys.length; ++i) {
      var key = objKeys[i];
      if (options.skipNulls && obj[key] === null) {
        continue;
      }
      pushToArray(keys2, stringify2(
        obj[key],
        key,
        generateArrayPrefix,
        commaRoundTrip,
        options.strictNullHandling,
        options.skipNulls,
        options.encode ? options.encoder : null,
        options.filter,
        options.sort,
        options.allowDots,
        options.serializeDate,
        options.format,
        options.formatter,
        options.encodeValuesOnly,
        options.charset,
        sideChannel2
      ));
    }
    var joined = keys2.join(options.delimiter);
    var prefix = options.addQueryPrefix === true ? "?" : "";
    if (options.charsetSentinel) {
      if (options.charset === "iso-8859-1") {
        prefix += "utf8=%26%2310003%3B&";
      } else {
        prefix += "utf8=%E2%9C%93&";
      }
    }
    return joined.length > 0 ? prefix + joined : "";
  };
  return stringify_1;
}
var parse$7;
var hasRequiredParse;
function requireParse() {
  if (hasRequiredParse)
    return parse$7;
  hasRequiredParse = 1;
  var utils2 = requireUtils();
  var has = Object.prototype.hasOwnProperty;
  var isArray2 = Array.isArray;
  var defaults2 = {
    allowDots: false,
    allowPrototypes: false,
    allowSparse: false,
    arrayLimit: 20,
    charset: "utf-8",
    charsetSentinel: false,
    comma: false,
    decoder: utils2.decode,
    delimiter: "&",
    depth: 5,
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1e3,
    parseArrays: true,
    plainObjects: false,
    strictNullHandling: false
  };
  var interpretNumericEntities = function(str) {
    return str.replace(/&#(\d+);/g, function($0, numberStr) {
      return String.fromCharCode(parseInt(numberStr, 10));
    });
  };
  var parseArrayValue = function(val, options) {
    if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
      return val.split(",");
    }
    return val;
  };
  var isoSentinel = "utf8=%26%2310003%3B";
  var charsetSentinel = "utf8=%E2%9C%93";
  var parseValues = function parseQueryStringValues(str, options) {
    var obj = {};
    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
    var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit);
    var skipIndex = -1;
    var i;
    var charset3 = options.charset;
    if (options.charsetSentinel) {
      for (i = 0; i < parts.length; ++i) {
        if (parts[i].indexOf("utf8=") === 0) {
          if (parts[i] === charsetSentinel) {
            charset3 = "utf-8";
          } else if (parts[i] === isoSentinel) {
            charset3 = "iso-8859-1";
          }
          skipIndex = i;
          i = parts.length;
        }
      }
    }
    for (i = 0; i < parts.length; ++i) {
      if (i === skipIndex) {
        continue;
      }
      var part = parts[i];
      var bracketEqualsPos = part.indexOf("]=");
      var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
      var key, val;
      if (pos === -1) {
        key = options.decoder(part, defaults2.decoder, charset3, "key");
        val = options.strictNullHandling ? null : "";
      } else {
        key = options.decoder(part.slice(0, pos), defaults2.decoder, charset3, "key");
        val = utils2.maybeMap(
          parseArrayValue(part.slice(pos + 1), options),
          function(encodedVal) {
            return options.decoder(encodedVal, defaults2.decoder, charset3, "value");
          }
        );
      }
      if (val && options.interpretNumericEntities && charset3 === "iso-8859-1") {
        val = interpretNumericEntities(val);
      }
      if (part.indexOf("[]=") > -1) {
        val = isArray2(val) ? [val] : val;
      }
      if (has.call(obj, key)) {
        obj[key] = utils2.combine(obj[key], val);
      } else {
        obj[key] = val;
      }
    }
    return obj;
  };
  var parseObject = function(chain, val, options, valuesParsed) {
    var leaf = valuesParsed ? val : parseArrayValue(val, options);
    for (var i = chain.length - 1; i >= 0; --i) {
      var obj;
      var root3 = chain[i];
      if (root3 === "[]" && options.parseArrays) {
        obj = [].concat(leaf);
      } else {
        obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
        var cleanRoot = root3.charAt(0) === "[" && root3.charAt(root3.length - 1) === "]" ? root3.slice(1, -1) : root3;
        var index2 = parseInt(cleanRoot, 10);
        if (!options.parseArrays && cleanRoot === "") {
          obj = { 0: leaf };
        } else if (!isNaN(index2) && root3 !== cleanRoot && String(index2) === cleanRoot && index2 >= 0 && (options.parseArrays && index2 <= options.arrayLimit)) {
          obj = [];
          obj[index2] = leaf;
        } else if (cleanRoot !== "__proto__") {
          obj[cleanRoot] = leaf;
        }
      }
      leaf = obj;
    }
    return leaf;
  };
  var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
    if (!givenKey) {
      return;
    }
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;
    var segment = options.depth > 0 && brackets.exec(key);
    var parent2 = segment ? key.slice(0, segment.index) : key;
    var keys2 = [];
    if (parent2) {
      if (!options.plainObjects && has.call(Object.prototype, parent2)) {
        if (!options.allowPrototypes) {
          return;
        }
      }
      keys2.push(parent2);
    }
    var i = 0;
    while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
      i += 1;
      if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
        if (!options.allowPrototypes) {
          return;
        }
      }
      keys2.push(segment[1]);
    }
    if (segment) {
      keys2.push("[" + key.slice(segment.index) + "]");
    }
    return parseObject(keys2, val, options, valuesParsed);
  };
  var normalizeParseOptions = function normalizeParseOptions2(opts) {
    if (!opts) {
      return defaults2;
    }
    if (opts.decoder !== null && opts.decoder !== void 0 && typeof opts.decoder !== "function") {
      throw new TypeError("Decoder has to be a function.");
    }
    if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
      throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    }
    var charset3 = typeof opts.charset === "undefined" ? defaults2.charset : opts.charset;
    return {
      allowDots: typeof opts.allowDots === "undefined" ? defaults2.allowDots : !!opts.allowDots,
      allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults2.allowPrototypes,
      allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults2.allowSparse,
      arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults2.arrayLimit,
      charset: charset3,
      charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults2.charsetSentinel,
      comma: typeof opts.comma === "boolean" ? opts.comma : defaults2.comma,
      decoder: typeof opts.decoder === "function" ? opts.decoder : defaults2.decoder,
      delimiter: typeof opts.delimiter === "string" || utils2.isRegExp(opts.delimiter) ? opts.delimiter : defaults2.delimiter,
      // eslint-disable-next-line no-implicit-coercion, no-extra-parens
      depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults2.depth,
      ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
      interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults2.interpretNumericEntities,
      parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults2.parameterLimit,
      parseArrays: opts.parseArrays !== false,
      plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults2.plainObjects,
      strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults2.strictNullHandling
    };
  };
  parse$7 = function(str, opts) {
    var options = normalizeParseOptions(opts);
    if (str === "" || str === null || typeof str === "undefined") {
      return options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
    }
    var tempObj = typeof str === "string" ? parseValues(str, options) : str;
    var obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
    var keys2 = Object.keys(tempObj);
    for (var i = 0; i < keys2.length; ++i) {
      var key = keys2[i];
      var newObj = parseKeys(key, tempObj[key], options, typeof str === "string");
      obj = utils2.merge(obj, newObj, options);
    }
    if (options.allowSparse === true) {
      return obj;
    }
    return utils2.compact(obj);
  };
  return parse$7;
}
var lib;
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib)
    return lib;
  hasRequiredLib = 1;
  var stringify2 = requireStringify();
  var parse2 = requireParse();
  var formats2 = requireFormats();
  lib = {
    formats: formats2,
    parse: parse2,
    stringify: stringify2
  };
  return lib;
}
/*!
 * body-parser
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var urlencoded_1;
var hasRequiredUrlencoded;
function requireUrlencoded() {
  if (hasRequiredUrlencoded)
    return urlencoded_1;
  hasRequiredUrlencoded = 1;
  var bytes2 = requireBytes();
  var contentType$1 = contentType;
  var createError2 = httpErrorsExports;
  var debug2 = requireSrc$1()("body-parser:urlencoded");
  var deprecate2 = depd_1("body-parser");
  var read = requireRead();
  var typeis2 = typeIsExports;
  urlencoded_1 = urlencoded;
  var parsers = /* @__PURE__ */ Object.create(null);
  function urlencoded(options) {
    var opts = options || {};
    if (opts.extended === void 0) {
      deprecate2("undefined extended: provide extended option");
    }
    var extended = opts.extended !== false;
    var inflate = opts.inflate !== false;
    var limit = typeof opts.limit !== "number" ? bytes2.parse(opts.limit || "100kb") : opts.limit;
    var type3 = opts.type || "application/x-www-form-urlencoded";
    var verify = opts.verify || false;
    if (verify !== false && typeof verify !== "function") {
      throw new TypeError("option verify must be function");
    }
    var queryparse = extended ? extendedparser(opts) : simpleparser(opts);
    var shouldParse = typeof type3 !== "function" ? typeChecker(type3) : type3;
    function parse2(body) {
      return body.length ? queryparse(body) : {};
    }
    return function urlencodedParser(req2, res2, next) {
      if (req2._body) {
        debug2("body already parsed");
        next();
        return;
      }
      req2.body = req2.body || {};
      if (!typeis2.hasBody(req2)) {
        debug2("skip empty body");
        next();
        return;
      }
      debug2("content-type %j", req2.headers["content-type"]);
      if (!shouldParse(req2)) {
        debug2("skip parsing");
        next();
        return;
      }
      var charset3 = getCharset(req2) || "utf-8";
      if (charset3 !== "utf-8") {
        debug2("invalid charset");
        next(createError2(415, 'unsupported charset "' + charset3.toUpperCase() + '"', {
          charset: charset3,
          type: "charset.unsupported"
        }));
        return;
      }
      read(req2, res2, next, parse2, debug2, {
        debug: debug2,
        encoding: charset3,
        inflate,
        limit,
        verify
      });
    };
  }
  function extendedparser(options) {
    var parameterLimit = options.parameterLimit !== void 0 ? options.parameterLimit : 1e3;
    var parse2 = parser("qs");
    if (isNaN(parameterLimit) || parameterLimit < 1) {
      throw new TypeError("option parameterLimit must be a positive number");
    }
    if (isFinite(parameterLimit)) {
      parameterLimit = parameterLimit | 0;
    }
    return function queryparse(body) {
      var paramCount = parameterCount(body, parameterLimit);
      if (paramCount === void 0) {
        debug2("too many parameters");
        throw createError2(413, "too many parameters", {
          type: "parameters.too.many"
        });
      }
      var arrayLimit = Math.max(100, paramCount);
      debug2("parse extended urlencoding");
      return parse2(body, {
        allowPrototypes: true,
        arrayLimit,
        depth: Infinity,
        parameterLimit
      });
    };
  }
  function getCharset(req2) {
    try {
      return (contentType$1.parse(req2).parameters.charset || "").toLowerCase();
    } catch (e) {
      return void 0;
    }
  }
  function parameterCount(body, limit) {
    var count = 0;
    var index2 = 0;
    while ((index2 = body.indexOf("&", index2)) !== -1) {
      count++;
      index2++;
      if (count === limit) {
        return void 0;
      }
    }
    return count;
  }
  function parser(name) {
    var mod = parsers[name];
    if (mod !== void 0) {
      return mod.parse;
    }
    switch (name) {
      case "qs":
        mod = requireLib();
        break;
      case "querystring":
        mod = require$$8;
        break;
    }
    parsers[name] = mod;
    return mod.parse;
  }
  function simpleparser(options) {
    var parameterLimit = options.parameterLimit !== void 0 ? options.parameterLimit : 1e3;
    var parse2 = parser("querystring");
    if (isNaN(parameterLimit) || parameterLimit < 1) {
      throw new TypeError("option parameterLimit must be a positive number");
    }
    if (isFinite(parameterLimit)) {
      parameterLimit = parameterLimit | 0;
    }
    return function queryparse(body) {
      var paramCount = parameterCount(body, parameterLimit);
      if (paramCount === void 0) {
        debug2("too many parameters");
        throw createError2(413, "too many parameters", {
          type: "parameters.too.many"
        });
      }
      debug2("parse urlencoding");
      return parse2(body, void 0, void 0, { maxKeys: parameterLimit });
    };
  }
  function typeChecker(type3) {
    return function checkType(req2) {
      return Boolean(typeis2(req2, type3));
    };
  }
  return urlencoded_1;
}
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
(function(module, exports) {
  var deprecate2 = depd_1("body-parser");
  var parsers = /* @__PURE__ */ Object.create(null);
  exports = module.exports = deprecate2.function(
    bodyParser2,
    "bodyParser: use individual json/urlencoded middlewares"
  );
  Object.defineProperty(exports, "json", {
    configurable: true,
    enumerable: true,
    get: createParserGetter("json")
  });
  Object.defineProperty(exports, "raw", {
    configurable: true,
    enumerable: true,
    get: createParserGetter("raw")
  });
  Object.defineProperty(exports, "text", {
    configurable: true,
    enumerable: true,
    get: createParserGetter("text")
  });
  Object.defineProperty(exports, "urlencoded", {
    configurable: true,
    enumerable: true,
    get: createParserGetter("urlencoded")
  });
  function bodyParser2(options) {
    var opts = Object.create(options || null, {
      type: {
        configurable: true,
        enumerable: true,
        value: void 0,
        writable: true
      }
    });
    var _urlencoded = exports.urlencoded(opts);
    var _json = exports.json(opts);
    return function bodyParser3(req2, res2, next) {
      _json(req2, res2, function(err) {
        if (err)
          return next(err);
        _urlencoded(req2, res2, next);
      });
    };
  }
  function createParserGetter(name) {
    return function get2() {
      return loadParser(name);
    };
  }
  function loadParser(parserName) {
    var parser = parsers[parserName];
    if (parser !== void 0) {
      return parser;
    }
    switch (parserName) {
      case "json":
        parser = requireJson();
        break;
      case "raw":
        parser = requireRaw();
        break;
      case "text":
        parser = requireText();
        break;
      case "urlencoded":
        parser = requireUrlencoded();
        break;
    }
    return parsers[parserName] = parser;
  }
})(bodyParser, bodyParser.exports);
var bodyParserExports = bodyParser.exports;
/*!
 * merge-descriptors
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var mergeDescriptors = merge$2;
var hasOwnProperty$g = Object.prototype.hasOwnProperty;
function merge$2(dest, src2, redefine) {
  if (!dest) {
    throw new TypeError("argument dest is required");
  }
  if (!src2) {
    throw new TypeError("argument src is required");
  }
  if (redefine === void 0) {
    redefine = true;
  }
  Object.getOwnPropertyNames(src2).forEach(function forEachOwnPropertyName(name) {
    if (!redefine && hasOwnProperty$g.call(dest, name)) {
      return;
    }
    var descriptor = Object.getOwnPropertyDescriptor(src2, name);
    Object.defineProperty(dest, name, descriptor);
  });
  return dest;
}
var application$1 = { exports: {} };
var src$3 = { exports: {} };
var browser$3 = { exports: {} };
var debug$a = { exports: {} };
var ms$5;
var hasRequiredMs$3;
function requireMs$3() {
  if (hasRequiredMs$3)
    return ms$5;
  hasRequiredMs$3 = 1;
  var s2 = 1e3;
  var m2 = s2 * 60;
  var h2 = m2 * 60;
  var d2 = h2 * 24;
  var y2 = d2 * 365.25;
  ms$5 = function(val, options) {
    options = options || {};
    var type3 = typeof val;
    if (type3 === "string" && val.length > 0) {
      return parse2(val);
    } else if (type3 === "number" && isNaN(val) === false) {
      return options.long ? fmtLong2(val) : fmtShort2(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse2(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match2 = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
      str
    );
    if (!match2) {
      return;
    }
    var n = parseFloat(match2[1]);
    var type3 = (match2[2] || "ms").toLowerCase();
    switch (type3) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y2;
      case "days":
      case "day":
      case "d":
        return n * d2;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h2;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m2;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s2;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort2(ms2) {
    if (ms2 >= d2) {
      return Math.round(ms2 / d2) + "d";
    }
    if (ms2 >= h2) {
      return Math.round(ms2 / h2) + "h";
    }
    if (ms2 >= m2) {
      return Math.round(ms2 / m2) + "m";
    }
    if (ms2 >= s2) {
      return Math.round(ms2 / s2) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong2(ms2) {
    return plural2(ms2, d2, "day") || plural2(ms2, h2, "hour") || plural2(ms2, m2, "minute") || plural2(ms2, s2, "second") || ms2 + " ms";
  }
  function plural2(ms2, n, name) {
    if (ms2 < n) {
      return;
    }
    if (ms2 < n * 1.5) {
      return Math.floor(ms2 / n) + " " + name;
    }
    return Math.ceil(ms2 / n) + " " + name + "s";
  }
  return ms$5;
}
var hasRequiredDebug$2;
function requireDebug$2() {
  if (hasRequiredDebug$2)
    return debug$a.exports;
  hasRequiredDebug$2 = 1;
  (function(module, exports) {
    exports = module.exports = createDebug.debug = createDebug["default"] = createDebug;
    exports.coerce = coerce;
    exports.disable = disable;
    exports.enable = enable;
    exports.enabled = enabled;
    exports.humanize = requireMs$3();
    exports.names = [];
    exports.skips = [];
    exports.formatters = {};
    var prevTime;
    function selectColor(namespace) {
      var hash = 0, i;
      for (i in namespace) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return exports.colors[Math.abs(hash) % exports.colors.length];
    }
    function createDebug(namespace) {
      function debug2() {
        if (!debug2.enabled)
          return;
        var self2 = debug2;
        var curr = +/* @__PURE__ */ new Date();
        var ms2 = curr - (prevTime || curr);
        self2.diff = ms2;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        args[0] = exports.coerce(args[0]);
        if ("string" !== typeof args[0]) {
          args.unshift("%O");
        }
        var index2 = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match2, format2) {
          if (match2 === "%%")
            return match2;
          index2++;
          var formatter = exports.formatters[format2];
          if ("function" === typeof formatter) {
            var val = args[index2];
            match2 = formatter.call(self2, val);
            args.splice(index2, 1);
            index2--;
          }
          return match2;
        });
        exports.formatArgs.call(self2, args);
        var logFn = debug2.log || exports.log || console.log.bind(console);
        logFn.apply(self2, args);
      }
      debug2.namespace = namespace;
      debug2.enabled = exports.enabled(namespace);
      debug2.useColors = exports.useColors();
      debug2.color = selectColor(namespace);
      if ("function" === typeof exports.init) {
        exports.init(debug2);
      }
      return debug2;
    }
    function enable(namespaces) {
      exports.save(namespaces);
      exports.names = [];
      exports.skips = [];
      var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      var len = split.length;
      for (var i = 0; i < len; i++) {
        if (!split[i])
          continue;
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          exports.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          exports.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      exports.enable("");
    }
    function enabled(name) {
      var i, len;
      for (i = 0, len = exports.skips.length; i < len; i++) {
        if (exports.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = exports.names.length; i < len; i++) {
        if (exports.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error)
        return val.stack || val.message;
      return val;
    }
  })(debug$a, debug$a.exports);
  return debug$a.exports;
}
var hasRequiredBrowser$3;
function requireBrowser$3() {
  if (hasRequiredBrowser$3)
    return browser$3.exports;
  hasRequiredBrowser$3 = 1;
  (function(module, exports) {
    exports = module.exports = requireDebug$2();
    exports.log = log2;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = "undefined" != typeof chrome && "undefined" != typeof chrome.storage ? chrome.storage.local : localstorage();
    exports.colors = [
      "lightseagreen",
      "forestgreen",
      "goldenrod",
      "dodgerblue",
      "darkorchid",
      "crimson"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
        return true;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    exports.formatters.j = function(v2) {
      try {
        return JSON.stringify(v2);
      } catch (err) {
        return "[UnexpectedJSONParseError]: " + err.message;
      }
    };
    function formatArgs(args) {
      var useColors2 = this.useColors;
      args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports.humanize(this.diff);
      if (!useColors2)
        return;
      var c2 = "color: " + this.color;
      args.splice(1, 0, c2, "color: inherit");
      var index2 = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function(match2) {
        if ("%%" === match2)
          return;
        index2++;
        if ("%c" === match2) {
          lastC = index2;
        }
      });
      args.splice(lastC, 0, c2);
    }
    function log2() {
      return "object" === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
    }
    function save(namespaces) {
      try {
        if (null == namespaces) {
          exports.storage.removeItem("debug");
        } else {
          exports.storage.debug = namespaces;
        }
      } catch (e) {
      }
    }
    function load() {
      var r;
      try {
        r = exports.storage.debug;
      } catch (e) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    exports.enable(load());
    function localstorage() {
      try {
        return window.localStorage;
      } catch (e) {
      }
    }
  })(browser$3, browser$3.exports);
  return browser$3.exports;
}
var node$3 = { exports: {} };
var hasRequiredNode$3;
function requireNode$3() {
  if (hasRequiredNode$3)
    return node$3.exports;
  hasRequiredNode$3 = 1;
  (function(module, exports) {
    var tty = require$$0$3;
    var util2 = require$$1$1;
    exports = module.exports = requireDebug$2();
    exports.init = init2;
    exports.log = log2;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.colors = [6, 2, 3, 4, 5, 1];
    exports.inspectOpts = Object.keys(process.env).filter(function(key) {
      return /^debug_/i.test(key);
    }).reduce(function(obj, key) {
      var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_2, k2) {
        return k2.toUpperCase();
      });
      var val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val))
        val = true;
      else if (/^(no|off|false|disabled)$/i.test(val))
        val = false;
      else if (val === "null")
        val = null;
      else
        val = Number(val);
      obj[prop] = val;
      return obj;
    }, {});
    var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
    if (1 !== fd && 2 !== fd) {
      util2.deprecate(function() {
      }, "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)")();
    }
    var stream3 = 1 === fd ? process.stdout : 2 === fd ? process.stderr : createWritableStdioStream(fd);
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(fd);
    }
    exports.formatters.o = function(v2) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v2, this.inspectOpts).split("\n").map(function(str) {
        return str.trim();
      }).join(" ");
    };
    exports.formatters.O = function(v2) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v2, this.inspectOpts);
    };
    function formatArgs(args) {
      var name = this.namespace;
      var useColors2 = this.useColors;
      if (useColors2) {
        var c2 = this.color;
        var prefix = "  \x1B[3" + c2 + ";1m" + name + " \x1B[0m";
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push("\x1B[3" + c2 + "m+" + exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = (/* @__PURE__ */ new Date()).toUTCString() + " " + name + " " + args[0];
      }
    }
    function log2() {
      return stream3.write(util2.format.apply(util2, arguments) + "\n");
    }
    function save(namespaces) {
      if (null == namespaces) {
        delete process.env.DEBUG;
      } else {
        process.env.DEBUG = namespaces;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function createWritableStdioStream(fd2) {
      var stream22;
      var tty_wrap = process.binding("tty_wrap");
      switch (tty_wrap.guessHandleType(fd2)) {
        case "TTY":
          stream22 = new tty.WriteStream(fd2);
          stream22._type = "tty";
          if (stream22._handle && stream22._handle.unref) {
            stream22._handle.unref();
          }
          break;
        case "FILE":
          var fs2 = require$$3$1;
          stream22 = new fs2.SyncWriteStream(fd2, { autoClose: false });
          stream22._type = "fs";
          break;
        case "PIPE":
        case "TCP":
          var net = require$$4$1;
          stream22 = new net.Socket({
            fd: fd2,
            readable: false,
            writable: true
          });
          stream22.readable = false;
          stream22.read = null;
          stream22._type = "pipe";
          if (stream22._handle && stream22._handle.unref) {
            stream22._handle.unref();
          }
          break;
        default:
          throw new Error("Implement me. Unknown stream file type!");
      }
      stream22.fd = fd2;
      stream22._isStdio = true;
      return stream22;
    }
    function init2(debug2) {
      debug2.inspectOpts = {};
      var keys2 = Object.keys(exports.inspectOpts);
      for (var i = 0; i < keys2.length; i++) {
        debug2.inspectOpts[keys2[i]] = exports.inspectOpts[keys2[i]];
      }
    }
    exports.enable(load());
  })(node$3, node$3.exports);
  return node$3.exports;
}
if (typeof process !== "undefined" && process.type === "renderer") {
  src$3.exports = requireBrowser$3();
} else {
  src$3.exports = requireNode$3();
}
var srcExports$2 = src$3.exports;
/*!
 * encodeurl
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var encodeurl = encodeUrl$3;
var ENCODE_CHARS_REGEXP = /(?:[^\x21\x25\x26-\x3B\x3D\x3F-\x5B\x5D\x5F\x61-\x7A\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g;
var UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g;
var UNMATCHED_SURROGATE_PAIR_REPLACE = "$1ï¿½$2";
function encodeUrl$3(url2) {
  return String(url2).replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE).replace(ENCODE_CHARS_REGEXP, encodeURI);
}
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */
var matchHtmlRegExp = /["'&<>]/;
var escapeHtml_1 = escapeHtml$3;
function escapeHtml$3(string) {
  var str = "" + string;
  var match2 = matchHtmlRegExp.exec(str);
  if (!match2) {
    return str;
  }
  var escape2;
  var html = "";
  var index2 = 0;
  var lastIndex = 0;
  for (index2 = match2.index; index2 < str.length; index2++) {
    switch (str.charCodeAt(index2)) {
      case 34:
        escape2 = "&quot;";
        break;
      case 38:
        escape2 = "&amp;";
        break;
      case 39:
        escape2 = "&#39;";
        break;
      case 60:
        escape2 = "&lt;";
        break;
      case 62:
        escape2 = "&gt;";
        break;
      default:
        continue;
    }
    if (lastIndex !== index2) {
      html += str.substring(lastIndex, index2);
    }
    lastIndex = index2 + 1;
    html += escape2;
  }
  return lastIndex !== index2 ? html + str.substring(lastIndex, index2) : html;
}
var parseurl$1 = { exports: {} };
/*!
 * parseurl
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
var url$1 = require$$0$6;
var parse$6 = url$1.parse;
var Url = url$1.Url;
parseurl$1.exports = parseurl;
parseurl$1.exports.original = originalurl;
function parseurl(req2) {
  var url2 = req2.url;
  if (url2 === void 0) {
    return void 0;
  }
  var parsed = req2._parsedUrl;
  if (fresh$3(url2, parsed)) {
    return parsed;
  }
  parsed = fastparse(url2);
  parsed._raw = url2;
  return req2._parsedUrl = parsed;
}
function originalurl(req2) {
  var url2 = req2.originalUrl;
  if (typeof url2 !== "string") {
    return parseurl(req2);
  }
  var parsed = req2._parsedOriginalUrl;
  if (fresh$3(url2, parsed)) {
    return parsed;
  }
  parsed = fastparse(url2);
  parsed._raw = url2;
  return req2._parsedOriginalUrl = parsed;
}
function fastparse(str) {
  if (typeof str !== "string" || str.charCodeAt(0) !== 47) {
    return parse$6(str);
  }
  var pathname = str;
  var query2 = null;
  var search = null;
  for (var i = 1; i < str.length; i++) {
    switch (str.charCodeAt(i)) {
      case 63:
        if (search === null) {
          pathname = str.substring(0, i);
          query2 = str.substring(i + 1);
          search = str.substring(i);
        }
        break;
      case 9:
      case 10:
      case 12:
      case 13:
      case 32:
      case 35:
      case 160:
      case 65279:
        return parse$6(str);
    }
  }
  var url2 = Url !== void 0 ? new Url() : {};
  url2.path = str;
  url2.href = str;
  url2.pathname = pathname;
  if (search !== null) {
    url2.query = query2;
    url2.search = search;
  }
  return url2;
}
function fresh$3(url2, parsedUrl) {
  return typeof parsedUrl === "object" && parsedUrl !== null && (Url === void 0 || parsedUrl instanceof Url) && parsedUrl._raw === url2;
}
var parseurlExports = parseurl$1.exports;
/*!
 * finalhandler
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var debug$9 = srcExports$2("finalhandler");
var encodeUrl$2 = encodeurl;
var escapeHtml$2 = escapeHtml_1;
var onFinished$2 = onFinishedExports;
var parseUrl$4 = parseurlExports;
var statuses$2 = statuses$3;
var unpipe = unpipe_1;
var DOUBLE_SPACE_REGEXP = /\x20{2}/g;
var NEWLINE_REGEXP = /\n/g;
var defer$2 = typeof setImmediate === "function" ? setImmediate : function(fn) {
  process.nextTick(fn.bind.apply(fn, arguments));
};
var isFinished = onFinished$2.isFinished;
function createHtmlDocument$1(message) {
  var body = escapeHtml$2(message).replace(NEWLINE_REGEXP, "<br>").replace(DOUBLE_SPACE_REGEXP, " &nbsp;");
  return '<!DOCTYPE html>\n<html lang="en">\n<head>\n<meta charset="utf-8">\n<title>Error</title>\n</head>\n<body>\n<pre>' + body + "</pre>\n</body>\n</html>\n";
}
var finalhandler_1 = finalhandler;
function finalhandler(req2, res2, options) {
  var opts = options || {};
  var env = opts.env || process.env.NODE_ENV || "development";
  var onerror = opts.onerror;
  return function(err) {
    var headers;
    var msg;
    var status3;
    if (!err && headersSent$1(res2)) {
      debug$9("cannot 404 after headers sent");
      return;
    }
    if (err) {
      status3 = getErrorStatusCode(err);
      if (status3 === void 0) {
        status3 = getResponseStatusCode(res2);
      } else {
        headers = getErrorHeaders(err);
      }
      msg = getErrorMessage(err, status3, env);
    } else {
      status3 = 404;
      msg = "Cannot " + req2.method + " " + encodeUrl$2(getResourceName(req2));
    }
    debug$9("default %s", status3);
    if (err && onerror) {
      defer$2(onerror, err, req2, res2);
    }
    if (headersSent$1(res2)) {
      debug$9("cannot %d after headers sent", status3);
      req2.socket.destroy();
      return;
    }
    send$3(req2, res2, status3, headers, msg);
  };
}
function getErrorHeaders(err) {
  if (!err.headers || typeof err.headers !== "object") {
    return void 0;
  }
  var headers = /* @__PURE__ */ Object.create(null);
  var keys2 = Object.keys(err.headers);
  for (var i = 0; i < keys2.length; i++) {
    var key = keys2[i];
    headers[key] = err.headers[key];
  }
  return headers;
}
function getErrorMessage(err, status3, env) {
  var msg;
  if (env !== "production") {
    msg = err.stack;
    if (!msg && typeof err.toString === "function") {
      msg = err.toString();
    }
  }
  return msg || statuses$2.message[status3];
}
function getErrorStatusCode(err) {
  if (typeof err.status === "number" && err.status >= 400 && err.status < 600) {
    return err.status;
  }
  if (typeof err.statusCode === "number" && err.statusCode >= 400 && err.statusCode < 600) {
    return err.statusCode;
  }
  return void 0;
}
function getResourceName(req2) {
  try {
    return parseUrl$4.original(req2).pathname;
  } catch (e) {
    return "resource";
  }
}
function getResponseStatusCode(res2) {
  var status3 = res2.statusCode;
  if (typeof status3 !== "number" || status3 < 400 || status3 > 599) {
    status3 = 500;
  }
  return status3;
}
function headersSent$1(res2) {
  return typeof res2.headersSent !== "boolean" ? Boolean(res2._header) : res2.headersSent;
}
function send$3(req2, res2, status3, headers, message) {
  function write() {
    var body = createHtmlDocument$1(message);
    res2.statusCode = status3;
    res2.statusMessage = statuses$2.message[status3];
    res2.removeHeader("Content-Encoding");
    res2.removeHeader("Content-Language");
    res2.removeHeader("Content-Range");
    setHeaders$1(res2, headers);
    res2.setHeader("Content-Security-Policy", "default-src 'none'");
    res2.setHeader("X-Content-Type-Options", "nosniff");
    res2.setHeader("Content-Type", "text/html; charset=utf-8");
    res2.setHeader("Content-Length", Buffer.byteLength(body, "utf8"));
    if (req2.method === "HEAD") {
      res2.end();
      return;
    }
    res2.end(body, "utf8");
  }
  if (isFinished(req2)) {
    write();
    return;
  }
  unpipe(req2);
  onFinished$2(req2, write);
  req2.resume();
}
function setHeaders$1(res2, headers) {
  if (!headers) {
    return;
  }
  var keys2 = Object.keys(headers);
  for (var i = 0; i < keys2.length; i++) {
    var key = keys2[i];
    res2.setHeader(key, headers[key]);
  }
}
var router$1 = { exports: {} };
var src$2 = { exports: {} };
var browser$2 = { exports: {} };
var debug$8 = { exports: {} };
var ms$4;
var hasRequiredMs$2;
function requireMs$2() {
  if (hasRequiredMs$2)
    return ms$4;
  hasRequiredMs$2 = 1;
  var s2 = 1e3;
  var m2 = s2 * 60;
  var h2 = m2 * 60;
  var d2 = h2 * 24;
  var y2 = d2 * 365.25;
  ms$4 = function(val, options) {
    options = options || {};
    var type3 = typeof val;
    if (type3 === "string" && val.length > 0) {
      return parse2(val);
    } else if (type3 === "number" && isNaN(val) === false) {
      return options.long ? fmtLong2(val) : fmtShort2(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse2(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match2 = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
      str
    );
    if (!match2) {
      return;
    }
    var n = parseFloat(match2[1]);
    var type3 = (match2[2] || "ms").toLowerCase();
    switch (type3) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y2;
      case "days":
      case "day":
      case "d":
        return n * d2;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h2;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m2;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s2;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort2(ms2) {
    if (ms2 >= d2) {
      return Math.round(ms2 / d2) + "d";
    }
    if (ms2 >= h2) {
      return Math.round(ms2 / h2) + "h";
    }
    if (ms2 >= m2) {
      return Math.round(ms2 / m2) + "m";
    }
    if (ms2 >= s2) {
      return Math.round(ms2 / s2) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong2(ms2) {
    return plural2(ms2, d2, "day") || plural2(ms2, h2, "hour") || plural2(ms2, m2, "minute") || plural2(ms2, s2, "second") || ms2 + " ms";
  }
  function plural2(ms2, n, name) {
    if (ms2 < n) {
      return;
    }
    if (ms2 < n * 1.5) {
      return Math.floor(ms2 / n) + " " + name;
    }
    return Math.ceil(ms2 / n) + " " + name + "s";
  }
  return ms$4;
}
var hasRequiredDebug$1;
function requireDebug$1() {
  if (hasRequiredDebug$1)
    return debug$8.exports;
  hasRequiredDebug$1 = 1;
  (function(module, exports) {
    exports = module.exports = createDebug.debug = createDebug["default"] = createDebug;
    exports.coerce = coerce;
    exports.disable = disable;
    exports.enable = enable;
    exports.enabled = enabled;
    exports.humanize = requireMs$2();
    exports.names = [];
    exports.skips = [];
    exports.formatters = {};
    var prevTime;
    function selectColor(namespace) {
      var hash = 0, i;
      for (i in namespace) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return exports.colors[Math.abs(hash) % exports.colors.length];
    }
    function createDebug(namespace) {
      function debug2() {
        if (!debug2.enabled)
          return;
        var self2 = debug2;
        var curr = +/* @__PURE__ */ new Date();
        var ms2 = curr - (prevTime || curr);
        self2.diff = ms2;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        args[0] = exports.coerce(args[0]);
        if ("string" !== typeof args[0]) {
          args.unshift("%O");
        }
        var index2 = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match2, format2) {
          if (match2 === "%%")
            return match2;
          index2++;
          var formatter = exports.formatters[format2];
          if ("function" === typeof formatter) {
            var val = args[index2];
            match2 = formatter.call(self2, val);
            args.splice(index2, 1);
            index2--;
          }
          return match2;
        });
        exports.formatArgs.call(self2, args);
        var logFn = debug2.log || exports.log || console.log.bind(console);
        logFn.apply(self2, args);
      }
      debug2.namespace = namespace;
      debug2.enabled = exports.enabled(namespace);
      debug2.useColors = exports.useColors();
      debug2.color = selectColor(namespace);
      if ("function" === typeof exports.init) {
        exports.init(debug2);
      }
      return debug2;
    }
    function enable(namespaces) {
      exports.save(namespaces);
      exports.names = [];
      exports.skips = [];
      var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      var len = split.length;
      for (var i = 0; i < len; i++) {
        if (!split[i])
          continue;
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          exports.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          exports.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      exports.enable("");
    }
    function enabled(name) {
      var i, len;
      for (i = 0, len = exports.skips.length; i < len; i++) {
        if (exports.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = exports.names.length; i < len; i++) {
        if (exports.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error)
        return val.stack || val.message;
      return val;
    }
  })(debug$8, debug$8.exports);
  return debug$8.exports;
}
var hasRequiredBrowser$2;
function requireBrowser$2() {
  if (hasRequiredBrowser$2)
    return browser$2.exports;
  hasRequiredBrowser$2 = 1;
  (function(module, exports) {
    exports = module.exports = requireDebug$1();
    exports.log = log2;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = "undefined" != typeof chrome && "undefined" != typeof chrome.storage ? chrome.storage.local : localstorage();
    exports.colors = [
      "lightseagreen",
      "forestgreen",
      "goldenrod",
      "dodgerblue",
      "darkorchid",
      "crimson"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
        return true;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    exports.formatters.j = function(v2) {
      try {
        return JSON.stringify(v2);
      } catch (err) {
        return "[UnexpectedJSONParseError]: " + err.message;
      }
    };
    function formatArgs(args) {
      var useColors2 = this.useColors;
      args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports.humanize(this.diff);
      if (!useColors2)
        return;
      var c2 = "color: " + this.color;
      args.splice(1, 0, c2, "color: inherit");
      var index2 = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function(match2) {
        if ("%%" === match2)
          return;
        index2++;
        if ("%c" === match2) {
          lastC = index2;
        }
      });
      args.splice(lastC, 0, c2);
    }
    function log2() {
      return "object" === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
    }
    function save(namespaces) {
      try {
        if (null == namespaces) {
          exports.storage.removeItem("debug");
        } else {
          exports.storage.debug = namespaces;
        }
      } catch (e) {
      }
    }
    function load() {
      var r;
      try {
        r = exports.storage.debug;
      } catch (e) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    exports.enable(load());
    function localstorage() {
      try {
        return window.localStorage;
      } catch (e) {
      }
    }
  })(browser$2, browser$2.exports);
  return browser$2.exports;
}
var node$2 = { exports: {} };
var hasRequiredNode$2;
function requireNode$2() {
  if (hasRequiredNode$2)
    return node$2.exports;
  hasRequiredNode$2 = 1;
  (function(module, exports) {
    var tty = require$$0$3;
    var util2 = require$$1$1;
    exports = module.exports = requireDebug$1();
    exports.init = init2;
    exports.log = log2;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.colors = [6, 2, 3, 4, 5, 1];
    exports.inspectOpts = Object.keys(process.env).filter(function(key) {
      return /^debug_/i.test(key);
    }).reduce(function(obj, key) {
      var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_2, k2) {
        return k2.toUpperCase();
      });
      var val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val))
        val = true;
      else if (/^(no|off|false|disabled)$/i.test(val))
        val = false;
      else if (val === "null")
        val = null;
      else
        val = Number(val);
      obj[prop] = val;
      return obj;
    }, {});
    var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
    if (1 !== fd && 2 !== fd) {
      util2.deprecate(function() {
      }, "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)")();
    }
    var stream3 = 1 === fd ? process.stdout : 2 === fd ? process.stderr : createWritableStdioStream(fd);
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(fd);
    }
    exports.formatters.o = function(v2) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v2, this.inspectOpts).split("\n").map(function(str) {
        return str.trim();
      }).join(" ");
    };
    exports.formatters.O = function(v2) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v2, this.inspectOpts);
    };
    function formatArgs(args) {
      var name = this.namespace;
      var useColors2 = this.useColors;
      if (useColors2) {
        var c2 = this.color;
        var prefix = "  \x1B[3" + c2 + ";1m" + name + " \x1B[0m";
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push("\x1B[3" + c2 + "m+" + exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = (/* @__PURE__ */ new Date()).toUTCString() + " " + name + " " + args[0];
      }
    }
    function log2() {
      return stream3.write(util2.format.apply(util2, arguments) + "\n");
    }
    function save(namespaces) {
      if (null == namespaces) {
        delete process.env.DEBUG;
      } else {
        process.env.DEBUG = namespaces;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function createWritableStdioStream(fd2) {
      var stream22;
      var tty_wrap = process.binding("tty_wrap");
      switch (tty_wrap.guessHandleType(fd2)) {
        case "TTY":
          stream22 = new tty.WriteStream(fd2);
          stream22._type = "tty";
          if (stream22._handle && stream22._handle.unref) {
            stream22._handle.unref();
          }
          break;
        case "FILE":
          var fs2 = require$$3$1;
          stream22 = new fs2.SyncWriteStream(fd2, { autoClose: false });
          stream22._type = "fs";
          break;
        case "PIPE":
        case "TCP":
          var net = require$$4$1;
          stream22 = new net.Socket({
            fd: fd2,
            readable: false,
            writable: true
          });
          stream22.readable = false;
          stream22.read = null;
          stream22._type = "pipe";
          if (stream22._handle && stream22._handle.unref) {
            stream22._handle.unref();
          }
          break;
        default:
          throw new Error("Implement me. Unknown stream file type!");
      }
      stream22.fd = fd2;
      stream22._isStdio = true;
      return stream22;
    }
    function init2(debug2) {
      debug2.inspectOpts = {};
      var keys2 = Object.keys(exports.inspectOpts);
      for (var i = 0; i < keys2.length; i++) {
        debug2.inspectOpts[keys2[i]] = exports.inspectOpts[keys2[i]];
      }
    }
    exports.enable(load());
  })(node$2, node$2.exports);
  return node$2.exports;
}
if (typeof process !== "undefined" && process.type === "renderer") {
  src$2.exports = requireBrowser$2();
} else {
  src$2.exports = requireNode$2();
}
var srcExports$1 = src$2.exports;
var arrayFlatten_1 = arrayFlatten;
function flattenWithDepth(array, result, depth) {
  for (var i = 0; i < array.length; i++) {
    var value = array[i];
    if (depth > 0 && Array.isArray(value)) {
      flattenWithDepth(value, result, depth - 1);
    } else {
      result.push(value);
    }
  }
  return result;
}
function flattenForever(array, result) {
  for (var i = 0; i < array.length; i++) {
    var value = array[i];
    if (Array.isArray(value)) {
      flattenForever(value, result);
    } else {
      result.push(value);
    }
  }
  return result;
}
function arrayFlatten(array, depth) {
  if (depth == null) {
    return flattenForever(array, []);
  }
  return flattenWithDepth(array, [], depth);
}
var pathToRegexp = pathtoRegexp;
var MATCHING_GROUP_REGEXP = /\((?!\?)/g;
function pathtoRegexp(path3, keys2, options) {
  options = options || {};
  keys2 = keys2 || [];
  var strict = options.strict;
  var end = options.end !== false;
  var flags = options.sensitive ? "" : "i";
  var extraOffset = 0;
  var keysOffset = keys2.length;
  var i = 0;
  var name = 0;
  var m2;
  if (path3 instanceof RegExp) {
    while (m2 = MATCHING_GROUP_REGEXP.exec(path3.source)) {
      keys2.push({
        name: name++,
        optional: false,
        offset: m2.index
      });
    }
    return path3;
  }
  if (Array.isArray(path3)) {
    path3 = path3.map(function(value) {
      return pathtoRegexp(value, keys2, options).source;
    });
    return new RegExp("(?:" + path3.join("|") + ")", flags);
  }
  path3 = ("^" + path3 + (strict ? "" : path3[path3.length - 1] === "/" ? "?" : "/?")).replace(/\/\(/g, "/(?:").replace(/([\/\.])/g, "\\$1").replace(/(\\\/)?(\\\.)?:(\w+)(\(.*?\))?(\*)?(\?)?/g, function(match2, slash, format2, key, capture, star, optional, offset) {
    slash = slash || "";
    format2 = format2 || "";
    capture = capture || "([^\\/" + format2 + "]+?)";
    optional = optional || "";
    keys2.push({
      name: key,
      optional: !!optional,
      offset: offset + extraOffset
    });
    var result = "" + (optional ? "" : slash) + "(?:" + format2 + (optional ? slash : "") + capture + (star ? "((?:[\\/" + format2 + "].+?)?)" : "") + ")" + optional;
    extraOffset += result.length - match2.length;
    return result;
  }).replace(/\*/g, function(star, index3) {
    var len = keys2.length;
    while (len-- > keysOffset && keys2[len].offset > index3) {
      keys2[len].offset += 3;
    }
    return "(.*)";
  });
  while (m2 = MATCHING_GROUP_REGEXP.exec(path3)) {
    var escapeCount = 0;
    var index2 = m2.index;
    while (path3.charAt(--index2) === "\\") {
      escapeCount++;
    }
    if (escapeCount % 2 === 1) {
      continue;
    }
    if (keysOffset + i === keys2.length || keys2[keysOffset + i].offset > m2.index) {
      keys2.splice(keysOffset + i, 0, {
        name: name++,
        // Unnamed matching groups must be consistently linear.
        optional: false,
        offset: m2.index
      });
    }
    i++;
  }
  path3 += end ? "$" : path3[path3.length - 1] === "/" ? "" : "(?=\\/|$)";
  return new RegExp(path3, flags);
}
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var pathRegexp = pathToRegexp;
var debug$7 = srcExports$1("express:router:layer");
var hasOwnProperty$f = Object.prototype.hasOwnProperty;
var layer = Layer$2;
function Layer$2(path3, options, fn) {
  if (!(this instanceof Layer$2)) {
    return new Layer$2(path3, options, fn);
  }
  debug$7("new %o", path3);
  var opts = options || {};
  this.handle = fn;
  this.name = fn.name || "<anonymous>";
  this.params = void 0;
  this.path = void 0;
  this.regexp = pathRegexp(path3, this.keys = [], opts);
  this.regexp.fast_star = path3 === "*";
  this.regexp.fast_slash = path3 === "/" && opts.end === false;
}
Layer$2.prototype.handle_error = function handle_error(error2, req2, res2, next) {
  var fn = this.handle;
  if (fn.length !== 4) {
    return next(error2);
  }
  try {
    fn(error2, req2, res2, next);
  } catch (err) {
    next(err);
  }
};
Layer$2.prototype.handle_request = function handle(req2, res2, next) {
  var fn = this.handle;
  if (fn.length > 3) {
    return next();
  }
  try {
    fn(req2, res2, next);
  } catch (err) {
    next(err);
  }
};
Layer$2.prototype.match = function match(path3) {
  var match2;
  if (path3 != null) {
    if (this.regexp.fast_slash) {
      this.params = {};
      this.path = "";
      return true;
    }
    if (this.regexp.fast_star) {
      this.params = { "0": decode_param(path3) };
      this.path = path3;
      return true;
    }
    match2 = this.regexp.exec(path3);
  }
  if (!match2) {
    this.params = void 0;
    this.path = void 0;
    return false;
  }
  this.params = {};
  this.path = match2[0];
  var keys2 = this.keys;
  var params = this.params;
  for (var i = 1; i < match2.length; i++) {
    var key = keys2[i - 1];
    var prop = key.name;
    var val = decode_param(match2[i]);
    if (val !== void 0 || !hasOwnProperty$f.call(params, prop)) {
      params[prop] = val;
    }
  }
  return true;
};
function decode_param(val) {
  if (typeof val !== "string" || val.length === 0) {
    return val;
  }
  try {
    return decodeURIComponent(val);
  } catch (err) {
    if (err instanceof URIError) {
      err.message = "Failed to decode param '" + val + "'";
      err.status = err.statusCode = 400;
    }
    throw err;
  }
}
/*!
 * methods
 * Copyright(c) 2013-2014 TJ Holowaychuk
 * Copyright(c) 2015-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var http$4 = require$$0$7;
var methods$2 = getCurrentNodeMethods() || getBasicNodeMethods();
function getCurrentNodeMethods() {
  return http$4.METHODS && http$4.METHODS.map(function lowerCaseMethod(method) {
    return method.toLowerCase();
  });
}
function getBasicNodeMethods() {
  return [
    "get",
    "post",
    "put",
    "head",
    "delete",
    "options",
    "trace",
    "copy",
    "lock",
    "mkcol",
    "move",
    "purge",
    "propfind",
    "proppatch",
    "unlock",
    "report",
    "mkactivity",
    "checkout",
    "merge",
    "m-search",
    "notify",
    "subscribe",
    "unsubscribe",
    "patch",
    "search",
    "connect"
  ];
}
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var debug$6 = srcExports$1("express:router:route");
var flatten$3 = arrayFlatten_1;
var Layer$1 = layer;
var methods$1 = methods$2;
var slice$1 = Array.prototype.slice;
var toString$5 = Object.prototype.toString;
var route = Route$1;
function Route$1(path3) {
  this.path = path3;
  this.stack = [];
  debug$6("new %o", path3);
  this.methods = {};
}
Route$1.prototype._handles_method = function _handles_method(method) {
  if (this.methods._all) {
    return true;
  }
  var name = typeof method === "string" ? method.toLowerCase() : method;
  if (name === "head" && !this.methods["head"]) {
    name = "get";
  }
  return Boolean(this.methods[name]);
};
Route$1.prototype._options = function _options() {
  var methods2 = Object.keys(this.methods);
  if (this.methods.get && !this.methods.head) {
    methods2.push("head");
  }
  for (var i = 0; i < methods2.length; i++) {
    methods2[i] = methods2[i].toUpperCase();
  }
  return methods2;
};
Route$1.prototype.dispatch = function dispatch(req2, res2, done) {
  var idx = 0;
  var stack = this.stack;
  var sync = 0;
  if (stack.length === 0) {
    return done();
  }
  var method = typeof req2.method === "string" ? req2.method.toLowerCase() : req2.method;
  if (method === "head" && !this.methods["head"]) {
    method = "get";
  }
  req2.route = this;
  next();
  function next(err) {
    if (err && err === "route") {
      return done();
    }
    if (err && err === "router") {
      return done(err);
    }
    if (++sync > 100) {
      return setImmediate(next, err);
    }
    var layer2 = stack[idx++];
    if (!layer2) {
      return done(err);
    }
    if (layer2.method && layer2.method !== method) {
      next(err);
    } else if (err) {
      layer2.handle_error(err, req2, res2, next);
    } else {
      layer2.handle_request(req2, res2, next);
    }
    sync = 0;
  }
};
Route$1.prototype.all = function all() {
  var handles = flatten$3(slice$1.call(arguments));
  for (var i = 0; i < handles.length; i++) {
    var handle3 = handles[i];
    if (typeof handle3 !== "function") {
      var type3 = toString$5.call(handle3);
      var msg = "Route.all() requires a callback function but got a " + type3;
      throw new TypeError(msg);
    }
    var layer2 = Layer$1("/", {}, handle3);
    layer2.method = void 0;
    this.methods._all = true;
    this.stack.push(layer2);
  }
  return this;
};
methods$1.forEach(function(method) {
  Route$1.prototype[method] = function() {
    var handles = flatten$3(slice$1.call(arguments));
    for (var i = 0; i < handles.length; i++) {
      var handle3 = handles[i];
      if (typeof handle3 !== "function") {
        var type3 = toString$5.call(handle3);
        var msg = "Route." + method + "() requires a callback function but got a " + type3;
        throw new Error(msg);
      }
      debug$6("%s %o", method, this.path);
      var layer2 = Layer$1("/", {}, handle3);
      layer2.method = method;
      this.methods[method] = true;
      this.stack.push(layer2);
    }
    return this;
  };
});
var utilsMerge = { exports: {} };
(function(module, exports) {
  module.exports = function(a, b2) {
    if (a && b2) {
      for (var key in b2) {
        a[key] = b2[key];
      }
    }
    return a;
  };
})(utilsMerge);
var utilsMergeExports = utilsMerge.exports;
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var Route = route;
var Layer = layer;
var methods = methods$2;
var mixin = utilsMergeExports;
var debug$5 = srcExports$1("express:router");
var deprecate$3 = depd_1("express");
var flatten$2 = arrayFlatten_1;
var parseUrl$3 = parseurlExports;
var setPrototypeOf$1 = setprototypeof;
var objectRegExp = /^\[object (\S+)\]$/;
var slice = Array.prototype.slice;
var toString$4 = Object.prototype.toString;
var proto = router$1.exports = function(options) {
  var opts = options || {};
  function router2(req2, res2, next) {
    router2.handle(req2, res2, next);
  }
  setPrototypeOf$1(router2, proto);
  router2.params = {};
  router2._params = [];
  router2.caseSensitive = opts.caseSensitive;
  router2.mergeParams = opts.mergeParams;
  router2.strict = opts.strict;
  router2.stack = [];
  return router2;
};
proto.param = function param(name, fn) {
  if (typeof name === "function") {
    deprecate$3("router.param(fn): Refactor to use path params");
    this._params.push(name);
    return;
  }
  var params = this._params;
  var len = params.length;
  var ret;
  if (name[0] === ":") {
    deprecate$3("router.param(" + JSON.stringify(name) + ", fn): Use router.param(" + JSON.stringify(name.slice(1)) + ", fn) instead");
    name = name.slice(1);
  }
  for (var i = 0; i < len; ++i) {
    if (ret = params[i](name, fn)) {
      fn = ret;
    }
  }
  if ("function" !== typeof fn) {
    throw new Error("invalid param() call for " + name + ", got " + fn);
  }
  (this.params[name] = this.params[name] || []).push(fn);
  return this;
};
proto.handle = function handle2(req2, res2, out) {
  var self2 = this;
  debug$5("dispatching %s %s", req2.method, req2.url);
  var idx = 0;
  var protohost = getProtohost(req2.url) || "";
  var removed = "";
  var slashAdded = false;
  var sync = 0;
  var paramcalled = {};
  var options = [];
  var stack = self2.stack;
  var parentParams = req2.params;
  var parentUrl = req2.baseUrl || "";
  var done = restore(out, req2, "baseUrl", "next", "params");
  req2.next = next;
  if (req2.method === "OPTIONS") {
    done = wrap$1(done, function(old, err) {
      if (err || options.length === 0)
        return old(err);
      sendOptionsResponse(res2, options, old);
    });
  }
  req2.baseUrl = parentUrl;
  req2.originalUrl = req2.originalUrl || req2.url;
  next();
  function next(err) {
    var layerError = err === "route" ? null : err;
    if (slashAdded) {
      req2.url = req2.url.slice(1);
      slashAdded = false;
    }
    if (removed.length !== 0) {
      req2.baseUrl = parentUrl;
      req2.url = protohost + removed + req2.url.slice(protohost.length);
      removed = "";
    }
    if (layerError === "router") {
      setImmediate(done, null);
      return;
    }
    if (idx >= stack.length) {
      setImmediate(done, layerError);
      return;
    }
    if (++sync > 100) {
      return setImmediate(next, err);
    }
    var path3 = getPathname(req2);
    if (path3 == null) {
      return done(layerError);
    }
    var layer2;
    var match2;
    var route3;
    while (match2 !== true && idx < stack.length) {
      layer2 = stack[idx++];
      match2 = matchLayer(layer2, path3);
      route3 = layer2.route;
      if (typeof match2 !== "boolean") {
        layerError = layerError || match2;
      }
      if (match2 !== true) {
        continue;
      }
      if (!route3) {
        continue;
      }
      if (layerError) {
        match2 = false;
        continue;
      }
      var method = req2.method;
      var has_method = route3._handles_method(method);
      if (!has_method && method === "OPTIONS") {
        appendMethods(options, route3._options());
      }
      if (!has_method && method !== "HEAD") {
        match2 = false;
      }
    }
    if (match2 !== true) {
      return done(layerError);
    }
    if (route3) {
      req2.route = route3;
    }
    req2.params = self2.mergeParams ? mergeParams(layer2.params, parentParams) : layer2.params;
    var layerPath = layer2.path;
    self2.process_params(layer2, paramcalled, req2, res2, function(err2) {
      if (err2) {
        next(layerError || err2);
      } else if (route3) {
        layer2.handle_request(req2, res2, next);
      } else {
        trim_prefix(layer2, layerError, layerPath, path3);
      }
      sync = 0;
    });
  }
  function trim_prefix(layer2, layerError, layerPath, path3) {
    if (layerPath.length !== 0) {
      if (layerPath !== path3.slice(0, layerPath.length)) {
        next(layerError);
        return;
      }
      var c2 = path3[layerPath.length];
      if (c2 && c2 !== "/" && c2 !== ".")
        return next(layerError);
      debug$5("trim prefix (%s) from url %s", layerPath, req2.url);
      removed = layerPath;
      req2.url = protohost + req2.url.slice(protohost.length + removed.length);
      if (!protohost && req2.url[0] !== "/") {
        req2.url = "/" + req2.url;
        slashAdded = true;
      }
      req2.baseUrl = parentUrl + (removed[removed.length - 1] === "/" ? removed.substring(0, removed.length - 1) : removed);
    }
    debug$5("%s %s : %s", layer2.name, layerPath, req2.originalUrl);
    if (layerError) {
      layer2.handle_error(layerError, req2, res2, next);
    } else {
      layer2.handle_request(req2, res2, next);
    }
  }
};
proto.process_params = function process_params(layer2, called, req2, res2, done) {
  var params = this.params;
  var keys2 = layer2.keys;
  if (!keys2 || keys2.length === 0) {
    return done();
  }
  var i = 0;
  var name;
  var paramIndex = 0;
  var key;
  var paramVal;
  var paramCallbacks;
  var paramCalled;
  function param3(err) {
    if (err) {
      return done(err);
    }
    if (i >= keys2.length) {
      return done();
    }
    paramIndex = 0;
    key = keys2[i++];
    name = key.name;
    paramVal = req2.params[name];
    paramCallbacks = params[name];
    paramCalled = called[name];
    if (paramVal === void 0 || !paramCallbacks) {
      return param3();
    }
    if (paramCalled && (paramCalled.match === paramVal || paramCalled.error && paramCalled.error !== "route")) {
      req2.params[name] = paramCalled.value;
      return param3(paramCalled.error);
    }
    called[name] = paramCalled = {
      error: null,
      match: paramVal,
      value: paramVal
    };
    paramCallback();
  }
  function paramCallback(err) {
    var fn = paramCallbacks[paramIndex++];
    paramCalled.value = req2.params[key.name];
    if (err) {
      paramCalled.error = err;
      param3(err);
      return;
    }
    if (!fn)
      return param3();
    try {
      fn(req2, res2, paramCallback, paramVal, key.name);
    } catch (e) {
      paramCallback(e);
    }
  }
  param3();
};
proto.use = function use(fn) {
  var offset = 0;
  var path3 = "/";
  if (typeof fn !== "function") {
    var arg = fn;
    while (Array.isArray(arg) && arg.length !== 0) {
      arg = arg[0];
    }
    if (typeof arg !== "function") {
      offset = 1;
      path3 = fn;
    }
  }
  var callbacks = flatten$2(slice.call(arguments, offset));
  if (callbacks.length === 0) {
    throw new TypeError("Router.use() requires a middleware function");
  }
  for (var i = 0; i < callbacks.length; i++) {
    var fn = callbacks[i];
    if (typeof fn !== "function") {
      throw new TypeError("Router.use() requires a middleware function but got a " + gettype(fn));
    }
    debug$5("use %o %s", path3, fn.name || "<anonymous>");
    var layer2 = new Layer(path3, {
      sensitive: this.caseSensitive,
      strict: false,
      end: false
    }, fn);
    layer2.route = void 0;
    this.stack.push(layer2);
  }
  return this;
};
proto.route = function route2(path3) {
  var route3 = new Route(path3);
  var layer2 = new Layer(path3, {
    sensitive: this.caseSensitive,
    strict: this.strict,
    end: true
  }, route3.dispatch.bind(route3));
  layer2.route = route3;
  this.stack.push(layer2);
  return route3;
};
methods.concat("all").forEach(function(method) {
  proto[method] = function(path3) {
    var route3 = this.route(path3);
    route3[method].apply(route3, slice.call(arguments, 1));
    return this;
  };
});
function appendMethods(list, addition) {
  for (var i = 0; i < addition.length; i++) {
    var method = addition[i];
    if (list.indexOf(method) === -1) {
      list.push(method);
    }
  }
}
function getPathname(req2) {
  try {
    return parseUrl$3(req2).pathname;
  } catch (err) {
    return void 0;
  }
}
function getProtohost(url2) {
  if (typeof url2 !== "string" || url2.length === 0 || url2[0] === "/") {
    return void 0;
  }
  var searchIndex = url2.indexOf("?");
  var pathLength = searchIndex !== -1 ? searchIndex : url2.length;
  var fqdnIndex = url2.slice(0, pathLength).indexOf("://");
  return fqdnIndex !== -1 ? url2.substring(0, url2.indexOf("/", 3 + fqdnIndex)) : void 0;
}
function gettype(obj) {
  var type3 = typeof obj;
  if (type3 !== "object") {
    return type3;
  }
  return toString$4.call(obj).replace(objectRegExp, "$1");
}
function matchLayer(layer2, path3) {
  try {
    return layer2.match(path3);
  } catch (err) {
    return err;
  }
}
function mergeParams(params, parent2) {
  if (typeof parent2 !== "object" || !parent2) {
    return params;
  }
  var obj = mixin({}, parent2);
  if (!(0 in params) || !(0 in parent2)) {
    return mixin(obj, params);
  }
  var i = 0;
  var o = 0;
  while (i in params) {
    i++;
  }
  while (o in parent2) {
    o++;
  }
  for (i--; i >= 0; i--) {
    params[i + o] = params[i];
    if (i < o) {
      delete params[i];
    }
  }
  return mixin(obj, params);
}
function restore(fn, obj) {
  var props = new Array(arguments.length - 2);
  var vals = new Array(arguments.length - 2);
  for (var i = 0; i < props.length; i++) {
    props[i] = arguments[i + 2];
    vals[i] = obj[props[i]];
  }
  return function() {
    for (var i2 = 0; i2 < props.length; i2++) {
      obj[props[i2]] = vals[i2];
    }
    return fn.apply(this, arguments);
  };
}
function sendOptionsResponse(res2, options, next) {
  try {
    var body = options.join(",");
    res2.set("Allow", body);
    res2.send(body);
  } catch (err) {
    next(err);
  }
}
function wrap$1(old, fn) {
  return function proxy() {
    var args = new Array(arguments.length + 1);
    args[0] = old;
    for (var i = 0, len = arguments.length; i < len; i++) {
      args[i + 1] = arguments[i];
    }
    fn.apply(this, args);
  };
}
var routerExports = router$1.exports;
var init = {};
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var setPrototypeOf = setprototypeof;
init.init = function(app) {
  return function expressInit(req2, res2, next) {
    if (app.enabled("x-powered-by"))
      res2.setHeader("X-Powered-By", "Express");
    req2.res = res2;
    res2.req = req2;
    req2.next = next;
    setPrototypeOf(req2, app.request);
    setPrototypeOf(res2, app.response);
    res2.locals = res2.locals || /* @__PURE__ */ Object.create(null);
    next();
  };
};
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var query;
var hasRequiredQuery;
function requireQuery() {
  if (hasRequiredQuery)
    return query;
  hasRequiredQuery = 1;
  var merge2 = utilsMergeExports;
  var parseUrl2 = parseurlExports;
  var qs = requireLib();
  query = function query2(options) {
    var opts = merge2({}, options);
    var queryparse = qs.parse;
    if (typeof options === "function") {
      queryparse = options;
      opts = void 0;
    }
    if (opts !== void 0 && opts.allowPrototypes === void 0) {
      opts.allowPrototypes = true;
    }
    return function query3(req2, res2, next) {
      if (!req2.query) {
        var val = parseUrl2(req2).query;
        req2.query = queryparse(val, opts);
      }
      next();
    };
  };
  return query;
}
function commonjsRequire(path3) {
  throw new Error('Could not dynamically require "' + path3 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var debug$4 = srcExports$1("express:view");
var path$3 = path$4;
var fs$3 = require$$3$1;
var dirname = path$3.dirname;
var basename$1 = path$3.basename;
var extname$2 = path$3.extname;
var join$1 = path$3.join;
var resolve$2 = path$3.resolve;
var view = View;
function View(name, options) {
  var opts = options || {};
  this.defaultEngine = opts.defaultEngine;
  this.ext = extname$2(name);
  this.name = name;
  this.root = opts.root;
  if (!this.ext && !this.defaultEngine) {
    throw new Error("No default engine was specified and no extension was provided.");
  }
  var fileName = name;
  if (!this.ext) {
    this.ext = this.defaultEngine[0] !== "." ? "." + this.defaultEngine : this.defaultEngine;
    fileName += this.ext;
  }
  if (!opts.engines[this.ext]) {
    var mod = this.ext.slice(1);
    debug$4('require "%s"', mod);
    var fn = commonjsRequire(mod).__express;
    if (typeof fn !== "function") {
      throw new Error('Module "' + mod + '" does not provide a view engine.');
    }
    opts.engines[this.ext] = fn;
  }
  this.engine = opts.engines[this.ext];
  this.path = this.lookup(fileName);
}
View.prototype.lookup = function lookup(name) {
  var path3;
  var roots = [].concat(this.root);
  debug$4('lookup "%s"', name);
  for (var i = 0; i < roots.length && !path3; i++) {
    var root3 = roots[i];
    var loc = resolve$2(root3, name);
    var dir = dirname(loc);
    var file = basename$1(loc);
    path3 = this.resolve(dir, file);
  }
  return path3;
};
View.prototype.render = function render(options, callback) {
  debug$4('render "%s"', this.path);
  this.engine(this.path, options, callback);
};
View.prototype.resolve = function resolve(dir, file) {
  var ext = this.ext;
  var path3 = join$1(dir, file);
  var stat = tryStat(path3);
  if (stat && stat.isFile()) {
    return path3;
  }
  path3 = join$1(dir, basename$1(file, ext), "index" + ext);
  stat = tryStat(path3);
  if (stat && stat.isFile()) {
    return path3;
  }
};
function tryStat(path3) {
  debug$4('stat "%s"', path3);
  try {
    return fs$3.statSync(path3);
  } catch (e) {
    return void 0;
  }
}
var utils$2 = {};
var safeBuffer = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(module, exports) {
  var buffer = require$$0$5;
  var Buffer2 = buffer.Buffer;
  function copyProps(src2, dst) {
    for (var key in src2) {
      dst[key] = src2[key];
    }
  }
  if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
    module.exports = buffer;
  } else {
    copyProps(buffer, exports);
    exports.Buffer = SafeBuffer;
  }
  function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer2(arg, encodingOrOffset, length);
  }
  SafeBuffer.prototype = Object.create(Buffer2.prototype);
  copyProps(Buffer2, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer2(arg, encodingOrOffset, length);
  };
  SafeBuffer.alloc = function(size, fill, encoding3) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer2(size);
    if (fill !== void 0) {
      if (typeof encoding3 === "string") {
        buf.fill(fill, encoding3);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer2(size);
  };
  SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer.SlowBuffer(size);
  };
})(safeBuffer, safeBuffer.exports);
var safeBufferExports = safeBuffer.exports;
var contentDisposition$2 = { exports: {} };
/*!
 * content-disposition
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
contentDisposition$2.exports = contentDisposition$1;
contentDisposition$2.exports.parse = parse$5;
var basename = path$4.basename;
var Buffer$2 = safeBufferExports.Buffer;
var ENCODE_URL_ATTR_CHAR_REGEXP = /[\x00-\x20"'()*,/:;<=>?@[\\\]{}\x7f]/g;
var HEX_ESCAPE_REGEXP = /%[0-9A-Fa-f]{2}/;
var HEX_ESCAPE_REPLACE_REGEXP = /%([0-9A-Fa-f]{2})/g;
var NON_LATIN1_REGEXP = /[^\x20-\x7e\xa0-\xff]/g;
var QESC_REGEXP = /\\([\u0000-\u007f])/g;
var QUOTE_REGEXP = /([\\"])/g;
var PARAM_REGEXP = /;[\x09\x20]*([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*=[\x09\x20]*("(?:[\x20!\x23-\x5b\x5d-\x7e\x80-\xff]|\\[\x20-\x7e])*"|[!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*/g;
var TEXT_REGEXP = /^[\x20-\x7e\x80-\xff]+$/;
var TOKEN_REGEXP = /^[!#$%&'*+.0-9A-Z^_`a-z|~-]+$/;
var EXT_VALUE_REGEXP = /^([A-Za-z0-9!#$%&+\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+.^_`|~-])+)$/;
var DISPOSITION_TYPE_REGEXP = /^([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*(?:$|;)/;
function contentDisposition$1(filename, options) {
  var opts = options || {};
  var type3 = opts.type || "attachment";
  var params = createparams(filename, opts.fallback);
  return format(new ContentDisposition(type3, params));
}
function createparams(filename, fallback) {
  if (filename === void 0) {
    return;
  }
  var params = {};
  if (typeof filename !== "string") {
    throw new TypeError("filename must be a string");
  }
  if (fallback === void 0) {
    fallback = true;
  }
  if (typeof fallback !== "string" && typeof fallback !== "boolean") {
    throw new TypeError("fallback must be a string or boolean");
  }
  if (typeof fallback === "string" && NON_LATIN1_REGEXP.test(fallback)) {
    throw new TypeError("fallback must be ISO-8859-1 string");
  }
  var name = basename(filename);
  var isQuotedString = TEXT_REGEXP.test(name);
  var fallbackName = typeof fallback !== "string" ? fallback && getlatin1(name) : basename(fallback);
  var hasFallback = typeof fallbackName === "string" && fallbackName !== name;
  if (hasFallback || !isQuotedString || HEX_ESCAPE_REGEXP.test(name)) {
    params["filename*"] = name;
  }
  if (isQuotedString || hasFallback) {
    params.filename = hasFallback ? fallbackName : name;
  }
  return params;
}
function format(obj) {
  var parameters = obj.parameters;
  var type3 = obj.type;
  if (!type3 || typeof type3 !== "string" || !TOKEN_REGEXP.test(type3)) {
    throw new TypeError("invalid type");
  }
  var string = String(type3).toLowerCase();
  if (parameters && typeof parameters === "object") {
    var param3;
    var params = Object.keys(parameters).sort();
    for (var i = 0; i < params.length; i++) {
      param3 = params[i];
      var val = param3.substr(-1) === "*" ? ustring(parameters[param3]) : qstring(parameters[param3]);
      string += "; " + param3 + "=" + val;
    }
  }
  return string;
}
function decodefield(str) {
  var match2 = EXT_VALUE_REGEXP.exec(str);
  if (!match2) {
    throw new TypeError("invalid extended field value");
  }
  var charset3 = match2[1].toLowerCase();
  var encoded = match2[2];
  var value;
  var binary = encoded.replace(HEX_ESCAPE_REPLACE_REGEXP, pdecode);
  switch (charset3) {
    case "iso-8859-1":
      value = getlatin1(binary);
      break;
    case "utf-8":
      value = Buffer$2.from(binary, "binary").toString("utf8");
      break;
    default:
      throw new TypeError("unsupported charset in extended field");
  }
  return value;
}
function getlatin1(val) {
  return String(val).replace(NON_LATIN1_REGEXP, "?");
}
function parse$5(string) {
  if (!string || typeof string !== "string") {
    throw new TypeError("argument string is required");
  }
  var match2 = DISPOSITION_TYPE_REGEXP.exec(string);
  if (!match2) {
    throw new TypeError("invalid type format");
  }
  var index2 = match2[0].length;
  var type3 = match2[1].toLowerCase();
  var key;
  var names = [];
  var params = {};
  var value;
  index2 = PARAM_REGEXP.lastIndex = match2[0].substr(-1) === ";" ? index2 - 1 : index2;
  while (match2 = PARAM_REGEXP.exec(string)) {
    if (match2.index !== index2) {
      throw new TypeError("invalid parameter format");
    }
    index2 += match2[0].length;
    key = match2[1].toLowerCase();
    value = match2[2];
    if (names.indexOf(key) !== -1) {
      throw new TypeError("invalid duplicate parameter");
    }
    names.push(key);
    if (key.indexOf("*") + 1 === key.length) {
      key = key.slice(0, -1);
      value = decodefield(value);
      params[key] = value;
      continue;
    }
    if (typeof params[key] === "string") {
      continue;
    }
    if (value[0] === '"') {
      value = value.substr(1, value.length - 2).replace(QESC_REGEXP, "$1");
    }
    params[key] = value;
  }
  if (index2 !== -1 && index2 !== string.length) {
    throw new TypeError("invalid parameter format");
  }
  return new ContentDisposition(type3, params);
}
function pdecode(str, hex) {
  return String.fromCharCode(parseInt(hex, 16));
}
function pencode(char) {
  return "%" + String(char).charCodeAt(0).toString(16).toUpperCase();
}
function qstring(val) {
  var str = String(val);
  return '"' + str.replace(QUOTE_REGEXP, "\\$1") + '"';
}
function ustring(val) {
  var str = String(val);
  var encoded = encodeURIComponent(str).replace(ENCODE_URL_ATTR_CHAR_REGEXP, pencode);
  return "UTF-8''" + encoded;
}
function ContentDisposition(type3, parameters) {
  this.type = type3;
  this.parameters = parameters;
}
var contentDispositionExports = contentDisposition$2.exports;
var send$2 = { exports: {} };
var src$1 = { exports: {} };
var browser$1 = { exports: {} };
var debug$3 = { exports: {} };
var ms$3;
var hasRequiredMs$1;
function requireMs$1() {
  if (hasRequiredMs$1)
    return ms$3;
  hasRequiredMs$1 = 1;
  var s2 = 1e3;
  var m2 = s2 * 60;
  var h2 = m2 * 60;
  var d2 = h2 * 24;
  var y2 = d2 * 365.25;
  ms$3 = function(val, options) {
    options = options || {};
    var type3 = typeof val;
    if (type3 === "string" && val.length > 0) {
      return parse2(val);
    } else if (type3 === "number" && isNaN(val) === false) {
      return options.long ? fmtLong2(val) : fmtShort2(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse2(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match2 = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
      str
    );
    if (!match2) {
      return;
    }
    var n = parseFloat(match2[1]);
    var type3 = (match2[2] || "ms").toLowerCase();
    switch (type3) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y2;
      case "days":
      case "day":
      case "d":
        return n * d2;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h2;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m2;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s2;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort2(ms2) {
    if (ms2 >= d2) {
      return Math.round(ms2 / d2) + "d";
    }
    if (ms2 >= h2) {
      return Math.round(ms2 / h2) + "h";
    }
    if (ms2 >= m2) {
      return Math.round(ms2 / m2) + "m";
    }
    if (ms2 >= s2) {
      return Math.round(ms2 / s2) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong2(ms2) {
    return plural2(ms2, d2, "day") || plural2(ms2, h2, "hour") || plural2(ms2, m2, "minute") || plural2(ms2, s2, "second") || ms2 + " ms";
  }
  function plural2(ms2, n, name) {
    if (ms2 < n) {
      return;
    }
    if (ms2 < n * 1.5) {
      return Math.floor(ms2 / n) + " " + name;
    }
    return Math.ceil(ms2 / n) + " " + name + "s";
  }
  return ms$3;
}
var hasRequiredDebug;
function requireDebug() {
  if (hasRequiredDebug)
    return debug$3.exports;
  hasRequiredDebug = 1;
  (function(module, exports) {
    exports = module.exports = createDebug.debug = createDebug["default"] = createDebug;
    exports.coerce = coerce;
    exports.disable = disable;
    exports.enable = enable;
    exports.enabled = enabled;
    exports.humanize = requireMs$1();
    exports.names = [];
    exports.skips = [];
    exports.formatters = {};
    var prevTime;
    function selectColor(namespace) {
      var hash = 0, i;
      for (i in namespace) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return exports.colors[Math.abs(hash) % exports.colors.length];
    }
    function createDebug(namespace) {
      function debug2() {
        if (!debug2.enabled)
          return;
        var self2 = debug2;
        var curr = +/* @__PURE__ */ new Date();
        var ms2 = curr - (prevTime || curr);
        self2.diff = ms2;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        args[0] = exports.coerce(args[0]);
        if ("string" !== typeof args[0]) {
          args.unshift("%O");
        }
        var index2 = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match2, format2) {
          if (match2 === "%%")
            return match2;
          index2++;
          var formatter = exports.formatters[format2];
          if ("function" === typeof formatter) {
            var val = args[index2];
            match2 = formatter.call(self2, val);
            args.splice(index2, 1);
            index2--;
          }
          return match2;
        });
        exports.formatArgs.call(self2, args);
        var logFn = debug2.log || exports.log || console.log.bind(console);
        logFn.apply(self2, args);
      }
      debug2.namespace = namespace;
      debug2.enabled = exports.enabled(namespace);
      debug2.useColors = exports.useColors();
      debug2.color = selectColor(namespace);
      if ("function" === typeof exports.init) {
        exports.init(debug2);
      }
      return debug2;
    }
    function enable(namespaces) {
      exports.save(namespaces);
      exports.names = [];
      exports.skips = [];
      var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      var len = split.length;
      for (var i = 0; i < len; i++) {
        if (!split[i])
          continue;
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          exports.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          exports.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      exports.enable("");
    }
    function enabled(name) {
      var i, len;
      for (i = 0, len = exports.skips.length; i < len; i++) {
        if (exports.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = exports.names.length; i < len; i++) {
        if (exports.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error)
        return val.stack || val.message;
      return val;
    }
  })(debug$3, debug$3.exports);
  return debug$3.exports;
}
var hasRequiredBrowser$1;
function requireBrowser$1() {
  if (hasRequiredBrowser$1)
    return browser$1.exports;
  hasRequiredBrowser$1 = 1;
  (function(module, exports) {
    exports = module.exports = requireDebug();
    exports.log = log2;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = "undefined" != typeof chrome && "undefined" != typeof chrome.storage ? chrome.storage.local : localstorage();
    exports.colors = [
      "lightseagreen",
      "forestgreen",
      "goldenrod",
      "dodgerblue",
      "darkorchid",
      "crimson"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
        return true;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    exports.formatters.j = function(v2) {
      try {
        return JSON.stringify(v2);
      } catch (err) {
        return "[UnexpectedJSONParseError]: " + err.message;
      }
    };
    function formatArgs(args) {
      var useColors2 = this.useColors;
      args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports.humanize(this.diff);
      if (!useColors2)
        return;
      var c2 = "color: " + this.color;
      args.splice(1, 0, c2, "color: inherit");
      var index2 = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function(match2) {
        if ("%%" === match2)
          return;
        index2++;
        if ("%c" === match2) {
          lastC = index2;
        }
      });
      args.splice(lastC, 0, c2);
    }
    function log2() {
      return "object" === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
    }
    function save(namespaces) {
      try {
        if (null == namespaces) {
          exports.storage.removeItem("debug");
        } else {
          exports.storage.debug = namespaces;
        }
      } catch (e) {
      }
    }
    function load() {
      var r;
      try {
        r = exports.storage.debug;
      } catch (e) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    exports.enable(load());
    function localstorage() {
      try {
        return window.localStorage;
      } catch (e) {
      }
    }
  })(browser$1, browser$1.exports);
  return browser$1.exports;
}
var node$1 = { exports: {} };
var hasRequiredNode$1;
function requireNode$1() {
  if (hasRequiredNode$1)
    return node$1.exports;
  hasRequiredNode$1 = 1;
  (function(module, exports) {
    var tty = require$$0$3;
    var util2 = require$$1$1;
    exports = module.exports = requireDebug();
    exports.init = init2;
    exports.log = log2;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.colors = [6, 2, 3, 4, 5, 1];
    exports.inspectOpts = Object.keys(process.env).filter(function(key) {
      return /^debug_/i.test(key);
    }).reduce(function(obj, key) {
      var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_2, k2) {
        return k2.toUpperCase();
      });
      var val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val))
        val = true;
      else if (/^(no|off|false|disabled)$/i.test(val))
        val = false;
      else if (val === "null")
        val = null;
      else
        val = Number(val);
      obj[prop] = val;
      return obj;
    }, {});
    var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
    if (1 !== fd && 2 !== fd) {
      util2.deprecate(function() {
      }, "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)")();
    }
    var stream3 = 1 === fd ? process.stdout : 2 === fd ? process.stderr : createWritableStdioStream(fd);
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(fd);
    }
    exports.formatters.o = function(v2) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v2, this.inspectOpts).split("\n").map(function(str) {
        return str.trim();
      }).join(" ");
    };
    exports.formatters.O = function(v2) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v2, this.inspectOpts);
    };
    function formatArgs(args) {
      var name = this.namespace;
      var useColors2 = this.useColors;
      if (useColors2) {
        var c2 = this.color;
        var prefix = "  \x1B[3" + c2 + ";1m" + name + " \x1B[0m";
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push("\x1B[3" + c2 + "m+" + exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = (/* @__PURE__ */ new Date()).toUTCString() + " " + name + " " + args[0];
      }
    }
    function log2() {
      return stream3.write(util2.format.apply(util2, arguments) + "\n");
    }
    function save(namespaces) {
      if (null == namespaces) {
        delete process.env.DEBUG;
      } else {
        process.env.DEBUG = namespaces;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function createWritableStdioStream(fd2) {
      var stream22;
      var tty_wrap = process.binding("tty_wrap");
      switch (tty_wrap.guessHandleType(fd2)) {
        case "TTY":
          stream22 = new tty.WriteStream(fd2);
          stream22._type = "tty";
          if (stream22._handle && stream22._handle.unref) {
            stream22._handle.unref();
          }
          break;
        case "FILE":
          var fs2 = require$$3$1;
          stream22 = new fs2.SyncWriteStream(fd2, { autoClose: false });
          stream22._type = "fs";
          break;
        case "PIPE":
        case "TCP":
          var net = require$$4$1;
          stream22 = new net.Socket({
            fd: fd2,
            readable: false,
            writable: true
          });
          stream22.readable = false;
          stream22.read = null;
          stream22._type = "pipe";
          if (stream22._handle && stream22._handle.unref) {
            stream22._handle.unref();
          }
          break;
        default:
          throw new Error("Implement me. Unknown stream file type!");
      }
      stream22.fd = fd2;
      stream22._isStdio = true;
      return stream22;
    }
    function init2(debug2) {
      debug2.inspectOpts = {};
      var keys2 = Object.keys(exports.inspectOpts);
      for (var i = 0; i < keys2.length; i++) {
        debug2.inspectOpts[keys2[i]] = exports.inspectOpts[keys2[i]];
      }
    }
    exports.enable(load());
  })(node$1, node$1.exports);
  return node$1.exports;
}
if (typeof process !== "undefined" && process.type === "renderer") {
  src$1.exports = requireBrowser$1();
} else {
  src$1.exports = requireNode$1();
}
var srcExports = src$1.exports;
/*!
 * etag
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var etag_1 = etag$1;
var crypto = require$$0$8;
var Stats = require$$3$1.Stats;
var toString$3 = Object.prototype.toString;
function entitytag(entity) {
  if (entity.length === 0) {
    return '"0-2jmj7l5rSw0yVb/vlWAYkK/YBwk"';
  }
  var hash = crypto.createHash("sha1").update(entity, "utf8").digest("base64").substring(0, 27);
  var len = typeof entity === "string" ? Buffer.byteLength(entity, "utf8") : entity.length;
  return '"' + len.toString(16) + "-" + hash + '"';
}
function etag$1(entity, options) {
  if (entity == null) {
    throw new TypeError("argument entity is required");
  }
  var isStats = isstats(entity);
  var weak = options && typeof options.weak === "boolean" ? options.weak : isStats;
  if (!isStats && typeof entity !== "string" && !Buffer.isBuffer(entity)) {
    throw new TypeError("argument entity must be string, Buffer, or fs.Stats");
  }
  var tag = isStats ? stattag(entity) : entitytag(entity);
  return weak ? "W/" + tag : tag;
}
function isstats(obj) {
  if (typeof Stats === "function" && obj instanceof Stats) {
    return true;
  }
  return obj && typeof obj === "object" && "ctime" in obj && toString$3.call(obj.ctime) === "[object Date]" && "mtime" in obj && toString$3.call(obj.mtime) === "[object Date]" && "ino" in obj && typeof obj.ino === "number" && "size" in obj && typeof obj.size === "number";
}
function stattag(stat) {
  var mtime = stat.mtime.getTime().toString(16);
  var size = stat.size.toString(16);
  return '"' + size + "-" + mtime + '"';
}
/*!
 * fresh
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2016-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
var CACHE_CONTROL_NO_CACHE_REGEXP = /(?:^|,)\s*?no-cache\s*?(?:,|$)/;
var fresh_1 = fresh$2;
function fresh$2(reqHeaders, resHeaders) {
  var modifiedSince = reqHeaders["if-modified-since"];
  var noneMatch = reqHeaders["if-none-match"];
  if (!modifiedSince && !noneMatch) {
    return false;
  }
  var cacheControl = reqHeaders["cache-control"];
  if (cacheControl && CACHE_CONTROL_NO_CACHE_REGEXP.test(cacheControl)) {
    return false;
  }
  if (noneMatch && noneMatch !== "*") {
    var etag3 = resHeaders["etag"];
    if (!etag3) {
      return false;
    }
    var etagStale = true;
    var matches = parseTokenList$1(noneMatch);
    for (var i = 0; i < matches.length; i++) {
      var match2 = matches[i];
      if (match2 === etag3 || match2 === "W/" + etag3 || "W/" + match2 === etag3) {
        etagStale = false;
        break;
      }
    }
    if (etagStale) {
      return false;
    }
  }
  if (modifiedSince) {
    var lastModified = resHeaders["last-modified"];
    var modifiedStale = !lastModified || !(parseHttpDate$1(lastModified) <= parseHttpDate$1(modifiedSince));
    if (modifiedStale) {
      return false;
    }
  }
  return true;
}
function parseHttpDate$1(date) {
  var timestamp = date && Date.parse(date);
  return typeof timestamp === "number" ? timestamp : NaN;
}
function parseTokenList$1(str) {
  var end = 0;
  var list = [];
  var start = 0;
  for (var i = 0, len = str.length; i < len; i++) {
    switch (str.charCodeAt(i)) {
      case 32:
        if (start === end) {
          start = end = i + 1;
        }
        break;
      case 44:
        list.push(str.substring(start, end));
        start = end = i + 1;
        break;
      default:
        end = i + 1;
        break;
    }
  }
  list.push(str.substring(start, end));
  return list;
}
const require$$2 = {
  "application/andrew-inset": [
    "ez"
  ],
  "application/applixware": [
    "aw"
  ],
  "application/atom+xml": [
    "atom"
  ],
  "application/atomcat+xml": [
    "atomcat"
  ],
  "application/atomsvc+xml": [
    "atomsvc"
  ],
  "application/bdoc": [
    "bdoc"
  ],
  "application/ccxml+xml": [
    "ccxml"
  ],
  "application/cdmi-capability": [
    "cdmia"
  ],
  "application/cdmi-container": [
    "cdmic"
  ],
  "application/cdmi-domain": [
    "cdmid"
  ],
  "application/cdmi-object": [
    "cdmio"
  ],
  "application/cdmi-queue": [
    "cdmiq"
  ],
  "application/cu-seeme": [
    "cu"
  ],
  "application/dash+xml": [
    "mpd"
  ],
  "application/davmount+xml": [
    "davmount"
  ],
  "application/docbook+xml": [
    "dbk"
  ],
  "application/dssc+der": [
    "dssc"
  ],
  "application/dssc+xml": [
    "xdssc"
  ],
  "application/ecmascript": [
    "ecma"
  ],
  "application/emma+xml": [
    "emma"
  ],
  "application/epub+zip": [
    "epub"
  ],
  "application/exi": [
    "exi"
  ],
  "application/font-tdpfr": [
    "pfr"
  ],
  "application/font-woff": [],
  "application/font-woff2": [],
  "application/geo+json": [
    "geojson"
  ],
  "application/gml+xml": [
    "gml"
  ],
  "application/gpx+xml": [
    "gpx"
  ],
  "application/gxf": [
    "gxf"
  ],
  "application/gzip": [
    "gz"
  ],
  "application/hyperstudio": [
    "stk"
  ],
  "application/inkml+xml": [
    "ink",
    "inkml"
  ],
  "application/ipfix": [
    "ipfix"
  ],
  "application/java-archive": [
    "jar",
    "war",
    "ear"
  ],
  "application/java-serialized-object": [
    "ser"
  ],
  "application/java-vm": [
    "class"
  ],
  "application/javascript": [
    "js",
    "mjs"
  ],
  "application/json": [
    "json",
    "map"
  ],
  "application/json5": [
    "json5"
  ],
  "application/jsonml+json": [
    "jsonml"
  ],
  "application/ld+json": [
    "jsonld"
  ],
  "application/lost+xml": [
    "lostxml"
  ],
  "application/mac-binhex40": [
    "hqx"
  ],
  "application/mac-compactpro": [
    "cpt"
  ],
  "application/mads+xml": [
    "mads"
  ],
  "application/manifest+json": [
    "webmanifest"
  ],
  "application/marc": [
    "mrc"
  ],
  "application/marcxml+xml": [
    "mrcx"
  ],
  "application/mathematica": [
    "ma",
    "nb",
    "mb"
  ],
  "application/mathml+xml": [
    "mathml"
  ],
  "application/mbox": [
    "mbox"
  ],
  "application/mediaservercontrol+xml": [
    "mscml"
  ],
  "application/metalink+xml": [
    "metalink"
  ],
  "application/metalink4+xml": [
    "meta4"
  ],
  "application/mets+xml": [
    "mets"
  ],
  "application/mods+xml": [
    "mods"
  ],
  "application/mp21": [
    "m21",
    "mp21"
  ],
  "application/mp4": [
    "mp4s",
    "m4p"
  ],
  "application/msword": [
    "doc",
    "dot"
  ],
  "application/mxf": [
    "mxf"
  ],
  "application/octet-stream": [
    "bin",
    "dms",
    "lrf",
    "mar",
    "so",
    "dist",
    "distz",
    "pkg",
    "bpk",
    "dump",
    "elc",
    "deploy",
    "exe",
    "dll",
    "deb",
    "dmg",
    "iso",
    "img",
    "msi",
    "msp",
    "msm",
    "buffer"
  ],
  "application/oda": [
    "oda"
  ],
  "application/oebps-package+xml": [
    "opf"
  ],
  "application/ogg": [
    "ogx"
  ],
  "application/omdoc+xml": [
    "omdoc"
  ],
  "application/onenote": [
    "onetoc",
    "onetoc2",
    "onetmp",
    "onepkg"
  ],
  "application/oxps": [
    "oxps"
  ],
  "application/patch-ops-error+xml": [
    "xer"
  ],
  "application/pdf": [
    "pdf"
  ],
  "application/pgp-encrypted": [
    "pgp"
  ],
  "application/pgp-signature": [
    "asc",
    "sig"
  ],
  "application/pics-rules": [
    "prf"
  ],
  "application/pkcs10": [
    "p10"
  ],
  "application/pkcs7-mime": [
    "p7m",
    "p7c"
  ],
  "application/pkcs7-signature": [
    "p7s"
  ],
  "application/pkcs8": [
    "p8"
  ],
  "application/pkix-attr-cert": [
    "ac"
  ],
  "application/pkix-cert": [
    "cer"
  ],
  "application/pkix-crl": [
    "crl"
  ],
  "application/pkix-pkipath": [
    "pkipath"
  ],
  "application/pkixcmp": [
    "pki"
  ],
  "application/pls+xml": [
    "pls"
  ],
  "application/postscript": [
    "ai",
    "eps",
    "ps"
  ],
  "application/prs.cww": [
    "cww"
  ],
  "application/pskc+xml": [
    "pskcxml"
  ],
  "application/raml+yaml": [
    "raml"
  ],
  "application/rdf+xml": [
    "rdf"
  ],
  "application/reginfo+xml": [
    "rif"
  ],
  "application/relax-ng-compact-syntax": [
    "rnc"
  ],
  "application/resource-lists+xml": [
    "rl"
  ],
  "application/resource-lists-diff+xml": [
    "rld"
  ],
  "application/rls-services+xml": [
    "rs"
  ],
  "application/rpki-ghostbusters": [
    "gbr"
  ],
  "application/rpki-manifest": [
    "mft"
  ],
  "application/rpki-roa": [
    "roa"
  ],
  "application/rsd+xml": [
    "rsd"
  ],
  "application/rss+xml": [
    "rss"
  ],
  "application/rtf": [
    "rtf"
  ],
  "application/sbml+xml": [
    "sbml"
  ],
  "application/scvp-cv-request": [
    "scq"
  ],
  "application/scvp-cv-response": [
    "scs"
  ],
  "application/scvp-vp-request": [
    "spq"
  ],
  "application/scvp-vp-response": [
    "spp"
  ],
  "application/sdp": [
    "sdp"
  ],
  "application/set-payment-initiation": [
    "setpay"
  ],
  "application/set-registration-initiation": [
    "setreg"
  ],
  "application/shf+xml": [
    "shf"
  ],
  "application/smil+xml": [
    "smi",
    "smil"
  ],
  "application/sparql-query": [
    "rq"
  ],
  "application/sparql-results+xml": [
    "srx"
  ],
  "application/srgs": [
    "gram"
  ],
  "application/srgs+xml": [
    "grxml"
  ],
  "application/sru+xml": [
    "sru"
  ],
  "application/ssdl+xml": [
    "ssdl"
  ],
  "application/ssml+xml": [
    "ssml"
  ],
  "application/tei+xml": [
    "tei",
    "teicorpus"
  ],
  "application/thraud+xml": [
    "tfi"
  ],
  "application/timestamped-data": [
    "tsd"
  ],
  "application/vnd.3gpp.pic-bw-large": [
    "plb"
  ],
  "application/vnd.3gpp.pic-bw-small": [
    "psb"
  ],
  "application/vnd.3gpp.pic-bw-var": [
    "pvb"
  ],
  "application/vnd.3gpp2.tcap": [
    "tcap"
  ],
  "application/vnd.3m.post-it-notes": [
    "pwn"
  ],
  "application/vnd.accpac.simply.aso": [
    "aso"
  ],
  "application/vnd.accpac.simply.imp": [
    "imp"
  ],
  "application/vnd.acucobol": [
    "acu"
  ],
  "application/vnd.acucorp": [
    "atc",
    "acutc"
  ],
  "application/vnd.adobe.air-application-installer-package+zip": [
    "air"
  ],
  "application/vnd.adobe.formscentral.fcdt": [
    "fcdt"
  ],
  "application/vnd.adobe.fxp": [
    "fxp",
    "fxpl"
  ],
  "application/vnd.adobe.xdp+xml": [
    "xdp"
  ],
  "application/vnd.adobe.xfdf": [
    "xfdf"
  ],
  "application/vnd.ahead.space": [
    "ahead"
  ],
  "application/vnd.airzip.filesecure.azf": [
    "azf"
  ],
  "application/vnd.airzip.filesecure.azs": [
    "azs"
  ],
  "application/vnd.amazon.ebook": [
    "azw"
  ],
  "application/vnd.americandynamics.acc": [
    "acc"
  ],
  "application/vnd.amiga.ami": [
    "ami"
  ],
  "application/vnd.android.package-archive": [
    "apk"
  ],
  "application/vnd.anser-web-certificate-issue-initiation": [
    "cii"
  ],
  "application/vnd.anser-web-funds-transfer-initiation": [
    "fti"
  ],
  "application/vnd.antix.game-component": [
    "atx"
  ],
  "application/vnd.apple.installer+xml": [
    "mpkg"
  ],
  "application/vnd.apple.mpegurl": [
    "m3u8"
  ],
  "application/vnd.apple.pkpass": [
    "pkpass"
  ],
  "application/vnd.aristanetworks.swi": [
    "swi"
  ],
  "application/vnd.astraea-software.iota": [
    "iota"
  ],
  "application/vnd.audiograph": [
    "aep"
  ],
  "application/vnd.blueice.multipass": [
    "mpm"
  ],
  "application/vnd.bmi": [
    "bmi"
  ],
  "application/vnd.businessobjects": [
    "rep"
  ],
  "application/vnd.chemdraw+xml": [
    "cdxml"
  ],
  "application/vnd.chipnuts.karaoke-mmd": [
    "mmd"
  ],
  "application/vnd.cinderella": [
    "cdy"
  ],
  "application/vnd.claymore": [
    "cla"
  ],
  "application/vnd.cloanto.rp9": [
    "rp9"
  ],
  "application/vnd.clonk.c4group": [
    "c4g",
    "c4d",
    "c4f",
    "c4p",
    "c4u"
  ],
  "application/vnd.cluetrust.cartomobile-config": [
    "c11amc"
  ],
  "application/vnd.cluetrust.cartomobile-config-pkg": [
    "c11amz"
  ],
  "application/vnd.commonspace": [
    "csp"
  ],
  "application/vnd.contact.cmsg": [
    "cdbcmsg"
  ],
  "application/vnd.cosmocaller": [
    "cmc"
  ],
  "application/vnd.crick.clicker": [
    "clkx"
  ],
  "application/vnd.crick.clicker.keyboard": [
    "clkk"
  ],
  "application/vnd.crick.clicker.palette": [
    "clkp"
  ],
  "application/vnd.crick.clicker.template": [
    "clkt"
  ],
  "application/vnd.crick.clicker.wordbank": [
    "clkw"
  ],
  "application/vnd.criticaltools.wbs+xml": [
    "wbs"
  ],
  "application/vnd.ctc-posml": [
    "pml"
  ],
  "application/vnd.cups-ppd": [
    "ppd"
  ],
  "application/vnd.curl.car": [
    "car"
  ],
  "application/vnd.curl.pcurl": [
    "pcurl"
  ],
  "application/vnd.dart": [
    "dart"
  ],
  "application/vnd.data-vision.rdz": [
    "rdz"
  ],
  "application/vnd.dece.data": [
    "uvf",
    "uvvf",
    "uvd",
    "uvvd"
  ],
  "application/vnd.dece.ttml+xml": [
    "uvt",
    "uvvt"
  ],
  "application/vnd.dece.unspecified": [
    "uvx",
    "uvvx"
  ],
  "application/vnd.dece.zip": [
    "uvz",
    "uvvz"
  ],
  "application/vnd.denovo.fcselayout-link": [
    "fe_launch"
  ],
  "application/vnd.dna": [
    "dna"
  ],
  "application/vnd.dolby.mlp": [
    "mlp"
  ],
  "application/vnd.dpgraph": [
    "dpg"
  ],
  "application/vnd.dreamfactory": [
    "dfac"
  ],
  "application/vnd.ds-keypoint": [
    "kpxx"
  ],
  "application/vnd.dvb.ait": [
    "ait"
  ],
  "application/vnd.dvb.service": [
    "svc"
  ],
  "application/vnd.dynageo": [
    "geo"
  ],
  "application/vnd.ecowin.chart": [
    "mag"
  ],
  "application/vnd.enliven": [
    "nml"
  ],
  "application/vnd.epson.esf": [
    "esf"
  ],
  "application/vnd.epson.msf": [
    "msf"
  ],
  "application/vnd.epson.quickanime": [
    "qam"
  ],
  "application/vnd.epson.salt": [
    "slt"
  ],
  "application/vnd.epson.ssf": [
    "ssf"
  ],
  "application/vnd.eszigno3+xml": [
    "es3",
    "et3"
  ],
  "application/vnd.ezpix-album": [
    "ez2"
  ],
  "application/vnd.ezpix-package": [
    "ez3"
  ],
  "application/vnd.fdf": [
    "fdf"
  ],
  "application/vnd.fdsn.mseed": [
    "mseed"
  ],
  "application/vnd.fdsn.seed": [
    "seed",
    "dataless"
  ],
  "application/vnd.flographit": [
    "gph"
  ],
  "application/vnd.fluxtime.clip": [
    "ftc"
  ],
  "application/vnd.framemaker": [
    "fm",
    "frame",
    "maker",
    "book"
  ],
  "application/vnd.frogans.fnc": [
    "fnc"
  ],
  "application/vnd.frogans.ltf": [
    "ltf"
  ],
  "application/vnd.fsc.weblaunch": [
    "fsc"
  ],
  "application/vnd.fujitsu.oasys": [
    "oas"
  ],
  "application/vnd.fujitsu.oasys2": [
    "oa2"
  ],
  "application/vnd.fujitsu.oasys3": [
    "oa3"
  ],
  "application/vnd.fujitsu.oasysgp": [
    "fg5"
  ],
  "application/vnd.fujitsu.oasysprs": [
    "bh2"
  ],
  "application/vnd.fujixerox.ddd": [
    "ddd"
  ],
  "application/vnd.fujixerox.docuworks": [
    "xdw"
  ],
  "application/vnd.fujixerox.docuworks.binder": [
    "xbd"
  ],
  "application/vnd.fuzzysheet": [
    "fzs"
  ],
  "application/vnd.genomatix.tuxedo": [
    "txd"
  ],
  "application/vnd.geogebra.file": [
    "ggb"
  ],
  "application/vnd.geogebra.tool": [
    "ggt"
  ],
  "application/vnd.geometry-explorer": [
    "gex",
    "gre"
  ],
  "application/vnd.geonext": [
    "gxt"
  ],
  "application/vnd.geoplan": [
    "g2w"
  ],
  "application/vnd.geospace": [
    "g3w"
  ],
  "application/vnd.gmx": [
    "gmx"
  ],
  "application/vnd.google-apps.document": [
    "gdoc"
  ],
  "application/vnd.google-apps.presentation": [
    "gslides"
  ],
  "application/vnd.google-apps.spreadsheet": [
    "gsheet"
  ],
  "application/vnd.google-earth.kml+xml": [
    "kml"
  ],
  "application/vnd.google-earth.kmz": [
    "kmz"
  ],
  "application/vnd.grafeq": [
    "gqf",
    "gqs"
  ],
  "application/vnd.groove-account": [
    "gac"
  ],
  "application/vnd.groove-help": [
    "ghf"
  ],
  "application/vnd.groove-identity-message": [
    "gim"
  ],
  "application/vnd.groove-injector": [
    "grv"
  ],
  "application/vnd.groove-tool-message": [
    "gtm"
  ],
  "application/vnd.groove-tool-template": [
    "tpl"
  ],
  "application/vnd.groove-vcard": [
    "vcg"
  ],
  "application/vnd.hal+xml": [
    "hal"
  ],
  "application/vnd.handheld-entertainment+xml": [
    "zmm"
  ],
  "application/vnd.hbci": [
    "hbci"
  ],
  "application/vnd.hhe.lesson-player": [
    "les"
  ],
  "application/vnd.hp-hpgl": [
    "hpgl"
  ],
  "application/vnd.hp-hpid": [
    "hpid"
  ],
  "application/vnd.hp-hps": [
    "hps"
  ],
  "application/vnd.hp-jlyt": [
    "jlt"
  ],
  "application/vnd.hp-pcl": [
    "pcl"
  ],
  "application/vnd.hp-pclxl": [
    "pclxl"
  ],
  "application/vnd.hydrostatix.sof-data": [
    "sfd-hdstx"
  ],
  "application/vnd.ibm.minipay": [
    "mpy"
  ],
  "application/vnd.ibm.modcap": [
    "afp",
    "listafp",
    "list3820"
  ],
  "application/vnd.ibm.rights-management": [
    "irm"
  ],
  "application/vnd.ibm.secure-container": [
    "sc"
  ],
  "application/vnd.iccprofile": [
    "icc",
    "icm"
  ],
  "application/vnd.igloader": [
    "igl"
  ],
  "application/vnd.immervision-ivp": [
    "ivp"
  ],
  "application/vnd.immervision-ivu": [
    "ivu"
  ],
  "application/vnd.insors.igm": [
    "igm"
  ],
  "application/vnd.intercon.formnet": [
    "xpw",
    "xpx"
  ],
  "application/vnd.intergeo": [
    "i2g"
  ],
  "application/vnd.intu.qbo": [
    "qbo"
  ],
  "application/vnd.intu.qfx": [
    "qfx"
  ],
  "application/vnd.ipunplugged.rcprofile": [
    "rcprofile"
  ],
  "application/vnd.irepository.package+xml": [
    "irp"
  ],
  "application/vnd.is-xpr": [
    "xpr"
  ],
  "application/vnd.isac.fcs": [
    "fcs"
  ],
  "application/vnd.jam": [
    "jam"
  ],
  "application/vnd.jcp.javame.midlet-rms": [
    "rms"
  ],
  "application/vnd.jisp": [
    "jisp"
  ],
  "application/vnd.joost.joda-archive": [
    "joda"
  ],
  "application/vnd.kahootz": [
    "ktz",
    "ktr"
  ],
  "application/vnd.kde.karbon": [
    "karbon"
  ],
  "application/vnd.kde.kchart": [
    "chrt"
  ],
  "application/vnd.kde.kformula": [
    "kfo"
  ],
  "application/vnd.kde.kivio": [
    "flw"
  ],
  "application/vnd.kde.kontour": [
    "kon"
  ],
  "application/vnd.kde.kpresenter": [
    "kpr",
    "kpt"
  ],
  "application/vnd.kde.kspread": [
    "ksp"
  ],
  "application/vnd.kde.kword": [
    "kwd",
    "kwt"
  ],
  "application/vnd.kenameaapp": [
    "htke"
  ],
  "application/vnd.kidspiration": [
    "kia"
  ],
  "application/vnd.kinar": [
    "kne",
    "knp"
  ],
  "application/vnd.koan": [
    "skp",
    "skd",
    "skt",
    "skm"
  ],
  "application/vnd.kodak-descriptor": [
    "sse"
  ],
  "application/vnd.las.las+xml": [
    "lasxml"
  ],
  "application/vnd.llamagraphics.life-balance.desktop": [
    "lbd"
  ],
  "application/vnd.llamagraphics.life-balance.exchange+xml": [
    "lbe"
  ],
  "application/vnd.lotus-1-2-3": [
    "123"
  ],
  "application/vnd.lotus-approach": [
    "apr"
  ],
  "application/vnd.lotus-freelance": [
    "pre"
  ],
  "application/vnd.lotus-notes": [
    "nsf"
  ],
  "application/vnd.lotus-organizer": [
    "org"
  ],
  "application/vnd.lotus-screencam": [
    "scm"
  ],
  "application/vnd.lotus-wordpro": [
    "lwp"
  ],
  "application/vnd.macports.portpkg": [
    "portpkg"
  ],
  "application/vnd.mcd": [
    "mcd"
  ],
  "application/vnd.medcalcdata": [
    "mc1"
  ],
  "application/vnd.mediastation.cdkey": [
    "cdkey"
  ],
  "application/vnd.mfer": [
    "mwf"
  ],
  "application/vnd.mfmp": [
    "mfm"
  ],
  "application/vnd.micrografx.flo": [
    "flo"
  ],
  "application/vnd.micrografx.igx": [
    "igx"
  ],
  "application/vnd.mif": [
    "mif"
  ],
  "application/vnd.mobius.daf": [
    "daf"
  ],
  "application/vnd.mobius.dis": [
    "dis"
  ],
  "application/vnd.mobius.mbk": [
    "mbk"
  ],
  "application/vnd.mobius.mqy": [
    "mqy"
  ],
  "application/vnd.mobius.msl": [
    "msl"
  ],
  "application/vnd.mobius.plc": [
    "plc"
  ],
  "application/vnd.mobius.txf": [
    "txf"
  ],
  "application/vnd.mophun.application": [
    "mpn"
  ],
  "application/vnd.mophun.certificate": [
    "mpc"
  ],
  "application/vnd.mozilla.xul+xml": [
    "xul"
  ],
  "application/vnd.ms-artgalry": [
    "cil"
  ],
  "application/vnd.ms-cab-compressed": [
    "cab"
  ],
  "application/vnd.ms-excel": [
    "xls",
    "xlm",
    "xla",
    "xlc",
    "xlt",
    "xlw"
  ],
  "application/vnd.ms-excel.addin.macroenabled.12": [
    "xlam"
  ],
  "application/vnd.ms-excel.sheet.binary.macroenabled.12": [
    "xlsb"
  ],
  "application/vnd.ms-excel.sheet.macroenabled.12": [
    "xlsm"
  ],
  "application/vnd.ms-excel.template.macroenabled.12": [
    "xltm"
  ],
  "application/vnd.ms-fontobject": [
    "eot"
  ],
  "application/vnd.ms-htmlhelp": [
    "chm"
  ],
  "application/vnd.ms-ims": [
    "ims"
  ],
  "application/vnd.ms-lrm": [
    "lrm"
  ],
  "application/vnd.ms-officetheme": [
    "thmx"
  ],
  "application/vnd.ms-outlook": [
    "msg"
  ],
  "application/vnd.ms-pki.seccat": [
    "cat"
  ],
  "application/vnd.ms-pki.stl": [
    "stl"
  ],
  "application/vnd.ms-powerpoint": [
    "ppt",
    "pps",
    "pot"
  ],
  "application/vnd.ms-powerpoint.addin.macroenabled.12": [
    "ppam"
  ],
  "application/vnd.ms-powerpoint.presentation.macroenabled.12": [
    "pptm"
  ],
  "application/vnd.ms-powerpoint.slide.macroenabled.12": [
    "sldm"
  ],
  "application/vnd.ms-powerpoint.slideshow.macroenabled.12": [
    "ppsm"
  ],
  "application/vnd.ms-powerpoint.template.macroenabled.12": [
    "potm"
  ],
  "application/vnd.ms-project": [
    "mpp",
    "mpt"
  ],
  "application/vnd.ms-word.document.macroenabled.12": [
    "docm"
  ],
  "application/vnd.ms-word.template.macroenabled.12": [
    "dotm"
  ],
  "application/vnd.ms-works": [
    "wps",
    "wks",
    "wcm",
    "wdb"
  ],
  "application/vnd.ms-wpl": [
    "wpl"
  ],
  "application/vnd.ms-xpsdocument": [
    "xps"
  ],
  "application/vnd.mseq": [
    "mseq"
  ],
  "application/vnd.musician": [
    "mus"
  ],
  "application/vnd.muvee.style": [
    "msty"
  ],
  "application/vnd.mynfc": [
    "taglet"
  ],
  "application/vnd.neurolanguage.nlu": [
    "nlu"
  ],
  "application/vnd.nitf": [
    "ntf",
    "nitf"
  ],
  "application/vnd.noblenet-directory": [
    "nnd"
  ],
  "application/vnd.noblenet-sealer": [
    "nns"
  ],
  "application/vnd.noblenet-web": [
    "nnw"
  ],
  "application/vnd.nokia.n-gage.data": [
    "ngdat"
  ],
  "application/vnd.nokia.n-gage.symbian.install": [
    "n-gage"
  ],
  "application/vnd.nokia.radio-preset": [
    "rpst"
  ],
  "application/vnd.nokia.radio-presets": [
    "rpss"
  ],
  "application/vnd.novadigm.edm": [
    "edm"
  ],
  "application/vnd.novadigm.edx": [
    "edx"
  ],
  "application/vnd.novadigm.ext": [
    "ext"
  ],
  "application/vnd.oasis.opendocument.chart": [
    "odc"
  ],
  "application/vnd.oasis.opendocument.chart-template": [
    "otc"
  ],
  "application/vnd.oasis.opendocument.database": [
    "odb"
  ],
  "application/vnd.oasis.opendocument.formula": [
    "odf"
  ],
  "application/vnd.oasis.opendocument.formula-template": [
    "odft"
  ],
  "application/vnd.oasis.opendocument.graphics": [
    "odg"
  ],
  "application/vnd.oasis.opendocument.graphics-template": [
    "otg"
  ],
  "application/vnd.oasis.opendocument.image": [
    "odi"
  ],
  "application/vnd.oasis.opendocument.image-template": [
    "oti"
  ],
  "application/vnd.oasis.opendocument.presentation": [
    "odp"
  ],
  "application/vnd.oasis.opendocument.presentation-template": [
    "otp"
  ],
  "application/vnd.oasis.opendocument.spreadsheet": [
    "ods"
  ],
  "application/vnd.oasis.opendocument.spreadsheet-template": [
    "ots"
  ],
  "application/vnd.oasis.opendocument.text": [
    "odt"
  ],
  "application/vnd.oasis.opendocument.text-master": [
    "odm"
  ],
  "application/vnd.oasis.opendocument.text-template": [
    "ott"
  ],
  "application/vnd.oasis.opendocument.text-web": [
    "oth"
  ],
  "application/vnd.olpc-sugar": [
    "xo"
  ],
  "application/vnd.oma.dd2+xml": [
    "dd2"
  ],
  "application/vnd.openofficeorg.extension": [
    "oxt"
  ],
  "application/vnd.openxmlformats-officedocument.presentationml.presentation": [
    "pptx"
  ],
  "application/vnd.openxmlformats-officedocument.presentationml.slide": [
    "sldx"
  ],
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow": [
    "ppsx"
  ],
  "application/vnd.openxmlformats-officedocument.presentationml.template": [
    "potx"
  ],
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": [
    "xlsx"
  ],
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template": [
    "xltx"
  ],
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document": [
    "docx"
  ],
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template": [
    "dotx"
  ],
  "application/vnd.osgeo.mapguide.package": [
    "mgp"
  ],
  "application/vnd.osgi.dp": [
    "dp"
  ],
  "application/vnd.osgi.subsystem": [
    "esa"
  ],
  "application/vnd.palm": [
    "pdb",
    "pqa",
    "oprc"
  ],
  "application/vnd.pawaafile": [
    "paw"
  ],
  "application/vnd.pg.format": [
    "str"
  ],
  "application/vnd.pg.osasli": [
    "ei6"
  ],
  "application/vnd.picsel": [
    "efif"
  ],
  "application/vnd.pmi.widget": [
    "wg"
  ],
  "application/vnd.pocketlearn": [
    "plf"
  ],
  "application/vnd.powerbuilder6": [
    "pbd"
  ],
  "application/vnd.previewsystems.box": [
    "box"
  ],
  "application/vnd.proteus.magazine": [
    "mgz"
  ],
  "application/vnd.publishare-delta-tree": [
    "qps"
  ],
  "application/vnd.pvi.ptid1": [
    "ptid"
  ],
  "application/vnd.quark.quarkxpress": [
    "qxd",
    "qxt",
    "qwd",
    "qwt",
    "qxl",
    "qxb"
  ],
  "application/vnd.realvnc.bed": [
    "bed"
  ],
  "application/vnd.recordare.musicxml": [
    "mxl"
  ],
  "application/vnd.recordare.musicxml+xml": [
    "musicxml"
  ],
  "application/vnd.rig.cryptonote": [
    "cryptonote"
  ],
  "application/vnd.rim.cod": [
    "cod"
  ],
  "application/vnd.rn-realmedia": [
    "rm"
  ],
  "application/vnd.rn-realmedia-vbr": [
    "rmvb"
  ],
  "application/vnd.route66.link66+xml": [
    "link66"
  ],
  "application/vnd.sailingtracker.track": [
    "st"
  ],
  "application/vnd.seemail": [
    "see"
  ],
  "application/vnd.sema": [
    "sema"
  ],
  "application/vnd.semd": [
    "semd"
  ],
  "application/vnd.semf": [
    "semf"
  ],
  "application/vnd.shana.informed.formdata": [
    "ifm"
  ],
  "application/vnd.shana.informed.formtemplate": [
    "itp"
  ],
  "application/vnd.shana.informed.interchange": [
    "iif"
  ],
  "application/vnd.shana.informed.package": [
    "ipk"
  ],
  "application/vnd.simtech-mindmapper": [
    "twd",
    "twds"
  ],
  "application/vnd.smaf": [
    "mmf"
  ],
  "application/vnd.smart.teacher": [
    "teacher"
  ],
  "application/vnd.solent.sdkm+xml": [
    "sdkm",
    "sdkd"
  ],
  "application/vnd.spotfire.dxp": [
    "dxp"
  ],
  "application/vnd.spotfire.sfs": [
    "sfs"
  ],
  "application/vnd.stardivision.calc": [
    "sdc"
  ],
  "application/vnd.stardivision.draw": [
    "sda"
  ],
  "application/vnd.stardivision.impress": [
    "sdd"
  ],
  "application/vnd.stardivision.math": [
    "smf"
  ],
  "application/vnd.stardivision.writer": [
    "sdw",
    "vor"
  ],
  "application/vnd.stardivision.writer-global": [
    "sgl"
  ],
  "application/vnd.stepmania.package": [
    "smzip"
  ],
  "application/vnd.stepmania.stepchart": [
    "sm"
  ],
  "application/vnd.sun.wadl+xml": [
    "wadl"
  ],
  "application/vnd.sun.xml.calc": [
    "sxc"
  ],
  "application/vnd.sun.xml.calc.template": [
    "stc"
  ],
  "application/vnd.sun.xml.draw": [
    "sxd"
  ],
  "application/vnd.sun.xml.draw.template": [
    "std"
  ],
  "application/vnd.sun.xml.impress": [
    "sxi"
  ],
  "application/vnd.sun.xml.impress.template": [
    "sti"
  ],
  "application/vnd.sun.xml.math": [
    "sxm"
  ],
  "application/vnd.sun.xml.writer": [
    "sxw"
  ],
  "application/vnd.sun.xml.writer.global": [
    "sxg"
  ],
  "application/vnd.sun.xml.writer.template": [
    "stw"
  ],
  "application/vnd.sus-calendar": [
    "sus",
    "susp"
  ],
  "application/vnd.svd": [
    "svd"
  ],
  "application/vnd.symbian.install": [
    "sis",
    "sisx"
  ],
  "application/vnd.syncml+xml": [
    "xsm"
  ],
  "application/vnd.syncml.dm+wbxml": [
    "bdm"
  ],
  "application/vnd.syncml.dm+xml": [
    "xdm"
  ],
  "application/vnd.tao.intent-module-archive": [
    "tao"
  ],
  "application/vnd.tcpdump.pcap": [
    "pcap",
    "cap",
    "dmp"
  ],
  "application/vnd.tmobile-livetv": [
    "tmo"
  ],
  "application/vnd.trid.tpt": [
    "tpt"
  ],
  "application/vnd.triscape.mxs": [
    "mxs"
  ],
  "application/vnd.trueapp": [
    "tra"
  ],
  "application/vnd.ufdl": [
    "ufd",
    "ufdl"
  ],
  "application/vnd.uiq.theme": [
    "utz"
  ],
  "application/vnd.umajin": [
    "umj"
  ],
  "application/vnd.unity": [
    "unityweb"
  ],
  "application/vnd.uoml+xml": [
    "uoml"
  ],
  "application/vnd.vcx": [
    "vcx"
  ],
  "application/vnd.visio": [
    "vsd",
    "vst",
    "vss",
    "vsw"
  ],
  "application/vnd.visionary": [
    "vis"
  ],
  "application/vnd.vsf": [
    "vsf"
  ],
  "application/vnd.wap.wbxml": [
    "wbxml"
  ],
  "application/vnd.wap.wmlc": [
    "wmlc"
  ],
  "application/vnd.wap.wmlscriptc": [
    "wmlsc"
  ],
  "application/vnd.webturbo": [
    "wtb"
  ],
  "application/vnd.wolfram.player": [
    "nbp"
  ],
  "application/vnd.wordperfect": [
    "wpd"
  ],
  "application/vnd.wqd": [
    "wqd"
  ],
  "application/vnd.wt.stf": [
    "stf"
  ],
  "application/vnd.xara": [
    "xar"
  ],
  "application/vnd.xfdl": [
    "xfdl"
  ],
  "application/vnd.yamaha.hv-dic": [
    "hvd"
  ],
  "application/vnd.yamaha.hv-script": [
    "hvs"
  ],
  "application/vnd.yamaha.hv-voice": [
    "hvp"
  ],
  "application/vnd.yamaha.openscoreformat": [
    "osf"
  ],
  "application/vnd.yamaha.openscoreformat.osfpvg+xml": [
    "osfpvg"
  ],
  "application/vnd.yamaha.smaf-audio": [
    "saf"
  ],
  "application/vnd.yamaha.smaf-phrase": [
    "spf"
  ],
  "application/vnd.yellowriver-custom-menu": [
    "cmp"
  ],
  "application/vnd.zul": [
    "zir",
    "zirz"
  ],
  "application/vnd.zzazz.deck+xml": [
    "zaz"
  ],
  "application/voicexml+xml": [
    "vxml"
  ],
  "application/wasm": [
    "wasm"
  ],
  "application/widget": [
    "wgt"
  ],
  "application/winhlp": [
    "hlp"
  ],
  "application/wsdl+xml": [
    "wsdl"
  ],
  "application/wspolicy+xml": [
    "wspolicy"
  ],
  "application/x-7z-compressed": [
    "7z"
  ],
  "application/x-abiword": [
    "abw"
  ],
  "application/x-ace-compressed": [
    "ace"
  ],
  "application/x-apple-diskimage": [],
  "application/x-arj": [
    "arj"
  ],
  "application/x-authorware-bin": [
    "aab",
    "x32",
    "u32",
    "vox"
  ],
  "application/x-authorware-map": [
    "aam"
  ],
  "application/x-authorware-seg": [
    "aas"
  ],
  "application/x-bcpio": [
    "bcpio"
  ],
  "application/x-bdoc": [],
  "application/x-bittorrent": [
    "torrent"
  ],
  "application/x-blorb": [
    "blb",
    "blorb"
  ],
  "application/x-bzip": [
    "bz"
  ],
  "application/x-bzip2": [
    "bz2",
    "boz"
  ],
  "application/x-cbr": [
    "cbr",
    "cba",
    "cbt",
    "cbz",
    "cb7"
  ],
  "application/x-cdlink": [
    "vcd"
  ],
  "application/x-cfs-compressed": [
    "cfs"
  ],
  "application/x-chat": [
    "chat"
  ],
  "application/x-chess-pgn": [
    "pgn"
  ],
  "application/x-chrome-extension": [
    "crx"
  ],
  "application/x-cocoa": [
    "cco"
  ],
  "application/x-conference": [
    "nsc"
  ],
  "application/x-cpio": [
    "cpio"
  ],
  "application/x-csh": [
    "csh"
  ],
  "application/x-debian-package": [
    "udeb"
  ],
  "application/x-dgc-compressed": [
    "dgc"
  ],
  "application/x-director": [
    "dir",
    "dcr",
    "dxr",
    "cst",
    "cct",
    "cxt",
    "w3d",
    "fgd",
    "swa"
  ],
  "application/x-doom": [
    "wad"
  ],
  "application/x-dtbncx+xml": [
    "ncx"
  ],
  "application/x-dtbook+xml": [
    "dtb"
  ],
  "application/x-dtbresource+xml": [
    "res"
  ],
  "application/x-dvi": [
    "dvi"
  ],
  "application/x-envoy": [
    "evy"
  ],
  "application/x-eva": [
    "eva"
  ],
  "application/x-font-bdf": [
    "bdf"
  ],
  "application/x-font-ghostscript": [
    "gsf"
  ],
  "application/x-font-linux-psf": [
    "psf"
  ],
  "application/x-font-pcf": [
    "pcf"
  ],
  "application/x-font-snf": [
    "snf"
  ],
  "application/x-font-type1": [
    "pfa",
    "pfb",
    "pfm",
    "afm"
  ],
  "application/x-freearc": [
    "arc"
  ],
  "application/x-futuresplash": [
    "spl"
  ],
  "application/x-gca-compressed": [
    "gca"
  ],
  "application/x-glulx": [
    "ulx"
  ],
  "application/x-gnumeric": [
    "gnumeric"
  ],
  "application/x-gramps-xml": [
    "gramps"
  ],
  "application/x-gtar": [
    "gtar"
  ],
  "application/x-hdf": [
    "hdf"
  ],
  "application/x-httpd-php": [
    "php"
  ],
  "application/x-install-instructions": [
    "install"
  ],
  "application/x-iso9660-image": [],
  "application/x-java-archive-diff": [
    "jardiff"
  ],
  "application/x-java-jnlp-file": [
    "jnlp"
  ],
  "application/x-latex": [
    "latex"
  ],
  "application/x-lua-bytecode": [
    "luac"
  ],
  "application/x-lzh-compressed": [
    "lzh",
    "lha"
  ],
  "application/x-makeself": [
    "run"
  ],
  "application/x-mie": [
    "mie"
  ],
  "application/x-mobipocket-ebook": [
    "prc",
    "mobi"
  ],
  "application/x-ms-application": [
    "application"
  ],
  "application/x-ms-shortcut": [
    "lnk"
  ],
  "application/x-ms-wmd": [
    "wmd"
  ],
  "application/x-ms-wmz": [
    "wmz"
  ],
  "application/x-ms-xbap": [
    "xbap"
  ],
  "application/x-msaccess": [
    "mdb"
  ],
  "application/x-msbinder": [
    "obd"
  ],
  "application/x-mscardfile": [
    "crd"
  ],
  "application/x-msclip": [
    "clp"
  ],
  "application/x-msdos-program": [],
  "application/x-msdownload": [
    "com",
    "bat"
  ],
  "application/x-msmediaview": [
    "mvb",
    "m13",
    "m14"
  ],
  "application/x-msmetafile": [
    "wmf",
    "emf",
    "emz"
  ],
  "application/x-msmoney": [
    "mny"
  ],
  "application/x-mspublisher": [
    "pub"
  ],
  "application/x-msschedule": [
    "scd"
  ],
  "application/x-msterminal": [
    "trm"
  ],
  "application/x-mswrite": [
    "wri"
  ],
  "application/x-netcdf": [
    "nc",
    "cdf"
  ],
  "application/x-ns-proxy-autoconfig": [
    "pac"
  ],
  "application/x-nzb": [
    "nzb"
  ],
  "application/x-perl": [
    "pl",
    "pm"
  ],
  "application/x-pilot": [],
  "application/x-pkcs12": [
    "p12",
    "pfx"
  ],
  "application/x-pkcs7-certificates": [
    "p7b",
    "spc"
  ],
  "application/x-pkcs7-certreqresp": [
    "p7r"
  ],
  "application/x-rar-compressed": [
    "rar"
  ],
  "application/x-redhat-package-manager": [
    "rpm"
  ],
  "application/x-research-info-systems": [
    "ris"
  ],
  "application/x-sea": [
    "sea"
  ],
  "application/x-sh": [
    "sh"
  ],
  "application/x-shar": [
    "shar"
  ],
  "application/x-shockwave-flash": [
    "swf"
  ],
  "application/x-silverlight-app": [
    "xap"
  ],
  "application/x-sql": [
    "sql"
  ],
  "application/x-stuffit": [
    "sit"
  ],
  "application/x-stuffitx": [
    "sitx"
  ],
  "application/x-subrip": [
    "srt"
  ],
  "application/x-sv4cpio": [
    "sv4cpio"
  ],
  "application/x-sv4crc": [
    "sv4crc"
  ],
  "application/x-t3vm-image": [
    "t3"
  ],
  "application/x-tads": [
    "gam"
  ],
  "application/x-tar": [
    "tar"
  ],
  "application/x-tcl": [
    "tcl",
    "tk"
  ],
  "application/x-tex": [
    "tex"
  ],
  "application/x-tex-tfm": [
    "tfm"
  ],
  "application/x-texinfo": [
    "texinfo",
    "texi"
  ],
  "application/x-tgif": [
    "obj"
  ],
  "application/x-ustar": [
    "ustar"
  ],
  "application/x-virtualbox-hdd": [
    "hdd"
  ],
  "application/x-virtualbox-ova": [
    "ova"
  ],
  "application/x-virtualbox-ovf": [
    "ovf"
  ],
  "application/x-virtualbox-vbox": [
    "vbox"
  ],
  "application/x-virtualbox-vbox-extpack": [
    "vbox-extpack"
  ],
  "application/x-virtualbox-vdi": [
    "vdi"
  ],
  "application/x-virtualbox-vhd": [
    "vhd"
  ],
  "application/x-virtualbox-vmdk": [
    "vmdk"
  ],
  "application/x-wais-source": [
    "src"
  ],
  "application/x-web-app-manifest+json": [
    "webapp"
  ],
  "application/x-x509-ca-cert": [
    "der",
    "crt",
    "pem"
  ],
  "application/x-xfig": [
    "fig"
  ],
  "application/x-xliff+xml": [
    "xlf"
  ],
  "application/x-xpinstall": [
    "xpi"
  ],
  "application/x-xz": [
    "xz"
  ],
  "application/x-zmachine": [
    "z1",
    "z2",
    "z3",
    "z4",
    "z5",
    "z6",
    "z7",
    "z8"
  ],
  "application/xaml+xml": [
    "xaml"
  ],
  "application/xcap-diff+xml": [
    "xdf"
  ],
  "application/xenc+xml": [
    "xenc"
  ],
  "application/xhtml+xml": [
    "xhtml",
    "xht"
  ],
  "application/xml": [
    "xml",
    "xsl",
    "xsd",
    "rng"
  ],
  "application/xml-dtd": [
    "dtd"
  ],
  "application/xop+xml": [
    "xop"
  ],
  "application/xproc+xml": [
    "xpl"
  ],
  "application/xslt+xml": [
    "xslt"
  ],
  "application/xspf+xml": [
    "xspf"
  ],
  "application/xv+xml": [
    "mxml",
    "xhvml",
    "xvml",
    "xvm"
  ],
  "application/yang": [
    "yang"
  ],
  "application/yin+xml": [
    "yin"
  ],
  "application/zip": [
    "zip"
  ],
  "audio/3gpp": [],
  "audio/adpcm": [
    "adp"
  ],
  "audio/basic": [
    "au",
    "snd"
  ],
  "audio/midi": [
    "mid",
    "midi",
    "kar",
    "rmi"
  ],
  "audio/mp3": [],
  "audio/mp4": [
    "m4a",
    "mp4a"
  ],
  "audio/mpeg": [
    "mpga",
    "mp2",
    "mp2a",
    "mp3",
    "m2a",
    "m3a"
  ],
  "audio/ogg": [
    "oga",
    "ogg",
    "spx"
  ],
  "audio/s3m": [
    "s3m"
  ],
  "audio/silk": [
    "sil"
  ],
  "audio/vnd.dece.audio": [
    "uva",
    "uvva"
  ],
  "audio/vnd.digital-winds": [
    "eol"
  ],
  "audio/vnd.dra": [
    "dra"
  ],
  "audio/vnd.dts": [
    "dts"
  ],
  "audio/vnd.dts.hd": [
    "dtshd"
  ],
  "audio/vnd.lucent.voice": [
    "lvp"
  ],
  "audio/vnd.ms-playready.media.pya": [
    "pya"
  ],
  "audio/vnd.nuera.ecelp4800": [
    "ecelp4800"
  ],
  "audio/vnd.nuera.ecelp7470": [
    "ecelp7470"
  ],
  "audio/vnd.nuera.ecelp9600": [
    "ecelp9600"
  ],
  "audio/vnd.rip": [
    "rip"
  ],
  "audio/wav": [
    "wav"
  ],
  "audio/wave": [],
  "audio/webm": [
    "weba"
  ],
  "audio/x-aac": [
    "aac"
  ],
  "audio/x-aiff": [
    "aif",
    "aiff",
    "aifc"
  ],
  "audio/x-caf": [
    "caf"
  ],
  "audio/x-flac": [
    "flac"
  ],
  "audio/x-m4a": [],
  "audio/x-matroska": [
    "mka"
  ],
  "audio/x-mpegurl": [
    "m3u"
  ],
  "audio/x-ms-wax": [
    "wax"
  ],
  "audio/x-ms-wma": [
    "wma"
  ],
  "audio/x-pn-realaudio": [
    "ram",
    "ra"
  ],
  "audio/x-pn-realaudio-plugin": [
    "rmp"
  ],
  "audio/x-realaudio": [],
  "audio/x-wav": [],
  "audio/xm": [
    "xm"
  ],
  "chemical/x-cdx": [
    "cdx"
  ],
  "chemical/x-cif": [
    "cif"
  ],
  "chemical/x-cmdf": [
    "cmdf"
  ],
  "chemical/x-cml": [
    "cml"
  ],
  "chemical/x-csml": [
    "csml"
  ],
  "chemical/x-xyz": [
    "xyz"
  ],
  "font/collection": [
    "ttc"
  ],
  "font/otf": [
    "otf"
  ],
  "font/ttf": [
    "ttf"
  ],
  "font/woff": [
    "woff"
  ],
  "font/woff2": [
    "woff2"
  ],
  "image/apng": [
    "apng"
  ],
  "image/bmp": [
    "bmp"
  ],
  "image/cgm": [
    "cgm"
  ],
  "image/g3fax": [
    "g3"
  ],
  "image/gif": [
    "gif"
  ],
  "image/ief": [
    "ief"
  ],
  "image/jp2": [
    "jp2",
    "jpg2"
  ],
  "image/jpeg": [
    "jpeg",
    "jpg",
    "jpe"
  ],
  "image/jpm": [
    "jpm"
  ],
  "image/jpx": [
    "jpx",
    "jpf"
  ],
  "image/ktx": [
    "ktx"
  ],
  "image/png": [
    "png"
  ],
  "image/prs.btif": [
    "btif"
  ],
  "image/sgi": [
    "sgi"
  ],
  "image/svg+xml": [
    "svg",
    "svgz"
  ],
  "image/tiff": [
    "tiff",
    "tif"
  ],
  "image/vnd.adobe.photoshop": [
    "psd"
  ],
  "image/vnd.dece.graphic": [
    "uvi",
    "uvvi",
    "uvg",
    "uvvg"
  ],
  "image/vnd.djvu": [
    "djvu",
    "djv"
  ],
  "image/vnd.dvb.subtitle": [],
  "image/vnd.dwg": [
    "dwg"
  ],
  "image/vnd.dxf": [
    "dxf"
  ],
  "image/vnd.fastbidsheet": [
    "fbs"
  ],
  "image/vnd.fpx": [
    "fpx"
  ],
  "image/vnd.fst": [
    "fst"
  ],
  "image/vnd.fujixerox.edmics-mmr": [
    "mmr"
  ],
  "image/vnd.fujixerox.edmics-rlc": [
    "rlc"
  ],
  "image/vnd.ms-modi": [
    "mdi"
  ],
  "image/vnd.ms-photo": [
    "wdp"
  ],
  "image/vnd.net-fpx": [
    "npx"
  ],
  "image/vnd.wap.wbmp": [
    "wbmp"
  ],
  "image/vnd.xiff": [
    "xif"
  ],
  "image/webp": [
    "webp"
  ],
  "image/x-3ds": [
    "3ds"
  ],
  "image/x-cmu-raster": [
    "ras"
  ],
  "image/x-cmx": [
    "cmx"
  ],
  "image/x-freehand": [
    "fh",
    "fhc",
    "fh4",
    "fh5",
    "fh7"
  ],
  "image/x-icon": [
    "ico"
  ],
  "image/x-jng": [
    "jng"
  ],
  "image/x-mrsid-image": [
    "sid"
  ],
  "image/x-ms-bmp": [],
  "image/x-pcx": [
    "pcx"
  ],
  "image/x-pict": [
    "pic",
    "pct"
  ],
  "image/x-portable-anymap": [
    "pnm"
  ],
  "image/x-portable-bitmap": [
    "pbm"
  ],
  "image/x-portable-graymap": [
    "pgm"
  ],
  "image/x-portable-pixmap": [
    "ppm"
  ],
  "image/x-rgb": [
    "rgb"
  ],
  "image/x-tga": [
    "tga"
  ],
  "image/x-xbitmap": [
    "xbm"
  ],
  "image/x-xpixmap": [
    "xpm"
  ],
  "image/x-xwindowdump": [
    "xwd"
  ],
  "message/rfc822": [
    "eml",
    "mime"
  ],
  "model/gltf+json": [
    "gltf"
  ],
  "model/gltf-binary": [
    "glb"
  ],
  "model/iges": [
    "igs",
    "iges"
  ],
  "model/mesh": [
    "msh",
    "mesh",
    "silo"
  ],
  "model/vnd.collada+xml": [
    "dae"
  ],
  "model/vnd.dwf": [
    "dwf"
  ],
  "model/vnd.gdl": [
    "gdl"
  ],
  "model/vnd.gtw": [
    "gtw"
  ],
  "model/vnd.mts": [
    "mts"
  ],
  "model/vnd.vtu": [
    "vtu"
  ],
  "model/vrml": [
    "wrl",
    "vrml"
  ],
  "model/x3d+binary": [
    "x3db",
    "x3dbz"
  ],
  "model/x3d+vrml": [
    "x3dv",
    "x3dvz"
  ],
  "model/x3d+xml": [
    "x3d",
    "x3dz"
  ],
  "text/cache-manifest": [
    "appcache",
    "manifest"
  ],
  "text/calendar": [
    "ics",
    "ifb"
  ],
  "text/coffeescript": [
    "coffee",
    "litcoffee"
  ],
  "text/css": [
    "css"
  ],
  "text/csv": [
    "csv"
  ],
  "text/hjson": [
    "hjson"
  ],
  "text/html": [
    "html",
    "htm",
    "shtml"
  ],
  "text/jade": [
    "jade"
  ],
  "text/jsx": [
    "jsx"
  ],
  "text/less": [
    "less"
  ],
  "text/markdown": [
    "markdown",
    "md"
  ],
  "text/mathml": [
    "mml"
  ],
  "text/n3": [
    "n3"
  ],
  "text/plain": [
    "txt",
    "text",
    "conf",
    "def",
    "list",
    "log",
    "in",
    "ini"
  ],
  "text/prs.lines.tag": [
    "dsc"
  ],
  "text/richtext": [
    "rtx"
  ],
  "text/rtf": [],
  "text/sgml": [
    "sgml",
    "sgm"
  ],
  "text/slim": [
    "slim",
    "slm"
  ],
  "text/stylus": [
    "stylus",
    "styl"
  ],
  "text/tab-separated-values": [
    "tsv"
  ],
  "text/troff": [
    "t",
    "tr",
    "roff",
    "man",
    "me",
    "ms"
  ],
  "text/turtle": [
    "ttl"
  ],
  "text/uri-list": [
    "uri",
    "uris",
    "urls"
  ],
  "text/vcard": [
    "vcard"
  ],
  "text/vnd.curl": [
    "curl"
  ],
  "text/vnd.curl.dcurl": [
    "dcurl"
  ],
  "text/vnd.curl.mcurl": [
    "mcurl"
  ],
  "text/vnd.curl.scurl": [
    "scurl"
  ],
  "text/vnd.dvb.subtitle": [
    "sub"
  ],
  "text/vnd.fly": [
    "fly"
  ],
  "text/vnd.fmi.flexstor": [
    "flx"
  ],
  "text/vnd.graphviz": [
    "gv"
  ],
  "text/vnd.in3d.3dml": [
    "3dml"
  ],
  "text/vnd.in3d.spot": [
    "spot"
  ],
  "text/vnd.sun.j2me.app-descriptor": [
    "jad"
  ],
  "text/vnd.wap.wml": [
    "wml"
  ],
  "text/vnd.wap.wmlscript": [
    "wmls"
  ],
  "text/vtt": [
    "vtt"
  ],
  "text/x-asm": [
    "s",
    "asm"
  ],
  "text/x-c": [
    "c",
    "cc",
    "cxx",
    "cpp",
    "h",
    "hh",
    "dic"
  ],
  "text/x-component": [
    "htc"
  ],
  "text/x-fortran": [
    "f",
    "for",
    "f77",
    "f90"
  ],
  "text/x-handlebars-template": [
    "hbs"
  ],
  "text/x-java-source": [
    "java"
  ],
  "text/x-lua": [
    "lua"
  ],
  "text/x-markdown": [
    "mkd"
  ],
  "text/x-nfo": [
    "nfo"
  ],
  "text/x-opml": [
    "opml"
  ],
  "text/x-org": [],
  "text/x-pascal": [
    "p",
    "pas"
  ],
  "text/x-processing": [
    "pde"
  ],
  "text/x-sass": [
    "sass"
  ],
  "text/x-scss": [
    "scss"
  ],
  "text/x-setext": [
    "etx"
  ],
  "text/x-sfv": [
    "sfv"
  ],
  "text/x-suse-ymp": [
    "ymp"
  ],
  "text/x-uuencode": [
    "uu"
  ],
  "text/x-vcalendar": [
    "vcs"
  ],
  "text/x-vcard": [
    "vcf"
  ],
  "text/xml": [],
  "text/yaml": [
    "yaml",
    "yml"
  ],
  "video/3gpp": [
    "3gp",
    "3gpp"
  ],
  "video/3gpp2": [
    "3g2"
  ],
  "video/h261": [
    "h261"
  ],
  "video/h263": [
    "h263"
  ],
  "video/h264": [
    "h264"
  ],
  "video/jpeg": [
    "jpgv"
  ],
  "video/jpm": [
    "jpgm"
  ],
  "video/mj2": [
    "mj2",
    "mjp2"
  ],
  "video/mp2t": [
    "ts"
  ],
  "video/mp4": [
    "mp4",
    "mp4v",
    "mpg4"
  ],
  "video/mpeg": [
    "mpeg",
    "mpg",
    "mpe",
    "m1v",
    "m2v"
  ],
  "video/ogg": [
    "ogv"
  ],
  "video/quicktime": [
    "qt",
    "mov"
  ],
  "video/vnd.dece.hd": [
    "uvh",
    "uvvh"
  ],
  "video/vnd.dece.mobile": [
    "uvm",
    "uvvm"
  ],
  "video/vnd.dece.pd": [
    "uvp",
    "uvvp"
  ],
  "video/vnd.dece.sd": [
    "uvs",
    "uvvs"
  ],
  "video/vnd.dece.video": [
    "uvv",
    "uvvv"
  ],
  "video/vnd.dvb.file": [
    "dvb"
  ],
  "video/vnd.fvt": [
    "fvt"
  ],
  "video/vnd.mpegurl": [
    "mxu",
    "m4u"
  ],
  "video/vnd.ms-playready.media.pyv": [
    "pyv"
  ],
  "video/vnd.uvvu.mp4": [
    "uvu",
    "uvvu"
  ],
  "video/vnd.vivo": [
    "viv"
  ],
  "video/webm": [
    "webm"
  ],
  "video/x-f4v": [
    "f4v"
  ],
  "video/x-fli": [
    "fli"
  ],
  "video/x-flv": [
    "flv"
  ],
  "video/x-m4v": [
    "m4v"
  ],
  "video/x-matroska": [
    "mkv",
    "mk3d",
    "mks"
  ],
  "video/x-mng": [
    "mng"
  ],
  "video/x-ms-asf": [
    "asf",
    "asx"
  ],
  "video/x-ms-vob": [
    "vob"
  ],
  "video/x-ms-wm": [
    "wm"
  ],
  "video/x-ms-wmv": [
    "wmv"
  ],
  "video/x-ms-wmx": [
    "wmx"
  ],
  "video/x-ms-wvx": [
    "wvx"
  ],
  "video/x-msvideo": [
    "avi"
  ],
  "video/x-sgi-movie": [
    "movie"
  ],
  "video/x-smv": [
    "smv"
  ],
  "x-conference/x-cooltalk": [
    "ice"
  ]
};
var fs$2 = require$$3$1;
function Mime() {
  this.types = /* @__PURE__ */ Object.create(null);
  this.extensions = /* @__PURE__ */ Object.create(null);
}
Mime.prototype.define = function(map2) {
  for (var type3 in map2) {
    var exts = map2[type3];
    for (var i = 0; i < exts.length; i++) {
      if (process.env.DEBUG_MIME && this.types[exts[i]]) {
        console.warn((this._loading || "define()").replace(/.*\//, ""), 'changes "' + exts[i] + '" extension type from ' + this.types[exts[i]] + " to " + type3);
      }
      this.types[exts[i]] = type3;
    }
    if (!this.extensions[type3]) {
      this.extensions[type3] = exts[0];
    }
  }
};
Mime.prototype.load = function(file) {
  this._loading = file;
  var map2 = {}, content = fs$2.readFileSync(file, "ascii"), lines = content.split(/[\r\n]+/);
  lines.forEach(function(line) {
    var fields = line.replace(/\s*#.*|^\s*|\s*$/g, "").split(/\s+/);
    map2[fields.shift()] = fields;
  });
  this.define(map2);
  this._loading = null;
};
Mime.prototype.lookup = function(path22, fallback) {
  var ext = path22.replace(/^.*[\.\/\\]/, "").toLowerCase();
  return this.types[ext] || fallback || this.default_type;
};
Mime.prototype.extension = function(mimeType) {
  var type3 = mimeType.match(/^\s*([^;\s]*)(?:;|\s|$)/)[1].toLowerCase();
  return this.extensions[type3];
};
var mime$4 = new Mime();
mime$4.define(require$$2);
mime$4.default_type = mime$4.lookup("bin");
mime$4.Mime = Mime;
mime$4.charsets = {
  lookup: function(mimeType, fallback) {
    return /^text\/|^application\/(javascript|json)/.test(mimeType) ? "UTF-8" : fallback;
  }
};
var mime_1 = mime$4;
var s = 1e3;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w$1 = d * 7;
var y$1 = d * 365.25;
var ms$2 = function(val, options) {
  options = options || {};
  var type3 = typeof val;
  if (type3 === "string" && val.length > 0) {
    return parse$4(val);
  } else if (type3 === "number" && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
  );
};
function parse$4(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match2 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match2) {
    return;
  }
  var n = parseFloat(match2[1]);
  var type3 = (match2[2] || "ms").toLowerCase();
  switch (type3) {
    case "years":
    case "year":
    case "yrs":
    case "yr":
    case "y":
      return n * y$1;
    case "weeks":
    case "week":
    case "w":
      return n * w$1;
    case "days":
    case "day":
    case "d":
      return n * d;
    case "hours":
    case "hour":
    case "hrs":
    case "hr":
    case "h":
      return n * h;
    case "minutes":
    case "minute":
    case "mins":
    case "min":
    case "m":
      return n * m;
    case "seconds":
    case "second":
    case "secs":
    case "sec":
    case "s":
      return n * s;
    case "milliseconds":
    case "millisecond":
    case "msecs":
    case "msec":
    case "ms":
      return n;
    default:
      return void 0;
  }
}
function fmtShort(ms2) {
  var msAbs = Math.abs(ms2);
  if (msAbs >= d) {
    return Math.round(ms2 / d) + "d";
  }
  if (msAbs >= h) {
    return Math.round(ms2 / h) + "h";
  }
  if (msAbs >= m) {
    return Math.round(ms2 / m) + "m";
  }
  if (msAbs >= s) {
    return Math.round(ms2 / s) + "s";
  }
  return ms2 + "ms";
}
function fmtLong(ms2) {
  var msAbs = Math.abs(ms2);
  if (msAbs >= d) {
    return plural(ms2, msAbs, d, "day");
  }
  if (msAbs >= h) {
    return plural(ms2, msAbs, h, "hour");
  }
  if (msAbs >= m) {
    return plural(ms2, msAbs, m, "minute");
  }
  if (msAbs >= s) {
    return plural(ms2, msAbs, s, "second");
  }
  return ms2 + " ms";
}
function plural(ms2, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
}
/*!
 * range-parser
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var rangeParser_1 = rangeParser;
function rangeParser(size, str, options) {
  if (typeof str !== "string") {
    throw new TypeError("argument str must be a string");
  }
  var index2 = str.indexOf("=");
  if (index2 === -1) {
    return -2;
  }
  var arr = str.slice(index2 + 1).split(",");
  var ranges = [];
  ranges.type = str.slice(0, index2);
  for (var i = 0; i < arr.length; i++) {
    var range3 = arr[i].split("-");
    var start = parseInt(range3[0], 10);
    var end = parseInt(range3[1], 10);
    if (isNaN(start)) {
      start = size - end;
      end = size - 1;
    } else if (isNaN(end)) {
      end = size - 1;
    }
    if (end > size - 1) {
      end = size - 1;
    }
    if (isNaN(start) || isNaN(end) || start > end || start < 0) {
      continue;
    }
    ranges.push({
      start,
      end
    });
  }
  if (ranges.length < 1) {
    return -1;
  }
  return options && options.combine ? combineRanges(ranges) : ranges;
}
function combineRanges(ranges) {
  var ordered = ranges.map(mapWithIndex).sort(sortByRangeStart);
  for (var j2 = 0, i = 1; i < ordered.length; i++) {
    var range3 = ordered[i];
    var current = ordered[j2];
    if (range3.start > current.end + 1) {
      ordered[++j2] = range3;
    } else if (range3.end > current.end) {
      current.end = range3.end;
      current.index = Math.min(current.index, range3.index);
    }
  }
  ordered.length = j2 + 1;
  var combined = ordered.sort(sortByRangeIndex).map(mapWithoutIndex);
  combined.type = ranges.type;
  return combined;
}
function mapWithIndex(range3, index2) {
  return {
    start: range3.start,
    end: range3.end,
    index: index2
  };
}
function mapWithoutIndex(range3) {
  return {
    start: range3.start,
    end: range3.end
  };
}
function sortByRangeIndex(a, b2) {
  return a.index - b2.index;
}
function sortByRangeStart(a, b2) {
  return a.start - b2.start;
}
/*!
 * send
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var createError$1 = httpErrorsExports;
var debug$2 = srcExports("send");
var deprecate$2 = depd_1("send");
var destroy$1 = destroy_1;
var encodeUrl$1 = encodeurl;
var escapeHtml$1 = escapeHtml_1;
var etag = etag_1;
var fresh$1 = fresh_1;
var fs$1 = require$$3$1;
var mime$3 = mime_1;
var ms$1 = ms$2;
var onFinished$1 = onFinishedExports;
var parseRange$1 = rangeParser_1;
var path$2 = path$4;
var statuses$1 = statuses$3;
var Stream$3 = stream;
var util$3 = require$$1$1;
var extname$1 = path$2.extname;
var join = path$2.join;
var normalize = path$2.normalize;
var resolve$1 = path$2.resolve;
var sep = path$2.sep;
var BYTES_RANGE_REGEXP = /^ *bytes=/;
var MAX_MAXAGE = 60 * 60 * 24 * 365 * 1e3;
var UP_PATH_REGEXP = /(?:^|[\\/])\.\.(?:[\\/]|$)/;
send$2.exports = send$1;
send$2.exports.mime = mime$3;
function send$1(req2, path3, options) {
  return new SendStream(req2, path3, options);
}
function SendStream(req2, path3, options) {
  Stream$3.call(this);
  var opts = options || {};
  this.options = opts;
  this.path = path3;
  this.req = req2;
  this._acceptRanges = opts.acceptRanges !== void 0 ? Boolean(opts.acceptRanges) : true;
  this._cacheControl = opts.cacheControl !== void 0 ? Boolean(opts.cacheControl) : true;
  this._etag = opts.etag !== void 0 ? Boolean(opts.etag) : true;
  this._dotfiles = opts.dotfiles !== void 0 ? opts.dotfiles : "ignore";
  if (this._dotfiles !== "ignore" && this._dotfiles !== "allow" && this._dotfiles !== "deny") {
    throw new TypeError('dotfiles option must be "allow", "deny", or "ignore"');
  }
  this._hidden = Boolean(opts.hidden);
  if (opts.hidden !== void 0) {
    deprecate$2("hidden: use dotfiles: '" + (this._hidden ? "allow" : "ignore") + "' instead");
  }
  if (opts.dotfiles === void 0) {
    this._dotfiles = void 0;
  }
  this._extensions = opts.extensions !== void 0 ? normalizeList(opts.extensions, "extensions option") : [];
  this._immutable = opts.immutable !== void 0 ? Boolean(opts.immutable) : false;
  this._index = opts.index !== void 0 ? normalizeList(opts.index, "index option") : ["index.html"];
  this._lastModified = opts.lastModified !== void 0 ? Boolean(opts.lastModified) : true;
  this._maxage = opts.maxAge || opts.maxage;
  this._maxage = typeof this._maxage === "string" ? ms$1(this._maxage) : Number(this._maxage);
  this._maxage = !isNaN(this._maxage) ? Math.min(Math.max(0, this._maxage), MAX_MAXAGE) : 0;
  this._root = opts.root ? resolve$1(opts.root) : null;
  if (!this._root && opts.from) {
    this.from(opts.from);
  }
}
util$3.inherits(SendStream, Stream$3);
SendStream.prototype.etag = deprecate$2.function(function etag2(val) {
  this._etag = Boolean(val);
  debug$2("etag %s", this._etag);
  return this;
}, "send.etag: pass etag as option");
SendStream.prototype.hidden = deprecate$2.function(function hidden(val) {
  this._hidden = Boolean(val);
  this._dotfiles = void 0;
  debug$2("hidden %s", this._hidden);
  return this;
}, "send.hidden: use dotfiles option");
SendStream.prototype.index = deprecate$2.function(function index(paths) {
  var index2 = !paths ? [] : normalizeList(paths, "paths argument");
  debug$2("index %o", paths);
  this._index = index2;
  return this;
}, "send.index: pass index as option");
SendStream.prototype.root = function root(path3) {
  this._root = resolve$1(String(path3));
  debug$2("root %s", this._root);
  return this;
};
SendStream.prototype.from = deprecate$2.function(
  SendStream.prototype.root,
  "send.from: pass root as option"
);
SendStream.prototype.root = deprecate$2.function(
  SendStream.prototype.root,
  "send.root: pass root as option"
);
SendStream.prototype.maxage = deprecate$2.function(function maxage(maxAge) {
  this._maxage = typeof maxAge === "string" ? ms$1(maxAge) : Number(maxAge);
  this._maxage = !isNaN(this._maxage) ? Math.min(Math.max(0, this._maxage), MAX_MAXAGE) : 0;
  debug$2("max-age %d", this._maxage);
  return this;
}, "send.maxage: pass maxAge as option");
SendStream.prototype.error = function error(status3, err) {
  if (hasListeners(this, "error")) {
    return this.emit("error", createHttpError(status3, err));
  }
  var res2 = this.res;
  var msg = statuses$1.message[status3] || String(status3);
  var doc = createHtmlDocument("Error", escapeHtml$1(msg));
  clearHeaders(res2);
  if (err && err.headers) {
    setHeaders(res2, err.headers);
  }
  res2.statusCode = status3;
  res2.setHeader("Content-Type", "text/html; charset=UTF-8");
  res2.setHeader("Content-Length", Buffer.byteLength(doc));
  res2.setHeader("Content-Security-Policy", "default-src 'none'");
  res2.setHeader("X-Content-Type-Options", "nosniff");
  res2.end(doc);
};
SendStream.prototype.hasTrailingSlash = function hasTrailingSlash() {
  return this.path[this.path.length - 1] === "/";
};
SendStream.prototype.isConditionalGET = function isConditionalGET() {
  return this.req.headers["if-match"] || this.req.headers["if-unmodified-since"] || this.req.headers["if-none-match"] || this.req.headers["if-modified-since"];
};
SendStream.prototype.isPreconditionFailure = function isPreconditionFailure() {
  var req2 = this.req;
  var res2 = this.res;
  var match2 = req2.headers["if-match"];
  if (match2) {
    var etag3 = res2.getHeader("ETag");
    return !etag3 || match2 !== "*" && parseTokenList(match2).every(function(match3) {
      return match3 !== etag3 && match3 !== "W/" + etag3 && "W/" + match3 !== etag3;
    });
  }
  var unmodifiedSince = parseHttpDate(req2.headers["if-unmodified-since"]);
  if (!isNaN(unmodifiedSince)) {
    var lastModified = parseHttpDate(res2.getHeader("Last-Modified"));
    return isNaN(lastModified) || lastModified > unmodifiedSince;
  }
  return false;
};
SendStream.prototype.removeContentHeaderFields = function removeContentHeaderFields() {
  var res2 = this.res;
  res2.removeHeader("Content-Encoding");
  res2.removeHeader("Content-Language");
  res2.removeHeader("Content-Length");
  res2.removeHeader("Content-Range");
  res2.removeHeader("Content-Type");
};
SendStream.prototype.notModified = function notModified() {
  var res2 = this.res;
  debug$2("not modified");
  this.removeContentHeaderFields();
  res2.statusCode = 304;
  res2.end();
};
SendStream.prototype.headersAlreadySent = function headersAlreadySent() {
  var err = new Error("Can't set headers after they are sent.");
  debug$2("headers already sent");
  this.error(500, err);
};
SendStream.prototype.isCachable = function isCachable() {
  var statusCode = this.res.statusCode;
  return statusCode >= 200 && statusCode < 300 || statusCode === 304;
};
SendStream.prototype.onStatError = function onStatError(error2) {
  switch (error2.code) {
    case "ENAMETOOLONG":
    case "ENOENT":
    case "ENOTDIR":
      this.error(404, error2);
      break;
    default:
      this.error(500, error2);
      break;
  }
};
SendStream.prototype.isFresh = function isFresh() {
  return fresh$1(this.req.headers, {
    etag: this.res.getHeader("ETag"),
    "last-modified": this.res.getHeader("Last-Modified")
  });
};
SendStream.prototype.isRangeFresh = function isRangeFresh() {
  var ifRange = this.req.headers["if-range"];
  if (!ifRange) {
    return true;
  }
  if (ifRange.indexOf('"') !== -1) {
    var etag3 = this.res.getHeader("ETag");
    return Boolean(etag3 && ifRange.indexOf(etag3) !== -1);
  }
  var lastModified = this.res.getHeader("Last-Modified");
  return parseHttpDate(lastModified) <= parseHttpDate(ifRange);
};
SendStream.prototype.redirect = function redirect(path3) {
  var res2 = this.res;
  if (hasListeners(this, "directory")) {
    this.emit("directory", res2, path3);
    return;
  }
  if (this.hasTrailingSlash()) {
    this.error(403);
    return;
  }
  var loc = encodeUrl$1(collapseLeadingSlashes(this.path + "/"));
  var doc = createHtmlDocument("Redirecting", 'Redirecting to <a href="' + escapeHtml$1(loc) + '">' + escapeHtml$1(loc) + "</a>");
  res2.statusCode = 301;
  res2.setHeader("Content-Type", "text/html; charset=UTF-8");
  res2.setHeader("Content-Length", Buffer.byteLength(doc));
  res2.setHeader("Content-Security-Policy", "default-src 'none'");
  res2.setHeader("X-Content-Type-Options", "nosniff");
  res2.setHeader("Location", loc);
  res2.end(doc);
};
SendStream.prototype.pipe = function pipe(res2) {
  var root3 = this._root;
  this.res = res2;
  var path3 = decode$1(this.path);
  if (path3 === -1) {
    this.error(400);
    return res2;
  }
  if (~path3.indexOf("\0")) {
    this.error(400);
    return res2;
  }
  var parts;
  if (root3 !== null) {
    if (path3) {
      path3 = normalize("." + sep + path3);
    }
    if (UP_PATH_REGEXP.test(path3)) {
      debug$2('malicious path "%s"', path3);
      this.error(403);
      return res2;
    }
    parts = path3.split(sep);
    path3 = normalize(join(root3, path3));
  } else {
    if (UP_PATH_REGEXP.test(path3)) {
      debug$2('malicious path "%s"', path3);
      this.error(403);
      return res2;
    }
    parts = normalize(path3).split(sep);
    path3 = resolve$1(path3);
  }
  if (containsDotFile(parts)) {
    var access = this._dotfiles;
    if (access === void 0) {
      access = parts[parts.length - 1][0] === "." ? this._hidden ? "allow" : "ignore" : "allow";
    }
    debug$2('%s dotfile "%s"', access, path3);
    switch (access) {
      case "allow":
        break;
      case "deny":
        this.error(403);
        return res2;
      case "ignore":
      default:
        this.error(404);
        return res2;
    }
  }
  if (this._index.length && this.hasTrailingSlash()) {
    this.sendIndex(path3);
    return res2;
  }
  this.sendFile(path3);
  return res2;
};
SendStream.prototype.send = function send(path3, stat) {
  var len = stat.size;
  var options = this.options;
  var opts = {};
  var res2 = this.res;
  var req2 = this.req;
  var ranges = req2.headers.range;
  var offset = options.start || 0;
  if (headersSent(res2)) {
    this.headersAlreadySent();
    return;
  }
  debug$2('pipe "%s"', path3);
  this.setHeader(path3, stat);
  this.type(path3);
  if (this.isConditionalGET()) {
    if (this.isPreconditionFailure()) {
      this.error(412);
      return;
    }
    if (this.isCachable() && this.isFresh()) {
      this.notModified();
      return;
    }
  }
  len = Math.max(0, len - offset);
  if (options.end !== void 0) {
    var bytes2 = options.end - offset + 1;
    if (len > bytes2)
      len = bytes2;
  }
  if (this._acceptRanges && BYTES_RANGE_REGEXP.test(ranges)) {
    ranges = parseRange$1(len, ranges, {
      combine: true
    });
    if (!this.isRangeFresh()) {
      debug$2("range stale");
      ranges = -2;
    }
    if (ranges === -1) {
      debug$2("range unsatisfiable");
      res2.setHeader("Content-Range", contentRange("bytes", len));
      return this.error(416, {
        headers: { "Content-Range": res2.getHeader("Content-Range") }
      });
    }
    if (ranges !== -2 && ranges.length === 1) {
      debug$2("range %j", ranges);
      res2.statusCode = 206;
      res2.setHeader("Content-Range", contentRange("bytes", len, ranges[0]));
      offset += ranges[0].start;
      len = ranges[0].end - ranges[0].start + 1;
    }
  }
  for (var prop in options) {
    opts[prop] = options[prop];
  }
  opts.start = offset;
  opts.end = Math.max(offset, offset + len - 1);
  res2.setHeader("Content-Length", len);
  if (req2.method === "HEAD") {
    res2.end();
    return;
  }
  this.stream(path3, opts);
};
SendStream.prototype.sendFile = function sendFile(path3) {
  var i = 0;
  var self2 = this;
  debug$2('stat "%s"', path3);
  fs$1.stat(path3, function onstat(err, stat) {
    if (err && err.code === "ENOENT" && !extname$1(path3) && path3[path3.length - 1] !== sep) {
      return next(err);
    }
    if (err)
      return self2.onStatError(err);
    if (stat.isDirectory())
      return self2.redirect(path3);
    self2.emit("file", path3, stat);
    self2.send(path3, stat);
  });
  function next(err) {
    if (self2._extensions.length <= i) {
      return err ? self2.onStatError(err) : self2.error(404);
    }
    var p2 = path3 + "." + self2._extensions[i++];
    debug$2('stat "%s"', p2);
    fs$1.stat(p2, function(err2, stat) {
      if (err2)
        return next(err2);
      if (stat.isDirectory())
        return next();
      self2.emit("file", p2, stat);
      self2.send(p2, stat);
    });
  }
};
SendStream.prototype.sendIndex = function sendIndex(path3) {
  var i = -1;
  var self2 = this;
  function next(err) {
    if (++i >= self2._index.length) {
      if (err)
        return self2.onStatError(err);
      return self2.error(404);
    }
    var p2 = join(path3, self2._index[i]);
    debug$2('stat "%s"', p2);
    fs$1.stat(p2, function(err2, stat) {
      if (err2)
        return next(err2);
      if (stat.isDirectory())
        return next();
      self2.emit("file", p2, stat);
      self2.send(p2, stat);
    });
  }
  next();
};
SendStream.prototype.stream = function stream2(path3, options) {
  var self2 = this;
  var res2 = this.res;
  var stream3 = fs$1.createReadStream(path3, options);
  this.emit("stream", stream3);
  stream3.pipe(res2);
  function cleanup() {
    destroy$1(stream3, true);
  }
  onFinished$1(res2, cleanup);
  stream3.on("error", function onerror(err) {
    cleanup();
    self2.onStatError(err);
  });
  stream3.on("end", function onend() {
    self2.emit("end");
  });
};
SendStream.prototype.type = function type2(path3) {
  var res2 = this.res;
  if (res2.getHeader("Content-Type"))
    return;
  var type3 = mime$3.lookup(path3);
  if (!type3) {
    debug$2("no content-type");
    return;
  }
  var charset3 = mime$3.charsets.lookup(type3);
  debug$2("content-type %s", type3);
  res2.setHeader("Content-Type", type3 + (charset3 ? "; charset=" + charset3 : ""));
};
SendStream.prototype.setHeader = function setHeader(path3, stat) {
  var res2 = this.res;
  this.emit("headers", res2, path3, stat);
  if (this._acceptRanges && !res2.getHeader("Accept-Ranges")) {
    debug$2("accept ranges");
    res2.setHeader("Accept-Ranges", "bytes");
  }
  if (this._cacheControl && !res2.getHeader("Cache-Control")) {
    var cacheControl = "public, max-age=" + Math.floor(this._maxage / 1e3);
    if (this._immutable) {
      cacheControl += ", immutable";
    }
    debug$2("cache-control %s", cacheControl);
    res2.setHeader("Cache-Control", cacheControl);
  }
  if (this._lastModified && !res2.getHeader("Last-Modified")) {
    var modified = stat.mtime.toUTCString();
    debug$2("modified %s", modified);
    res2.setHeader("Last-Modified", modified);
  }
  if (this._etag && !res2.getHeader("ETag")) {
    var val = etag(stat);
    debug$2("etag %s", val);
    res2.setHeader("ETag", val);
  }
};
function clearHeaders(res2) {
  var headers = getHeaderNames(res2);
  for (var i = 0; i < headers.length; i++) {
    res2.removeHeader(headers[i]);
  }
}
function collapseLeadingSlashes(str) {
  for (var i = 0; i < str.length; i++) {
    if (str[i] !== "/") {
      break;
    }
  }
  return i > 1 ? "/" + str.substr(i) : str;
}
function containsDotFile(parts) {
  for (var i = 0; i < parts.length; i++) {
    var part = parts[i];
    if (part.length > 1 && part[0] === ".") {
      return true;
    }
  }
  return false;
}
function contentRange(type3, size, range3) {
  return type3 + " " + (range3 ? range3.start + "-" + range3.end : "*") + "/" + size;
}
function createHtmlDocument(title, body) {
  return '<!DOCTYPE html>\n<html lang="en">\n<head>\n<meta charset="utf-8">\n<title>' + title + "</title>\n</head>\n<body>\n<pre>" + body + "</pre>\n</body>\n</html>\n";
}
function createHttpError(status3, err) {
  if (!err) {
    return createError$1(status3);
  }
  return err instanceof Error ? createError$1(status3, err, { expose: false }) : createError$1(status3, err);
}
function decode$1(path3) {
  try {
    return decodeURIComponent(path3);
  } catch (err) {
    return -1;
  }
}
function getHeaderNames(res2) {
  return typeof res2.getHeaderNames !== "function" ? Object.keys(res2._headers || {}) : res2.getHeaderNames();
}
function hasListeners(emitter, type3) {
  var count = typeof emitter.listenerCount !== "function" ? emitter.listeners(type3).length : emitter.listenerCount(type3);
  return count > 0;
}
function headersSent(res2) {
  return typeof res2.headersSent !== "boolean" ? Boolean(res2._header) : res2.headersSent;
}
function normalizeList(val, name) {
  var list = [].concat(val || []);
  for (var i = 0; i < list.length; i++) {
    if (typeof list[i] !== "string") {
      throw new TypeError(name + " must be array of strings or false");
    }
  }
  return list;
}
function parseHttpDate(date) {
  var timestamp = date && Date.parse(date);
  return typeof timestamp === "number" ? timestamp : NaN;
}
function parseTokenList(str) {
  var end = 0;
  var list = [];
  var start = 0;
  for (var i = 0, len = str.length; i < len; i++) {
    switch (str.charCodeAt(i)) {
      case 32:
        if (start === end) {
          start = end = i + 1;
        }
        break;
      case 44:
        if (start !== end) {
          list.push(str.substring(start, end));
        }
        start = end = i + 1;
        break;
      default:
        end = i + 1;
        break;
    }
  }
  if (start !== end) {
    list.push(str.substring(start, end));
  }
  return list;
}
function setHeaders(res2, headers) {
  var keys2 = Object.keys(headers);
  for (var i = 0; i < keys2.length; i++) {
    var key = keys2[i];
    res2.setHeader(key, headers[key]);
  }
}
var sendExports = send$2.exports;
var proxyAddr = { exports: {} };
/*!
 * forwarded
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
var forwarded_1 = forwarded$1;
function forwarded$1(req2) {
  if (!req2) {
    throw new TypeError("argument req is required");
  }
  var proxyAddrs = parse$3(req2.headers["x-forwarded-for"] || "");
  var socketAddr = getSocketAddr(req2);
  var addrs = [socketAddr].concat(proxyAddrs);
  return addrs;
}
function getSocketAddr(req2) {
  return req2.socket ? req2.socket.remoteAddress : req2.connection.remoteAddress;
}
function parse$3(header3) {
  var end = header3.length;
  var list = [];
  var start = header3.length;
  for (var i = header3.length - 1; i >= 0; i--) {
    switch (header3.charCodeAt(i)) {
      case 32:
        if (start === end) {
          start = end = i;
        }
        break;
      case 44:
        if (start !== end) {
          list.push(header3.substring(start, end));
        }
        start = end = i;
        break;
      default:
        start = i;
        break;
    }
  }
  if (start !== end) {
    list.push(header3.substring(start, end));
  }
  return list;
}
var ipaddr$1 = { exports: {} };
ipaddr$1.exports;
(function(module) {
  (function() {
    var expandIPv6, ipaddr2, ipv4Part, ipv4Regexes, ipv6Part, ipv6Regexes, matchCIDR, root3, zoneIndex;
    ipaddr2 = {};
    root3 = this;
    if (module !== null && module.exports) {
      module.exports = ipaddr2;
    } else {
      root3["ipaddr"] = ipaddr2;
    }
    matchCIDR = function(first2, second, partSize, cidrBits) {
      var part, shift;
      if (first2.length !== second.length) {
        throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
      }
      part = 0;
      while (cidrBits > 0) {
        shift = partSize - cidrBits;
        if (shift < 0) {
          shift = 0;
        }
        if (first2[part] >> shift !== second[part] >> shift) {
          return false;
        }
        cidrBits -= partSize;
        part += 1;
      }
      return true;
    };
    ipaddr2.subnetMatch = function(address, rangeList, defaultName) {
      var k2, len, rangeName, rangeSubnets, subnet;
      if (defaultName == null) {
        defaultName = "unicast";
      }
      for (rangeName in rangeList) {
        rangeSubnets = rangeList[rangeName];
        if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
          rangeSubnets = [rangeSubnets];
        }
        for (k2 = 0, len = rangeSubnets.length; k2 < len; k2++) {
          subnet = rangeSubnets[k2];
          if (address.kind() === subnet[0].kind()) {
            if (address.match.apply(address, subnet)) {
              return rangeName;
            }
          }
        }
      }
      return defaultName;
    };
    ipaddr2.IPv4 = function() {
      function IPv4(octets) {
        var k2, len, octet;
        if (octets.length !== 4) {
          throw new Error("ipaddr: ipv4 octet count should be 4");
        }
        for (k2 = 0, len = octets.length; k2 < len; k2++) {
          octet = octets[k2];
          if (!(0 <= octet && octet <= 255)) {
            throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
          }
        }
        this.octets = octets;
      }
      IPv4.prototype.kind = function() {
        return "ipv4";
      };
      IPv4.prototype.toString = function() {
        return this.octets.join(".");
      };
      IPv4.prototype.toNormalizedString = function() {
        return this.toString();
      };
      IPv4.prototype.toByteArray = function() {
        return this.octets.slice(0);
      };
      IPv4.prototype.match = function(other, cidrRange) {
        var ref2;
        if (cidrRange === void 0) {
          ref2 = other, other = ref2[0], cidrRange = ref2[1];
        }
        if (other.kind() !== "ipv4") {
          throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
        }
        return matchCIDR(this.octets, other.octets, 8, cidrRange);
      };
      IPv4.prototype.SpecialRanges = {
        unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
        broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
        multicast: [[new IPv4([224, 0, 0, 0]), 4]],
        linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
        loopback: [[new IPv4([127, 0, 0, 0]), 8]],
        carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],
        "private": [[new IPv4([10, 0, 0, 0]), 8], [new IPv4([172, 16, 0, 0]), 12], [new IPv4([192, 168, 0, 0]), 16]],
        reserved: [[new IPv4([192, 0, 0, 0]), 24], [new IPv4([192, 0, 2, 0]), 24], [new IPv4([192, 88, 99, 0]), 24], [new IPv4([198, 51, 100, 0]), 24], [new IPv4([203, 0, 113, 0]), 24], [new IPv4([240, 0, 0, 0]), 4]]
      };
      IPv4.prototype.range = function() {
        return ipaddr2.subnetMatch(this, this.SpecialRanges);
      };
      IPv4.prototype.toIPv4MappedAddress = function() {
        return ipaddr2.IPv6.parse("::ffff:" + this.toString());
      };
      IPv4.prototype.prefixLengthFromSubnetMask = function() {
        var cidr, i, k2, octet, stop, zeros, zerotable;
        zerotable = {
          0: 8,
          128: 7,
          192: 6,
          224: 5,
          240: 4,
          248: 3,
          252: 2,
          254: 1,
          255: 0
        };
        cidr = 0;
        stop = false;
        for (i = k2 = 3; k2 >= 0; i = k2 += -1) {
          octet = this.octets[i];
          if (octet in zerotable) {
            zeros = zerotable[octet];
            if (stop && zeros !== 0) {
              return null;
            }
            if (zeros !== 8) {
              stop = true;
            }
            cidr += zeros;
          } else {
            return null;
          }
        }
        return 32 - cidr;
      };
      return IPv4;
    }();
    ipv4Part = "(0?\\d+|0x[a-f0-9]+)";
    ipv4Regexes = {
      fourOctet: new RegExp("^" + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "$", "i"),
      longValue: new RegExp("^" + ipv4Part + "$", "i")
    };
    ipaddr2.IPv4.parser = function(string) {
      var match2, parseIntAuto, part, shift, value;
      parseIntAuto = function(string2) {
        if (string2[0] === "0" && string2[1] !== "x") {
          return parseInt(string2, 8);
        } else {
          return parseInt(string2);
        }
      };
      if (match2 = string.match(ipv4Regexes.fourOctet)) {
        return function() {
          var k2, len, ref2, results;
          ref2 = match2.slice(1, 6);
          results = [];
          for (k2 = 0, len = ref2.length; k2 < len; k2++) {
            part = ref2[k2];
            results.push(parseIntAuto(part));
          }
          return results;
        }();
      } else if (match2 = string.match(ipv4Regexes.longValue)) {
        value = parseIntAuto(match2[1]);
        if (value > 4294967295 || value < 0) {
          throw new Error("ipaddr: address outside defined range");
        }
        return function() {
          var k2, results;
          results = [];
          for (shift = k2 = 0; k2 <= 24; shift = k2 += 8) {
            results.push(value >> shift & 255);
          }
          return results;
        }().reverse();
      } else {
        return null;
      }
    };
    ipaddr2.IPv6 = function() {
      function IPv6(parts, zoneId) {
        var i, k2, l, len, part, ref2;
        if (parts.length === 16) {
          this.parts = [];
          for (i = k2 = 0; k2 <= 14; i = k2 += 2) {
            this.parts.push(parts[i] << 8 | parts[i + 1]);
          }
        } else if (parts.length === 8) {
          this.parts = parts;
        } else {
          throw new Error("ipaddr: ipv6 part count should be 8 or 16");
        }
        ref2 = this.parts;
        for (l = 0, len = ref2.length; l < len; l++) {
          part = ref2[l];
          if (!(0 <= part && part <= 65535)) {
            throw new Error("ipaddr: ipv6 part should fit in 16 bits");
          }
        }
        if (zoneId) {
          this.zoneId = zoneId;
        }
      }
      IPv6.prototype.kind = function() {
        return "ipv6";
      };
      IPv6.prototype.toString = function() {
        return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/, "::");
      };
      IPv6.prototype.toRFC5952String = function() {
        var bestMatchIndex, bestMatchLength, match2, regex, string;
        regex = /((^|:)(0(:|$)){2,})/g;
        string = this.toNormalizedString();
        bestMatchIndex = 0;
        bestMatchLength = -1;
        while (match2 = regex.exec(string)) {
          if (match2[0].length > bestMatchLength) {
            bestMatchIndex = match2.index;
            bestMatchLength = match2[0].length;
          }
        }
        if (bestMatchLength < 0) {
          return string;
        }
        return string.substring(0, bestMatchIndex) + "::" + string.substring(bestMatchIndex + bestMatchLength);
      };
      IPv6.prototype.toByteArray = function() {
        var bytes2, k2, len, part, ref2;
        bytes2 = [];
        ref2 = this.parts;
        for (k2 = 0, len = ref2.length; k2 < len; k2++) {
          part = ref2[k2];
          bytes2.push(part >> 8);
          bytes2.push(part & 255);
        }
        return bytes2;
      };
      IPv6.prototype.toNormalizedString = function() {
        var addr, part, suffix;
        addr = function() {
          var k2, len, ref2, results;
          ref2 = this.parts;
          results = [];
          for (k2 = 0, len = ref2.length; k2 < len; k2++) {
            part = ref2[k2];
            results.push(part.toString(16));
          }
          return results;
        }.call(this).join(":");
        suffix = "";
        if (this.zoneId) {
          suffix = "%" + this.zoneId;
        }
        return addr + suffix;
      };
      IPv6.prototype.toFixedLengthString = function() {
        var addr, part, suffix;
        addr = function() {
          var k2, len, ref2, results;
          ref2 = this.parts;
          results = [];
          for (k2 = 0, len = ref2.length; k2 < len; k2++) {
            part = ref2[k2];
            results.push(part.toString(16).padStart(4, "0"));
          }
          return results;
        }.call(this).join(":");
        suffix = "";
        if (this.zoneId) {
          suffix = "%" + this.zoneId;
        }
        return addr + suffix;
      };
      IPv6.prototype.match = function(other, cidrRange) {
        var ref2;
        if (cidrRange === void 0) {
          ref2 = other, other = ref2[0], cidrRange = ref2[1];
        }
        if (other.kind() !== "ipv6") {
          throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
        }
        return matchCIDR(this.parts, other.parts, 16, cidrRange);
      };
      IPv6.prototype.SpecialRanges = {
        unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
        linkLocal: [new IPv6([65152, 0, 0, 0, 0, 0, 0, 0]), 10],
        multicast: [new IPv6([65280, 0, 0, 0, 0, 0, 0, 0]), 8],
        loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
        uniqueLocal: [new IPv6([64512, 0, 0, 0, 0, 0, 0, 0]), 7],
        ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 65535, 0, 0]), 96],
        rfc6145: [new IPv6([0, 0, 0, 0, 65535, 0, 0, 0]), 96],
        rfc6052: [new IPv6([100, 65435, 0, 0, 0, 0, 0, 0]), 96],
        "6to4": [new IPv6([8194, 0, 0, 0, 0, 0, 0, 0]), 16],
        teredo: [new IPv6([8193, 0, 0, 0, 0, 0, 0, 0]), 32],
        reserved: [[new IPv6([8193, 3512, 0, 0, 0, 0, 0, 0]), 32]]
      };
      IPv6.prototype.range = function() {
        return ipaddr2.subnetMatch(this, this.SpecialRanges);
      };
      IPv6.prototype.isIPv4MappedAddress = function() {
        return this.range() === "ipv4Mapped";
      };
      IPv6.prototype.toIPv4Address = function() {
        var high, low, ref2;
        if (!this.isIPv4MappedAddress()) {
          throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
        }
        ref2 = this.parts.slice(-2), high = ref2[0], low = ref2[1];
        return new ipaddr2.IPv4([high >> 8, high & 255, low >> 8, low & 255]);
      };
      IPv6.prototype.prefixLengthFromSubnetMask = function() {
        var cidr, i, k2, part, stop, zeros, zerotable;
        zerotable = {
          0: 16,
          32768: 15,
          49152: 14,
          57344: 13,
          61440: 12,
          63488: 11,
          64512: 10,
          65024: 9,
          65280: 8,
          65408: 7,
          65472: 6,
          65504: 5,
          65520: 4,
          65528: 3,
          65532: 2,
          65534: 1,
          65535: 0
        };
        cidr = 0;
        stop = false;
        for (i = k2 = 7; k2 >= 0; i = k2 += -1) {
          part = this.parts[i];
          if (part in zerotable) {
            zeros = zerotable[part];
            if (stop && zeros !== 0) {
              return null;
            }
            if (zeros !== 16) {
              stop = true;
            }
            cidr += zeros;
          } else {
            return null;
          }
        }
        return 128 - cidr;
      };
      return IPv6;
    }();
    ipv6Part = "(?:[0-9a-f]+::?)+";
    zoneIndex = "%[0-9a-z]{1,}";
    ipv6Regexes = {
      zoneIndex: new RegExp(zoneIndex, "i"),
      "native": new RegExp("^(::)?(" + ipv6Part + ")?([0-9a-f]+)?(::)?(" + zoneIndex + ")?$", "i"),
      transitional: new RegExp("^((?:" + ipv6Part + ")|(?:::)(?:" + ipv6Part + ")?)" + (ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part) + ("(" + zoneIndex + ")?$"), "i")
    };
    expandIPv6 = function(string, parts) {
      var colonCount, lastColon, part, replacement, replacementCount, zoneId;
      if (string.indexOf("::") !== string.lastIndexOf("::")) {
        return null;
      }
      zoneId = (string.match(ipv6Regexes["zoneIndex"]) || [])[0];
      if (zoneId) {
        zoneId = zoneId.substring(1);
        string = string.replace(/%.+$/, "");
      }
      colonCount = 0;
      lastColon = -1;
      while ((lastColon = string.indexOf(":", lastColon + 1)) >= 0) {
        colonCount++;
      }
      if (string.substr(0, 2) === "::") {
        colonCount--;
      }
      if (string.substr(-2, 2) === "::") {
        colonCount--;
      }
      if (colonCount > parts) {
        return null;
      }
      replacementCount = parts - colonCount;
      replacement = ":";
      while (replacementCount--) {
        replacement += "0:";
      }
      string = string.replace("::", replacement);
      if (string[0] === ":") {
        string = string.slice(1);
      }
      if (string[string.length - 1] === ":") {
        string = string.slice(0, -1);
      }
      parts = function() {
        var k2, len, ref2, results;
        ref2 = string.split(":");
        results = [];
        for (k2 = 0, len = ref2.length; k2 < len; k2++) {
          part = ref2[k2];
          results.push(parseInt(part, 16));
        }
        return results;
      }();
      return {
        parts,
        zoneId
      };
    };
    ipaddr2.IPv6.parser = function(string) {
      var addr, k2, len, match2, octet, octets, zoneId;
      if (ipv6Regexes["native"].test(string)) {
        return expandIPv6(string, 8);
      } else if (match2 = string.match(ipv6Regexes["transitional"])) {
        zoneId = match2[6] || "";
        addr = expandIPv6(match2[1].slice(0, -1) + zoneId, 6);
        if (addr.parts) {
          octets = [parseInt(match2[2]), parseInt(match2[3]), parseInt(match2[4]), parseInt(match2[5])];
          for (k2 = 0, len = octets.length; k2 < len; k2++) {
            octet = octets[k2];
            if (!(0 <= octet && octet <= 255)) {
              return null;
            }
          }
          addr.parts.push(octets[0] << 8 | octets[1]);
          addr.parts.push(octets[2] << 8 | octets[3]);
          return {
            parts: addr.parts,
            zoneId: addr.zoneId
          };
        }
      }
      return null;
    };
    ipaddr2.IPv4.isIPv4 = ipaddr2.IPv6.isIPv6 = function(string) {
      return this.parser(string) !== null;
    };
    ipaddr2.IPv4.isValid = function(string) {
      try {
        new this(this.parser(string));
        return true;
      } catch (error1) {
        return false;
      }
    };
    ipaddr2.IPv4.isValidFourPartDecimal = function(string) {
      if (ipaddr2.IPv4.isValid(string) && string.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)) {
        return true;
      } else {
        return false;
      }
    };
    ipaddr2.IPv6.isValid = function(string) {
      var addr;
      if (typeof string === "string" && string.indexOf(":") === -1) {
        return false;
      }
      try {
        addr = this.parser(string);
        new this(addr.parts, addr.zoneId);
        return true;
      } catch (error1) {
        return false;
      }
    };
    ipaddr2.IPv4.parse = function(string) {
      var parts;
      parts = this.parser(string);
      if (parts === null) {
        throw new Error("ipaddr: string is not formatted like ip address");
      }
      return new this(parts);
    };
    ipaddr2.IPv6.parse = function(string) {
      var addr;
      addr = this.parser(string);
      if (addr.parts === null) {
        throw new Error("ipaddr: string is not formatted like ip address");
      }
      return new this(addr.parts, addr.zoneId);
    };
    ipaddr2.IPv4.parseCIDR = function(string) {
      var maskLength, match2, parsed;
      if (match2 = string.match(/^(.+)\/(\d+)$/)) {
        maskLength = parseInt(match2[2]);
        if (maskLength >= 0 && maskLength <= 32) {
          parsed = [this.parse(match2[1]), maskLength];
          Object.defineProperty(parsed, "toString", {
            value: function() {
              return this.join("/");
            }
          });
          return parsed;
        }
      }
      throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
    };
    ipaddr2.IPv4.subnetMaskFromPrefixLength = function(prefix) {
      var filledOctetCount, j2, octets;
      prefix = parseInt(prefix);
      if (prefix < 0 || prefix > 32) {
        throw new Error("ipaddr: invalid IPv4 prefix length");
      }
      octets = [0, 0, 0, 0];
      j2 = 0;
      filledOctetCount = Math.floor(prefix / 8);
      while (j2 < filledOctetCount) {
        octets[j2] = 255;
        j2++;
      }
      if (filledOctetCount < 4) {
        octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
      }
      return new this(octets);
    };
    ipaddr2.IPv4.broadcastAddressFromCIDR = function(string) {
      var cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
      try {
        cidr = this.parseCIDR(string);
        ipInterfaceOctets = cidr[0].toByteArray();
        subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
        octets = [];
        i = 0;
        while (i < 4) {
          octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
          i++;
        }
        return new this(octets);
      } catch (error1) {
        throw new Error("ipaddr: the address does not have IPv4 CIDR format");
      }
    };
    ipaddr2.IPv4.networkAddressFromCIDR = function(string) {
      var cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
      try {
        cidr = this.parseCIDR(string);
        ipInterfaceOctets = cidr[0].toByteArray();
        subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
        octets = [];
        i = 0;
        while (i < 4) {
          octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
          i++;
        }
        return new this(octets);
      } catch (error1) {
        throw new Error("ipaddr: the address does not have IPv4 CIDR format");
      }
    };
    ipaddr2.IPv6.parseCIDR = function(string) {
      var maskLength, match2, parsed;
      if (match2 = string.match(/^(.+)\/(\d+)$/)) {
        maskLength = parseInt(match2[2]);
        if (maskLength >= 0 && maskLength <= 128) {
          parsed = [this.parse(match2[1]), maskLength];
          Object.defineProperty(parsed, "toString", {
            value: function() {
              return this.join("/");
            }
          });
          return parsed;
        }
      }
      throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
    };
    ipaddr2.isValid = function(string) {
      return ipaddr2.IPv6.isValid(string) || ipaddr2.IPv4.isValid(string);
    };
    ipaddr2.parse = function(string) {
      if (ipaddr2.IPv6.isValid(string)) {
        return ipaddr2.IPv6.parse(string);
      } else if (ipaddr2.IPv4.isValid(string)) {
        return ipaddr2.IPv4.parse(string);
      } else {
        throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
      }
    };
    ipaddr2.parseCIDR = function(string) {
      try {
        return ipaddr2.IPv6.parseCIDR(string);
      } catch (error1) {
        try {
          return ipaddr2.IPv4.parseCIDR(string);
        } catch (error12) {
          throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
        }
      }
    };
    ipaddr2.fromByteArray = function(bytes2) {
      var length;
      length = bytes2.length;
      if (length === 4) {
        return new ipaddr2.IPv4(bytes2);
      } else if (length === 16) {
        return new ipaddr2.IPv6(bytes2);
      } else {
        throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
      }
    };
    ipaddr2.process = function(string) {
      var addr;
      addr = this.parse(string);
      if (addr.kind() === "ipv6" && addr.isIPv4MappedAddress()) {
        return addr.toIPv4Address();
      } else {
        return addr;
      }
    };
  }).call(commonjsGlobal);
})(ipaddr$1);
var ipaddrExports = ipaddr$1.exports;
/*!
 * proxy-addr
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
proxyAddr.exports = proxyaddr$1;
proxyAddr.exports.all = alladdrs;
proxyAddr.exports.compile = compile;
var forwarded = forwarded_1;
var ipaddr = ipaddrExports;
var DIGIT_REGEXP = /^[0-9]+$/;
var isip = ipaddr.isValid;
var parseip = ipaddr.parse;
var IP_RANGES = {
  linklocal: ["169.254.0.0/16", "fe80::/10"],
  loopback: ["127.0.0.1/8", "::1/128"],
  uniquelocal: ["10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16", "fc00::/7"]
};
function alladdrs(req2, trust) {
  var addrs = forwarded(req2);
  if (!trust) {
    return addrs;
  }
  if (typeof trust !== "function") {
    trust = compile(trust);
  }
  for (var i = 0; i < addrs.length - 1; i++) {
    if (trust(addrs[i], i))
      continue;
    addrs.length = i + 1;
  }
  return addrs;
}
function compile(val) {
  if (!val) {
    throw new TypeError("argument is required");
  }
  var trust;
  if (typeof val === "string") {
    trust = [val];
  } else if (Array.isArray(val)) {
    trust = val.slice();
  } else {
    throw new TypeError("unsupported trust argument");
  }
  for (var i = 0; i < trust.length; i++) {
    val = trust[i];
    if (!Object.prototype.hasOwnProperty.call(IP_RANGES, val)) {
      continue;
    }
    val = IP_RANGES[val];
    trust.splice.apply(trust, [i, 1].concat(val));
    i += val.length - 1;
  }
  return compileTrust(compileRangeSubnets(trust));
}
function compileRangeSubnets(arr) {
  var rangeSubnets = new Array(arr.length);
  for (var i = 0; i < arr.length; i++) {
    rangeSubnets[i] = parseipNotation(arr[i]);
  }
  return rangeSubnets;
}
function compileTrust(rangeSubnets) {
  var len = rangeSubnets.length;
  return len === 0 ? trustNone : len === 1 ? trustSingle(rangeSubnets[0]) : trustMulti(rangeSubnets);
}
function parseipNotation(note) {
  var pos = note.lastIndexOf("/");
  var str = pos !== -1 ? note.substring(0, pos) : note;
  if (!isip(str)) {
    throw new TypeError("invalid IP address: " + str);
  }
  var ip2 = parseip(str);
  if (pos === -1 && ip2.kind() === "ipv6" && ip2.isIPv4MappedAddress()) {
    ip2 = ip2.toIPv4Address();
  }
  var max = ip2.kind() === "ipv6" ? 128 : 32;
  var range3 = pos !== -1 ? note.substring(pos + 1, note.length) : null;
  if (range3 === null) {
    range3 = max;
  } else if (DIGIT_REGEXP.test(range3)) {
    range3 = parseInt(range3, 10);
  } else if (ip2.kind() === "ipv4" && isip(range3)) {
    range3 = parseNetmask(range3);
  } else {
    range3 = null;
  }
  if (range3 <= 0 || range3 > max) {
    throw new TypeError("invalid range on address: " + note);
  }
  return [ip2, range3];
}
function parseNetmask(netmask) {
  var ip2 = parseip(netmask);
  var kind = ip2.kind();
  return kind === "ipv4" ? ip2.prefixLengthFromSubnetMask() : null;
}
function proxyaddr$1(req2, trust) {
  if (!req2) {
    throw new TypeError("req argument is required");
  }
  if (!trust) {
    throw new TypeError("trust argument is required");
  }
  var addrs = alladdrs(req2, trust);
  var addr = addrs[addrs.length - 1];
  return addr;
}
function trustNone() {
  return false;
}
function trustMulti(subnets) {
  return function trust(addr) {
    if (!isip(addr))
      return false;
    var ip2 = parseip(addr);
    var ipconv;
    var kind = ip2.kind();
    for (var i = 0; i < subnets.length; i++) {
      var subnet = subnets[i];
      var subnetip = subnet[0];
      var subnetkind = subnetip.kind();
      var subnetrange = subnet[1];
      var trusted = ip2;
      if (kind !== subnetkind) {
        if (subnetkind === "ipv4" && !ip2.isIPv4MappedAddress()) {
          continue;
        }
        if (!ipconv) {
          ipconv = subnetkind === "ipv4" ? ip2.toIPv4Address() : ip2.toIPv4MappedAddress();
        }
        trusted = ipconv;
      }
      if (trusted.match(subnetip, subnetrange)) {
        return true;
      }
    }
    return false;
  };
}
function trustSingle(subnet) {
  var subnetip = subnet[0];
  var subnetkind = subnetip.kind();
  var subnetisipv4 = subnetkind === "ipv4";
  var subnetrange = subnet[1];
  return function trust(addr) {
    if (!isip(addr))
      return false;
    var ip2 = parseip(addr);
    var kind = ip2.kind();
    if (kind !== subnetkind) {
      if (subnetisipv4 && !ip2.isIPv4MappedAddress()) {
        return false;
      }
      ip2 = subnetisipv4 ? ip2.toIPv4Address() : ip2.toIPv4MappedAddress();
    }
    return ip2.match(subnetip, subnetrange);
  };
}
var proxyAddrExports = proxyAddr.exports;
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
(function(exports) {
  var Buffer2 = safeBufferExports.Buffer;
  var contentDisposition2 = contentDispositionExports;
  var contentType$1 = contentType;
  var deprecate2 = depd_1("express");
  var flatten2 = arrayFlatten_1;
  var mime2 = sendExports.mime;
  var etag3 = etag_1;
  var proxyaddr2 = proxyAddrExports;
  var qs = requireLib();
  var querystring = require$$8;
  exports.etag = createETagGenerator({ weak: false });
  exports.wetag = createETagGenerator({ weak: true });
  exports.isAbsolute = function(path3) {
    if ("/" === path3[0])
      return true;
    if (":" === path3[1] && ("\\" === path3[2] || "/" === path3[2]))
      return true;
    if ("\\\\" === path3.substring(0, 2))
      return true;
  };
  exports.flatten = deprecate2.function(
    flatten2,
    "utils.flatten: use array-flatten npm module instead"
  );
  exports.normalizeType = function(type3) {
    return ~type3.indexOf("/") ? acceptParams(type3) : { value: mime2.lookup(type3), params: {} };
  };
  exports.normalizeTypes = function(types) {
    var ret = [];
    for (var i = 0; i < types.length; ++i) {
      ret.push(exports.normalizeType(types[i]));
    }
    return ret;
  };
  exports.contentDisposition = deprecate2.function(
    contentDisposition2,
    "utils.contentDisposition: use content-disposition npm module instead"
  );
  function acceptParams(str) {
    var parts = str.split(/ *; */);
    var ret = { value: parts[0], quality: 1, params: {} };
    for (var i = 1; i < parts.length; ++i) {
      var pms = parts[i].split(/ *= */);
      if ("q" === pms[0]) {
        ret.quality = parseFloat(pms[1]);
      } else {
        ret.params[pms[0]] = pms[1];
      }
    }
    return ret;
  }
  exports.compileETag = function(val) {
    var fn;
    if (typeof val === "function") {
      return val;
    }
    switch (val) {
      case true:
      case "weak":
        fn = exports.wetag;
        break;
      case false:
        break;
      case "strong":
        fn = exports.etag;
        break;
      default:
        throw new TypeError("unknown value for etag function: " + val);
    }
    return fn;
  };
  exports.compileQueryParser = function compileQueryParser(val) {
    var fn;
    if (typeof val === "function") {
      return val;
    }
    switch (val) {
      case true:
      case "simple":
        fn = querystring.parse;
        break;
      case false:
        fn = newObject;
        break;
      case "extended":
        fn = parseExtendedQueryString;
        break;
      default:
        throw new TypeError("unknown value for query parser function: " + val);
    }
    return fn;
  };
  exports.compileTrust = function(val) {
    if (typeof val === "function")
      return val;
    if (val === true) {
      return function() {
        return true;
      };
    }
    if (typeof val === "number") {
      return function(a, i) {
        return i < val;
      };
    }
    if (typeof val === "string") {
      val = val.split(",").map(function(v2) {
        return v2.trim();
      });
    }
    return proxyaddr2.compile(val || []);
  };
  exports.setCharset = function setCharset2(type3, charset3) {
    if (!type3 || !charset3) {
      return type3;
    }
    var parsed = contentType$1.parse(type3);
    parsed.parameters.charset = charset3;
    return contentType$1.format(parsed);
  };
  function createETagGenerator(options) {
    return function generateETag(body, encoding3) {
      var buf = !Buffer2.isBuffer(body) ? Buffer2.from(body, encoding3) : body;
      return etag3(buf, options);
    };
  }
  function parseExtendedQueryString(str) {
    return qs.parse(str, {
      allowPrototypes: true
    });
  }
  function newObject() {
    return {};
  }
})(utils$2);
(function(module, exports) {
  /*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2013 Roman Shtylman
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var finalhandler2 = finalhandler_1;
  var Router = routerExports;
  var methods2 = methods$2;
  var middleware = init;
  var query2 = requireQuery();
  var debug2 = srcExports$1("express:application");
  var View2 = view;
  var http2 = require$$0$7;
  var compileETag = utils$2.compileETag;
  var compileQueryParser = utils$2.compileQueryParser;
  var compileTrust2 = utils$2.compileTrust;
  var deprecate2 = depd_1("express");
  var flatten2 = arrayFlatten_1;
  var merge2 = utilsMergeExports;
  var resolve3 = path$4.resolve;
  var setPrototypeOf2 = setprototypeof;
  var hasOwnProperty2 = Object.prototype.hasOwnProperty;
  var slice2 = Array.prototype.slice;
  var app = module.exports = {};
  var trustProxyDefaultSymbol = "@@symbol:trust_proxy_default";
  app.init = function init2() {
    this.cache = {};
    this.engines = {};
    this.settings = {};
    this.defaultConfiguration();
  };
  app.defaultConfiguration = function defaultConfiguration() {
    var env = process.env.NODE_ENV || "development";
    this.enable("x-powered-by");
    this.set("etag", "weak");
    this.set("env", env);
    this.set("query parser", "extended");
    this.set("subdomain offset", 2);
    this.set("trust proxy", false);
    Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
      configurable: true,
      value: true
    });
    debug2("booting in %s mode", env);
    this.on("mount", function onmount(parent2) {
      if (this.settings[trustProxyDefaultSymbol] === true && typeof parent2.settings["trust proxy fn"] === "function") {
        delete this.settings["trust proxy"];
        delete this.settings["trust proxy fn"];
      }
      setPrototypeOf2(this.request, parent2.request);
      setPrototypeOf2(this.response, parent2.response);
      setPrototypeOf2(this.engines, parent2.engines);
      setPrototypeOf2(this.settings, parent2.settings);
    });
    this.locals = /* @__PURE__ */ Object.create(null);
    this.mountpath = "/";
    this.locals.settings = this.settings;
    this.set("view", View2);
    this.set("views", resolve3("views"));
    this.set("jsonp callback name", "callback");
    if (env === "production") {
      this.enable("view cache");
    }
    Object.defineProperty(this, "router", {
      get: function() {
        throw new Error("'app.router' is deprecated!\nPlease see the 3.x to 4.x migration guide for details on how to update your app.");
      }
    });
  };
  app.lazyrouter = function lazyrouter() {
    if (!this._router) {
      this._router = new Router({
        caseSensitive: this.enabled("case sensitive routing"),
        strict: this.enabled("strict routing")
      });
      this._router.use(query2(this.get("query parser fn")));
      this._router.use(middleware.init(this));
    }
  };
  app.handle = function handle3(req2, res2, callback) {
    var router2 = this._router;
    var done = callback || finalhandler2(req2, res2, {
      env: this.get("env"),
      onerror: logerror.bind(this)
    });
    if (!router2) {
      debug2("no routes defined on app");
      done();
      return;
    }
    router2.handle(req2, res2, done);
  };
  app.use = function use2(fn) {
    var offset = 0;
    var path22 = "/";
    if (typeof fn !== "function") {
      var arg = fn;
      while (Array.isArray(arg) && arg.length !== 0) {
        arg = arg[0];
      }
      if (typeof arg !== "function") {
        offset = 1;
        path22 = fn;
      }
    }
    var fns = flatten2(slice2.call(arguments, offset));
    if (fns.length === 0) {
      throw new TypeError("app.use() requires a middleware function");
    }
    this.lazyrouter();
    var router2 = this._router;
    fns.forEach(function(fn2) {
      if (!fn2 || !fn2.handle || !fn2.set) {
        return router2.use(path22, fn2);
      }
      debug2(".use app under %s", path22);
      fn2.mountpath = path22;
      fn2.parent = this;
      router2.use(path22, function mounted_app(req2, res2, next) {
        var orig = req2.app;
        fn2.handle(req2, res2, function(err) {
          setPrototypeOf2(req2, orig.request);
          setPrototypeOf2(res2, orig.response);
          next(err);
        });
      });
      fn2.emit("mount", this);
    }, this);
    return this;
  };
  app.route = function route3(path22) {
    this.lazyrouter();
    return this._router.route(path22);
  };
  app.engine = function engine(ext, fn) {
    if (typeof fn !== "function") {
      throw new Error("callback function required");
    }
    var extension = ext[0] !== "." ? "." + ext : ext;
    this.engines[extension] = fn;
    return this;
  };
  app.param = function param3(name, fn) {
    this.lazyrouter();
    if (Array.isArray(name)) {
      for (var i = 0; i < name.length; i++) {
        this.param(name[i], fn);
      }
      return this;
    }
    this._router.param(name, fn);
    return this;
  };
  app.set = function set2(setting, val) {
    if (arguments.length === 1) {
      var settings = this.settings;
      while (settings && settings !== Object.prototype) {
        if (hasOwnProperty2.call(settings, setting)) {
          return settings[setting];
        }
        settings = Object.getPrototypeOf(settings);
      }
      return void 0;
    }
    debug2('set "%s" to %o', setting, val);
    this.settings[setting] = val;
    switch (setting) {
      case "etag":
        this.set("etag fn", compileETag(val));
        break;
      case "query parser":
        this.set("query parser fn", compileQueryParser(val));
        break;
      case "trust proxy":
        this.set("trust proxy fn", compileTrust2(val));
        Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
          configurable: true,
          value: false
        });
        break;
    }
    return this;
  };
  app.path = function path3() {
    return this.parent ? this.parent.path() + this.mountpath : "";
  };
  app.enabled = function enabled(setting) {
    return Boolean(this.set(setting));
  };
  app.disabled = function disabled(setting) {
    return !this.set(setting);
  };
  app.enable = function enable(setting) {
    return this.set(setting, true);
  };
  app.disable = function disable(setting) {
    return this.set(setting, false);
  };
  methods2.forEach(function(method) {
    app[method] = function(path22) {
      if (method === "get" && arguments.length === 1) {
        return this.set(path22);
      }
      this.lazyrouter();
      var route22 = this._router.route(path22);
      route22[method].apply(route22, slice2.call(arguments, 1));
      return this;
    };
  });
  app.all = function all3(path22) {
    this.lazyrouter();
    var route22 = this._router.route(path22);
    var args = slice2.call(arguments, 1);
    for (var i = 0; i < methods2.length; i++) {
      route22[methods2[i]].apply(route22, args);
    }
    return this;
  };
  app.del = deprecate2.function(app.delete, "app.del: Use app.delete instead");
  app.render = function render3(name, options, callback) {
    var cache = this.cache;
    var done = callback;
    var engines = this.engines;
    var opts = options;
    var renderOptions = {};
    var view2;
    if (typeof options === "function") {
      done = options;
      opts = {};
    }
    merge2(renderOptions, this.locals);
    if (opts._locals) {
      merge2(renderOptions, opts._locals);
    }
    merge2(renderOptions, opts);
    if (renderOptions.cache == null) {
      renderOptions.cache = this.enabled("view cache");
    }
    if (renderOptions.cache) {
      view2 = cache[name];
    }
    if (!view2) {
      var View22 = this.get("view");
      view2 = new View22(name, {
        defaultEngine: this.get("view engine"),
        root: this.get("views"),
        engines
      });
      if (!view2.path) {
        var dirs = Array.isArray(view2.root) && view2.root.length > 1 ? 'directories "' + view2.root.slice(0, -1).join('", "') + '" or "' + view2.root[view2.root.length - 1] + '"' : 'directory "' + view2.root + '"';
        var err = new Error('Failed to lookup view "' + name + '" in views ' + dirs);
        err.view = view2;
        return done(err);
      }
      if (renderOptions.cache) {
        cache[name] = view2;
      }
    }
    tryRender(view2, renderOptions, done);
  };
  app.listen = function listen() {
    var server = http2.createServer(this);
    return server.listen.apply(server, arguments);
  };
  function logerror(err) {
    if (this.get("env") !== "test")
      console.error(err.stack || err.toString());
  }
  function tryRender(view2, options, callback) {
    try {
      view2.render(options, callback);
    } catch (err) {
      callback(err);
    }
  }
})(application$1);
var applicationExports = application$1.exports;
var negotiator = { exports: {} };
var charset = { exports: {} };
charset.exports = preferredCharsets$1;
charset.exports.preferredCharsets = preferredCharsets$1;
var simpleCharsetRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
function parseAcceptCharset(accept) {
  var accepts2 = accept.split(",");
  for (var i = 0, j2 = 0; i < accepts2.length; i++) {
    var charset3 = parseCharset(accepts2[i].trim(), i);
    if (charset3) {
      accepts2[j2++] = charset3;
    }
  }
  accepts2.length = j2;
  return accepts2;
}
function parseCharset(str, i) {
  var match2 = simpleCharsetRegExp.exec(str);
  if (!match2)
    return null;
  var charset3 = match2[1];
  var q2 = 1;
  if (match2[2]) {
    var params = match2[2].split(";");
    for (var j2 = 0; j2 < params.length; j2++) {
      var p2 = params[j2].trim().split("=");
      if (p2[0] === "q") {
        q2 = parseFloat(p2[1]);
        break;
      }
    }
  }
  return {
    charset: charset3,
    q: q2,
    i
  };
}
function getCharsetPriority(charset3, accepted, index2) {
  var priority = { o: -1, q: 0, s: 0 };
  for (var i = 0; i < accepted.length; i++) {
    var spec = specify$3(charset3, accepted[i], index2);
    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
      priority = spec;
    }
  }
  return priority;
}
function specify$3(charset3, spec, index2) {
  var s2 = 0;
  if (spec.charset.toLowerCase() === charset3.toLowerCase()) {
    s2 |= 1;
  } else if (spec.charset !== "*") {
    return null;
  }
  return {
    i: index2,
    o: spec.i,
    q: spec.q,
    s: s2
  };
}
function preferredCharsets$1(accept, provided) {
  var accepts2 = parseAcceptCharset(accept === void 0 ? "*" : accept || "");
  if (!provided) {
    return accepts2.filter(isQuality$3).sort(compareSpecs$3).map(getFullCharset);
  }
  var priorities = provided.map(function getPriority(type3, index2) {
    return getCharsetPriority(type3, accepts2, index2);
  });
  return priorities.filter(isQuality$3).sort(compareSpecs$3).map(function getCharset(priority) {
    return provided[priorities.indexOf(priority)];
  });
}
function compareSpecs$3(a, b2) {
  return b2.q - a.q || b2.s - a.s || a.o - b2.o || a.i - b2.i || 0;
}
function getFullCharset(spec) {
  return spec.charset;
}
function isQuality$3(spec) {
  return spec.q > 0;
}
var charsetExports = charset.exports;
var encoding = { exports: {} };
encoding.exports = preferredEncodings$1;
encoding.exports.preferredEncodings = preferredEncodings$1;
var simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
function parseAcceptEncoding(accept) {
  var accepts2 = accept.split(",");
  var hasIdentity = false;
  var minQuality = 1;
  for (var i = 0, j2 = 0; i < accepts2.length; i++) {
    var encoding3 = parseEncoding(accepts2[i].trim(), i);
    if (encoding3) {
      accepts2[j2++] = encoding3;
      hasIdentity = hasIdentity || specify$2("identity", encoding3);
      minQuality = Math.min(minQuality, encoding3.q || 1);
    }
  }
  if (!hasIdentity) {
    accepts2[j2++] = {
      encoding: "identity",
      q: minQuality,
      i
    };
  }
  accepts2.length = j2;
  return accepts2;
}
function parseEncoding(str, i) {
  var match2 = simpleEncodingRegExp.exec(str);
  if (!match2)
    return null;
  var encoding3 = match2[1];
  var q2 = 1;
  if (match2[2]) {
    var params = match2[2].split(";");
    for (var j2 = 0; j2 < params.length; j2++) {
      var p2 = params[j2].trim().split("=");
      if (p2[0] === "q") {
        q2 = parseFloat(p2[1]);
        break;
      }
    }
  }
  return {
    encoding: encoding3,
    q: q2,
    i
  };
}
function getEncodingPriority(encoding3, accepted, index2) {
  var priority = { o: -1, q: 0, s: 0 };
  for (var i = 0; i < accepted.length; i++) {
    var spec = specify$2(encoding3, accepted[i], index2);
    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
      priority = spec;
    }
  }
  return priority;
}
function specify$2(encoding3, spec, index2) {
  var s2 = 0;
  if (spec.encoding.toLowerCase() === encoding3.toLowerCase()) {
    s2 |= 1;
  } else if (spec.encoding !== "*") {
    return null;
  }
  return {
    i: index2,
    o: spec.i,
    q: spec.q,
    s: s2
  };
}
function preferredEncodings$1(accept, provided) {
  var accepts2 = parseAcceptEncoding(accept || "");
  if (!provided) {
    return accepts2.filter(isQuality$2).sort(compareSpecs$2).map(getFullEncoding);
  }
  var priorities = provided.map(function getPriority(type3, index2) {
    return getEncodingPriority(type3, accepts2, index2);
  });
  return priorities.filter(isQuality$2).sort(compareSpecs$2).map(function getEncoding(priority) {
    return provided[priorities.indexOf(priority)];
  });
}
function compareSpecs$2(a, b2) {
  return b2.q - a.q || b2.s - a.s || a.o - b2.o || a.i - b2.i || 0;
}
function getFullEncoding(spec) {
  return spec.encoding;
}
function isQuality$2(spec) {
  return spec.q > 0;
}
var encodingExports = encoding.exports;
var language = { exports: {} };
language.exports = preferredLanguages$1;
language.exports.preferredLanguages = preferredLanguages$1;
var simpleLanguageRegExp = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;
function parseAcceptLanguage(accept) {
  var accepts2 = accept.split(",");
  for (var i = 0, j2 = 0; i < accepts2.length; i++) {
    var language3 = parseLanguage(accepts2[i].trim(), i);
    if (language3) {
      accepts2[j2++] = language3;
    }
  }
  accepts2.length = j2;
  return accepts2;
}
function parseLanguage(str, i) {
  var match2 = simpleLanguageRegExp.exec(str);
  if (!match2)
    return null;
  var prefix = match2[1];
  var suffix = match2[2];
  var full = prefix;
  if (suffix)
    full += "-" + suffix;
  var q2 = 1;
  if (match2[3]) {
    var params = match2[3].split(";");
    for (var j2 = 0; j2 < params.length; j2++) {
      var p2 = params[j2].split("=");
      if (p2[0] === "q")
        q2 = parseFloat(p2[1]);
    }
  }
  return {
    prefix,
    suffix,
    q: q2,
    i,
    full
  };
}
function getLanguagePriority(language3, accepted, index2) {
  var priority = { o: -1, q: 0, s: 0 };
  for (var i = 0; i < accepted.length; i++) {
    var spec = specify$1(language3, accepted[i], index2);
    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
      priority = spec;
    }
  }
  return priority;
}
function specify$1(language3, spec, index2) {
  var p2 = parseLanguage(language3);
  if (!p2)
    return null;
  var s2 = 0;
  if (spec.full.toLowerCase() === p2.full.toLowerCase()) {
    s2 |= 4;
  } else if (spec.prefix.toLowerCase() === p2.full.toLowerCase()) {
    s2 |= 2;
  } else if (spec.full.toLowerCase() === p2.prefix.toLowerCase()) {
    s2 |= 1;
  } else if (spec.full !== "*") {
    return null;
  }
  return {
    i: index2,
    o: spec.i,
    q: spec.q,
    s: s2
  };
}
function preferredLanguages$1(accept, provided) {
  var accepts2 = parseAcceptLanguage(accept === void 0 ? "*" : accept || "");
  if (!provided) {
    return accepts2.filter(isQuality$1).sort(compareSpecs$1).map(getFullLanguage);
  }
  var priorities = provided.map(function getPriority(type3, index2) {
    return getLanguagePriority(type3, accepts2, index2);
  });
  return priorities.filter(isQuality$1).sort(compareSpecs$1).map(function getLanguage(priority) {
    return provided[priorities.indexOf(priority)];
  });
}
function compareSpecs$1(a, b2) {
  return b2.q - a.q || b2.s - a.s || a.o - b2.o || a.i - b2.i || 0;
}
function getFullLanguage(spec) {
  return spec.full;
}
function isQuality$1(spec) {
  return spec.q > 0;
}
var languageExports = language.exports;
var mediaType = { exports: {} };
mediaType.exports = preferredMediaTypes$1;
mediaType.exports.preferredMediaTypes = preferredMediaTypes$1;
var simpleMediaTypeRegExp = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;
function parseAccept(accept) {
  var accepts2 = splitMediaTypes(accept);
  for (var i = 0, j2 = 0; i < accepts2.length; i++) {
    var mediaType3 = parseMediaType(accepts2[i].trim(), i);
    if (mediaType3) {
      accepts2[j2++] = mediaType3;
    }
  }
  accepts2.length = j2;
  return accepts2;
}
function parseMediaType(str, i) {
  var match2 = simpleMediaTypeRegExp.exec(str);
  if (!match2)
    return null;
  var params = /* @__PURE__ */ Object.create(null);
  var q2 = 1;
  var subtype = match2[2];
  var type3 = match2[1];
  if (match2[3]) {
    var kvps = splitParameters(match2[3]).map(splitKeyValuePair);
    for (var j2 = 0; j2 < kvps.length; j2++) {
      var pair = kvps[j2];
      var key = pair[0].toLowerCase();
      var val = pair[1];
      var value = val && val[0] === '"' && val[val.length - 1] === '"' ? val.substr(1, val.length - 2) : val;
      if (key === "q") {
        q2 = parseFloat(value);
        break;
      }
      params[key] = value;
    }
  }
  return {
    type: type3,
    subtype,
    params,
    q: q2,
    i
  };
}
function getMediaTypePriority(type3, accepted, index2) {
  var priority = { o: -1, q: 0, s: 0 };
  for (var i = 0; i < accepted.length; i++) {
    var spec = specify(type3, accepted[i], index2);
    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
      priority = spec;
    }
  }
  return priority;
}
function specify(type3, spec, index2) {
  var p2 = parseMediaType(type3);
  var s2 = 0;
  if (!p2) {
    return null;
  }
  if (spec.type.toLowerCase() == p2.type.toLowerCase()) {
    s2 |= 4;
  } else if (spec.type != "*") {
    return null;
  }
  if (spec.subtype.toLowerCase() == p2.subtype.toLowerCase()) {
    s2 |= 2;
  } else if (spec.subtype != "*") {
    return null;
  }
  var keys2 = Object.keys(spec.params);
  if (keys2.length > 0) {
    if (keys2.every(function(k2) {
      return spec.params[k2] == "*" || (spec.params[k2] || "").toLowerCase() == (p2.params[k2] || "").toLowerCase();
    })) {
      s2 |= 1;
    } else {
      return null;
    }
  }
  return {
    i: index2,
    o: spec.i,
    q: spec.q,
    s: s2
  };
}
function preferredMediaTypes$1(accept, provided) {
  var accepts2 = parseAccept(accept === void 0 ? "*/*" : accept || "");
  if (!provided) {
    return accepts2.filter(isQuality).sort(compareSpecs).map(getFullType);
  }
  var priorities = provided.map(function getPriority(type3, index2) {
    return getMediaTypePriority(type3, accepts2, index2);
  });
  return priorities.filter(isQuality).sort(compareSpecs).map(function getType(priority) {
    return provided[priorities.indexOf(priority)];
  });
}
function compareSpecs(a, b2) {
  return b2.q - a.q || b2.s - a.s || a.o - b2.o || a.i - b2.i || 0;
}
function getFullType(spec) {
  return spec.type + "/" + spec.subtype;
}
function isQuality(spec) {
  return spec.q > 0;
}
function quoteCount(string) {
  var count = 0;
  var index2 = 0;
  while ((index2 = string.indexOf('"', index2)) !== -1) {
    count++;
    index2++;
  }
  return count;
}
function splitKeyValuePair(str) {
  var index2 = str.indexOf("=");
  var key;
  var val;
  if (index2 === -1) {
    key = str;
  } else {
    key = str.substr(0, index2);
    val = str.substr(index2 + 1);
  }
  return [key, val];
}
function splitMediaTypes(accept) {
  var accepts2 = accept.split(",");
  for (var i = 1, j2 = 0; i < accepts2.length; i++) {
    if (quoteCount(accepts2[j2]) % 2 == 0) {
      accepts2[++j2] = accepts2[i];
    } else {
      accepts2[j2] += "," + accepts2[i];
    }
  }
  accepts2.length = j2 + 1;
  return accepts2;
}
function splitParameters(str) {
  var parameters = str.split(";");
  for (var i = 1, j2 = 0; i < parameters.length; i++) {
    if (quoteCount(parameters[j2]) % 2 == 0) {
      parameters[++j2] = parameters[i];
    } else {
      parameters[j2] += ";" + parameters[i];
    }
  }
  parameters.length = j2 + 1;
  for (var i = 0; i < parameters.length; i++) {
    parameters[i] = parameters[i].trim();
  }
  return parameters;
}
var mediaTypeExports = mediaType.exports;
/*!
 * negotiator
 * Copyright(c) 2012 Federico Romero
 * Copyright(c) 2012-2014 Isaac Z. Schlueter
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var preferredCharsets = charsetExports;
var preferredEncodings = encodingExports;
var preferredLanguages = languageExports;
var preferredMediaTypes = mediaTypeExports;
negotiator.exports = Negotiator$1;
negotiator.exports.Negotiator = Negotiator$1;
function Negotiator$1(request2) {
  if (!(this instanceof Negotiator$1)) {
    return new Negotiator$1(request2);
  }
  this.request = request2;
}
Negotiator$1.prototype.charset = function charset2(available) {
  var set2 = this.charsets(available);
  return set2 && set2[0];
};
Negotiator$1.prototype.charsets = function charsets(available) {
  return preferredCharsets(this.request.headers["accept-charset"], available);
};
Negotiator$1.prototype.encoding = function encoding2(available) {
  var set2 = this.encodings(available);
  return set2 && set2[0];
};
Negotiator$1.prototype.encodings = function encodings2(available) {
  return preferredEncodings(this.request.headers["accept-encoding"], available);
};
Negotiator$1.prototype.language = function language2(available) {
  var set2 = this.languages(available);
  return set2 && set2[0];
};
Negotiator$1.prototype.languages = function languages(available) {
  return preferredLanguages(this.request.headers["accept-language"], available);
};
Negotiator$1.prototype.mediaType = function mediaType2(available) {
  var set2 = this.mediaTypes(available);
  return set2 && set2[0];
};
Negotiator$1.prototype.mediaTypes = function mediaTypes(available) {
  return preferredMediaTypes(this.request.headers.accept, available);
};
Negotiator$1.prototype.preferredCharset = Negotiator$1.prototype.charset;
Negotiator$1.prototype.preferredCharsets = Negotiator$1.prototype.charsets;
Negotiator$1.prototype.preferredEncoding = Negotiator$1.prototype.encoding;
Negotiator$1.prototype.preferredEncodings = Negotiator$1.prototype.encodings;
Negotiator$1.prototype.preferredLanguage = Negotiator$1.prototype.language;
Negotiator$1.prototype.preferredLanguages = Negotiator$1.prototype.languages;
Negotiator$1.prototype.preferredMediaType = Negotiator$1.prototype.mediaType;
Negotiator$1.prototype.preferredMediaTypes = Negotiator$1.prototype.mediaTypes;
var negotiatorExports = negotiator.exports;
/*!
 * accepts
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var Negotiator = negotiatorExports;
var mime$2 = mimeTypes;
var accepts$1 = Accepts;
function Accepts(req2) {
  if (!(this instanceof Accepts)) {
    return new Accepts(req2);
  }
  this.headers = req2.headers;
  this.negotiator = new Negotiator(req2);
}
Accepts.prototype.type = Accepts.prototype.types = function(types_) {
  var types = types_;
  if (types && !Array.isArray(types)) {
    types = new Array(arguments.length);
    for (var i = 0; i < types.length; i++) {
      types[i] = arguments[i];
    }
  }
  if (!types || types.length === 0) {
    return this.negotiator.mediaTypes();
  }
  if (!this.headers.accept) {
    return types[0];
  }
  var mimes = types.map(extToMime);
  var accepts2 = this.negotiator.mediaTypes(mimes.filter(validMime));
  var first2 = accepts2[0];
  return first2 ? types[mimes.indexOf(first2)] : false;
};
Accepts.prototype.encoding = Accepts.prototype.encodings = function(encodings_) {
  var encodings3 = encodings_;
  if (encodings3 && !Array.isArray(encodings3)) {
    encodings3 = new Array(arguments.length);
    for (var i = 0; i < encodings3.length; i++) {
      encodings3[i] = arguments[i];
    }
  }
  if (!encodings3 || encodings3.length === 0) {
    return this.negotiator.encodings();
  }
  return this.negotiator.encodings(encodings3)[0] || false;
};
Accepts.prototype.charset = Accepts.prototype.charsets = function(charsets_) {
  var charsets2 = charsets_;
  if (charsets2 && !Array.isArray(charsets2)) {
    charsets2 = new Array(arguments.length);
    for (var i = 0; i < charsets2.length; i++) {
      charsets2[i] = arguments[i];
    }
  }
  if (!charsets2 || charsets2.length === 0) {
    return this.negotiator.charsets();
  }
  return this.negotiator.charsets(charsets2)[0] || false;
};
Accepts.prototype.lang = Accepts.prototype.langs = Accepts.prototype.language = Accepts.prototype.languages = function(languages_) {
  var languages2 = languages_;
  if (languages2 && !Array.isArray(languages2)) {
    languages2 = new Array(arguments.length);
    for (var i = 0; i < languages2.length; i++) {
      languages2[i] = arguments[i];
    }
  }
  if (!languages2 || languages2.length === 0) {
    return this.negotiator.languages();
  }
  return this.negotiator.languages(languages2)[0] || false;
};
function extToMime(type3) {
  return type3.indexOf("/") === -1 ? mime$2.lookup(type3) : type3;
}
function validMime(type3) {
  return typeof type3 === "string";
}
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var accepts = accepts$1;
var deprecate$1 = depd_1("express");
var isIP = require$$4$1.isIP;
var typeis = typeIsExports;
var http$3 = require$$0$7;
var fresh = fresh_1;
var parseRange = rangeParser_1;
var parse$2 = parseurlExports;
var proxyaddr = proxyAddrExports;
var req = Object.create(http$3.IncomingMessage.prototype);
var request = req;
req.get = req.header = function header(name) {
  if (!name) {
    throw new TypeError("name argument is required to req.get");
  }
  if (typeof name !== "string") {
    throw new TypeError("name must be a string to req.get");
  }
  var lc = name.toLowerCase();
  switch (lc) {
    case "referer":
    case "referrer":
      return this.headers.referrer || this.headers.referer;
    default:
      return this.headers[lc];
  }
};
req.accepts = function() {
  var accept = accepts(this);
  return accept.types.apply(accept, arguments);
};
req.acceptsEncodings = function() {
  var accept = accepts(this);
  return accept.encodings.apply(accept, arguments);
};
req.acceptsEncoding = deprecate$1.function(
  req.acceptsEncodings,
  "req.acceptsEncoding: Use acceptsEncodings instead"
);
req.acceptsCharsets = function() {
  var accept = accepts(this);
  return accept.charsets.apply(accept, arguments);
};
req.acceptsCharset = deprecate$1.function(
  req.acceptsCharsets,
  "req.acceptsCharset: Use acceptsCharsets instead"
);
req.acceptsLanguages = function() {
  var accept = accepts(this);
  return accept.languages.apply(accept, arguments);
};
req.acceptsLanguage = deprecate$1.function(
  req.acceptsLanguages,
  "req.acceptsLanguage: Use acceptsLanguages instead"
);
req.range = function range2(size, options) {
  var range3 = this.get("Range");
  if (!range3)
    return;
  return parseRange(size, range3, options);
};
req.param = function param2(name, defaultValue) {
  var params = this.params || {};
  var body = this.body || {};
  var query2 = this.query || {};
  var args = arguments.length === 1 ? "name" : "name, default";
  deprecate$1("req.param(" + args + "): Use req.params, req.body, or req.query instead");
  if (null != params[name] && params.hasOwnProperty(name))
    return params[name];
  if (null != body[name])
    return body[name];
  if (null != query2[name])
    return query2[name];
  return defaultValue;
};
req.is = function is(types) {
  var arr = types;
  if (!Array.isArray(types)) {
    arr = new Array(arguments.length);
    for (var i = 0; i < arr.length; i++) {
      arr[i] = arguments[i];
    }
  }
  return typeis(this, arr);
};
defineGetter(req, "protocol", function protocol() {
  var proto2 = this.connection.encrypted ? "https" : "http";
  var trust = this.app.get("trust proxy fn");
  if (!trust(this.connection.remoteAddress, 0)) {
    return proto2;
  }
  var header3 = this.get("X-Forwarded-Proto") || proto2;
  var index2 = header3.indexOf(",");
  return index2 !== -1 ? header3.substring(0, index2).trim() : header3.trim();
});
defineGetter(req, "secure", function secure() {
  return this.protocol === "https";
});
defineGetter(req, "ip", function ip() {
  var trust = this.app.get("trust proxy fn");
  return proxyaddr(this, trust);
});
defineGetter(req, "ips", function ips() {
  var trust = this.app.get("trust proxy fn");
  var addrs = proxyaddr.all(this, trust);
  addrs.reverse().pop();
  return addrs;
});
defineGetter(req, "subdomains", function subdomains() {
  var hostname2 = this.hostname;
  if (!hostname2)
    return [];
  var offset = this.app.get("subdomain offset");
  var subdomains2 = !isIP(hostname2) ? hostname2.split(".").reverse() : [hostname2];
  return subdomains2.slice(offset);
});
defineGetter(req, "path", function path() {
  return parse$2(this).pathname;
});
defineGetter(req, "hostname", function hostname() {
  var trust = this.app.get("trust proxy fn");
  var host2 = this.get("X-Forwarded-Host");
  if (!host2 || !trust(this.connection.remoteAddress, 0)) {
    host2 = this.get("Host");
  } else if (host2.indexOf(",") !== -1) {
    host2 = host2.substring(0, host2.indexOf(",")).trimRight();
  }
  if (!host2)
    return;
  var offset = host2[0] === "[" ? host2.indexOf("]") + 1 : 0;
  var index2 = host2.indexOf(":", offset);
  return index2 !== -1 ? host2.substring(0, index2) : host2;
});
defineGetter(req, "host", deprecate$1.function(function host() {
  return this.hostname;
}, "req.host: Use req.hostname instead"));
defineGetter(req, "fresh", function() {
  var method = this.method;
  var res2 = this.res;
  var status3 = res2.statusCode;
  if ("GET" !== method && "HEAD" !== method)
    return false;
  if (status3 >= 200 && status3 < 300 || 304 === status3) {
    return fresh(this.headers, {
      "etag": res2.get("ETag"),
      "last-modified": res2.get("Last-Modified")
    });
  }
  return false;
});
defineGetter(req, "stale", function stale() {
  return !this.fresh;
});
defineGetter(req, "xhr", function xhr() {
  var val = this.get("X-Requested-With") || "";
  return val.toLowerCase() === "xmlhttprequest";
});
function defineGetter(obj, name, getter) {
  Object.defineProperty(obj, name, {
    configurable: true,
    enumerable: true,
    get: getter
  });
}
var cookieSignature = {};
(function(exports) {
  var crypto2 = require$$0$8;
  exports.sign = function(val, secret) {
    if ("string" != typeof val)
      throw new TypeError("Cookie value must be provided as a string.");
    if ("string" != typeof secret)
      throw new TypeError("Secret string must be provided.");
    return val + "." + crypto2.createHmac("sha256", secret).update(val).digest("base64").replace(/\=+$/, "");
  };
  exports.unsign = function(val, secret) {
    if ("string" != typeof val)
      throw new TypeError("Signed cookie string must be provided.");
    if ("string" != typeof secret)
      throw new TypeError("Secret string must be provided.");
    var str = val.slice(0, val.lastIndexOf(".")), mac = exports.sign(str, secret);
    return sha1(mac) == sha1(val) ? str : false;
  };
  function sha1(str) {
    return crypto2.createHash("sha1").update(str).digest("hex");
  }
})(cookieSignature);
var cookie$1 = {};
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
cookie$1.parse = parse$1;
cookie$1.serialize = serialize;
var __toString = Object.prototype.toString;
var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
function parse$1(str, options) {
  if (typeof str !== "string") {
    throw new TypeError("argument str must be a string");
  }
  var obj = {};
  var opt = options || {};
  var dec = opt.decode || decode;
  var index2 = 0;
  while (index2 < str.length) {
    var eqIdx = str.indexOf("=", index2);
    if (eqIdx === -1) {
      break;
    }
    var endIdx = str.indexOf(";", index2);
    if (endIdx === -1) {
      endIdx = str.length;
    } else if (endIdx < eqIdx) {
      index2 = str.lastIndexOf(";", eqIdx - 1) + 1;
      continue;
    }
    var key = str.slice(index2, eqIdx).trim();
    if (void 0 === obj[key]) {
      var val = str.slice(eqIdx + 1, endIdx).trim();
      if (val.charCodeAt(0) === 34) {
        val = val.slice(1, -1);
      }
      obj[key] = tryDecode(val, dec);
    }
    index2 = endIdx + 1;
  }
  return obj;
}
function serialize(name, val, options) {
  var opt = options || {};
  var enc = opt.encode || encode$2;
  if (typeof enc !== "function") {
    throw new TypeError("option encode is invalid");
  }
  if (!fieldContentRegExp.test(name)) {
    throw new TypeError("argument name is invalid");
  }
  var value = enc(val);
  if (value && !fieldContentRegExp.test(value)) {
    throw new TypeError("argument val is invalid");
  }
  var str = name + "=" + value;
  if (null != opt.maxAge) {
    var maxAge = opt.maxAge - 0;
    if (isNaN(maxAge) || !isFinite(maxAge)) {
      throw new TypeError("option maxAge is invalid");
    }
    str += "; Max-Age=" + Math.floor(maxAge);
  }
  if (opt.domain) {
    if (!fieldContentRegExp.test(opt.domain)) {
      throw new TypeError("option domain is invalid");
    }
    str += "; Domain=" + opt.domain;
  }
  if (opt.path) {
    if (!fieldContentRegExp.test(opt.path)) {
      throw new TypeError("option path is invalid");
    }
    str += "; Path=" + opt.path;
  }
  if (opt.expires) {
    var expires = opt.expires;
    if (!isDate$1(expires) || isNaN(expires.valueOf())) {
      throw new TypeError("option expires is invalid");
    }
    str += "; Expires=" + expires.toUTCString();
  }
  if (opt.httpOnly) {
    str += "; HttpOnly";
  }
  if (opt.secure) {
    str += "; Secure";
  }
  if (opt.priority) {
    var priority = typeof opt.priority === "string" ? opt.priority.toLowerCase() : opt.priority;
    switch (priority) {
      case "low":
        str += "; Priority=Low";
        break;
      case "medium":
        str += "; Priority=Medium";
        break;
      case "high":
        str += "; Priority=High";
        break;
      default:
        throw new TypeError("option priority is invalid");
    }
  }
  if (opt.sameSite) {
    var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
    switch (sameSite) {
      case true:
        str += "; SameSite=Strict";
        break;
      case "lax":
        str += "; SameSite=Lax";
        break;
      case "strict":
        str += "; SameSite=Strict";
        break;
      case "none":
        str += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  }
  return str;
}
function decode(str) {
  return str.indexOf("%") !== -1 ? decodeURIComponent(str) : str;
}
function encode$2(val) {
  return encodeURIComponent(val);
}
function isDate$1(val) {
  return __toString.call(val) === "[object Date]" || val instanceof Date;
}
function tryDecode(str, decode2) {
  try {
    return decode2(str);
  } catch (e) {
    return str;
  }
}
var vary$2 = { exports: {} };
/*!
 * vary
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
vary$2.exports = vary$1;
vary$2.exports.append = append;
var FIELD_NAME_REGEXP = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
function append(header3, field) {
  if (typeof header3 !== "string") {
    throw new TypeError("header argument is required");
  }
  if (!field) {
    throw new TypeError("field argument is required");
  }
  var fields = !Array.isArray(field) ? parse(String(field)) : field;
  for (var j2 = 0; j2 < fields.length; j2++) {
    if (!FIELD_NAME_REGEXP.test(fields[j2])) {
      throw new TypeError("field argument contains an invalid header name");
    }
  }
  if (header3 === "*") {
    return header3;
  }
  var val = header3;
  var vals = parse(header3.toLowerCase());
  if (fields.indexOf("*") !== -1 || vals.indexOf("*") !== -1) {
    return "*";
  }
  for (var i = 0; i < fields.length; i++) {
    var fld = fields[i].toLowerCase();
    if (vals.indexOf(fld) === -1) {
      vals.push(fld);
      val = val ? val + ", " + fields[i] : fields[i];
    }
  }
  return val;
}
function parse(header3) {
  var end = 0;
  var list = [];
  var start = 0;
  for (var i = 0, len = header3.length; i < len; i++) {
    switch (header3.charCodeAt(i)) {
      case 32:
        if (start === end) {
          start = end = i + 1;
        }
        break;
      case 44:
        list.push(header3.substring(start, end));
        start = end = i + 1;
        break;
      default:
        end = i + 1;
        break;
    }
  }
  list.push(header3.substring(start, end));
  return list;
}
function vary$1(res2, field) {
  if (!res2 || !res2.getHeader || !res2.setHeader) {
    throw new TypeError("res argument is required");
  }
  var val = res2.getHeader("Vary") || "";
  var header3 = Array.isArray(val) ? val.join(", ") : String(val);
  if (val = append(header3, field)) {
    res2.setHeader("Vary", val);
  }
}
var varyExports = vary$2.exports;
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var Buffer$1 = safeBufferExports.Buffer;
var contentDisposition = contentDispositionExports;
var createError = httpErrorsExports;
var deprecate = depd_1("express");
var encodeUrl = encodeurl;
var escapeHtml = escapeHtml_1;
var http$2 = require$$0$7;
var isAbsolute = utils$2.isAbsolute;
var onFinished = onFinishedExports;
var path$1 = path$4;
var statuses = statuses$3;
var merge$1 = utilsMergeExports;
var sign = cookieSignature.sign;
var normalizeType = utils$2.normalizeType;
var normalizeTypes = utils$2.normalizeTypes;
var setCharset = utils$2.setCharset;
var cookie = cookie$1;
var send2 = sendExports;
var extname = path$1.extname;
var mime$1 = send2.mime;
var resolve2 = path$1.resolve;
var vary = varyExports;
var res = Object.create(http$2.ServerResponse.prototype);
var response = res;
var charsetRegExp = /;\s*charset\s*=/;
res.status = function status2(code) {
  if ((typeof code === "string" || Math.floor(code) !== code) && code > 99 && code < 1e3) {
    deprecate("res.status(" + JSON.stringify(code) + "): use res.status(" + Math.floor(code) + ") instead");
  }
  this.statusCode = code;
  return this;
};
res.links = function(links) {
  var link = this.get("Link") || "";
  if (link)
    link += ", ";
  return this.set("Link", link + Object.keys(links).map(function(rel) {
    return "<" + links[rel] + '>; rel="' + rel + '"';
  }).join(", "));
};
res.send = function send3(body) {
  var chunk = body;
  var encoding3;
  var req2 = this.req;
  var type3;
  var app = this.app;
  if (arguments.length === 2) {
    if (typeof arguments[0] !== "number" && typeof arguments[1] === "number") {
      deprecate("res.send(body, status): Use res.status(status).send(body) instead");
      this.statusCode = arguments[1];
    } else {
      deprecate("res.send(status, body): Use res.status(status).send(body) instead");
      this.statusCode = arguments[0];
      chunk = arguments[1];
    }
  }
  if (typeof chunk === "number" && arguments.length === 1) {
    if (!this.get("Content-Type")) {
      this.type("txt");
    }
    deprecate("res.send(status): Use res.sendStatus(status) instead");
    this.statusCode = chunk;
    chunk = statuses.message[chunk];
  }
  switch (typeof chunk) {
    case "string":
      if (!this.get("Content-Type")) {
        this.type("html");
      }
      break;
    case "boolean":
    case "number":
    case "object":
      if (chunk === null) {
        chunk = "";
      } else if (Buffer$1.isBuffer(chunk)) {
        if (!this.get("Content-Type")) {
          this.type("bin");
        }
      } else {
        return this.json(chunk);
      }
      break;
  }
  if (typeof chunk === "string") {
    encoding3 = "utf8";
    type3 = this.get("Content-Type");
    if (typeof type3 === "string") {
      this.set("Content-Type", setCharset(type3, "utf-8"));
    }
  }
  var etagFn = app.get("etag fn");
  var generateETag = !this.get("ETag") && typeof etagFn === "function";
  var len;
  if (chunk !== void 0) {
    if (Buffer$1.isBuffer(chunk)) {
      len = chunk.length;
    } else if (!generateETag && chunk.length < 1e3) {
      len = Buffer$1.byteLength(chunk, encoding3);
    } else {
      chunk = Buffer$1.from(chunk, encoding3);
      encoding3 = void 0;
      len = chunk.length;
    }
    this.set("Content-Length", len);
  }
  var etag3;
  if (generateETag && len !== void 0) {
    if (etag3 = etagFn(chunk, encoding3)) {
      this.set("ETag", etag3);
    }
  }
  if (req2.fresh)
    this.statusCode = 304;
  if (204 === this.statusCode || 304 === this.statusCode) {
    this.removeHeader("Content-Type");
    this.removeHeader("Content-Length");
    this.removeHeader("Transfer-Encoding");
    chunk = "";
  }
  if (this.statusCode === 205) {
    this.set("Content-Length", "0");
    this.removeHeader("Transfer-Encoding");
    chunk = "";
  }
  if (req2.method === "HEAD") {
    this.end();
  } else {
    this.end(chunk, encoding3);
  }
  return this;
};
res.json = function json(obj) {
  var val = obj;
  if (arguments.length === 2) {
    if (typeof arguments[1] === "number") {
      deprecate("res.json(obj, status): Use res.status(status).json(obj) instead");
      this.statusCode = arguments[1];
    } else {
      deprecate("res.json(status, obj): Use res.status(status).json(obj) instead");
      this.statusCode = arguments[0];
      val = arguments[1];
    }
  }
  var app = this.app;
  var escape2 = app.get("json escape");
  var replacer = app.get("json replacer");
  var spaces = app.get("json spaces");
  var body = stringify(val, replacer, spaces, escape2);
  if (!this.get("Content-Type")) {
    this.set("Content-Type", "application/json");
  }
  return this.send(body);
};
res.jsonp = function jsonp(obj) {
  var val = obj;
  if (arguments.length === 2) {
    if (typeof arguments[1] === "number") {
      deprecate("res.jsonp(obj, status): Use res.status(status).jsonp(obj) instead");
      this.statusCode = arguments[1];
    } else {
      deprecate("res.jsonp(status, obj): Use res.status(status).jsonp(obj) instead");
      this.statusCode = arguments[0];
      val = arguments[1];
    }
  }
  var app = this.app;
  var escape2 = app.get("json escape");
  var replacer = app.get("json replacer");
  var spaces = app.get("json spaces");
  var body = stringify(val, replacer, spaces, escape2);
  var callback = this.req.query[app.get("jsonp callback name")];
  if (!this.get("Content-Type")) {
    this.set("X-Content-Type-Options", "nosniff");
    this.set("Content-Type", "application/json");
  }
  if (Array.isArray(callback)) {
    callback = callback[0];
  }
  if (typeof callback === "string" && callback.length !== 0) {
    this.set("X-Content-Type-Options", "nosniff");
    this.set("Content-Type", "text/javascript");
    callback = callback.replace(/[^\[\]\w$.]/g, "");
    if (body === void 0) {
      body = "";
    } else if (typeof body === "string") {
      body = body.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    body = "/**/ typeof " + callback + " === 'function' && " + callback + "(" + body + ");";
  }
  return this.send(body);
};
res.sendStatus = function sendStatus(statusCode) {
  var body = statuses.message[statusCode] || String(statusCode);
  this.statusCode = statusCode;
  this.type("txt");
  return this.send(body);
};
res.sendFile = function sendFile2(path3, options, callback) {
  var done = callback;
  var req2 = this.req;
  var res2 = this;
  var next = req2.next;
  var opts = options || {};
  if (!path3) {
    throw new TypeError("path argument is required to res.sendFile");
  }
  if (typeof path3 !== "string") {
    throw new TypeError("path must be a string to res.sendFile");
  }
  if (typeof options === "function") {
    done = options;
    opts = {};
  }
  if (!opts.root && !isAbsolute(path3)) {
    throw new TypeError("path must be absolute or specify root to res.sendFile");
  }
  var pathname = encodeURI(path3);
  var file = send2(req2, pathname, opts);
  sendfile(res2, file, opts, function(err) {
    if (done)
      return done(err);
    if (err && err.code === "EISDIR")
      return next();
    if (err && err.code !== "ECONNABORTED" && err.syscall !== "write") {
      next(err);
    }
  });
};
res.sendfile = function(path3, options, callback) {
  var done = callback;
  var req2 = this.req;
  var res2 = this;
  var next = req2.next;
  var opts = options || {};
  if (typeof options === "function") {
    done = options;
    opts = {};
  }
  var file = send2(req2, path3, opts);
  sendfile(res2, file, opts, function(err) {
    if (done)
      return done(err);
    if (err && err.code === "EISDIR")
      return next();
    if (err && err.code !== "ECONNABORTED" && err.syscall !== "write") {
      next(err);
    }
  });
};
res.sendfile = deprecate.function(
  res.sendfile,
  "res.sendfile: Use res.sendFile instead"
);
res.download = function download(path3, filename, options, callback) {
  var done = callback;
  var name = filename;
  var opts = options || null;
  if (typeof filename === "function") {
    done = filename;
    name = null;
    opts = null;
  } else if (typeof options === "function") {
    done = options;
    opts = null;
  }
  if (typeof filename === "object" && (typeof options === "function" || options === void 0)) {
    name = null;
    opts = filename;
  }
  var headers = {
    "Content-Disposition": contentDisposition(name || path3)
  };
  if (opts && opts.headers) {
    var keys2 = Object.keys(opts.headers);
    for (var i = 0; i < keys2.length; i++) {
      var key = keys2[i];
      if (key.toLowerCase() !== "content-disposition") {
        headers[key] = opts.headers[key];
      }
    }
  }
  opts = Object.create(opts);
  opts.headers = headers;
  var fullPath = !opts.root ? resolve2(path3) : path3;
  return this.sendFile(fullPath, opts, done);
};
res.contentType = res.type = function contentType2(type3) {
  var ct = type3.indexOf("/") === -1 ? mime$1.lookup(type3) : type3;
  return this.set("Content-Type", ct);
};
res.format = function(obj) {
  var req2 = this.req;
  var next = req2.next;
  var keys2 = Object.keys(obj).filter(function(v2) {
    return v2 !== "default";
  });
  var key = keys2.length > 0 ? req2.accepts(keys2) : false;
  this.vary("Accept");
  if (key) {
    this.set("Content-Type", normalizeType(key).value);
    obj[key](req2, this, next);
  } else if (obj.default) {
    obj.default(req2, this, next);
  } else {
    next(createError(406, {
      types: normalizeTypes(keys2).map(function(o) {
        return o.value;
      })
    }));
  }
  return this;
};
res.attachment = function attachment(filename) {
  if (filename) {
    this.type(extname(filename));
  }
  this.set("Content-Disposition", contentDisposition(filename));
  return this;
};
res.append = function append2(field, val) {
  var prev = this.get(field);
  var value = val;
  if (prev) {
    value = Array.isArray(prev) ? prev.concat(val) : Array.isArray(val) ? [prev].concat(val) : [prev, val];
  }
  return this.set(field, value);
};
res.set = res.header = function header2(field, val) {
  if (arguments.length === 2) {
    var value = Array.isArray(val) ? val.map(String) : String(val);
    if (field.toLowerCase() === "content-type") {
      if (Array.isArray(value)) {
        throw new TypeError("Content-Type cannot be set to an Array");
      }
      if (!charsetRegExp.test(value)) {
        var charset3 = mime$1.charsets.lookup(value.split(";")[0]);
        if (charset3)
          value += "; charset=" + charset3.toLowerCase();
      }
    }
    this.setHeader(field, value);
  } else {
    for (var key in field) {
      this.set(key, field[key]);
    }
  }
  return this;
};
res.get = function(field) {
  return this.getHeader(field);
};
res.clearCookie = function clearCookie(name, options) {
  var opts = merge$1({ expires: /* @__PURE__ */ new Date(1), path: "/" }, options);
  return this.cookie(name, "", opts);
};
res.cookie = function(name, value, options) {
  var opts = merge$1({}, options);
  var secret = this.req.secret;
  var signed = opts.signed;
  if (signed && !secret) {
    throw new Error('cookieParser("secret") required for signed cookies');
  }
  var val = typeof value === "object" ? "j:" + JSON.stringify(value) : String(value);
  if (signed) {
    val = "s:" + sign(val, secret);
  }
  if (opts.maxAge != null) {
    var maxAge = opts.maxAge - 0;
    if (!isNaN(maxAge)) {
      opts.expires = new Date(Date.now() + maxAge);
      opts.maxAge = Math.floor(maxAge / 1e3);
    }
  }
  if (opts.path == null) {
    opts.path = "/";
  }
  this.append("Set-Cookie", cookie.serialize(name, String(val), opts));
  return this;
};
res.location = function location(url2) {
  var loc = url2;
  if (url2 === "back") {
    loc = this.req.get("Referrer") || "/";
  }
  return this.set("Location", encodeUrl(loc));
};
res.redirect = function redirect2(url2) {
  var address = url2;
  var body;
  var status3 = 302;
  if (arguments.length === 2) {
    if (typeof arguments[0] === "number") {
      status3 = arguments[0];
      address = arguments[1];
    } else {
      deprecate("res.redirect(url, status): Use res.redirect(status, url) instead");
      status3 = arguments[1];
    }
  }
  address = this.location(address).get("Location");
  this.format({
    text: function() {
      body = statuses.message[status3] + ". Redirecting to " + address;
    },
    html: function() {
      var u2 = escapeHtml(address);
      body = "<p>" + statuses.message[status3] + '. Redirecting to <a href="' + u2 + '">' + u2 + "</a></p>";
    },
    default: function() {
      body = "";
    }
  });
  this.statusCode = status3;
  this.set("Content-Length", Buffer$1.byteLength(body));
  if (this.req.method === "HEAD") {
    this.end();
  } else {
    this.end(body);
  }
};
res.vary = function(field) {
  if (!field || Array.isArray(field) && !field.length) {
    deprecate("res.vary(): Provide a field name");
    return this;
  }
  vary(this, field);
  return this;
};
res.render = function render2(view2, options, callback) {
  var app = this.req.app;
  var done = callback;
  var opts = options || {};
  var req2 = this.req;
  var self2 = this;
  if (typeof options === "function") {
    done = options;
    opts = {};
  }
  opts._locals = self2.locals;
  done = done || function(err, str) {
    if (err)
      return req2.next(err);
    self2.send(str);
  };
  app.render(view2, opts, done);
};
function sendfile(res2, file, options, callback) {
  var done = false;
  var streaming;
  function onaborted() {
    if (done)
      return;
    done = true;
    var err = new Error("Request aborted");
    err.code = "ECONNABORTED";
    callback(err);
  }
  function ondirectory() {
    if (done)
      return;
    done = true;
    var err = new Error("EISDIR, read");
    err.code = "EISDIR";
    callback(err);
  }
  function onerror(err) {
    if (done)
      return;
    done = true;
    callback(err);
  }
  function onend() {
    if (done)
      return;
    done = true;
    callback();
  }
  function onfile() {
    streaming = false;
  }
  function onfinish(err) {
    if (err && err.code === "ECONNRESET")
      return onaborted();
    if (err)
      return onerror(err);
    if (done)
      return;
    setImmediate(function() {
      if (streaming !== false && !done) {
        onaborted();
        return;
      }
      if (done)
        return;
      done = true;
      callback();
    });
  }
  function onstream() {
    streaming = true;
  }
  file.on("directory", ondirectory);
  file.on("end", onend);
  file.on("error", onerror);
  file.on("file", onfile);
  file.on("stream", onstream);
  onFinished(res2, onfinish);
  if (options.headers) {
    file.on("headers", function headers(res3) {
      var obj = options.headers;
      var keys2 = Object.keys(obj);
      for (var i = 0; i < keys2.length; i++) {
        var k2 = keys2[i];
        res3.setHeader(k2, obj[k2]);
      }
    });
  }
  file.pipe(res2);
}
function stringify(value, replacer, spaces, escape2) {
  var json2 = replacer || spaces ? JSON.stringify(value, replacer, spaces) : JSON.stringify(value);
  if (escape2 && typeof json2 === "string") {
    json2 = json2.replace(/[<>&]/g, function(c2) {
      switch (c2.charCodeAt(0)) {
        case 60:
          return "\\u003c";
        case 62:
          return "\\u003e";
        case 38:
          return "\\u0026";
        default:
          return c2;
      }
    });
  }
  return json2;
}
var serveStatic = { exports: {} };
/*!
 * serve-static
 * Copyright(c) 2010 Sencha Inc.
 * Copyright(c) 2011 TJ Holowaychuk
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredServeStatic;
function requireServeStatic() {
  if (hasRequiredServeStatic)
    return serveStatic.exports;
  hasRequiredServeStatic = 1;
  var encodeUrl2 = encodeurl;
  var escapeHtml2 = escapeHtml_1;
  var parseUrl2 = parseurlExports;
  var resolve3 = path$4.resolve;
  var send4 = sendExports;
  var url2 = require$$0$6;
  serveStatic.exports = serveStatic$1;
  serveStatic.exports.mime = send4.mime;
  function serveStatic$1(root3, options) {
    if (!root3) {
      throw new TypeError("root path required");
    }
    if (typeof root3 !== "string") {
      throw new TypeError("root path must be a string");
    }
    var opts = Object.create(options || null);
    var fallthrough = opts.fallthrough !== false;
    var redirect3 = opts.redirect !== false;
    var setHeaders2 = opts.setHeaders;
    if (setHeaders2 && typeof setHeaders2 !== "function") {
      throw new TypeError("option setHeaders must be function");
    }
    opts.maxage = opts.maxage || opts.maxAge || 0;
    opts.root = resolve3(root3);
    var onDirectory = redirect3 ? createRedirectDirectoryListener() : createNotFoundDirectoryListener();
    return function serveStatic2(req2, res2, next) {
      if (req2.method !== "GET" && req2.method !== "HEAD") {
        if (fallthrough) {
          return next();
        }
        res2.statusCode = 405;
        res2.setHeader("Allow", "GET, HEAD");
        res2.setHeader("Content-Length", "0");
        res2.end();
        return;
      }
      var forwardError = !fallthrough;
      var originalUrl = parseUrl2.original(req2);
      var path3 = parseUrl2(req2).pathname;
      if (path3 === "/" && originalUrl.pathname.substr(-1) !== "/") {
        path3 = "";
      }
      var stream3 = send4(req2, path3, opts);
      stream3.on("directory", onDirectory);
      if (setHeaders2) {
        stream3.on("headers", setHeaders2);
      }
      if (fallthrough) {
        stream3.on("file", function onFile() {
          forwardError = true;
        });
      }
      stream3.on("error", function error2(err) {
        if (forwardError || !(err.statusCode < 500)) {
          next(err);
          return;
        }
        next();
      });
      stream3.pipe(res2);
    };
  }
  function collapseLeadingSlashes2(str) {
    for (var i = 0; i < str.length; i++) {
      if (str.charCodeAt(i) !== 47) {
        break;
      }
    }
    return i > 1 ? "/" + str.substr(i) : str;
  }
  function createHtmlDocument2(title, body) {
    return '<!DOCTYPE html>\n<html lang="en">\n<head>\n<meta charset="utf-8">\n<title>' + title + "</title>\n</head>\n<body>\n<pre>" + body + "</pre>\n</body>\n</html>\n";
  }
  function createNotFoundDirectoryListener() {
    return function notFound() {
      this.error(404);
    };
  }
  function createRedirectDirectoryListener() {
    return function redirect3(res2) {
      if (this.hasTrailingSlash()) {
        this.error(404);
        return;
      }
      var originalUrl = parseUrl2.original(this.req);
      originalUrl.path = null;
      originalUrl.pathname = collapseLeadingSlashes2(originalUrl.pathname + "/");
      var loc = encodeUrl2(url2.format(originalUrl));
      var doc = createHtmlDocument2("Redirecting", 'Redirecting to <a href="' + escapeHtml2(loc) + '">' + escapeHtml2(loc) + "</a>");
      res2.statusCode = 301;
      res2.setHeader("Content-Type", "text/html; charset=UTF-8");
      res2.setHeader("Content-Length", Buffer.byteLength(doc));
      res2.setHeader("Content-Security-Policy", "default-src 'none'");
      res2.setHeader("X-Content-Type-Options", "nosniff");
      res2.setHeader("Location", loc);
      res2.end(doc);
    };
  }
  return serveStatic.exports;
}
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
(function(module, exports) {
  var bodyParser2 = bodyParserExports;
  var EventEmitter2 = require$$0$4.EventEmitter;
  var mixin2 = mergeDescriptors;
  var proto2 = applicationExports;
  var Route2 = route;
  var Router = routerExports;
  var req2 = request;
  var res2 = response;
  exports = module.exports = createApplication;
  function createApplication() {
    var app = function(req3, res3, next) {
      app.handle(req3, res3, next);
    };
    mixin2(app, EventEmitter2.prototype, false);
    mixin2(app, proto2, false);
    app.request = Object.create(req2, {
      app: { configurable: true, enumerable: true, writable: true, value: app }
    });
    app.response = Object.create(res2, {
      app: { configurable: true, enumerable: true, writable: true, value: app }
    });
    app.init();
    return app;
  }
  exports.application = proto2;
  exports.request = req2;
  exports.response = res2;
  exports.Route = Route2;
  exports.Router = Router;
  exports.json = bodyParser2.json;
  exports.query = requireQuery();
  exports.raw = bodyParser2.raw;
  exports.static = requireServeStatic();
  exports.text = bodyParser2.text;
  exports.urlencoded = bodyParser2.urlencoded;
  var removedMiddlewares = [
    "bodyParser",
    "compress",
    "cookieSession",
    "session",
    "logger",
    "cookieParser",
    "favicon",
    "responseTime",
    "errorHandler",
    "timeout",
    "methodOverride",
    "vhost",
    "csrf",
    "directory",
    "limit",
    "multipart",
    "staticCache"
  ];
  removedMiddlewares.forEach(function(name) {
    Object.defineProperty(exports, name, {
      get: function() {
        throw new Error("Most middleware (like " + name + ") is no longer bundled with Express and must be installed separately. Please see https://github.com/senchalabs/connect#middleware.");
      },
      configurable: true
    });
  });
})(express$2, express$2.exports);
var expressExports = express$2.exports;
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var express = expressExports;
const express$1 = /* @__PURE__ */ getDefaultExportFromCjs(express);
function extractBasics(req2, res2, next) {
  try {
    const credentials = req2.headers["x-credentials"] || "{}";
    const sheetID = req2.headers["x-sheet-id"];
    const pageName = req2.headers["x-sheet-name"];
    req2.sheetID = sheetID;
    req2.credentials = JSON.parse(credentials);
    req2.pageName = pageName;
    next();
  } catch (exception) {
    return res2.status(500).send({ message: exception.message });
  }
}
function bind(fn, thisArg) {
  return function wrap2() {
    return fn.apply(thisArg, arguments);
  };
}
const { toString: toString$2 } = Object.prototype;
const { getPrototypeOf } = Object;
const kindOf = /* @__PURE__ */ ((cache) => (thing) => {
  const str = toString$2.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
const kindOfTest = (type3) => {
  type3 = type3.toLowerCase();
  return (thing) => kindOf(thing) === type3;
};
const typeOfTest = (type3) => (thing) => typeof thing === type3;
const { isArray: isArray$i } = Array;
const isUndefined = typeOfTest("undefined");
function isBuffer$5(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction$4(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
const isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
const isString$2 = typeOfTest("string");
const isFunction$4 = typeOfTest("function");
const isNumber = typeOfTest("number");
const isObject$a = (thing) => thing !== null && typeof thing === "object";
const isBoolean$1 = (thing) => thing === true || thing === false;
const isPlainObject$2 = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype2 = getPrototypeOf(val);
  return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
const isDate = kindOfTest("Date");
const isFile = kindOfTest("File");
const isBlob = kindOfTest("Blob");
const isFileList = kindOfTest("FileList");
const isStream = (val) => isObject$a(val) && isFunction$4(val.pipe);
const isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction$4(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction$4(thing.toString) && thing.toString() === "[object FormData]"));
};
const isURLSearchParams = kindOfTest("URLSearchParams");
const trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach$1(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i;
  let l;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray$i(obj)) {
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    const keys2 = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys2.length;
    let key;
    for (i = 0; i < len; i++) {
      key = keys2[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  key = key.toLowerCase();
  const keys2 = Object.keys(obj);
  let i = keys2.length;
  let _key;
  while (i-- > 0) {
    _key = keys2[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
const _global = (() => {
  if (typeof globalThis !== "undefined")
    return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
const isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue2 = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject$2(result[targetKey]) && isPlainObject$2(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject$2(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray$i(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach$1(arguments[i], assignValue2);
  }
  return result;
}
const extend = (a, b2, thisArg, { allOwnKeys } = {}) => {
  forEach$1(b2, (val, key) => {
    if (thisArg && isFunction$4(val)) {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  }, { allOwnKeys });
  return a;
};
const stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
const inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
const toFlatObject = (sourceObj, destObj, filter3, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null)
    return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter3 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter3 || filter3(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
const endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
const toArray = (thing) => {
  if (!thing)
    return null;
  if (isArray$i(thing))
    return thing;
  let i = thing.length;
  if (!isNumber(i))
    return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};
const isTypedArray$3 = /* @__PURE__ */ ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
const forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator = generator.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
const matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
const isHTMLForm = kindOfTest("HTMLFormElement");
const toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer(m2, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
const hasOwnProperty$e = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
const isRegExp = kindOfTest("RegExp");
const reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach$1(descriptors2, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction$4(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value = obj[name];
    if (!isFunction$4(value))
      return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
};
const toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray$i(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
  return obj;
};
const noop$1 = () => {
};
const toFiniteNumber = (value, defaultValue) => {
  value = +value;
  return Number.isFinite(value) ? value : defaultValue;
};
const ALPHA = "abcdefghijklmnopqrstuvwxyz";
const DIGIT = "0123456789";
const ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = "";
  const { length } = alphabet;
  while (size--) {
    str += alphabet[Math.random() * length | 0];
  }
  return str;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction$4(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
const toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i) => {
    if (isObject$a(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i] = source;
        const target = isArray$i(source) ? [] : {};
        forEach$1(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
const isAsyncFn = kindOfTest("AsyncFunction");
const isThenable = (thing) => thing && (isObject$a(thing) || isFunction$4(thing)) && isFunction$4(thing.then) && isFunction$4(thing.catch);
const utils$1 = {
  isArray: isArray$i,
  isArrayBuffer,
  isBuffer: isBuffer$5,
  isFormData,
  isArrayBufferView,
  isString: isString$2,
  isNumber,
  isBoolean: isBoolean$1,
  isObject: isObject$a,
  isPlainObject: isPlainObject$2,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction: isFunction$4,
  isStream,
  isURLSearchParams,
  isTypedArray: isTypedArray$3,
  isFileList,
  forEach: forEach$1,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty: hasOwnProperty$e,
  hasOwnProp: hasOwnProperty$e,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop: noop$1,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable
};
function AxiosError(message, code, config, request2, response2) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config && (this.config = config);
  request2 && (this.request = request2);
  response2 && (this.response = response2);
}
utils$1.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils$1.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
const prototype$1 = AxiosError.prototype;
const descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code) => {
  descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype$1, "isAxiosError", { value: true });
AxiosError.from = (error2, code, config, request2, response2, customProps) => {
  const axiosError = Object.create(prototype$1);
  utils$1.toFlatObject(error2, axiosError, function filter3(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error2.message, code, config, request2, response2);
  axiosError.cause = error2;
  axiosError.name = error2.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var Stream$2 = stream.Stream;
var util$2 = require$$1$1;
var delayed_stream = DelayedStream$1;
function DelayedStream$1() {
  this.source = null;
  this.dataSize = 0;
  this.maxDataSize = 1024 * 1024;
  this.pauseStream = true;
  this._maxDataSizeExceeded = false;
  this._released = false;
  this._bufferedEvents = [];
}
util$2.inherits(DelayedStream$1, Stream$2);
DelayedStream$1.create = function(source, options) {
  var delayedStream = new this();
  options = options || {};
  for (var option in options) {
    delayedStream[option] = options[option];
  }
  delayedStream.source = source;
  var realEmit = source.emit;
  source.emit = function() {
    delayedStream._handleEmit(arguments);
    return realEmit.apply(source, arguments);
  };
  source.on("error", function() {
  });
  if (delayedStream.pauseStream) {
    source.pause();
  }
  return delayedStream;
};
Object.defineProperty(DelayedStream$1.prototype, "readable", {
  configurable: true,
  enumerable: true,
  get: function() {
    return this.source.readable;
  }
});
DelayedStream$1.prototype.setEncoding = function() {
  return this.source.setEncoding.apply(this.source, arguments);
};
DelayedStream$1.prototype.resume = function() {
  if (!this._released) {
    this.release();
  }
  this.source.resume();
};
DelayedStream$1.prototype.pause = function() {
  this.source.pause();
};
DelayedStream$1.prototype.release = function() {
  this._released = true;
  this._bufferedEvents.forEach(function(args) {
    this.emit.apply(this, args);
  }.bind(this));
  this._bufferedEvents = [];
};
DelayedStream$1.prototype.pipe = function() {
  var r = Stream$2.prototype.pipe.apply(this, arguments);
  this.resume();
  return r;
};
DelayedStream$1.prototype._handleEmit = function(args) {
  if (this._released) {
    this.emit.apply(this, args);
    return;
  }
  if (args[0] === "data") {
    this.dataSize += args[1].length;
    this._checkIfMaxDataSizeExceeded();
  }
  this._bufferedEvents.push(args);
};
DelayedStream$1.prototype._checkIfMaxDataSizeExceeded = function() {
  if (this._maxDataSizeExceeded) {
    return;
  }
  if (this.dataSize <= this.maxDataSize) {
    return;
  }
  this._maxDataSizeExceeded = true;
  var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
  this.emit("error", new Error(message));
};
var util$1 = require$$1$1;
var Stream$1 = stream.Stream;
var DelayedStream = delayed_stream;
var combined_stream = CombinedStream$1;
function CombinedStream$1() {
  this.writable = false;
  this.readable = true;
  this.dataSize = 0;
  this.maxDataSize = 2 * 1024 * 1024;
  this.pauseStreams = true;
  this._released = false;
  this._streams = [];
  this._currentStream = null;
  this._insideLoop = false;
  this._pendingNext = false;
}
util$1.inherits(CombinedStream$1, Stream$1);
CombinedStream$1.create = function(options) {
  var combinedStream = new this();
  options = options || {};
  for (var option in options) {
    combinedStream[option] = options[option];
  }
  return combinedStream;
};
CombinedStream$1.isStreamLike = function(stream3) {
  return typeof stream3 !== "function" && typeof stream3 !== "string" && typeof stream3 !== "boolean" && typeof stream3 !== "number" && !Buffer.isBuffer(stream3);
};
CombinedStream$1.prototype.append = function(stream3) {
  var isStreamLike = CombinedStream$1.isStreamLike(stream3);
  if (isStreamLike) {
    if (!(stream3 instanceof DelayedStream)) {
      var newStream = DelayedStream.create(stream3, {
        maxDataSize: Infinity,
        pauseStream: this.pauseStreams
      });
      stream3.on("data", this._checkDataSize.bind(this));
      stream3 = newStream;
    }
    this._handleErrors(stream3);
    if (this.pauseStreams) {
      stream3.pause();
    }
  }
  this._streams.push(stream3);
  return this;
};
CombinedStream$1.prototype.pipe = function(dest, options) {
  Stream$1.prototype.pipe.call(this, dest, options);
  this.resume();
  return dest;
};
CombinedStream$1.prototype._getNext = function() {
  this._currentStream = null;
  if (this._insideLoop) {
    this._pendingNext = true;
    return;
  }
  this._insideLoop = true;
  try {
    do {
      this._pendingNext = false;
      this._realGetNext();
    } while (this._pendingNext);
  } finally {
    this._insideLoop = false;
  }
};
CombinedStream$1.prototype._realGetNext = function() {
  var stream3 = this._streams.shift();
  if (typeof stream3 == "undefined") {
    this.end();
    return;
  }
  if (typeof stream3 !== "function") {
    this._pipeNext(stream3);
    return;
  }
  var getStream = stream3;
  getStream(function(stream4) {
    var isStreamLike = CombinedStream$1.isStreamLike(stream4);
    if (isStreamLike) {
      stream4.on("data", this._checkDataSize.bind(this));
      this._handleErrors(stream4);
    }
    this._pipeNext(stream4);
  }.bind(this));
};
CombinedStream$1.prototype._pipeNext = function(stream3) {
  this._currentStream = stream3;
  var isStreamLike = CombinedStream$1.isStreamLike(stream3);
  if (isStreamLike) {
    stream3.on("end", this._getNext.bind(this));
    stream3.pipe(this, { end: false });
    return;
  }
  var value = stream3;
  this.write(value);
  this._getNext();
};
CombinedStream$1.prototype._handleErrors = function(stream3) {
  var self2 = this;
  stream3.on("error", function(err) {
    self2._emitError(err);
  });
};
CombinedStream$1.prototype.write = function(data) {
  this.emit("data", data);
};
CombinedStream$1.prototype.pause = function() {
  if (!this.pauseStreams) {
    return;
  }
  if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function")
    this._currentStream.pause();
  this.emit("pause");
};
CombinedStream$1.prototype.resume = function() {
  if (!this._released) {
    this._released = true;
    this.writable = true;
    this._getNext();
  }
  if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function")
    this._currentStream.resume();
  this.emit("resume");
};
CombinedStream$1.prototype.end = function() {
  this._reset();
  this.emit("end");
};
CombinedStream$1.prototype.destroy = function() {
  this._reset();
  this.emit("close");
};
CombinedStream$1.prototype._reset = function() {
  this.writable = false;
  this._streams = [];
  this._currentStream = null;
};
CombinedStream$1.prototype._checkDataSize = function() {
  this._updateDataSize();
  if (this.dataSize <= this.maxDataSize) {
    return;
  }
  var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
  this._emitError(new Error(message));
};
CombinedStream$1.prototype._updateDataSize = function() {
  this.dataSize = 0;
  var self2 = this;
  this._streams.forEach(function(stream3) {
    if (!stream3.dataSize) {
      return;
    }
    self2.dataSize += stream3.dataSize;
  });
  if (this._currentStream && this._currentStream.dataSize) {
    this.dataSize += this._currentStream.dataSize;
  }
};
CombinedStream$1.prototype._emitError = function(err) {
  this._reset();
  this.emit("error", err);
};
var defer_1 = defer$1;
function defer$1(fn) {
  var nextTick = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
  if (nextTick) {
    nextTick(fn);
  } else {
    setTimeout(fn, 0);
  }
}
var defer = defer_1;
var async_1 = async$2;
function async$2(callback) {
  var isAsync = false;
  defer(function() {
    isAsync = true;
  });
  return function async_callback(err, result) {
    if (isAsync) {
      callback(err, result);
    } else {
      defer(function nextTick_callback() {
        callback(err, result);
      });
    }
  };
}
var abort_1 = abort$2;
function abort$2(state2) {
  Object.keys(state2.jobs).forEach(clean.bind(state2));
  state2.jobs = {};
}
function clean(key) {
  if (typeof this.jobs[key] == "function") {
    this.jobs[key]();
  }
}
var async$1 = async_1, abort$1 = abort_1;
var iterate_1 = iterate$2;
function iterate$2(list, iterator, state2, callback) {
  var key = state2["keyedList"] ? state2["keyedList"][state2.index] : state2.index;
  state2.jobs[key] = runJob(iterator, key, list[key], function(error2, output) {
    if (!(key in state2.jobs)) {
      return;
    }
    delete state2.jobs[key];
    if (error2) {
      abort$1(state2);
    } else {
      state2.results[key] = output;
    }
    callback(error2, state2.results);
  });
}
function runJob(iterator, key, item, callback) {
  var aborter;
  if (iterator.length == 2) {
    aborter = iterator(item, async$1(callback));
  } else {
    aborter = iterator(item, key, async$1(callback));
  }
  return aborter;
}
var state_1 = state;
function state(list, sortMethod) {
  var isNamedList = !Array.isArray(list), initState2 = {
    index: 0,
    keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
    jobs: {},
    results: isNamedList ? {} : [],
    size: isNamedList ? Object.keys(list).length : list.length
  };
  if (sortMethod) {
    initState2.keyedList.sort(isNamedList ? sortMethod : function(a, b2) {
      return sortMethod(list[a], list[b2]);
    });
  }
  return initState2;
}
var abort = abort_1, async = async_1;
var terminator_1 = terminator$2;
function terminator$2(callback) {
  if (!Object.keys(this.jobs).length) {
    return;
  }
  this.index = this.size;
  abort(this);
  async(callback)(null, this.results);
}
var iterate$1 = iterate_1, initState$1 = state_1, terminator$1 = terminator_1;
var parallel_1 = parallel;
function parallel(list, iterator, callback) {
  var state2 = initState$1(list);
  while (state2.index < (state2["keyedList"] || list).length) {
    iterate$1(list, iterator, state2, function(error2, result) {
      if (error2) {
        callback(error2, result);
        return;
      }
      if (Object.keys(state2.jobs).length === 0) {
        callback(null, state2.results);
        return;
      }
    });
    state2.index++;
  }
  return terminator$1.bind(state2, callback);
}
var serialOrdered$2 = { exports: {} };
var iterate = iterate_1, initState = state_1, terminator = terminator_1;
serialOrdered$2.exports = serialOrdered$1;
serialOrdered$2.exports.ascending = ascending;
serialOrdered$2.exports.descending = descending;
function serialOrdered$1(list, iterator, sortMethod, callback) {
  var state2 = initState(list, sortMethod);
  iterate(list, iterator, state2, function iteratorHandler(error2, result) {
    if (error2) {
      callback(error2, result);
      return;
    }
    state2.index++;
    if (state2.index < (state2["keyedList"] || list).length) {
      iterate(list, iterator, state2, iteratorHandler);
      return;
    }
    callback(null, state2.results);
  });
  return terminator.bind(state2, callback);
}
function ascending(a, b2) {
  return a < b2 ? -1 : a > b2 ? 1 : 0;
}
function descending(a, b2) {
  return -1 * ascending(a, b2);
}
var serialOrderedExports = serialOrdered$2.exports;
var serialOrdered = serialOrderedExports;
var serial_1 = serial;
function serial(list, iterator, callback) {
  return serialOrdered(list, iterator, null, callback);
}
var asynckit$1 = {
  parallel: parallel_1,
  serial: serial_1,
  serialOrdered: serialOrderedExports
};
var populate$1 = function(dst, src2) {
  Object.keys(src2).forEach(function(prop) {
    dst[prop] = dst[prop] || src2[prop];
  });
  return dst;
};
var CombinedStream = combined_stream;
var util = require$$1$1;
var path2 = path$4;
var http$1 = require$$0$7;
var https$1 = require$$4$2;
var parseUrl$2 = require$$0$6.parse;
var fs = require$$3$1;
var Stream = stream.Stream;
var mime = mimeTypes;
var asynckit = asynckit$1;
var populate = populate$1;
var form_data = FormData$1;
util.inherits(FormData$1, CombinedStream);
function FormData$1(options) {
  if (!(this instanceof FormData$1)) {
    return new FormData$1(options);
  }
  this._overheadLength = 0;
  this._valueLength = 0;
  this._valuesToMeasure = [];
  CombinedStream.call(this);
  options = options || {};
  for (var option in options) {
    this[option] = options[option];
  }
}
FormData$1.LINE_BREAK = "\r\n";
FormData$1.DEFAULT_CONTENT_TYPE = "application/octet-stream";
FormData$1.prototype.append = function(field, value, options) {
  options = options || {};
  if (typeof options == "string") {
    options = { filename: options };
  }
  var append4 = CombinedStream.prototype.append.bind(this);
  if (typeof value == "number") {
    value = "" + value;
  }
  if (util.isArray(value)) {
    this._error(new Error("Arrays are not supported."));
    return;
  }
  var header3 = this._multiPartHeader(field, value, options);
  var footer = this._multiPartFooter();
  append4(header3);
  append4(value);
  append4(footer);
  this._trackLength(header3, value, options);
};
FormData$1.prototype._trackLength = function(header3, value, options) {
  var valueLength = 0;
  if (options.knownLength != null) {
    valueLength += +options.knownLength;
  } else if (Buffer.isBuffer(value)) {
    valueLength = value.length;
  } else if (typeof value === "string") {
    valueLength = Buffer.byteLength(value);
  }
  this._valueLength += valueLength;
  this._overheadLength += Buffer.byteLength(header3) + FormData$1.LINE_BREAK.length;
  if (!value || !value.path && !(value.readable && value.hasOwnProperty("httpVersion")) && !(value instanceof Stream)) {
    return;
  }
  if (!options.knownLength) {
    this._valuesToMeasure.push(value);
  }
};
FormData$1.prototype._lengthRetriever = function(value, callback) {
  if (value.hasOwnProperty("fd")) {
    if (value.end != void 0 && value.end != Infinity && value.start != void 0) {
      callback(null, value.end + 1 - (value.start ? value.start : 0));
    } else {
      fs.stat(value.path, function(err, stat) {
        var fileSize;
        if (err) {
          callback(err);
          return;
        }
        fileSize = stat.size - (value.start ? value.start : 0);
        callback(null, fileSize);
      });
    }
  } else if (value.hasOwnProperty("httpVersion")) {
    callback(null, +value.headers["content-length"]);
  } else if (value.hasOwnProperty("httpModule")) {
    value.on("response", function(response2) {
      value.pause();
      callback(null, +response2.headers["content-length"]);
    });
    value.resume();
  } else {
    callback("Unknown stream");
  }
};
FormData$1.prototype._multiPartHeader = function(field, value, options) {
  if (typeof options.header == "string") {
    return options.header;
  }
  var contentDisposition2 = this._getContentDisposition(value, options);
  var contentType3 = this._getContentType(value, options);
  var contents = "";
  var headers = {
    // add custom disposition as third element or keep it two elements if not
    "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition2 || []),
    // if no content type. allow it to be empty array
    "Content-Type": [].concat(contentType3 || [])
  };
  if (typeof options.header == "object") {
    populate(headers, options.header);
  }
  var header3;
  for (var prop in headers) {
    if (!headers.hasOwnProperty(prop))
      continue;
    header3 = headers[prop];
    if (header3 == null) {
      continue;
    }
    if (!Array.isArray(header3)) {
      header3 = [header3];
    }
    if (header3.length) {
      contents += prop + ": " + header3.join("; ") + FormData$1.LINE_BREAK;
    }
  }
  return "--" + this.getBoundary() + FormData$1.LINE_BREAK + contents + FormData$1.LINE_BREAK;
};
FormData$1.prototype._getContentDisposition = function(value, options) {
  var filename, contentDisposition2;
  if (typeof options.filepath === "string") {
    filename = path2.normalize(options.filepath).replace(/\\/g, "/");
  } else if (options.filename || value.name || value.path) {
    filename = path2.basename(options.filename || value.name || value.path);
  } else if (value.readable && value.hasOwnProperty("httpVersion")) {
    filename = path2.basename(value.client._httpMessage.path || "");
  }
  if (filename) {
    contentDisposition2 = 'filename="' + filename + '"';
  }
  return contentDisposition2;
};
FormData$1.prototype._getContentType = function(value, options) {
  var contentType3 = options.contentType;
  if (!contentType3 && value.name) {
    contentType3 = mime.lookup(value.name);
  }
  if (!contentType3 && value.path) {
    contentType3 = mime.lookup(value.path);
  }
  if (!contentType3 && value.readable && value.hasOwnProperty("httpVersion")) {
    contentType3 = value.headers["content-type"];
  }
  if (!contentType3 && (options.filepath || options.filename)) {
    contentType3 = mime.lookup(options.filepath || options.filename);
  }
  if (!contentType3 && typeof value == "object") {
    contentType3 = FormData$1.DEFAULT_CONTENT_TYPE;
  }
  return contentType3;
};
FormData$1.prototype._multiPartFooter = function() {
  return function(next) {
    var footer = FormData$1.LINE_BREAK;
    var lastPart = this._streams.length === 0;
    if (lastPart) {
      footer += this._lastBoundary();
    }
    next(footer);
  }.bind(this);
};
FormData$1.prototype._lastBoundary = function() {
  return "--" + this.getBoundary() + "--" + FormData$1.LINE_BREAK;
};
FormData$1.prototype.getHeaders = function(userHeaders) {
  var header3;
  var formHeaders = {
    "content-type": "multipart/form-data; boundary=" + this.getBoundary()
  };
  for (header3 in userHeaders) {
    if (userHeaders.hasOwnProperty(header3)) {
      formHeaders[header3.toLowerCase()] = userHeaders[header3];
    }
  }
  return formHeaders;
};
FormData$1.prototype.setBoundary = function(boundary) {
  this._boundary = boundary;
};
FormData$1.prototype.getBoundary = function() {
  if (!this._boundary) {
    this._generateBoundary();
  }
  return this._boundary;
};
FormData$1.prototype.getBuffer = function() {
  var dataBuffer = new Buffer.alloc(0);
  var boundary = this.getBoundary();
  for (var i = 0, len = this._streams.length; i < len; i++) {
    if (typeof this._streams[i] !== "function") {
      if (Buffer.isBuffer(this._streams[i])) {
        dataBuffer = Buffer.concat([dataBuffer, this._streams[i]]);
      } else {
        dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i])]);
      }
      if (typeof this._streams[i] !== "string" || this._streams[i].substring(2, boundary.length + 2) !== boundary) {
        dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData$1.LINE_BREAK)]);
      }
    }
  }
  return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
};
FormData$1.prototype._generateBoundary = function() {
  var boundary = "--------------------------";
  for (var i = 0; i < 24; i++) {
    boundary += Math.floor(Math.random() * 10).toString(16);
  }
  this._boundary = boundary;
};
FormData$1.prototype.getLengthSync = function() {
  var knownLength = this._overheadLength + this._valueLength;
  if (this._streams.length) {
    knownLength += this._lastBoundary().length;
  }
  if (!this.hasKnownLength()) {
    this._error(new Error("Cannot calculate proper length in synchronous way."));
  }
  return knownLength;
};
FormData$1.prototype.hasKnownLength = function() {
  var hasKnownLength = true;
  if (this._valuesToMeasure.length) {
    hasKnownLength = false;
  }
  return hasKnownLength;
};
FormData$1.prototype.getLength = function(cb) {
  var knownLength = this._overheadLength + this._valueLength;
  if (this._streams.length) {
    knownLength += this._lastBoundary().length;
  }
  if (!this._valuesToMeasure.length) {
    process.nextTick(cb.bind(this, null, knownLength));
    return;
  }
  asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values2) {
    if (err) {
      cb(err);
      return;
    }
    values2.forEach(function(length) {
      knownLength += length;
    });
    cb(null, knownLength);
  });
};
FormData$1.prototype.submit = function(params, cb) {
  var request2, options, defaults2 = { method: "post" };
  if (typeof params == "string") {
    params = parseUrl$2(params);
    options = populate({
      port: params.port,
      path: params.pathname,
      host: params.hostname,
      protocol: params.protocol
    }, defaults2);
  } else {
    options = populate(params, defaults2);
    if (!options.port) {
      options.port = options.protocol == "https:" ? 443 : 80;
    }
  }
  options.headers = this.getHeaders(params.headers);
  if (options.protocol == "https:") {
    request2 = https$1.request(options);
  } else {
    request2 = http$1.request(options);
  }
  this.getLength(function(err, length) {
    if (err && err !== "Unknown stream") {
      this._error(err);
      return;
    }
    if (length) {
      request2.setHeader("Content-Length", length);
    }
    this.pipe(request2);
    if (cb) {
      var onResponse;
      var callback = function(error2, responce) {
        request2.removeListener("error", callback);
        request2.removeListener("response", onResponse);
        return cb.call(this, error2, responce);
      };
      onResponse = callback.bind(this, null);
      request2.on("error", callback);
      request2.on("response", onResponse);
    }
  }.bind(this));
  return request2;
};
FormData$1.prototype._error = function(err) {
  if (!this.error) {
    this.error = err;
    this.pause();
    this.emit("error", err);
  }
};
FormData$1.prototype.toString = function() {
  return "[object FormData]";
};
const FormData$2 = /* @__PURE__ */ getDefaultExportFromCjs(form_data);
function isVisitable(thing) {
  return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
}
function removeBrackets(key) {
  return utils$1.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path3, key, dots) {
  if (!path3)
    return key;
  return path3.concat(key).map(function each2(token, i) {
    token = removeBrackets(token);
    return !dots && i ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils$1.isArray(arr) && !arr.some(isVisitable);
}
const predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options) {
  if (!utils$1.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new (FormData$2 || FormData)();
  options = utils$1.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils$1.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);
  if (!utils$1.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null)
      return "";
    if (utils$1.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils$1.isBlob(value)) {
      throw new AxiosError("Blob is not supported. Use a Buffer instead.");
    }
    if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path3) {
    let arr = value;
    if (value && !path3 && typeof value === "object") {
      if (utils$1.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils$1.isArray(value) && isFlatArray(value) || (utils$1.isFileList(value) || utils$1.endsWith(key, "[]")) && (arr = utils$1.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each2(el, index2) {
          !(utils$1.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index2, dots) : indexes === null ? key : key + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path3, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path3) {
    if (utils$1.isUndefined(value))
      return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path3.join("."));
    }
    stack.push(value);
    utils$1.forEach(value, function each2(el, key) {
      const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils$1.isString(key) ? key.trim() : key,
        path3,
        exposedHelpers
      );
      if (result === true) {
        build(el, path3 ? path3.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils$1.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
function encode$1(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match2) {
    return charMap[match2];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData(params, this, options);
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function append3(name, value) {
  this._pairs.push([name, value]);
};
prototype.toString = function toString(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode$1);
  } : encode$1;
  return this._pairs.map(function each2(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
function encode(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url2, params, options) {
  if (!params) {
    return url2;
  }
  const _encode = options && options.encode || encode;
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url2.indexOf("#");
    if (hashmarkIndex !== -1) {
      url2 = url2.slice(0, hashmarkIndex);
    }
    url2 += (url2.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url2;
}
class InterceptorManager {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils$1.forEach(this.handlers, function forEachHandler(h2) {
      if (h2 !== null) {
        fn(h2);
      }
    });
  }
}
const transitionalDefaults = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
const URLSearchParams = require$$0$6.URLSearchParams;
const platform$1 = {
  isNode: true,
  classes: {
    URLSearchParams,
    FormData: FormData$2,
    Blob: typeof Blob !== "undefined" && Blob || null
  },
  protocols: ["http", "https", "file", "data"]
};
const hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
const hasStandardBrowserEnv = ((product) => {
  return hasBrowserEnv && ["ReactNative", "NativeScript", "NS"].indexOf(product) < 0;
})(typeof navigator !== "undefined" && navigator.product);
const hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
const utils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv,
  hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv
}, Symbol.toStringTag, { value: "Module" }));
const platform = {
  ...utils,
  ...platform$1
};
function toURLEncodedForm(data, options) {
  return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path3, helpers) {
      if (platform.isNode && utils$1.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}
function parsePropPath(name) {
  return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map((match2) => {
    return match2[0] === "[]" ? "" : match2[1] || match2[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys2 = Object.keys(arr);
  let i;
  const len = keys2.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys2[i];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path3, value, target, index2) {
    let name = path3[index2++];
    if (name === "__proto__")
      return true;
    const isNumericKey = Number.isFinite(+name);
    const isLast = index2 >= path3.length;
    name = !name && utils$1.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils$1.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils$1.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path3, value, target[name], index2);
    if (result && utils$1.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
    const obj = {};
    utils$1.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}
function stringifySafely(rawValue, parser, encoder) {
  if (utils$1.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils$1.trim(rawValue);
    } catch (e) {
      if (e.name !== "SyntaxError") {
        throw e;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
const defaults = {
  transitional: transitionalDefaults,
  adapter: ["xhr", "http"],
  transformRequest: [function transformRequest(data, headers) {
    const contentType3 = headers.getContentType() || "";
    const hasJSONContentType = contentType3.indexOf("application/json") > -1;
    const isObjectPayload = utils$1.isObject(data);
    if (isObjectPayload && utils$1.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils$1.isFormData(data);
    if (isFormData2) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
    }
    if (utils$1.isArrayBuffer(data) || utils$1.isBuffer(data) || utils$1.isStream(data) || utils$1.isFile(data) || utils$1.isBlob(data)) {
      return data;
    }
    if (utils$1.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils$1.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType3.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils$1.isFileList(data)) || contentType3.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (data && utils$1.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === "SyntaxError") {
            throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },
  validateStatus: function validateStatus(status3) {
    return status3 >= 200 && status3 < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults.headers[method] = {};
});
const defaults$1 = defaults;
const ignoreDuplicateOf = utils$1.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
const parseHeaders = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i = line.indexOf(":");
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};
const $internals = Symbol("internals");
function normalizeHeader(header3) {
  return header3 && String(header3).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match2;
  while (match2 = tokensRE.exec(str)) {
    tokens[match2[1]] = match2[2];
  }
  return tokens;
}
const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header3, filter3, isHeaderNameFilter) {
  if (utils$1.isFunction(filter3)) {
    return filter3.call(this, value, header3);
  }
  if (isHeaderNameFilter) {
    value = header3;
  }
  if (!utils$1.isString(value))
    return;
  if (utils$1.isString(filter3)) {
    return value.indexOf(filter3) !== -1;
  }
  if (utils$1.isRegExp(filter3)) {
    return filter3.test(value);
  }
}
function formatHeader(header3) {
  return header3.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w2, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header3) {
  const accessorName = utils$1.toCamelCase(" " + header3);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header3, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header3, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader2(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils$1.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders2 = (headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader2(_value, _header, _rewrite));
    if (utils$1.isPlainObject(header3) || header3 instanceof this.constructor) {
      setHeaders2(header3, valueOrRewrite);
    } else if (utils$1.isString(header3) && (header3 = header3.trim()) && !isValidHeaderName(header3)) {
      setHeaders2(parseHeaders(header3), valueOrRewrite);
    } else {
      header3 != null && setHeader2(valueOrRewrite, header3, rewrite);
    }
    return this;
  }
  get(header3, parser) {
    header3 = normalizeHeader(header3);
    if (header3) {
      const key = utils$1.findKey(this, header3);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils$1.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils$1.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header3, matcher) {
    header3 = normalizeHeader(header3);
    if (header3) {
      const key = utils$1.findKey(this, header3);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header3, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils$1.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils$1.isArray(header3)) {
      header3.forEach(deleteHeader);
    } else {
      deleteHeader(header3);
    }
    return deleted;
  }
  clear(matcher) {
    const keys2 = Object.keys(this);
    let i = keys2.length;
    let deleted = false;
    while (i--) {
      const key = keys2[i];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format2) {
    const self2 = this;
    const headers = {};
    utils$1.forEach(this, (value, header3) => {
      const key = utils$1.findKey(headers, header3);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header3];
        return;
      }
      const normalized = format2 ? formatHeader(header3) : String(header3).trim();
      if (normalized !== header3) {
        delete self2[header3];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils$1.forEach(this, (value, header3) => {
      value != null && value !== false && (obj[header3] = asStrings && utils$1.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header3, value]) => header3 + ": " + value).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first2, ...targets) {
    const computed = new this(first2);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header3) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype2 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype2, _header);
        accessors[lHeader] = true;
      }
    }
    utils$1.isArray(header3) ? header3.forEach(defineAccessor) : defineAccessor(header3);
    return this;
  }
}
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils$1.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils$1.freezeMethods(AxiosHeaders);
const AxiosHeaders$1 = AxiosHeaders;
function transformData(fns, response2) {
  const config = this || defaults$1;
  const context = response2 || config;
  const headers = AxiosHeaders$1.from(context.headers);
  let data = context.data;
  utils$1.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response2 ? response2.status : void 0);
  });
  headers.normalize();
  return data;
}
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}
function CanceledError(message, config, request2) {
  AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config, request2);
  this.name = "CanceledError";
}
utils$1.inherits(CanceledError, AxiosError, {
  __CANCEL__: true
});
function settle(resolve3, reject, response2) {
  const validateStatus2 = response2.config.validateStatus;
  if (!response2.status || !validateStatus2 || validateStatus2(response2.status)) {
    resolve3(response2);
  } else {
    reject(new AxiosError(
      "Request failed with status code " + response2.status,
      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response2.status / 100) - 4],
      response2.config,
      response2.request,
      response2
    ));
  }
}
function isAbsoluteURL(url2) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url2);
}
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}
var parseUrl$1 = require$$0$6.parse;
var DEFAULT_PORTS = {
  ftp: 21,
  gopher: 70,
  http: 80,
  https: 443,
  ws: 80,
  wss: 443
};
var stringEndsWith = String.prototype.endsWith || function(s2) {
  return s2.length <= this.length && this.indexOf(s2, this.length - s2.length) !== -1;
};
function getProxyForUrl(url2) {
  var parsedUrl = typeof url2 === "string" ? parseUrl$1(url2) : url2 || {};
  var proto2 = parsedUrl.protocol;
  var hostname2 = parsedUrl.host;
  var port = parsedUrl.port;
  if (typeof hostname2 !== "string" || !hostname2 || typeof proto2 !== "string") {
    return "";
  }
  proto2 = proto2.split(":", 1)[0];
  hostname2 = hostname2.replace(/:\d*$/, "");
  port = parseInt(port) || DEFAULT_PORTS[proto2] || 0;
  if (!shouldProxy(hostname2, port)) {
    return "";
  }
  var proxy = getEnv("npm_config_" + proto2 + "_proxy") || getEnv(proto2 + "_proxy") || getEnv("npm_config_proxy") || getEnv("all_proxy");
  if (proxy && proxy.indexOf("://") === -1) {
    proxy = proto2 + "://" + proxy;
  }
  return proxy;
}
function shouldProxy(hostname2, port) {
  var NO_PROXY = (getEnv("npm_config_no_proxy") || getEnv("no_proxy")).toLowerCase();
  if (!NO_PROXY) {
    return true;
  }
  if (NO_PROXY === "*") {
    return false;
  }
  return NO_PROXY.split(/[,\s]/).every(function(proxy) {
    if (!proxy) {
      return true;
    }
    var parsedProxy = proxy.match(/^(.+):(\d+)$/);
    var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;
    var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
    if (parsedProxyPort && parsedProxyPort !== port) {
      return true;
    }
    if (!/^[.*]/.test(parsedProxyHostname)) {
      return hostname2 !== parsedProxyHostname;
    }
    if (parsedProxyHostname.charAt(0) === "*") {
      parsedProxyHostname = parsedProxyHostname.slice(1);
    }
    return !stringEndsWith.call(hostname2, parsedProxyHostname);
  });
}
function getEnv(key) {
  return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || "";
}
var getProxyForUrl_1 = getProxyForUrl;
var followRedirects$1 = { exports: {} };
var src = { exports: {} };
var browser = { exports: {} };
var ms;
var hasRequiredMs;
function requireMs() {
  if (hasRequiredMs)
    return ms;
  hasRequiredMs = 1;
  var s2 = 1e3;
  var m2 = s2 * 60;
  var h2 = m2 * 60;
  var d2 = h2 * 24;
  var w2 = d2 * 7;
  var y2 = d2 * 365.25;
  ms = function(val, options) {
    options = options || {};
    var type3 = typeof val;
    if (type3 === "string" && val.length > 0) {
      return parse2(val);
    } else if (type3 === "number" && isFinite(val)) {
      return options.long ? fmtLong2(val) : fmtShort2(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse2(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match2 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str
    );
    if (!match2) {
      return;
    }
    var n = parseFloat(match2[1]);
    var type3 = (match2[2] || "ms").toLowerCase();
    switch (type3) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y2;
      case "weeks":
      case "week":
      case "w":
        return n * w2;
      case "days":
      case "day":
      case "d":
        return n * d2;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h2;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m2;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s2;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort2(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d2) {
      return Math.round(ms2 / d2) + "d";
    }
    if (msAbs >= h2) {
      return Math.round(ms2 / h2) + "h";
    }
    if (msAbs >= m2) {
      return Math.round(ms2 / m2) + "m";
    }
    if (msAbs >= s2) {
      return Math.round(ms2 / s2) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong2(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d2) {
      return plural2(ms2, msAbs, d2, "day");
    }
    if (msAbs >= h2) {
      return plural2(ms2, msAbs, h2, "hour");
    }
    if (msAbs >= m2) {
      return plural2(ms2, msAbs, m2, "minute");
    }
    if (msAbs >= s2) {
      return plural2(ms2, msAbs, s2, "second");
    }
    return ms2 + " ms";
  }
  function plural2(ms2, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
  }
  return ms;
}
var common;
var hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon)
    return common;
  hasRequiredCommon = 1;
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = requireMs();
    createDebug.destroy = destroy2;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug2(...args) {
        if (!debug2.enabled) {
          return;
        }
        const self2 = debug2;
        const curr = Number(/* @__PURE__ */ new Date());
        const ms2 = curr - (prevTime || curr);
        self2.diff = ms2;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index2 = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match2, format2) => {
          if (match2 === "%%") {
            return "%";
          }
          index2++;
          const formatter = createDebug.formatters[format2];
          if (typeof formatter === "function") {
            const val = args[index2];
            match2 = formatter.call(self2, val);
            args.splice(index2, 1);
            index2--;
          }
          return match2;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug2.namespace = namespace;
      debug2.useColors = createDebug.useColors();
      debug2.color = createDebug.selectColor(namespace);
      debug2.extend = extend2;
      debug2.destroy = createDebug.destroy;
      Object.defineProperty(debug2, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v2) => {
          enableOverride = v2;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug2);
      }
      return debug2;
    }
    function extend2(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      let i;
      const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len = split.length;
      for (i = 0; i < len; i++) {
        if (!split[i]) {
          continue;
        }
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      if (name[name.length - 1] === "*") {
        return true;
      }
      let i;
      let len;
      for (i = 0, len = createDebug.skips.length; i < len; i++) {
        if (createDebug.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = createDebug.names.length; i < len; i++) {
        if (createDebug.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy2() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  common = setup;
  return common;
}
var hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser)
    return browser.exports;
  hasRequiredBrowser = 1;
  (function(module, exports) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c2 = "color: " + this.color;
      args.splice(1, 0, c2, "color: inherit");
      let index2 = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match2) => {
        if (match2 === "%%") {
          return;
        }
        index2++;
        if (match2 === "%c") {
          lastC = index2;
        }
      });
      args.splice(lastC, 0, c2);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error2) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error2) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error2) {
      }
    }
    module.exports = requireCommon()(exports);
    const { formatters } = module.exports;
    formatters.j = function(v2) {
      try {
        return JSON.stringify(v2);
      } catch (error2) {
        return "[UnexpectedJSONParseError]: " + error2.message;
      }
    };
  })(browser, browser.exports);
  return browser.exports;
}
var node = { exports: {} };
var hasFlag;
var hasRequiredHasFlag;
function requireHasFlag() {
  if (hasRequiredHasFlag)
    return hasFlag;
  hasRequiredHasFlag = 1;
  hasFlag = (flag, argv = process.argv) => {
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf("--");
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
  };
  return hasFlag;
}
var supportsColor_1;
var hasRequiredSupportsColor;
function requireSupportsColor() {
  if (hasRequiredSupportsColor)
    return supportsColor_1;
  hasRequiredSupportsColor = 1;
  const os = require$$0$9;
  const tty = require$$0$3;
  const hasFlag2 = requireHasFlag();
  const { env } = process;
  let forceColor;
  if (hasFlag2("no-color") || hasFlag2("no-colors") || hasFlag2("color=false") || hasFlag2("color=never")) {
    forceColor = 0;
  } else if (hasFlag2("color") || hasFlag2("colors") || hasFlag2("color=true") || hasFlag2("color=always")) {
    forceColor = 1;
  }
  if ("FORCE_COLOR" in env) {
    if (env.FORCE_COLOR === "true") {
      forceColor = 1;
    } else if (env.FORCE_COLOR === "false") {
      forceColor = 0;
    } else {
      forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
    }
  }
  function translateLevel(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }
  function supportsColor(haveStream, streamIsTTY) {
    if (forceColor === 0) {
      return 0;
    }
    if (hasFlag2("color=16m") || hasFlag2("color=full") || hasFlag2("color=truecolor")) {
      return 3;
    }
    if (hasFlag2("color=256")) {
      return 2;
    }
    if (haveStream && !streamIsTTY && forceColor === void 0) {
      return 0;
    }
    const min = forceColor || 0;
    if (env.TERM === "dumb") {
      return min;
    }
    if (process.platform === "win32") {
      const osRelease = os.release().split(".");
      if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign2) => sign2 in env) || env.CI_NAME === "codeship") {
        return 1;
      }
      return min;
    }
    if ("TEAMCITY_VERSION" in env) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env.COLORTERM === "truecolor") {
      return 3;
    }
    if ("TERM_PROGRAM" in env) {
      const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env.TERM_PROGRAM) {
        case "iTerm.app":
          return version >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env) {
      return 1;
    }
    return min;
  }
  function getSupportLevel(stream3) {
    const level = supportsColor(stream3, stream3 && stream3.isTTY);
    return translateLevel(level);
  }
  supportsColor_1 = {
    supportsColor: getSupportLevel,
    stdout: translateLevel(supportsColor(true, tty.isatty(1))),
    stderr: translateLevel(supportsColor(true, tty.isatty(2)))
  };
  return supportsColor_1;
}
var hasRequiredNode;
function requireNode() {
  if (hasRequiredNode)
    return node.exports;
  hasRequiredNode = 1;
  (function(module, exports) {
    const tty = require$$0$3;
    const util2 = require$$1$1;
    exports.init = init2;
    exports.log = log2;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.destroy = util2.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = requireSupportsColor();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error2) {
    }
    exports.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_2, k2) => {
        return k2.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c2 = this.color;
        const colorCode = "\x1B[3" + (c2 < 8 ? c2 : "8;5;" + c2);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log2(...args) {
      return process.stderr.write(util2.format(...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init2(debug2) {
      debug2.inspectOpts = {};
      const keys2 = Object.keys(exports.inspectOpts);
      for (let i = 0; i < keys2.length; i++) {
        debug2.inspectOpts[keys2[i]] = exports.inspectOpts[keys2[i]];
      }
    }
    module.exports = requireCommon()(exports);
    const { formatters } = module.exports;
    formatters.o = function(v2) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v2, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v2) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v2, this.inspectOpts);
    };
  })(node, node.exports);
  return node.exports;
}
var hasRequiredSrc;
function requireSrc() {
  if (hasRequiredSrc)
    return src.exports;
  hasRequiredSrc = 1;
  if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
    src.exports = requireBrowser();
  } else {
    src.exports = requireNode();
  }
  return src.exports;
}
var debug$1;
var debug_1 = function() {
  if (!debug$1) {
    try {
      debug$1 = requireSrc()("follow-redirects");
    } catch (error2) {
    }
    if (typeof debug$1 !== "function") {
      debug$1 = function() {
      };
    }
  }
  debug$1.apply(null, arguments);
};
var url = require$$0$6;
var URL$1 = url.URL;
var http = require$$0$7;
var https = require$$4$2;
var Writable = stream.Writable;
var assert = require$$4$3;
var debug = debug_1;
var useNativeURL = false;
try {
  assert(new URL$1());
} catch (error2) {
  useNativeURL = error2.code === "ERR_INVALID_URL";
}
var preservedUrlFields = [
  "auth",
  "host",
  "hostname",
  "href",
  "path",
  "pathname",
  "port",
  "protocol",
  "query",
  "search",
  "hash"
];
var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
var eventHandlers = /* @__PURE__ */ Object.create(null);
events.forEach(function(event) {
  eventHandlers[event] = function(arg1, arg2, arg3) {
    this._redirectable.emit(event, arg1, arg2, arg3);
  };
});
var InvalidUrlError = createErrorType(
  "ERR_INVALID_URL",
  "Invalid URL",
  TypeError
);
var RedirectionError = createErrorType(
  "ERR_FR_REDIRECTION_FAILURE",
  "Redirected request failed"
);
var TooManyRedirectsError = createErrorType(
  "ERR_FR_TOO_MANY_REDIRECTS",
  "Maximum number of redirects exceeded",
  RedirectionError
);
var MaxBodyLengthExceededError = createErrorType(
  "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
  "Request body larger than maxBodyLength limit"
);
var WriteAfterEndError = createErrorType(
  "ERR_STREAM_WRITE_AFTER_END",
  "write after end"
);
var destroy = Writable.prototype.destroy || noop;
function RedirectableRequest(options, responseCallback) {
  Writable.call(this);
  this._sanitizeOptions(options);
  this._options = options;
  this._ended = false;
  this._ending = false;
  this._redirectCount = 0;
  this._redirects = [];
  this._requestBodyLength = 0;
  this._requestBodyBuffers = [];
  if (responseCallback) {
    this.on("response", responseCallback);
  }
  var self2 = this;
  this._onNativeResponse = function(response2) {
    try {
      self2._processResponse(response2);
    } catch (cause) {
      self2.emit("error", cause instanceof RedirectionError ? cause : new RedirectionError({ cause }));
    }
  };
  this._performRequest();
}
RedirectableRequest.prototype = Object.create(Writable.prototype);
RedirectableRequest.prototype.abort = function() {
  destroyRequest(this._currentRequest);
  this._currentRequest.abort();
  this.emit("abort");
};
RedirectableRequest.prototype.destroy = function(error2) {
  destroyRequest(this._currentRequest, error2);
  destroy.call(this, error2);
  return this;
};
RedirectableRequest.prototype.write = function(data, encoding3, callback) {
  if (this._ending) {
    throw new WriteAfterEndError();
  }
  if (!isString$1(data) && !isBuffer$4(data)) {
    throw new TypeError("data should be a string, Buffer or Uint8Array");
  }
  if (isFunction$3(encoding3)) {
    callback = encoding3;
    encoding3 = null;
  }
  if (data.length === 0) {
    if (callback) {
      callback();
    }
    return;
  }
  if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
    this._requestBodyLength += data.length;
    this._requestBodyBuffers.push({ data, encoding: encoding3 });
    this._currentRequest.write(data, encoding3, callback);
  } else {
    this.emit("error", new MaxBodyLengthExceededError());
    this.abort();
  }
};
RedirectableRequest.prototype.end = function(data, encoding3, callback) {
  if (isFunction$3(data)) {
    callback = data;
    data = encoding3 = null;
  } else if (isFunction$3(encoding3)) {
    callback = encoding3;
    encoding3 = null;
  }
  if (!data) {
    this._ended = this._ending = true;
    this._currentRequest.end(null, null, callback);
  } else {
    var self2 = this;
    var currentRequest = this._currentRequest;
    this.write(data, encoding3, function() {
      self2._ended = true;
      currentRequest.end(null, null, callback);
    });
    this._ending = true;
  }
};
RedirectableRequest.prototype.setHeader = function(name, value) {
  this._options.headers[name] = value;
  this._currentRequest.setHeader(name, value);
};
RedirectableRequest.prototype.removeHeader = function(name) {
  delete this._options.headers[name];
  this._currentRequest.removeHeader(name);
};
RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
  var self2 = this;
  function destroyOnTimeout(socket) {
    socket.setTimeout(msecs);
    socket.removeListener("timeout", socket.destroy);
    socket.addListener("timeout", socket.destroy);
  }
  function startTimer(socket) {
    if (self2._timeout) {
      clearTimeout(self2._timeout);
    }
    self2._timeout = setTimeout(function() {
      self2.emit("timeout");
      clearTimer();
    }, msecs);
    destroyOnTimeout(socket);
  }
  function clearTimer() {
    if (self2._timeout) {
      clearTimeout(self2._timeout);
      self2._timeout = null;
    }
    self2.removeListener("abort", clearTimer);
    self2.removeListener("error", clearTimer);
    self2.removeListener("response", clearTimer);
    self2.removeListener("close", clearTimer);
    if (callback) {
      self2.removeListener("timeout", callback);
    }
    if (!self2.socket) {
      self2._currentRequest.removeListener("socket", startTimer);
    }
  }
  if (callback) {
    this.on("timeout", callback);
  }
  if (this.socket) {
    startTimer(this.socket);
  } else {
    this._currentRequest.once("socket", startTimer);
  }
  this.on("socket", destroyOnTimeout);
  this.on("abort", clearTimer);
  this.on("error", clearTimer);
  this.on("response", clearTimer);
  this.on("close", clearTimer);
  return this;
};
[
  "flushHeaders",
  "getHeader",
  "setNoDelay",
  "setSocketKeepAlive"
].forEach(function(method) {
  RedirectableRequest.prototype[method] = function(a, b2) {
    return this._currentRequest[method](a, b2);
  };
});
["aborted", "connection", "socket"].forEach(function(property2) {
  Object.defineProperty(RedirectableRequest.prototype, property2, {
    get: function() {
      return this._currentRequest[property2];
    }
  });
});
RedirectableRequest.prototype._sanitizeOptions = function(options) {
  if (!options.headers) {
    options.headers = {};
  }
  if (options.host) {
    if (!options.hostname) {
      options.hostname = options.host;
    }
    delete options.host;
  }
  if (!options.pathname && options.path) {
    var searchPos = options.path.indexOf("?");
    if (searchPos < 0) {
      options.pathname = options.path;
    } else {
      options.pathname = options.path.substring(0, searchPos);
      options.search = options.path.substring(searchPos);
    }
  }
};
RedirectableRequest.prototype._performRequest = function() {
  var protocol2 = this._options.protocol;
  var nativeProtocol = this._options.nativeProtocols[protocol2];
  if (!nativeProtocol) {
    throw new TypeError("Unsupported protocol " + protocol2);
  }
  if (this._options.agents) {
    var scheme = protocol2.slice(0, -1);
    this._options.agent = this._options.agents[scheme];
  }
  var request2 = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
  request2._redirectable = this;
  for (var event of events) {
    request2.on(event, eventHandlers[event]);
  }
  this._currentUrl = /^\//.test(this._options.path) ? url.format(this._options) : (
    // When making a request to a proxy, [â€¦]
    // a client MUST send the target URI in absolute-form [â€¦].
    this._options.path
  );
  if (this._isRedirect) {
    var i = 0;
    var self2 = this;
    var buffers = this._requestBodyBuffers;
    (function writeNext(error2) {
      if (request2 === self2._currentRequest) {
        if (error2) {
          self2.emit("error", error2);
        } else if (i < buffers.length) {
          var buffer = buffers[i++];
          if (!request2.finished) {
            request2.write(buffer.data, buffer.encoding, writeNext);
          }
        } else if (self2._ended) {
          request2.end();
        }
      }
    })();
  }
};
RedirectableRequest.prototype._processResponse = function(response2) {
  var statusCode = response2.statusCode;
  if (this._options.trackRedirects) {
    this._redirects.push({
      url: this._currentUrl,
      headers: response2.headers,
      statusCode
    });
  }
  var location2 = response2.headers.location;
  if (!location2 || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {
    response2.responseUrl = this._currentUrl;
    response2.redirects = this._redirects;
    this.emit("response", response2);
    this._requestBodyBuffers = [];
    return;
  }
  destroyRequest(this._currentRequest);
  response2.destroy();
  if (++this._redirectCount > this._options.maxRedirects) {
    throw new TooManyRedirectsError();
  }
  var requestHeaders;
  var beforeRedirect = this._options.beforeRedirect;
  if (beforeRedirect) {
    requestHeaders = Object.assign({
      // The Host header was set by nativeProtocol.request
      Host: response2.req.getHeader("host")
    }, this._options.headers);
  }
  var method = this._options.method;
  if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || // RFC7231Â§6.4.4: The 303 (See Other) status code indicates that
  // the server is redirecting the user agent to a different resource [â€¦]
  // A user agent can perform a retrieval request targeting that URI
  // (a GET or HEAD request if using HTTP) [â€¦]
  statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
    this._options.method = "GET";
    this._requestBodyBuffers = [];
    removeMatchingHeaders(/^content-/i, this._options.headers);
  }
  var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
  var currentUrlParts = parseUrl(this._currentUrl);
  var currentHost = currentHostHeader || currentUrlParts.host;
  var currentUrl = /^\w+:/.test(location2) ? this._currentUrl : url.format(Object.assign(currentUrlParts, { host: currentHost }));
  var redirectUrl = resolveUrl(location2, currentUrl);
  debug("redirecting to", redirectUrl.href);
  this._isRedirect = true;
  spreadUrlObject(redirectUrl, this._options);
  if (redirectUrl.protocol !== currentUrlParts.protocol && redirectUrl.protocol !== "https:" || redirectUrl.host !== currentHost && !isSubdomain(redirectUrl.host, currentHost)) {
    removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);
  }
  if (isFunction$3(beforeRedirect)) {
    var responseDetails = {
      headers: response2.headers,
      statusCode
    };
    var requestDetails = {
      url: currentUrl,
      method,
      headers: requestHeaders
    };
    beforeRedirect(this._options, responseDetails, requestDetails);
    this._sanitizeOptions(this._options);
  }
  this._performRequest();
};
function wrap(protocols) {
  var exports = {
    maxRedirects: 21,
    maxBodyLength: 10 * 1024 * 1024
  };
  var nativeProtocols = {};
  Object.keys(protocols).forEach(function(scheme) {
    var protocol2 = scheme + ":";
    var nativeProtocol = nativeProtocols[protocol2] = protocols[scheme];
    var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol);
    function request2(input, options, callback) {
      if (isURL(input)) {
        input = spreadUrlObject(input);
      } else if (isString$1(input)) {
        input = spreadUrlObject(parseUrl(input));
      } else {
        callback = options;
        options = validateUrl(input);
        input = { protocol: protocol2 };
      }
      if (isFunction$3(options)) {
        callback = options;
        options = null;
      }
      options = Object.assign({
        maxRedirects: exports.maxRedirects,
        maxBodyLength: exports.maxBodyLength
      }, input, options);
      options.nativeProtocols = nativeProtocols;
      if (!isString$1(options.host) && !isString$1(options.hostname)) {
        options.hostname = "::1";
      }
      assert.equal(options.protocol, protocol2, "protocol mismatch");
      debug("options", options);
      return new RedirectableRequest(options, callback);
    }
    function get2(input, options, callback) {
      var wrappedRequest = wrappedProtocol.request(input, options, callback);
      wrappedRequest.end();
      return wrappedRequest;
    }
    Object.defineProperties(wrappedProtocol, {
      request: { value: request2, configurable: true, enumerable: true, writable: true },
      get: { value: get2, configurable: true, enumerable: true, writable: true }
    });
  });
  return exports;
}
function noop() {
}
function parseUrl(input) {
  var parsed;
  if (useNativeURL) {
    parsed = new URL$1(input);
  } else {
    parsed = validateUrl(url.parse(input));
    if (!isString$1(parsed.protocol)) {
      throw new InvalidUrlError({ input });
    }
  }
  return parsed;
}
function resolveUrl(relative2, base) {
  return useNativeURL ? new URL$1(relative2, base) : parseUrl(url.resolve(base, relative2));
}
function validateUrl(input) {
  if (/^\[/.test(input.hostname) && !/^\[[:0-9a-f]+\]$/i.test(input.hostname)) {
    throw new InvalidUrlError({ input: input.href || input });
  }
  if (/^\[/.test(input.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(input.host)) {
    throw new InvalidUrlError({ input: input.href || input });
  }
  return input;
}
function spreadUrlObject(urlObject, target) {
  var spread2 = target || {};
  for (var key of preservedUrlFields) {
    spread2[key] = urlObject[key];
  }
  if (spread2.hostname.startsWith("[")) {
    spread2.hostname = spread2.hostname.slice(1, -1);
  }
  if (spread2.port !== "") {
    spread2.port = Number(spread2.port);
  }
  spread2.path = spread2.search ? spread2.pathname + spread2.search : spread2.pathname;
  return spread2;
}
function removeMatchingHeaders(regex, headers) {
  var lastValue;
  for (var header3 in headers) {
    if (regex.test(header3)) {
      lastValue = headers[header3];
      delete headers[header3];
    }
  }
  return lastValue === null || typeof lastValue === "undefined" ? void 0 : String(lastValue).trim();
}
function createErrorType(code, message, baseClass) {
  function CustomError(properties) {
    Error.captureStackTrace(this, this.constructor);
    Object.assign(this, properties || {});
    this.code = code;
    this.message = this.cause ? message + ": " + this.cause.message : message;
  }
  CustomError.prototype = new (baseClass || Error)();
  Object.defineProperties(CustomError.prototype, {
    constructor: {
      value: CustomError,
      enumerable: false
    },
    name: {
      value: "Error [" + code + "]",
      enumerable: false
    }
  });
  return CustomError;
}
function destroyRequest(request2, error2) {
  for (var event of events) {
    request2.removeListener(event, eventHandlers[event]);
  }
  request2.on("error", noop);
  request2.destroy(error2);
}
function isSubdomain(subdomain, domain) {
  assert(isString$1(subdomain) && isString$1(domain));
  var dot = subdomain.length - domain.length - 1;
  return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
}
function isString$1(value) {
  return typeof value === "string" || value instanceof String;
}
function isFunction$3(value) {
  return typeof value === "function";
}
function isBuffer$4(value) {
  return typeof value === "object" && "length" in value;
}
function isURL(value) {
  return URL$1 && value instanceof URL$1;
}
followRedirects$1.exports = wrap({ http, https });
followRedirects$1.exports.wrap = wrap;
var followRedirectsExports = followRedirects$1.exports;
const followRedirects = /* @__PURE__ */ getDefaultExportFromCjs(followRedirectsExports);
const VERSION = "1.6.8";
function parseProtocol(url2) {
  const match2 = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url2);
  return match2 && match2[1] || "";
}
const DATA_URL_PATTERN = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\s\S]*)$/;
function fromDataURI(uri2, asBlob, options) {
  const _Blob = options && options.Blob || platform.classes.Blob;
  const protocol2 = parseProtocol(uri2);
  if (asBlob === void 0 && _Blob) {
    asBlob = true;
  }
  if (protocol2 === "data") {
    uri2 = protocol2.length ? uri2.slice(protocol2.length + 1) : uri2;
    const match2 = DATA_URL_PATTERN.exec(uri2);
    if (!match2) {
      throw new AxiosError("Invalid URL", AxiosError.ERR_INVALID_URL);
    }
    const mime2 = match2[1];
    const isBase64 = match2[2];
    const body = match2[3];
    const buffer = Buffer.from(decodeURIComponent(body), isBase64 ? "base64" : "utf8");
    if (asBlob) {
      if (!_Blob) {
        throw new AxiosError("Blob is not supported", AxiosError.ERR_NOT_SUPPORT);
      }
      return new _Blob([buffer], { type: mime2 });
    }
    return buffer;
  }
  throw new AxiosError("Unsupported protocol " + protocol2, AxiosError.ERR_NOT_SUPPORT);
}
function throttle(fn, freq) {
  let timestamp = 0;
  const threshold = 1e3 / freq;
  let timer = null;
  return function throttled(force, args) {
    const now = Date.now();
    if (force || now - timestamp > threshold) {
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
      timestamp = now;
      return fn.apply(null, args);
    }
    if (!timer) {
      timer = setTimeout(() => {
        timer = null;
        timestamp = Date.now();
        return fn.apply(null, args);
      }, threshold - (now - timestamp));
    }
  };
}
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes2 = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== void 0 ? min : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes2[head] = chunkLength;
    timestamps[head] = now;
    let i = tail;
    let bytesCount = 0;
    while (i !== head) {
      bytesCount += bytes2[i++];
      i = i % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
const kInternals = Symbol("internals");
class AxiosTransformStream extends stream.Transform {
  constructor(options) {
    options = utils$1.toFlatObject(options, {
      maxRate: 0,
      chunkSize: 64 * 1024,
      minChunkSize: 100,
      timeWindow: 500,
      ticksRate: 2,
      samplesCount: 15
    }, null, (prop, source) => {
      return !utils$1.isUndefined(source[prop]);
    });
    super({
      readableHighWaterMark: options.chunkSize
    });
    const self2 = this;
    const internals = this[kInternals] = {
      length: options.length,
      timeWindow: options.timeWindow,
      ticksRate: options.ticksRate,
      chunkSize: options.chunkSize,
      maxRate: options.maxRate,
      minChunkSize: options.minChunkSize,
      bytesSeen: 0,
      isCaptured: false,
      notifiedBytesLoaded: 0,
      ts: Date.now(),
      bytes: 0,
      onReadCallback: null
    };
    const _speedometer = speedometer(internals.ticksRate * options.samplesCount, internals.timeWindow);
    this.on("newListener", (event) => {
      if (event === "progress") {
        if (!internals.isCaptured) {
          internals.isCaptured = true;
        }
      }
    });
    let bytesNotified = 0;
    internals.updateProgress = throttle(function throttledHandler() {
      const totalBytes = internals.length;
      const bytesTransferred = internals.bytesSeen;
      const progressBytes = bytesTransferred - bytesNotified;
      if (!progressBytes || self2.destroyed)
        return;
      const rate = _speedometer(progressBytes);
      bytesNotified = bytesTransferred;
      process.nextTick(() => {
        self2.emit("progress", {
          "loaded": bytesTransferred,
          "total": totalBytes,
          "progress": totalBytes ? bytesTransferred / totalBytes : void 0,
          "bytes": progressBytes,
          "rate": rate ? rate : void 0,
          "estimated": rate && totalBytes && bytesTransferred <= totalBytes ? (totalBytes - bytesTransferred) / rate : void 0
        });
      });
    }, internals.ticksRate);
    const onFinish = () => {
      internals.updateProgress(true);
    };
    this.once("end", onFinish);
    this.once("error", onFinish);
  }
  _read(size) {
    const internals = this[kInternals];
    if (internals.onReadCallback) {
      internals.onReadCallback();
    }
    return super._read(size);
  }
  _transform(chunk, encoding3, callback) {
    const self2 = this;
    const internals = this[kInternals];
    const maxRate = internals.maxRate;
    const readableHighWaterMark = this.readableHighWaterMark;
    const timeWindow = internals.timeWindow;
    const divider = 1e3 / timeWindow;
    const bytesThreshold = maxRate / divider;
    const minChunkSize = internals.minChunkSize !== false ? Math.max(internals.minChunkSize, bytesThreshold * 0.01) : 0;
    function pushChunk(_chunk, _callback) {
      const bytes2 = Buffer.byteLength(_chunk);
      internals.bytesSeen += bytes2;
      internals.bytes += bytes2;
      if (internals.isCaptured) {
        internals.updateProgress();
      }
      if (self2.push(_chunk)) {
        process.nextTick(_callback);
      } else {
        internals.onReadCallback = () => {
          internals.onReadCallback = null;
          process.nextTick(_callback);
        };
      }
    }
    const transformChunk = (_chunk, _callback) => {
      const chunkSize = Buffer.byteLength(_chunk);
      let chunkRemainder = null;
      let maxChunkSize = readableHighWaterMark;
      let bytesLeft;
      let passed = 0;
      if (maxRate) {
        const now = Date.now();
        if (!internals.ts || (passed = now - internals.ts) >= timeWindow) {
          internals.ts = now;
          bytesLeft = bytesThreshold - internals.bytes;
          internals.bytes = bytesLeft < 0 ? -bytesLeft : 0;
          passed = 0;
        }
        bytesLeft = bytesThreshold - internals.bytes;
      }
      if (maxRate) {
        if (bytesLeft <= 0) {
          return setTimeout(() => {
            _callback(null, _chunk);
          }, timeWindow - passed);
        }
        if (bytesLeft < maxChunkSize) {
          maxChunkSize = bytesLeft;
        }
      }
      if (maxChunkSize && chunkSize > maxChunkSize && chunkSize - maxChunkSize > minChunkSize) {
        chunkRemainder = _chunk.subarray(maxChunkSize);
        _chunk = _chunk.subarray(0, maxChunkSize);
      }
      pushChunk(_chunk, chunkRemainder ? () => {
        process.nextTick(_callback, null, chunkRemainder);
      } : _callback);
    };
    transformChunk(chunk, function transformNextChunk(err, _chunk) {
      if (err) {
        return callback(err);
      }
      if (_chunk) {
        transformChunk(_chunk, transformNextChunk);
      } else {
        callback(null);
      }
    });
  }
  setLength(length) {
    this[kInternals].length = +length;
    return this;
  }
}
const AxiosTransformStream$1 = AxiosTransformStream;
const { asyncIterator } = Symbol;
const readBlob = async function* (blob) {
  if (blob.stream) {
    yield* blob.stream();
  } else if (blob.arrayBuffer) {
    yield await blob.arrayBuffer();
  } else if (blob[asyncIterator]) {
    yield* blob[asyncIterator]();
  } else {
    yield blob;
  }
};
const BOUNDARY_ALPHABET = utils$1.ALPHABET.ALPHA_DIGIT + "-_";
const textEncoder = new require$$1$1.TextEncoder();
const CRLF = "\r\n";
const CRLF_BYTES = textEncoder.encode(CRLF);
const CRLF_BYTES_COUNT = 2;
class FormDataPart {
  constructor(name, value) {
    const { escapeName } = this.constructor;
    const isStringValue = utils$1.isString(value);
    let headers = `Content-Disposition: form-data; name="${escapeName(name)}"${!isStringValue && value.name ? `; filename="${escapeName(value.name)}"` : ""}${CRLF}`;
    if (isStringValue) {
      value = textEncoder.encode(String(value).replace(/\r?\n|\r\n?/g, CRLF));
    } else {
      headers += `Content-Type: ${value.type || "application/octet-stream"}${CRLF}`;
    }
    this.headers = textEncoder.encode(headers + CRLF);
    this.contentLength = isStringValue ? value.byteLength : value.size;
    this.size = this.headers.byteLength + this.contentLength + CRLF_BYTES_COUNT;
    this.name = name;
    this.value = value;
  }
  async *encode() {
    yield this.headers;
    const { value } = this;
    if (utils$1.isTypedArray(value)) {
      yield value;
    } else {
      yield* readBlob(value);
    }
    yield CRLF_BYTES;
  }
  static escapeName(name) {
    return String(name).replace(/[\r\n"]/g, (match2) => ({
      "\r": "%0D",
      "\n": "%0A",
      '"': "%22"
    })[match2]);
  }
}
const formDataToStream = (form, headersHandler, options) => {
  const {
    tag = "form-data-boundary",
    size = 25,
    boundary = tag + "-" + utils$1.generateString(size, BOUNDARY_ALPHABET)
  } = options || {};
  if (!utils$1.isFormData(form)) {
    throw TypeError("FormData instance required");
  }
  if (boundary.length < 1 || boundary.length > 70) {
    throw Error("boundary must be 10-70 characters long");
  }
  const boundaryBytes = textEncoder.encode("--" + boundary + CRLF);
  const footerBytes = textEncoder.encode("--" + boundary + "--" + CRLF + CRLF);
  let contentLength = footerBytes.byteLength;
  const parts = Array.from(form.entries()).map(([name, value]) => {
    const part = new FormDataPart(name, value);
    contentLength += part.size;
    return part;
  });
  contentLength += boundaryBytes.byteLength * parts.length;
  contentLength = utils$1.toFiniteNumber(contentLength);
  const computedHeaders = {
    "Content-Type": `multipart/form-data; boundary=${boundary}`
  };
  if (Number.isFinite(contentLength)) {
    computedHeaders["Content-Length"] = contentLength;
  }
  headersHandler && headersHandler(computedHeaders);
  return stream.Readable.from(async function* () {
    for (const part of parts) {
      yield boundaryBytes;
      yield* part.encode();
    }
    yield footerBytes;
  }());
};
class ZlibHeaderTransformStream extends stream.Transform {
  __transform(chunk, encoding3, callback) {
    this.push(chunk);
    callback();
  }
  _transform(chunk, encoding3, callback) {
    if (chunk.length !== 0) {
      this._transform = this.__transform;
      if (chunk[0] !== 120) {
        const header3 = Buffer.alloc(2);
        header3[0] = 120;
        header3[1] = 156;
        this.push(header3, encoding3);
      }
    }
    this.__transform(chunk, encoding3, callback);
  }
}
const callbackify = (fn, reducer) => {
  return utils$1.isAsyncFn(fn) ? function(...args) {
    const cb = args.pop();
    fn.apply(this, args).then((value) => {
      try {
        reducer ? cb(null, ...reducer(value)) : cb(null, value);
      } catch (err) {
        cb(err);
      }
    }, cb);
  } : fn;
};
const zlibOptions = {
  flush: zlib.constants.Z_SYNC_FLUSH,
  finishFlush: zlib.constants.Z_SYNC_FLUSH
};
const brotliOptions = {
  flush: zlib.constants.BROTLI_OPERATION_FLUSH,
  finishFlush: zlib.constants.BROTLI_OPERATION_FLUSH
};
const isBrotliSupported = utils$1.isFunction(zlib.createBrotliDecompress);
const { http: httpFollow, https: httpsFollow } = followRedirects;
const isHttps = /https:?/;
const supportedProtocols = platform.protocols.map((protocol2) => {
  return protocol2 + ":";
});
function dispatchBeforeRedirect(options, responseDetails) {
  if (options.beforeRedirects.proxy) {
    options.beforeRedirects.proxy(options);
  }
  if (options.beforeRedirects.config) {
    options.beforeRedirects.config(options, responseDetails);
  }
}
function setProxy(options, configProxy, location2) {
  let proxy = configProxy;
  if (!proxy && proxy !== false) {
    const proxyUrl = getProxyForUrl_1(location2);
    if (proxyUrl) {
      proxy = new URL(proxyUrl);
    }
  }
  if (proxy) {
    if (proxy.username) {
      proxy.auth = (proxy.username || "") + ":" + (proxy.password || "");
    }
    if (proxy.auth) {
      if (proxy.auth.username || proxy.auth.password) {
        proxy.auth = (proxy.auth.username || "") + ":" + (proxy.auth.password || "");
      }
      const base64 = Buffer.from(proxy.auth, "utf8").toString("base64");
      options.headers["Proxy-Authorization"] = "Basic " + base64;
    }
    options.headers.host = options.hostname + (options.port ? ":" + options.port : "");
    const proxyHost = proxy.hostname || proxy.host;
    options.hostname = proxyHost;
    options.host = proxyHost;
    options.port = proxy.port;
    options.path = location2;
    if (proxy.protocol) {
      options.protocol = proxy.protocol.includes(":") ? proxy.protocol : `${proxy.protocol}:`;
    }
  }
  options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {
    setProxy(redirectOptions, configProxy, redirectOptions.href);
  };
}
const isHttpAdapterSupported = typeof process !== "undefined" && utils$1.kindOf(process) === "process";
const wrapAsync = (asyncExecutor) => {
  return new Promise((resolve3, reject) => {
    let onDone;
    let isDone;
    const done = (value, isRejected) => {
      if (isDone)
        return;
      isDone = true;
      onDone && onDone(value, isRejected);
    };
    const _resolve = (value) => {
      done(value);
      resolve3(value);
    };
    const _reject = (reason) => {
      done(reason, true);
      reject(reason);
    };
    asyncExecutor(_resolve, _reject, (onDoneHandler) => onDone = onDoneHandler).catch(_reject);
  });
};
const resolveFamily = ({ address, family }) => {
  if (!utils$1.isString(address)) {
    throw TypeError("address must be a string");
  }
  return {
    address,
    family: family || (address.indexOf(".") < 0 ? 6 : 4)
  };
};
const buildAddressEntry = (address, family) => resolveFamily(utils$1.isObject(address) ? address : { address, family });
const httpAdapter = isHttpAdapterSupported && function httpAdapter2(config) {
  return wrapAsync(async function dispatchHttpRequest(resolve3, reject, onDone) {
    let { data, lookup: lookup2, family } = config;
    const { responseType, responseEncoding } = config;
    const method = config.method.toUpperCase();
    let isDone;
    let rejected = false;
    let req2;
    if (lookup2) {
      const _lookup = callbackify(lookup2, (value) => utils$1.isArray(value) ? value : [value]);
      lookup2 = (hostname2, opt, cb) => {
        _lookup(hostname2, opt, (err, arg0, arg1) => {
          if (err) {
            return cb(err);
          }
          const addresses = utils$1.isArray(arg0) ? arg0.map((addr) => buildAddressEntry(addr)) : [buildAddressEntry(arg0, arg1)];
          opt.all ? cb(err, addresses) : cb(err, addresses[0].address, addresses[0].family);
        });
      };
    }
    const emitter = new require$$0$4.EventEmitter();
    const onFinished2 = () => {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(abort2);
      }
      if (config.signal) {
        config.signal.removeEventListener("abort", abort2);
      }
      emitter.removeAllListeners();
    };
    onDone((value, isRejected) => {
      isDone = true;
      if (isRejected) {
        rejected = true;
        onFinished2();
      }
    });
    function abort2(reason) {
      emitter.emit("abort", !reason || reason.type ? new CanceledError(null, config, req2) : reason);
    }
    emitter.once("abort", reject);
    if (config.cancelToken || config.signal) {
      config.cancelToken && config.cancelToken.subscribe(abort2);
      if (config.signal) {
        config.signal.aborted ? abort2() : config.signal.addEventListener("abort", abort2);
      }
    }
    const fullPath = buildFullPath(config.baseURL, config.url);
    const parsed = new URL(fullPath, "http://localhost");
    const protocol2 = parsed.protocol || supportedProtocols[0];
    if (protocol2 === "data:") {
      let convertedData;
      if (method !== "GET") {
        return settle(resolve3, reject, {
          status: 405,
          statusText: "method not allowed",
          headers: {},
          config
        });
      }
      try {
        convertedData = fromDataURI(config.url, responseType === "blob", {
          Blob: config.env && config.env.Blob
        });
      } catch (err) {
        throw AxiosError.from(err, AxiosError.ERR_BAD_REQUEST, config);
      }
      if (responseType === "text") {
        convertedData = convertedData.toString(responseEncoding);
        if (!responseEncoding || responseEncoding === "utf8") {
          convertedData = utils$1.stripBOM(convertedData);
        }
      } else if (responseType === "stream") {
        convertedData = stream.Readable.from(convertedData);
      }
      return settle(resolve3, reject, {
        data: convertedData,
        status: 200,
        statusText: "OK",
        headers: new AxiosHeaders$1(),
        config
      });
    }
    if (supportedProtocols.indexOf(protocol2) === -1) {
      return reject(new AxiosError(
        "Unsupported protocol " + protocol2,
        AxiosError.ERR_BAD_REQUEST,
        config
      ));
    }
    const headers = AxiosHeaders$1.from(config.headers).normalize();
    headers.set("User-Agent", "axios/" + VERSION, false);
    const onDownloadProgress = config.onDownloadProgress;
    const onUploadProgress = config.onUploadProgress;
    const maxRate = config.maxRate;
    let maxUploadRate = void 0;
    let maxDownloadRate = void 0;
    if (utils$1.isSpecCompliantForm(data)) {
      const userBoundary = headers.getContentType(/boundary=([-_\w\d]{10,70})/i);
      data = formDataToStream(data, (formHeaders) => {
        headers.set(formHeaders);
      }, {
        tag: `axios-${VERSION}-boundary`,
        boundary: userBoundary && userBoundary[1] || void 0
      });
    } else if (utils$1.isFormData(data) && utils$1.isFunction(data.getHeaders)) {
      headers.set(data.getHeaders());
      if (!headers.hasContentLength()) {
        try {
          const knownLength = await require$$1$1.promisify(data.getLength).call(data);
          Number.isFinite(knownLength) && knownLength >= 0 && headers.setContentLength(knownLength);
        } catch (e) {
        }
      }
    } else if (utils$1.isBlob(data)) {
      data.size && headers.setContentType(data.type || "application/octet-stream");
      headers.setContentLength(data.size || 0);
      data = stream.Readable.from(readBlob(data));
    } else if (data && !utils$1.isStream(data)) {
      if (Buffer.isBuffer(data))
        ;
      else if (utils$1.isArrayBuffer(data)) {
        data = Buffer.from(new Uint8Array(data));
      } else if (utils$1.isString(data)) {
        data = Buffer.from(data, "utf-8");
      } else {
        return reject(new AxiosError(
          "Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream",
          AxiosError.ERR_BAD_REQUEST,
          config
        ));
      }
      headers.setContentLength(data.length, false);
      if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {
        return reject(new AxiosError(
          "Request body larger than maxBodyLength limit",
          AxiosError.ERR_BAD_REQUEST,
          config
        ));
      }
    }
    const contentLength = utils$1.toFiniteNumber(headers.getContentLength());
    if (utils$1.isArray(maxRate)) {
      maxUploadRate = maxRate[0];
      maxDownloadRate = maxRate[1];
    } else {
      maxUploadRate = maxDownloadRate = maxRate;
    }
    if (data && (onUploadProgress || maxUploadRate)) {
      if (!utils$1.isStream(data)) {
        data = stream.Readable.from(data, { objectMode: false });
      }
      data = stream.pipeline([data, new AxiosTransformStream$1({
        length: contentLength,
        maxRate: utils$1.toFiniteNumber(maxUploadRate)
      })], utils$1.noop);
      onUploadProgress && data.on("progress", (progress) => {
        onUploadProgress(Object.assign(progress, {
          upload: true
        }));
      });
    }
    let auth = void 0;
    if (config.auth) {
      const username = config.auth.username || "";
      const password = config.auth.password || "";
      auth = username + ":" + password;
    }
    if (!auth && parsed.username) {
      const urlUsername = parsed.username;
      const urlPassword = parsed.password;
      auth = urlUsername + ":" + urlPassword;
    }
    auth && headers.delete("authorization");
    let path3;
    try {
      path3 = buildURL(
        parsed.pathname + parsed.search,
        config.params,
        config.paramsSerializer
      ).replace(/^\?/, "");
    } catch (err) {
      const customErr = new Error(err.message);
      customErr.config = config;
      customErr.url = config.url;
      customErr.exists = true;
      return reject(customErr);
    }
    headers.set(
      "Accept-Encoding",
      "gzip, compress, deflate" + (isBrotliSupported ? ", br" : ""),
      false
    );
    const options = {
      path: path3,
      method,
      headers: headers.toJSON(),
      agents: { http: config.httpAgent, https: config.httpsAgent },
      auth,
      protocol: protocol2,
      family,
      beforeRedirect: dispatchBeforeRedirect,
      beforeRedirects: {}
    };
    !utils$1.isUndefined(lookup2) && (options.lookup = lookup2);
    if (config.socketPath) {
      options.socketPath = config.socketPath;
    } else {
      options.hostname = parsed.hostname;
      options.port = parsed.port;
      setProxy(options, config.proxy, protocol2 + "//" + parsed.hostname + (parsed.port ? ":" + parsed.port : "") + options.path);
    }
    let transport;
    const isHttpsRequest = isHttps.test(options.protocol);
    options.agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;
    if (config.transport) {
      transport = config.transport;
    } else if (config.maxRedirects === 0) {
      transport = isHttpsRequest ? require$$4$2 : require$$0$7;
    } else {
      if (config.maxRedirects) {
        options.maxRedirects = config.maxRedirects;
      }
      if (config.beforeRedirect) {
        options.beforeRedirects.config = config.beforeRedirect;
      }
      transport = isHttpsRequest ? httpsFollow : httpFollow;
    }
    if (config.maxBodyLength > -1) {
      options.maxBodyLength = config.maxBodyLength;
    } else {
      options.maxBodyLength = Infinity;
    }
    if (config.insecureHTTPParser) {
      options.insecureHTTPParser = config.insecureHTTPParser;
    }
    req2 = transport.request(options, function handleResponse(res2) {
      if (req2.destroyed)
        return;
      const streams2 = [res2];
      const responseLength = +res2.headers["content-length"];
      if (onDownloadProgress) {
        const transformStream = new AxiosTransformStream$1({
          length: utils$1.toFiniteNumber(responseLength),
          maxRate: utils$1.toFiniteNumber(maxDownloadRate)
        });
        onDownloadProgress && transformStream.on("progress", (progress) => {
          onDownloadProgress(Object.assign(progress, {
            download: true
          }));
        });
        streams2.push(transformStream);
      }
      let responseStream = res2;
      const lastRequest = res2.req || req2;
      if (config.decompress !== false && res2.headers["content-encoding"]) {
        if (method === "HEAD" || res2.statusCode === 204) {
          delete res2.headers["content-encoding"];
        }
        switch ((res2.headers["content-encoding"] || "").toLowerCase()) {
          case "gzip":
          case "x-gzip":
          case "compress":
          case "x-compress":
            streams2.push(zlib.createUnzip(zlibOptions));
            delete res2.headers["content-encoding"];
            break;
          case "deflate":
            streams2.push(new ZlibHeaderTransformStream());
            streams2.push(zlib.createUnzip(zlibOptions));
            delete res2.headers["content-encoding"];
            break;
          case "br":
            if (isBrotliSupported) {
              streams2.push(zlib.createBrotliDecompress(brotliOptions));
              delete res2.headers["content-encoding"];
            }
        }
      }
      responseStream = streams2.length > 1 ? stream.pipeline(streams2, utils$1.noop) : streams2[0];
      const offListeners = stream.finished(responseStream, () => {
        offListeners();
        onFinished2();
      });
      const response2 = {
        status: res2.statusCode,
        statusText: res2.statusMessage,
        headers: new AxiosHeaders$1(res2.headers),
        config,
        request: lastRequest
      };
      if (responseType === "stream") {
        response2.data = responseStream;
        settle(resolve3, reject, response2);
      } else {
        const responseBuffer = [];
        let totalResponseBytes = 0;
        responseStream.on("data", function handleStreamData(chunk) {
          responseBuffer.push(chunk);
          totalResponseBytes += chunk.length;
          if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
            rejected = true;
            responseStream.destroy();
            reject(new AxiosError(
              "maxContentLength size of " + config.maxContentLength + " exceeded",
              AxiosError.ERR_BAD_RESPONSE,
              config,
              lastRequest
            ));
          }
        });
        responseStream.on("aborted", function handlerStreamAborted() {
          if (rejected) {
            return;
          }
          const err = new AxiosError(
            "maxContentLength size of " + config.maxContentLength + " exceeded",
            AxiosError.ERR_BAD_RESPONSE,
            config,
            lastRequest
          );
          responseStream.destroy(err);
          reject(err);
        });
        responseStream.on("error", function handleStreamError(err) {
          if (req2.destroyed)
            return;
          reject(AxiosError.from(err, null, config, lastRequest));
        });
        responseStream.on("end", function handleStreamEnd() {
          try {
            let responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
            if (responseType !== "arraybuffer") {
              responseData = responseData.toString(responseEncoding);
              if (!responseEncoding || responseEncoding === "utf8") {
                responseData = utils$1.stripBOM(responseData);
              }
            }
            response2.data = responseData;
          } catch (err) {
            return reject(AxiosError.from(err, null, config, response2.request, response2));
          }
          settle(resolve3, reject, response2);
        });
      }
      emitter.once("abort", (err) => {
        if (!responseStream.destroyed) {
          responseStream.emit("error", err);
          responseStream.destroy();
        }
      });
    });
    emitter.once("abort", (err) => {
      reject(err);
      req2.destroy(err);
    });
    req2.on("error", function handleRequestError(err) {
      reject(AxiosError.from(err, null, config, req2));
    });
    req2.on("socket", function handleRequestSocket(socket) {
      socket.setKeepAlive(true, 1e3 * 60);
    });
    if (config.timeout) {
      const timeout = parseInt(config.timeout, 10);
      if (Number.isNaN(timeout)) {
        reject(new AxiosError(
          "error trying to parse `config.timeout` to int",
          AxiosError.ERR_BAD_OPTION_VALUE,
          config,
          req2
        ));
        return;
      }
      req2.setTimeout(timeout, function handleRequestTimeout() {
        if (isDone)
          return;
        let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
        const transitional2 = config.transitional || transitionalDefaults;
        if (config.timeoutErrorMessage) {
          timeoutErrorMessage = config.timeoutErrorMessage;
        }
        reject(new AxiosError(
          timeoutErrorMessage,
          transitional2.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
          config,
          req2
        ));
        abort2();
      });
    }
    if (utils$1.isStream(data)) {
      let ended = false;
      let errored = false;
      data.on("end", () => {
        ended = true;
      });
      data.once("error", (err) => {
        errored = true;
        req2.destroy(err);
      });
      data.on("close", () => {
        if (!ended && !errored) {
          abort2(new CanceledError("Request stream has been aborted", config, req2));
        }
      });
      data.pipe(req2);
    } else {
      req2.end(data);
    }
  });
};
const cookies = platform.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(name, value, expires, path3, domain, secure2) {
      const cookie2 = [name + "=" + encodeURIComponent(value)];
      utils$1.isNumber(expires) && cookie2.push("expires=" + new Date(expires).toGMTString());
      utils$1.isString(path3) && cookie2.push("path=" + path3);
      utils$1.isString(domain) && cookie2.push("domain=" + domain);
      secure2 === true && cookie2.push("secure");
      document.cookie = cookie2.join("; ");
    },
    read(name) {
      const match2 = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
      return match2 ? decodeURIComponent(match2[3]) : null;
    },
    remove(name) {
      this.write(name, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
const isURLSameOrigin = platform.hasStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function standardBrowserEnv() {
    const msie = /(msie|trident)/i.test(navigator.userAgent);
    const urlParsingNode = document.createElement("a");
    let originURL;
    function resolveURL(url2) {
      let href = url2;
      if (msie) {
        urlParsingNode.setAttribute("href", href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute("href", href);
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
      };
    }
    originURL = resolveURL(window.location.href);
    return function isURLSameOrigin2(requestURL) {
      const parsed = utils$1.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  /* @__PURE__ */ function nonStandardBrowserEnv() {
    return function isURLSameOrigin2() {
      return true;
    };
  }()
);
function progressEventReducer(listener2, isDownloadStream) {
  let bytesNotified = 0;
  const _speedometer = speedometer(50, 250);
  return (e) => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e
    };
    data[isDownloadStream ? "download" : "upload"] = true;
    listener2(data);
  };
}
const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
const xhrAdapter = isXHRAdapterSupported && function(config) {
  return new Promise(function dispatchXhrRequest(resolve3, reject) {
    let requestData = config.data;
    const requestHeaders = AxiosHeaders$1.from(config.headers).normalize();
    let { responseType, withXSRFToken } = config;
    let onCanceled;
    function done() {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(onCanceled);
      }
      if (config.signal) {
        config.signal.removeEventListener("abort", onCanceled);
      }
    }
    let contentType3;
    if (utils$1.isFormData(requestData)) {
      if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
        requestHeaders.setContentType(false);
      } else if ((contentType3 = requestHeaders.getContentType()) !== false) {
        const [type3, ...tokens] = contentType3 ? contentType3.split(";").map((token) => token.trim()).filter(Boolean) : [];
        requestHeaders.setContentType([type3 || "multipart/form-data", ...tokens].join("; "));
      }
    }
    let request2 = new XMLHttpRequest();
    if (config.auth) {
      const username = config.auth.username || "";
      const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
      requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
    }
    const fullPath = buildFullPath(config.baseURL, config.url);
    request2.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
    request2.timeout = config.timeout;
    function onloadend() {
      if (!request2) {
        return;
      }
      const responseHeaders = AxiosHeaders$1.from(
        "getAllResponseHeaders" in request2 && request2.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request2.responseText : request2.response;
      const response2 = {
        data: responseData,
        status: request2.status,
        statusText: request2.statusText,
        headers: responseHeaders,
        config,
        request: request2
      };
      settle(function _resolve(value) {
        resolve3(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response2);
      request2 = null;
    }
    if ("onloadend" in request2) {
      request2.onloadend = onloadend;
    } else {
      request2.onreadystatechange = function handleLoad() {
        if (!request2 || request2.readyState !== 4) {
          return;
        }
        if (request2.status === 0 && !(request2.responseURL && request2.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request2.onabort = function handleAbort() {
      if (!request2) {
        return;
      }
      reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config, request2));
      request2 = null;
    };
    request2.onerror = function handleError() {
      reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request2));
      request2 = null;
    };
    request2.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = config.transitional || transitionalDefaults;
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(new AxiosError(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
        config,
        request2
      ));
      request2 = null;
    };
    if (platform.hasStandardBrowserEnv) {
      withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(config));
      if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(fullPath)) {
        const xsrfValue = config.xsrfHeaderName && config.xsrfCookieName && cookies.read(config.xsrfCookieName);
        if (xsrfValue) {
          requestHeaders.set(config.xsrfHeaderName, xsrfValue);
        }
      }
    }
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request2) {
      utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request2.setRequestHeader(key, val);
      });
    }
    if (!utils$1.isUndefined(config.withCredentials)) {
      request2.withCredentials = !!config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request2.responseType = config.responseType;
    }
    if (typeof config.onDownloadProgress === "function") {
      request2.addEventListener("progress", progressEventReducer(config.onDownloadProgress, true));
    }
    if (typeof config.onUploadProgress === "function" && request2.upload) {
      request2.upload.addEventListener("progress", progressEventReducer(config.onUploadProgress));
    }
    if (config.cancelToken || config.signal) {
      onCanceled = (cancel) => {
        if (!request2) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError(null, config, request2) : cancel);
        request2.abort();
        request2 = null;
      };
      config.cancelToken && config.cancelToken.subscribe(onCanceled);
      if (config.signal) {
        config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol2 = parseProtocol(fullPath);
    if (protocol2 && platform.protocols.indexOf(protocol2) === -1) {
      reject(new AxiosError("Unsupported protocol " + protocol2 + ":", AxiosError.ERR_BAD_REQUEST, config));
      return;
    }
    request2.send(requestData || null);
  });
};
const knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter
};
utils$1.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value });
    } catch (e) {
    }
    Object.defineProperty(fn, "adapterName", { value });
  }
});
const renderReason = (reason) => `- ${reason}`;
const isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;
const adapters = {
  getAdapter: (adapters2) => {
    adapters2 = utils$1.isArray(adapters2) ? adapters2 : [adapters2];
    const { length } = adapters2;
    let nameOrAdapter;
    let adapter;
    const rejectedReasons = {};
    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters2[i];
      let id;
      adapter = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
        if (adapter === void 0) {
          throw new AxiosError(`Unknown adapter '${id}'`);
        }
      }
      if (adapter) {
        break;
      }
      rejectedReasons[id || "#" + i] = adapter;
    }
    if (!adapter) {
      const reasons = Object.entries(rejectedReasons).map(
        ([id, state2]) => `adapter ${id} ` + (state2 === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s2 = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
      throw new AxiosError(
        `There is no suitable adapter to dispatch the request ` + s2,
        "ERR_NOT_SUPPORT"
      );
    }
    return adapter;
  },
  adapters: knownAdapters
};
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError(null, config);
  }
}
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders$1.from(config.headers);
  config.data = transformData.call(
    config,
    config.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config.method) !== -1) {
    config.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter);
  return adapter(config).then(function onAdapterResolution(response2) {
    throwIfCancellationRequested(config);
    response2.data = transformData.call(
      config,
      config.transformResponse,
      response2
    );
    response2.headers = AxiosHeaders$1.from(response2.headers);
    return response2;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}
const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? { ...thing } : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source, caseless) {
    if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
      return utils$1.merge.call({ caseless }, target, source);
    } else if (utils$1.isPlainObject(source)) {
      return utils$1.merge({}, source);
    } else if (utils$1.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a, b2, caseless) {
    if (!utils$1.isUndefined(b2)) {
      return getMergedValue(a, b2, caseless);
    } else if (!utils$1.isUndefined(a)) {
      return getMergedValue(void 0, a, caseless);
    }
  }
  function valueFromConfig2(a, b2) {
    if (!utils$1.isUndefined(b2)) {
      return getMergedValue(void 0, b2);
    }
  }
  function defaultToConfig2(a, b2) {
    if (!utils$1.isUndefined(b2)) {
      return getMergedValue(void 0, b2);
    } else if (!utils$1.isUndefined(a)) {
      return getMergedValue(void 0, a);
    }
  }
  function mergeDirectKeys(a, b2, prop) {
    if (prop in config2) {
      return getMergedValue(a, b2);
    } else if (prop in config1) {
      return getMergedValue(void 0, a);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b2) => mergeDeepProperties(headersToObject(a), headersToObject(b2), true)
  };
  utils$1.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils$1.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}
const validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type3, i) => {
  validators$1[type3] = function validator2(thing) {
    return typeof thing === type3 || "a" + (i < 1 ? "n " : " ") + type3;
  };
});
const deprecatedWarnings = {};
validators$1.transitional = function transitional(validator2, version, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator2 === false) {
      throw new AxiosError(
        formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
        AxiosError.ERR_DEPRECATED
      );
    }
    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version + " and will be removed in the near future"
        )
      );
    }
    return validator2 ? validator2(value, opt, opts) : true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
  }
  const keys2 = Object.keys(options);
  let i = keys2.length;
  while (i-- > 0) {
    const opt = keys2[i];
    const validator2 = schema[opt];
    if (validator2) {
      const value = options[opt];
      const result = value === void 0 || validator2(value, opt, options);
      if (result !== true) {
        throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}
const validator = {
  assertOptions,
  validators: validators$1
};
const validators = validator.validators;
class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager(),
      response: new InterceptorManager()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config) {
    try {
      return await this._request(configOrUrl, config);
    } catch (err) {
      if (err instanceof Error) {
        let dummy;
        Error.captureStackTrace ? Error.captureStackTrace(dummy = {}) : dummy = new Error();
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
        if (!err.stack) {
          err.stack = stack;
        } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
          err.stack += "\n" + stack;
        }
      }
      throw err;
    }
  }
  _request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig(this.defaults, config);
    const { transitional: transitional2, paramsSerializer, headers } = config;
    if (transitional2 !== void 0) {
      validator.assertOptions(transitional2, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils$1.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator.assertOptions(paramsSerializer, {
          encode: validators.function,
          serialize: validators.function
        }, true);
      }
    }
    config.method = (config.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils$1.merge(
      headers.common,
      headers[config.method]
    );
    headers && utils$1.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config.headers = AxiosHeaders$1.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config);
      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    i = 0;
    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error2) {
        onRejected.call(this, error2);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error2) {
      return Promise.reject(error2);
    }
    i = 0;
    len = responseInterceptorChain.length;
    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }
    return promise;
  }
  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
}
utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios.prototype[method] = function(url2, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url: url2,
      data: (config || {}).data
    }));
  };
});
utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url2, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: url2,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
const Axios$1 = Axios;
class CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve3) {
      resolvePromise = resolve3;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners)
        return;
      let i = token._listeners.length;
      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve3) => {
        token.subscribe(resolve3);
        _resolve = resolve3;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config, request2) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError(message, config, request2);
      resolvePromise(token.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener2) {
    if (this.reason) {
      listener2(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener2);
    } else {
      this._listeners = [listener2];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener2) {
    if (!this._listeners) {
      return;
    }
    const index2 = this._listeners.indexOf(listener2);
    if (index2 !== -1) {
      this._listeners.splice(index2, 1);
    }
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c2) {
      cancel = c2;
    });
    return {
      token,
      cancel
    };
  }
}
const CancelToken$1 = CancelToken;
function spread(callback) {
  return function wrap2(arr) {
    return callback.apply(null, arr);
  };
}
function isAxiosError(payload) {
  return utils$1.isObject(payload) && payload.isAxiosError === true;
}
const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
const HttpStatusCode$1 = HttpStatusCode;
function createInstance(defaultConfig) {
  const context = new Axios$1(defaultConfig);
  const instance = bind(Axios$1.prototype.request, context);
  utils$1.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
  utils$1.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
const axios = createInstance(defaults$1);
axios.Axios = Axios$1;
axios.CanceledError = CanceledError;
axios.CancelToken = CancelToken$1;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData;
axios.AxiosError = AxiosError;
axios.Cancel = axios.CanceledError;
axios.all = function all2(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders$1;
axios.formToJSON = (thing) => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters.getAdapter;
axios.HttpStatusCode = HttpStatusCode$1;
axios.default = axios;
function compact(array) {
  var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
  while (++index2 < length) {
    var value = array[index2];
    if (value) {
      result[resIndex++] = value;
    }
  }
  return result;
}
var compact_1 = compact;
const g = /* @__PURE__ */ getDefaultExportFromCjs(compact_1);
function arrayEach$2(array, iteratee) {
  var index2 = -1, length = array == null ? 0 : array.length;
  while (++index2 < length) {
    if (iteratee(array[index2], index2, array) === false) {
      break;
    }
  }
  return array;
}
var _arrayEach = arrayEach$2;
function createBaseFor$1(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index2 = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
    while (length--) {
      var key = props[fromRight ? length : ++index2];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
var _createBaseFor = createBaseFor$1;
var createBaseFor = _createBaseFor;
var baseFor$1 = createBaseFor();
var _baseFor = baseFor$1;
function baseTimes$2(n, iteratee) {
  var index2 = -1, result = Array(n);
  while (++index2 < n) {
    result[index2] = iteratee(index2);
  }
  return result;
}
var _baseTimes = baseTimes$2;
var freeGlobal$1 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var _freeGlobal = freeGlobal$1;
var freeGlobal = _freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root$9 = freeGlobal || freeSelf || Function("return this")();
var _root = root$9;
var root$8 = _root;
var Symbol$7 = root$8.Symbol;
var _Symbol = Symbol$7;
var Symbol$6 = _Symbol;
var objectProto$g = Object.prototype;
var hasOwnProperty$d = objectProto$g.hasOwnProperty;
var nativeObjectToString$1 = objectProto$g.toString;
var symToStringTag$1 = Symbol$6 ? Symbol$6.toStringTag : void 0;
function getRawTag$1(value) {
  var isOwn = hasOwnProperty$d.call(value, symToStringTag$1), tag = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var _getRawTag = getRawTag$1;
var objectProto$f = Object.prototype;
var nativeObjectToString = objectProto$f.toString;
function objectToString$1(value) {
  return nativeObjectToString.call(value);
}
var _objectToString = objectToString$1;
var Symbol$5 = _Symbol, getRawTag = _getRawTag, objectToString = _objectToString;
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$5 ? Symbol$5.toStringTag : void 0;
function baseGetTag$8(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
var _baseGetTag = baseGetTag$8;
function isObjectLike$a(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_1 = isObjectLike$a;
var baseGetTag$7 = _baseGetTag, isObjectLike$9 = isObjectLike_1;
var argsTag$3 = "[object Arguments]";
function baseIsArguments$1(value) {
  return isObjectLike$9(value) && baseGetTag$7(value) == argsTag$3;
}
var _baseIsArguments = baseIsArguments$1;
var baseIsArguments = _baseIsArguments, isObjectLike$8 = isObjectLike_1;
var objectProto$e = Object.prototype;
var hasOwnProperty$c = objectProto$e.hasOwnProperty;
var propertyIsEnumerable$1 = objectProto$e.propertyIsEnumerable;
var isArguments$3 = baseIsArguments(/* @__PURE__ */ function() {
  return arguments;
}()) ? baseIsArguments : function(value) {
  return isObjectLike$8(value) && hasOwnProperty$c.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
};
var isArguments_1 = isArguments$3;
var isArray$h = Array.isArray;
var isArray_1 = isArray$h;
const f = /* @__PURE__ */ getDefaultExportFromCjs(isArray_1);
var isBuffer$3 = { exports: {} };
function stubFalse() {
  return false;
}
var stubFalse_1 = stubFalse;
isBuffer$3.exports;
(function(module, exports) {
  var root3 = _root, stubFalse2 = stubFalse_1;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer2 = moduleExports ? root3.Buffer : void 0;
  var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
  var isBuffer2 = nativeIsBuffer || stubFalse2;
  module.exports = isBuffer2;
})(isBuffer$3, isBuffer$3.exports);
var isBufferExports = isBuffer$3.exports;
var MAX_SAFE_INTEGER$2 = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex$4(value, length) {
  var type3 = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$2 : length;
  return !!length && (type3 == "number" || type3 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
var _isIndex = isIndex$4;
var MAX_SAFE_INTEGER$1 = 9007199254740991;
function isLength$3(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
}
var isLength_1 = isLength$3;
var baseGetTag$6 = _baseGetTag, isLength$2 = isLength_1, isObjectLike$7 = isObjectLike_1;
var argsTag$2 = "[object Arguments]", arrayTag$2 = "[object Array]", boolTag$4 = "[object Boolean]", dateTag$3 = "[object Date]", errorTag$2 = "[object Error]", funcTag$2 = "[object Function]", mapTag$5 = "[object Map]", numberTag$3 = "[object Number]", objectTag$4 = "[object Object]", regexpTag$3 = "[object RegExp]", setTag$5 = "[object Set]", stringTag$4 = "[object String]", weakMapTag$2 = "[object WeakMap]";
var arrayBufferTag$3 = "[object ArrayBuffer]", dataViewTag$4 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$4] = typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] = typedArrayTags[errorTag$2] = typedArrayTags[funcTag$2] = typedArrayTags[mapTag$5] = typedArrayTags[numberTag$3] = typedArrayTags[objectTag$4] = typedArrayTags[regexpTag$3] = typedArrayTags[setTag$5] = typedArrayTags[stringTag$4] = typedArrayTags[weakMapTag$2] = false;
function baseIsTypedArray$1(value) {
  return isObjectLike$7(value) && isLength$2(value.length) && !!typedArrayTags[baseGetTag$6(value)];
}
var _baseIsTypedArray = baseIsTypedArray$1;
function baseUnary$4(func) {
  return function(value) {
    return func(value);
  };
}
var _baseUnary = baseUnary$4;
var _nodeUtil = { exports: {} };
_nodeUtil.exports;
(function(module, exports) {
  var freeGlobal2 = _freeGlobal;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal2.process;
  var nodeUtil2 = function() {
    try {
      var types = freeModule && freeModule.require && freeModule.require("util").types;
      if (types) {
        return types;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e) {
    }
  }();
  module.exports = nodeUtil2;
})(_nodeUtil, _nodeUtil.exports);
var _nodeUtilExports = _nodeUtil.exports;
var baseIsTypedArray = _baseIsTypedArray, baseUnary$3 = _baseUnary, nodeUtil$2 = _nodeUtilExports;
var nodeIsTypedArray = nodeUtil$2 && nodeUtil$2.isTypedArray;
var isTypedArray$2 = nodeIsTypedArray ? baseUnary$3(nodeIsTypedArray) : baseIsTypedArray;
var isTypedArray_1 = isTypedArray$2;
var baseTimes$1 = _baseTimes, isArguments$2 = isArguments_1, isArray$g = isArray_1, isBuffer$2 = isBufferExports, isIndex$3 = _isIndex, isTypedArray$1 = isTypedArray_1;
var objectProto$d = Object.prototype;
var hasOwnProperty$b = objectProto$d.hasOwnProperty;
function arrayLikeKeys$2(value, inherited) {
  var isArr = isArray$g(value), isArg = !isArr && isArguments$2(value), isBuff = !isArr && !isArg && isBuffer$2(value), isType = !isArr && !isArg && !isBuff && isTypedArray$1(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes$1(value.length, String) : [], length = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty$b.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    isIndex$3(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
var _arrayLikeKeys = arrayLikeKeys$2;
var objectProto$c = Object.prototype;
function isPrototype$3(value) {
  var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto$c;
  return value === proto2;
}
var _isPrototype = isPrototype$3;
function overArg$2(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var _overArg = overArg$2;
var overArg$1 = _overArg;
var nativeKeys$1 = overArg$1(Object.keys, Object);
var _nativeKeys = nativeKeys$1;
var isPrototype$2 = _isPrototype, nativeKeys = _nativeKeys;
var objectProto$b = Object.prototype;
var hasOwnProperty$a = objectProto$b.hasOwnProperty;
function baseKeys$1(object) {
  if (!isPrototype$2(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$a.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
var _baseKeys = baseKeys$1;
function isObject$9(value) {
  var type3 = typeof value;
  return value != null && (type3 == "object" || type3 == "function");
}
var isObject_1 = isObject$9;
const y = /* @__PURE__ */ getDefaultExportFromCjs(isObject_1);
var baseGetTag$5 = _baseGetTag, isObject$8 = isObject_1;
var asyncTag = "[object AsyncFunction]", funcTag$1 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction$2(value) {
  if (!isObject$8(value)) {
    return false;
  }
  var tag = baseGetTag$5(value);
  return tag == funcTag$1 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
}
var isFunction_1 = isFunction$2;
var isFunction$1 = isFunction_1, isLength$1 = isLength_1;
function isArrayLike$6(value) {
  return value != null && isLength$1(value.length) && !isFunction$1(value);
}
var isArrayLike_1 = isArrayLike$6;
var arrayLikeKeys$1 = _arrayLikeKeys, baseKeys = _baseKeys, isArrayLike$5 = isArrayLike_1;
function keys$7(object) {
  return isArrayLike$5(object) ? arrayLikeKeys$1(object) : baseKeys(object);
}
var keys_1 = keys$7;
const R = /* @__PURE__ */ getDefaultExportFromCjs(keys_1);
var baseFor = _baseFor, keys$6 = keys_1;
function baseForOwn$1(object, iteratee) {
  return object && baseFor(object, iteratee, keys$6);
}
var _baseForOwn = baseForOwn$1;
var isArrayLike$4 = isArrayLike_1;
function createBaseEach$1(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike$4(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length, index2 = fromRight ? length : -1, iterable = Object(collection);
    while (fromRight ? index2-- : ++index2 < length) {
      if (iteratee(iterable[index2], index2, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}
var _createBaseEach = createBaseEach$1;
var baseForOwn = _baseForOwn, createBaseEach = _createBaseEach;
var baseEach$5 = createBaseEach(baseForOwn);
var _baseEach = baseEach$5;
function identity$5(value) {
  return value;
}
var identity_1 = identity$5;
var identity$4 = identity_1;
function castFunction$2(value) {
  return typeof value == "function" ? value : identity$4;
}
var _castFunction = castFunction$2;
var arrayEach$1 = _arrayEach, baseEach$4 = _baseEach, castFunction$1 = _castFunction, isArray$f = isArray_1;
function forEach(collection, iteratee) {
  var func = isArray$f(collection) ? arrayEach$1 : baseEach$4;
  return func(collection, castFunction$1(iteratee));
}
var forEach_1 = forEach;
var each = forEach_1;
const u = /* @__PURE__ */ getDefaultExportFromCjs(each);
function arrayFilter$2(array, predicate) {
  var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
  while (++index2 < length) {
    var value = array[index2];
    if (predicate(value, index2, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
var _arrayFilter = arrayFilter$2;
var baseEach$3 = _baseEach;
function baseFilter$1(collection, predicate) {
  var result = [];
  baseEach$3(collection, function(value, index2, collection2) {
    if (predicate(value, index2, collection2)) {
      result.push(value);
    }
  });
  return result;
}
var _baseFilter = baseFilter$1;
function listCacheClear$1() {
  this.__data__ = [];
  this.size = 0;
}
var _listCacheClear = listCacheClear$1;
function eq$4(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_1 = eq$4;
var eq$3 = eq_1;
function assocIndexOf$4(array, key) {
  var length = array.length;
  while (length--) {
    if (eq$3(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var _assocIndexOf = assocIndexOf$4;
var assocIndexOf$3 = _assocIndexOf;
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete$1(key) {
  var data = this.__data__, index2 = assocIndexOf$3(data, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index2 == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index2, 1);
  }
  --this.size;
  return true;
}
var _listCacheDelete = listCacheDelete$1;
var assocIndexOf$2 = _assocIndexOf;
function listCacheGet$1(key) {
  var data = this.__data__, index2 = assocIndexOf$2(data, key);
  return index2 < 0 ? void 0 : data[index2][1];
}
var _listCacheGet = listCacheGet$1;
var assocIndexOf$1 = _assocIndexOf;
function listCacheHas$1(key) {
  return assocIndexOf$1(this.__data__, key) > -1;
}
var _listCacheHas = listCacheHas$1;
var assocIndexOf = _assocIndexOf;
function listCacheSet$1(key, value) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  if (index2 < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index2][1] = value;
  }
  return this;
}
var _listCacheSet = listCacheSet$1;
var listCacheClear = _listCacheClear, listCacheDelete = _listCacheDelete, listCacheGet = _listCacheGet, listCacheHas = _listCacheHas, listCacheSet = _listCacheSet;
function ListCache$4(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache$4.prototype.clear = listCacheClear;
ListCache$4.prototype["delete"] = listCacheDelete;
ListCache$4.prototype.get = listCacheGet;
ListCache$4.prototype.has = listCacheHas;
ListCache$4.prototype.set = listCacheSet;
var _ListCache = ListCache$4;
var ListCache$3 = _ListCache;
function stackClear$1() {
  this.__data__ = new ListCache$3();
  this.size = 0;
}
var _stackClear = stackClear$1;
function stackDelete$1(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
var _stackDelete = stackDelete$1;
function stackGet$1(key) {
  return this.__data__.get(key);
}
var _stackGet = stackGet$1;
function stackHas$1(key) {
  return this.__data__.has(key);
}
var _stackHas = stackHas$1;
var root$7 = _root;
var coreJsData$1 = root$7["__core-js_shared__"];
var _coreJsData = coreJsData$1;
var coreJsData = _coreJsData;
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked$1(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var _isMasked = isMasked$1;
var funcProto$2 = Function.prototype;
var funcToString$2 = funcProto$2.toString;
function toSource$2(func) {
  if (func != null) {
    try {
      return funcToString$2.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var _toSource = toSource$2;
var isFunction = isFunction_1, isMasked = _isMasked, isObject$7 = isObject_1, toSource$1 = _toSource;
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto$1 = Function.prototype, objectProto$a = Object.prototype;
var funcToString$1 = funcProto$1.toString;
var hasOwnProperty$9 = objectProto$a.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString$1.call(hasOwnProperty$9).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative$1(value) {
  if (!isObject$7(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource$1(value));
}
var _baseIsNative = baseIsNative$1;
function getValue$1(object, key) {
  return object == null ? void 0 : object[key];
}
var _getValue = getValue$1;
var baseIsNative = _baseIsNative, getValue = _getValue;
function getNative$7(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : void 0;
}
var _getNative = getNative$7;
var getNative$6 = _getNative, root$6 = _root;
var Map$4 = getNative$6(root$6, "Map");
var _Map = Map$4;
var getNative$5 = _getNative;
var nativeCreate$4 = getNative$5(Object, "create");
var _nativeCreate = nativeCreate$4;
var nativeCreate$3 = _nativeCreate;
function hashClear$1() {
  this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
  this.size = 0;
}
var _hashClear = hashClear$1;
function hashDelete$1(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var _hashDelete = hashDelete$1;
var nativeCreate$2 = _nativeCreate;
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
var objectProto$9 = Object.prototype;
var hasOwnProperty$8 = objectProto$9.hasOwnProperty;
function hashGet$1(key) {
  var data = this.__data__;
  if (nativeCreate$2) {
    var result = data[key];
    return result === HASH_UNDEFINED$2 ? void 0 : result;
  }
  return hasOwnProperty$8.call(data, key) ? data[key] : void 0;
}
var _hashGet = hashGet$1;
var nativeCreate$1 = _nativeCreate;
var objectProto$8 = Object.prototype;
var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
function hashHas$1(key) {
  var data = this.__data__;
  return nativeCreate$1 ? data[key] !== void 0 : hasOwnProperty$7.call(data, key);
}
var _hashHas = hashHas$1;
var nativeCreate = _nativeCreate;
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
function hashSet$1(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED$1 : value;
  return this;
}
var _hashSet = hashSet$1;
var hashClear = _hashClear, hashDelete = _hashDelete, hashGet = _hashGet, hashHas = _hashHas, hashSet = _hashSet;
function Hash$1(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash$1.prototype.clear = hashClear;
Hash$1.prototype["delete"] = hashDelete;
Hash$1.prototype.get = hashGet;
Hash$1.prototype.has = hashHas;
Hash$1.prototype.set = hashSet;
var _Hash = Hash$1;
var Hash = _Hash, ListCache$2 = _ListCache, Map$3 = _Map;
function mapCacheClear$1() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$3 || ListCache$2)(),
    "string": new Hash()
  };
}
var _mapCacheClear = mapCacheClear$1;
function isKeyable$1(value) {
  var type3 = typeof value;
  return type3 == "string" || type3 == "number" || type3 == "symbol" || type3 == "boolean" ? value !== "__proto__" : value === null;
}
var _isKeyable = isKeyable$1;
var isKeyable = _isKeyable;
function getMapData$4(map2, key) {
  var data = map2.__data__;
  return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var _getMapData = getMapData$4;
var getMapData$3 = _getMapData;
function mapCacheDelete$1(key) {
  var result = getMapData$3(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
var _mapCacheDelete = mapCacheDelete$1;
var getMapData$2 = _getMapData;
function mapCacheGet$1(key) {
  return getMapData$2(this, key).get(key);
}
var _mapCacheGet = mapCacheGet$1;
var getMapData$1 = _getMapData;
function mapCacheHas$1(key) {
  return getMapData$1(this, key).has(key);
}
var _mapCacheHas = mapCacheHas$1;
var getMapData = _getMapData;
function mapCacheSet$1(key, value) {
  var data = getMapData(this, key), size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}
var _mapCacheSet = mapCacheSet$1;
var mapCacheClear = _mapCacheClear, mapCacheDelete = _mapCacheDelete, mapCacheGet = _mapCacheGet, mapCacheHas = _mapCacheHas, mapCacheSet = _mapCacheSet;
function MapCache$3(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache$3.prototype.clear = mapCacheClear;
MapCache$3.prototype["delete"] = mapCacheDelete;
MapCache$3.prototype.get = mapCacheGet;
MapCache$3.prototype.has = mapCacheHas;
MapCache$3.prototype.set = mapCacheSet;
var _MapCache = MapCache$3;
var ListCache$1 = _ListCache, Map$2 = _Map, MapCache$2 = _MapCache;
var LARGE_ARRAY_SIZE = 200;
function stackSet$1(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache$1) {
    var pairs = data.__data__;
    if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache$2(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
var _stackSet = stackSet$1;
var ListCache = _ListCache, stackClear = _stackClear, stackDelete = _stackDelete, stackGet = _stackGet, stackHas = _stackHas, stackSet = _stackSet;
function Stack$3(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}
Stack$3.prototype.clear = stackClear;
Stack$3.prototype["delete"] = stackDelete;
Stack$3.prototype.get = stackGet;
Stack$3.prototype.has = stackHas;
Stack$3.prototype.set = stackSet;
var _Stack = Stack$3;
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function setCacheAdd$1(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}
var _setCacheAdd = setCacheAdd$1;
function setCacheHas$1(value) {
  return this.__data__.has(value);
}
var _setCacheHas = setCacheHas$1;
var MapCache$1 = _MapCache, setCacheAdd = _setCacheAdd, setCacheHas = _setCacheHas;
function SetCache$1(values2) {
  var index2 = -1, length = values2 == null ? 0 : values2.length;
  this.__data__ = new MapCache$1();
  while (++index2 < length) {
    this.add(values2[index2]);
  }
}
SetCache$1.prototype.add = SetCache$1.prototype.push = setCacheAdd;
SetCache$1.prototype.has = setCacheHas;
var _SetCache = SetCache$1;
function arraySome$2(array, predicate) {
  var index2 = -1, length = array == null ? 0 : array.length;
  while (++index2 < length) {
    if (predicate(array[index2], index2, array)) {
      return true;
    }
  }
  return false;
}
var _arraySome = arraySome$2;
function cacheHas$1(cache, key) {
  return cache.has(key);
}
var _cacheHas = cacheHas$1;
var SetCache = _SetCache, arraySome$1 = _arraySome, cacheHas = _cacheHas;
var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
function equalArrays$2(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;
  stack.set(array, other);
  stack.set(other, array);
  while (++index2 < arrLength) {
    var arrValue = array[index2], othValue = other[index2];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!arraySome$1(other, function(othValue2, othIndex) {
        if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack["delete"](array);
  stack["delete"](other);
  return result;
}
var _equalArrays = equalArrays$2;
var root$5 = _root;
var Uint8Array$3 = root$5.Uint8Array;
var _Uint8Array = Uint8Array$3;
function mapToArray$1(map2) {
  var index2 = -1, result = Array(map2.size);
  map2.forEach(function(value, key) {
    result[++index2] = [key, value];
  });
  return result;
}
var _mapToArray = mapToArray$1;
function setToArray$1(set2) {
  var index2 = -1, result = Array(set2.size);
  set2.forEach(function(value) {
    result[++index2] = value;
  });
  return result;
}
var _setToArray = setToArray$1;
var Symbol$4 = _Symbol, Uint8Array$2 = _Uint8Array, eq$2 = eq_1, equalArrays$1 = _equalArrays, mapToArray = _mapToArray, setToArray = _setToArray;
var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
var boolTag$3 = "[object Boolean]", dateTag$2 = "[object Date]", errorTag$1 = "[object Error]", mapTag$4 = "[object Map]", numberTag$2 = "[object Number]", regexpTag$2 = "[object RegExp]", setTag$4 = "[object Set]", stringTag$3 = "[object String]", symbolTag$3 = "[object Symbol]";
var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$3 = "[object DataView]";
var symbolProto$2 = Symbol$4 ? Symbol$4.prototype : void 0, symbolValueOf$1 = symbolProto$2 ? symbolProto$2.valueOf : void 0;
function equalByTag$1(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag$3:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;
    case arrayBufferTag$2:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array$2(object), new Uint8Array$2(other))) {
        return false;
      }
      return true;
    case boolTag$3:
    case dateTag$2:
    case numberTag$2:
      return eq$2(+object, +other);
    case errorTag$1:
      return object.name == other.name && object.message == other.message;
    case regexpTag$2:
    case stringTag$3:
      return object == other + "";
    case mapTag$4:
      var convert = mapToArray;
    case setTag$4:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
      convert || (convert = setToArray);
      if (object.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG$2;
      stack.set(object, other);
      var result = equalArrays$1(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object);
      return result;
    case symbolTag$3:
      if (symbolValueOf$1) {
        return symbolValueOf$1.call(object) == symbolValueOf$1.call(other);
      }
  }
  return false;
}
var _equalByTag = equalByTag$1;
function arrayPush$3(array, values2) {
  var index2 = -1, length = values2.length, offset = array.length;
  while (++index2 < length) {
    array[offset + index2] = values2[index2];
  }
  return array;
}
var _arrayPush = arrayPush$3;
var arrayPush$2 = _arrayPush, isArray$e = isArray_1;
function baseGetAllKeys$2(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray$e(object) ? result : arrayPush$2(result, symbolsFunc(object));
}
var _baseGetAllKeys = baseGetAllKeys$2;
function stubArray$2() {
  return [];
}
var stubArray_1 = stubArray$2;
var arrayFilter$1 = _arrayFilter, stubArray$1 = stubArray_1;
var objectProto$7 = Object.prototype;
var propertyIsEnumerable = objectProto$7.propertyIsEnumerable;
var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
var getSymbols$3 = !nativeGetSymbols$1 ? stubArray$1 : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter$1(nativeGetSymbols$1(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};
var _getSymbols = getSymbols$3;
var baseGetAllKeys$1 = _baseGetAllKeys, getSymbols$2 = _getSymbols, keys$5 = keys_1;
function getAllKeys$2(object) {
  return baseGetAllKeys$1(object, keys$5, getSymbols$2);
}
var _getAllKeys = getAllKeys$2;
var getAllKeys$1 = _getAllKeys;
var COMPARE_PARTIAL_FLAG$3 = 1;
var objectProto$6 = Object.prototype;
var hasOwnProperty$6 = objectProto$6.hasOwnProperty;
function equalObjects$1(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys$1(object), objLength = objProps.length, othProps = getAllKeys$1(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index2 = objLength;
  while (index2--) {
    var key = objProps[index2];
    if (!(isPartial ? key in other : hasOwnProperty$6.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;
  while (++index2 < objLength) {
    key = objProps[index2];
    var objValue = object[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack["delete"](object);
  stack["delete"](other);
  return result;
}
var _equalObjects = equalObjects$1;
var getNative$4 = _getNative, root$4 = _root;
var DataView$2 = getNative$4(root$4, "DataView");
var _DataView = DataView$2;
var getNative$3 = _getNative, root$3 = _root;
var Promise$2 = getNative$3(root$3, "Promise");
var _Promise = Promise$2;
var getNative$2 = _getNative, root$2 = _root;
var Set$2 = getNative$2(root$2, "Set");
var _Set = Set$2;
var getNative$1 = _getNative, root$1 = _root;
var WeakMap$2 = getNative$1(root$1, "WeakMap");
var _WeakMap = WeakMap$2;
var DataView$1 = _DataView, Map$1 = _Map, Promise$1 = _Promise, Set$1 = _Set, WeakMap$1 = _WeakMap, baseGetTag$4 = _baseGetTag, toSource = _toSource;
var mapTag$3 = "[object Map]", objectTag$3 = "[object Object]", promiseTag = "[object Promise]", setTag$3 = "[object Set]", weakMapTag$1 = "[object WeakMap]";
var dataViewTag$2 = "[object DataView]";
var dataViewCtorString = toSource(DataView$1), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap$1);
var getTag$4 = baseGetTag$4;
if (DataView$1 && getTag$4(new DataView$1(new ArrayBuffer(1))) != dataViewTag$2 || Map$1 && getTag$4(new Map$1()) != mapTag$3 || Promise$1 && getTag$4(Promise$1.resolve()) != promiseTag || Set$1 && getTag$4(new Set$1()) != setTag$3 || WeakMap$1 && getTag$4(new WeakMap$1()) != weakMapTag$1) {
  getTag$4 = function(value) {
    var result = baseGetTag$4(value), Ctor = result == objectTag$3 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag$2;
        case mapCtorString:
          return mapTag$3;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag$3;
        case weakMapCtorString:
          return weakMapTag$1;
      }
    }
    return result;
  };
}
var _getTag = getTag$4;
var Stack$2 = _Stack, equalArrays = _equalArrays, equalByTag = _equalByTag, equalObjects = _equalObjects, getTag$3 = _getTag, isArray$d = isArray_1, isBuffer$1 = isBufferExports, isTypedArray = isTypedArray_1;
var COMPARE_PARTIAL_FLAG$2 = 1;
var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", objectTag$2 = "[object Object]";
var objectProto$5 = Object.prototype;
var hasOwnProperty$5 = objectProto$5.hasOwnProperty;
function baseIsEqualDeep$1(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray$d(object), othIsArr = isArray$d(other), objTag = objIsArr ? arrayTag$1 : getTag$3(object), othTag = othIsArr ? arrayTag$1 : getTag$3(other);
  objTag = objTag == argsTag$1 ? objectTag$2 : objTag;
  othTag = othTag == argsTag$1 ? objectTag$2 : othTag;
  var objIsObj = objTag == objectTag$2, othIsObj = othTag == objectTag$2, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer$1(object)) {
    if (!isBuffer$1(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack$2());
    return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
    var objIsWrapped = objIsObj && hasOwnProperty$5.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$5.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack$2());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack$2());
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}
var _baseIsEqualDeep = baseIsEqualDeep$1;
var baseIsEqualDeep = _baseIsEqualDeep, isObjectLike$6 = isObjectLike_1;
function baseIsEqual$3(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike$6(value) && !isObjectLike$6(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual$3, stack);
}
var _baseIsEqual = baseIsEqual$3;
var Stack$1 = _Stack, baseIsEqual$2 = _baseIsEqual;
var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
function baseIsMatch$1(object, source, matchData, customizer) {
  var index2 = matchData.length, length = index2, noCustomizer = !customizer;
  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index2--) {
    var data = matchData[index2];
    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }
  while (++index2 < length) {
    data = matchData[index2];
    var key = data[0], objValue = object[key], srcValue = data[1];
    if (noCustomizer && data[2]) {
      if (objValue === void 0 && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack$1();
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === void 0 ? baseIsEqual$2(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result)) {
        return false;
      }
    }
  }
  return true;
}
var _baseIsMatch = baseIsMatch$1;
var isObject$6 = isObject_1;
function isStrictComparable$2(value) {
  return value === value && !isObject$6(value);
}
var _isStrictComparable = isStrictComparable$2;
var isStrictComparable$1 = _isStrictComparable, keys$4 = keys_1;
function getMatchData$1(object) {
  var result = keys$4(object), length = result.length;
  while (length--) {
    var key = result[length], value = object[key];
    result[length] = [key, value, isStrictComparable$1(value)];
  }
  return result;
}
var _getMatchData = getMatchData$1;
function matchesStrictComparable$2(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
  };
}
var _matchesStrictComparable = matchesStrictComparable$2;
var baseIsMatch = _baseIsMatch, getMatchData = _getMatchData, matchesStrictComparable$1 = _matchesStrictComparable;
function baseMatches$1(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable$1(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}
var _baseMatches = baseMatches$1;
var baseGetTag$3 = _baseGetTag, isObjectLike$5 = isObjectLike_1;
var symbolTag$2 = "[object Symbol]";
function isSymbol$5(value) {
  return typeof value == "symbol" || isObjectLike$5(value) && baseGetTag$3(value) == symbolTag$2;
}
var isSymbol_1 = isSymbol$5;
var isArray$c = isArray_1, isSymbol$4 = isSymbol_1;
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
function isKey$3(value, object) {
  if (isArray$c(value)) {
    return false;
  }
  var type3 = typeof value;
  if (type3 == "number" || type3 == "symbol" || type3 == "boolean" || value == null || isSymbol$4(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
var _isKey = isKey$3;
var MapCache = _MapCache;
var FUNC_ERROR_TEXT = "Expected a function";
function memoize$1(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize$1.Cache || MapCache)();
  return memoized;
}
memoize$1.Cache = MapCache;
var memoize_1 = memoize$1;
var memoize = memoize_1;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped$1(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });
  var cache = result.cache;
  return result;
}
var _memoizeCapped = memoizeCapped$1;
var memoizeCapped = _memoizeCapped;
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath$1 = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46) {
    result.push("");
  }
  string.replace(rePropName, function(match2, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match2);
  });
  return result;
});
var _stringToPath = stringToPath$1;
function arrayMap$6(array, iteratee) {
  var index2 = -1, length = array == null ? 0 : array.length, result = Array(length);
  while (++index2 < length) {
    result[index2] = iteratee(array[index2], index2, array);
  }
  return result;
}
var _arrayMap = arrayMap$6;
var Symbol$3 = _Symbol, arrayMap$5 = _arrayMap, isArray$b = isArray_1, isSymbol$3 = isSymbol_1;
var INFINITY$2 = 1 / 0;
var symbolProto$1 = Symbol$3 ? Symbol$3.prototype : void 0, symbolToString = symbolProto$1 ? symbolProto$1.toString : void 0;
function baseToString$1(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray$b(value)) {
    return arrayMap$5(value, baseToString$1) + "";
  }
  if (isSymbol$3(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$2 ? "-0" : result;
}
var _baseToString = baseToString$1;
var baseToString = _baseToString;
function toString$1(value) {
  return value == null ? "" : baseToString(value);
}
var toString_1 = toString$1;
var isArray$a = isArray_1, isKey$2 = _isKey, stringToPath = _stringToPath, toString2 = toString_1;
function castPath$6(value, object) {
  if (isArray$a(value)) {
    return value;
  }
  return isKey$2(value, object) ? [value] : stringToPath(toString2(value));
}
var _castPath = castPath$6;
var isSymbol$2 = isSymbol_1;
var INFINITY$1 = 1 / 0;
function toKey$6(value) {
  if (typeof value == "string" || isSymbol$2(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$1 ? "-0" : result;
}
var _toKey = toKey$6;
var castPath$5 = _castPath, toKey$5 = _toKey;
function baseGet$5(object, path3) {
  path3 = castPath$5(path3, object);
  var index2 = 0, length = path3.length;
  while (object != null && index2 < length) {
    object = object[toKey$5(path3[index2++])];
  }
  return index2 && index2 == length ? object : void 0;
}
var _baseGet = baseGet$5;
var baseGet$4 = _baseGet;
function get$1(object, path3, defaultValue) {
  var result = object == null ? void 0 : baseGet$4(object, path3);
  return result === void 0 ? defaultValue : result;
}
var get_1 = get$1;
const p = /* @__PURE__ */ getDefaultExportFromCjs(get_1);
function baseHasIn$1(object, key) {
  return object != null && key in Object(object);
}
var _baseHasIn = baseHasIn$1;
var castPath$4 = _castPath, isArguments$1 = isArguments_1, isArray$9 = isArray_1, isIndex$2 = _isIndex, isLength = isLength_1, toKey$4 = _toKey;
function hasPath$1(object, path3, hasFunc) {
  path3 = castPath$4(path3, object);
  var index2 = -1, length = path3.length, result = false;
  while (++index2 < length) {
    var key = toKey$4(path3[index2]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index2 != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex$2(key, length) && (isArray$9(object) || isArguments$1(object));
}
var _hasPath = hasPath$1;
var baseHasIn = _baseHasIn, hasPath = _hasPath;
function hasIn$1(object, path3) {
  return object != null && hasPath(object, path3, baseHasIn);
}
var hasIn_1 = hasIn$1;
var baseIsEqual$1 = _baseIsEqual, get = get_1, hasIn = hasIn_1, isKey$1 = _isKey, isStrictComparable = _isStrictComparable, matchesStrictComparable = _matchesStrictComparable, toKey$3 = _toKey;
var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
function baseMatchesProperty$1(path3, srcValue) {
  if (isKey$1(path3) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey$3(path3), srcValue);
  }
  return function(object) {
    var objValue = get(object, path3);
    return objValue === void 0 && objValue === srcValue ? hasIn(object, path3) : baseIsEqual$1(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}
var _baseMatchesProperty = baseMatchesProperty$1;
function baseProperty$1(key) {
  return function(object) {
    return object == null ? void 0 : object[key];
  };
}
var _baseProperty = baseProperty$1;
var baseGet$3 = _baseGet;
function basePropertyDeep$1(path3) {
  return function(object) {
    return baseGet$3(object, path3);
  };
}
var _basePropertyDeep = basePropertyDeep$1;
var baseProperty = _baseProperty, basePropertyDeep = _basePropertyDeep, isKey = _isKey, toKey$2 = _toKey;
function property$1(path3) {
  return isKey(path3) ? baseProperty(toKey$2(path3)) : basePropertyDeep(path3);
}
var property_1 = property$1;
var baseMatches = _baseMatches, baseMatchesProperty = _baseMatchesProperty, identity$3 = identity_1, isArray$8 = isArray_1, property = property_1;
function baseIteratee$8(value) {
  if (typeof value == "function") {
    return value;
  }
  if (value == null) {
    return identity$3;
  }
  if (typeof value == "object") {
    return isArray$8(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
  }
  return property(value);
}
var _baseIteratee = baseIteratee$8;
var arrayFilter = _arrayFilter, baseFilter = _baseFilter, baseIteratee$7 = _baseIteratee, isArray$7 = isArray_1;
function filter2(collection, predicate) {
  var func = isArray$7(collection) ? arrayFilter : baseFilter;
  return func(collection, baseIteratee$7(predicate));
}
var filter_1 = filter2;
const P = /* @__PURE__ */ getDefaultExportFromCjs(filter_1);
var baseIteratee$6 = _baseIteratee, isArrayLike$3 = isArrayLike_1, keys$3 = keys_1;
function createFind$1(findIndexFunc) {
  return function(collection, predicate, fromIndex) {
    var iterable = Object(collection);
    if (!isArrayLike$3(collection)) {
      var iteratee = baseIteratee$6(predicate);
      collection = keys$3(collection);
      predicate = function(key) {
        return iteratee(iterable[key], key, iterable);
      };
    }
    var index2 = findIndexFunc(collection, predicate, fromIndex);
    return index2 > -1 ? iterable[iteratee ? collection[index2] : index2] : void 0;
  };
}
var _createFind = createFind$1;
function baseFindIndex$1(array, predicate, fromIndex, fromRight) {
  var length = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
  while (fromRight ? index2-- : ++index2 < length) {
    if (predicate(array[index2], index2, array)) {
      return index2;
    }
  }
  return -1;
}
var _baseFindIndex = baseFindIndex$1;
var reWhitespace = /\s/;
function trimmedEndIndex$1(string) {
  var index2 = string.length;
  while (index2-- && reWhitespace.test(string.charAt(index2))) {
  }
  return index2;
}
var _trimmedEndIndex = trimmedEndIndex$1;
var trimmedEndIndex = _trimmedEndIndex;
var reTrimStart = /^\s+/;
function baseTrim$1(string) {
  return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
}
var _baseTrim = baseTrim$1;
var baseTrim = _baseTrim, isObject$5 = isObject_1, isSymbol$1 = isSymbol_1;
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber$1(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol$1(value)) {
    return NAN;
  }
  if (isObject$5(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject$5(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var toNumber_1 = toNumber$1;
var toNumber = toNumber_1;
var INFINITY = 1 / 0, MAX_INTEGER = 17976931348623157e292;
function toFinite$1(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign2 = value < 0 ? -1 : 1;
    return sign2 * MAX_INTEGER;
  }
  return value === value ? value : 0;
}
var toFinite_1 = toFinite$1;
var toFinite = toFinite_1;
function toInteger$3(value) {
  var result = toFinite(value), remainder = result % 1;
  return result === result ? remainder ? result - remainder : result : 0;
}
var toInteger_1 = toInteger$3;
var baseFindIndex = _baseFindIndex, baseIteratee$5 = _baseIteratee, toInteger$2 = toInteger_1;
var nativeMax$1 = Math.max;
function findIndex$1(array, predicate, fromIndex) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return -1;
  }
  var index2 = fromIndex == null ? 0 : toInteger$2(fromIndex);
  if (index2 < 0) {
    index2 = nativeMax$1(length + index2, 0);
  }
  return baseFindIndex(array, baseIteratee$5(predicate), index2);
}
var findIndex_1 = findIndex$1;
var createFind = _createFind, findIndex = findIndex_1;
var find = createFind(findIndex);
var find_1 = find;
const j = /* @__PURE__ */ getDefaultExportFromCjs(find_1);
var Symbol$2 = _Symbol, isArguments = isArguments_1, isArray$6 = isArray_1;
var spreadableSymbol = Symbol$2 ? Symbol$2.isConcatSpreadable : void 0;
function isFlattenable$1(value) {
  return isArray$6(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
var _isFlattenable = isFlattenable$1;
var arrayPush$1 = _arrayPush, isFlattenable = _isFlattenable;
function baseFlatten$2(array, depth, predicate, isStrict, result) {
  var index2 = -1, length = array.length;
  predicate || (predicate = isFlattenable);
  result || (result = []);
  while (++index2 < length) {
    var value = array[index2];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        baseFlatten$2(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush$1(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}
var _baseFlatten = baseFlatten$2;
var baseFlatten$1 = _baseFlatten;
function flatten$1(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten$1(array, 1) : [];
}
var flatten_1 = flatten$1;
const A = /* @__PURE__ */ getDefaultExportFromCjs(flatten_1);
var getNative = _getNative;
var defineProperty$2 = function() {
  try {
    var func = getNative(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e) {
  }
}();
var _defineProperty = defineProperty$2;
var defineProperty$1 = _defineProperty;
function baseAssignValue$4(object, key, value) {
  if (key == "__proto__" && defineProperty$1) {
    defineProperty$1(object, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object[key] = value;
  }
}
var _baseAssignValue = baseAssignValue$4;
function arrayAggregator$1(array, setter, iteratee, accumulator) {
  var index2 = -1, length = array == null ? 0 : array.length;
  while (++index2 < length) {
    var value = array[index2];
    setter(accumulator, value, iteratee(value), array);
  }
  return accumulator;
}
var _arrayAggregator = arrayAggregator$1;
var baseEach$2 = _baseEach;
function baseAggregator$1(collection, setter, iteratee, accumulator) {
  baseEach$2(collection, function(value, key, collection2) {
    setter(accumulator, value, iteratee(value), collection2);
  });
  return accumulator;
}
var _baseAggregator = baseAggregator$1;
var arrayAggregator = _arrayAggregator, baseAggregator = _baseAggregator, baseIteratee$4 = _baseIteratee, isArray$5 = isArray_1;
function createAggregator$2(setter, initializer) {
  return function(collection, iteratee) {
    var func = isArray$5(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
    return func(collection, setter, baseIteratee$4(iteratee), accumulator);
  };
}
var _createAggregator = createAggregator$2;
var baseAssignValue$3 = _baseAssignValue, createAggregator$1 = _createAggregator;
var objectProto$4 = Object.prototype;
var hasOwnProperty$4 = objectProto$4.hasOwnProperty;
var groupBy = createAggregator$1(function(result, value, key) {
  if (hasOwnProperty$4.call(result, key)) {
    result[key].push(value);
  } else {
    baseAssignValue$3(result, key, [value]);
  }
});
var groupBy_1 = groupBy;
const L = /* @__PURE__ */ getDefaultExportFromCjs(groupBy_1);
var baseGetTag$2 = _baseGetTag, isObjectLike$4 = isObjectLike_1;
var boolTag$2 = "[object Boolean]";
function isBoolean(value) {
  return value === true || value === false || isObjectLike$4(value) && baseGetTag$2(value) == boolTag$2;
}
var isBoolean_1 = isBoolean;
const O = /* @__PURE__ */ getDefaultExportFromCjs(isBoolean_1);
var baseIsEqual = _baseIsEqual;
function isEqual(value, other) {
  return baseIsEqual(value, other);
}
var isEqual_1 = isEqual;
const q = /* @__PURE__ */ getDefaultExportFromCjs(isEqual_1);
var root2 = _root;
var nativeIsFinite = root2.isFinite;
function isFinite$1(value) {
  return typeof value == "number" && nativeIsFinite(value);
}
var _isFinite = isFinite$1;
const M = /* @__PURE__ */ getDefaultExportFromCjs(_isFinite);
var toInteger$1 = toInteger_1;
function isInteger(value) {
  return typeof value == "number" && value == toInteger$1(value);
}
var isInteger_1 = isInteger;
const x = /* @__PURE__ */ getDefaultExportFromCjs(isInteger_1);
function isNil(value) {
  return value == null;
}
var isNil_1 = isNil;
const B = /* @__PURE__ */ getDefaultExportFromCjs(isNil_1);
var baseGetTag$1 = _baseGetTag, isArray$4 = isArray_1, isObjectLike$3 = isObjectLike_1;
var stringTag$2 = "[object String]";
function isString(value) {
  return typeof value == "string" || !isArray$4(value) && isObjectLike$3(value) && baseGetTag$1(value) == stringTag$2;
}
var isString_1 = isString;
const w = /* @__PURE__ */ getDefaultExportFromCjs(isString_1);
var baseAssignValue$2 = _baseAssignValue, createAggregator = _createAggregator;
var keyBy = createAggregator(function(result, value, key) {
  baseAssignValue$2(result, key, value);
});
var keyBy_1 = keyBy;
const G = /* @__PURE__ */ getDefaultExportFromCjs(keyBy_1);
var baseEach$1 = _baseEach, isArrayLike$2 = isArrayLike_1;
function baseMap$2(collection, iteratee) {
  var index2 = -1, result = isArrayLike$2(collection) ? Array(collection.length) : [];
  baseEach$1(collection, function(value, key, collection2) {
    result[++index2] = iteratee(value, key, collection2);
  });
  return result;
}
var _baseMap = baseMap$2;
var arrayMap$4 = _arrayMap, baseIteratee$3 = _baseIteratee, baseMap$1 = _baseMap, isArray$3 = isArray_1;
function map(collection, iteratee) {
  var func = isArray$3(collection) ? arrayMap$4 : baseMap$1;
  return func(collection, baseIteratee$3(iteratee));
}
var map_1 = map;
const c = /* @__PURE__ */ getDefaultExportFromCjs(map_1);
var baseAssignValue$1 = _baseAssignValue, eq$1 = eq_1;
var objectProto$3 = Object.prototype;
var hasOwnProperty$3 = objectProto$3.hasOwnProperty;
function assignValue$3(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$3.call(object, key) && eq$1(objValue, value)) || value === void 0 && !(key in object)) {
    baseAssignValue$1(object, key, value);
  }
}
var _assignValue = assignValue$3;
var assignValue$2 = _assignValue, baseAssignValue = _baseAssignValue;
function copyObject$5(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index2 = -1, length = props.length;
  while (++index2 < length) {
    var key = props[index2];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue$2(object, key, newValue);
    }
  }
  return object;
}
var _copyObject = copyObject$5;
var copyObject$4 = _copyObject, keys$2 = keys_1;
function baseAssign$1(object, source) {
  return object && copyObject$4(source, keys$2(source), object);
}
var _baseAssign = baseAssign$1;
function nativeKeysIn$1(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}
var _nativeKeysIn = nativeKeysIn$1;
var isObject$4 = isObject_1, isPrototype$1 = _isPrototype, nativeKeysIn = _nativeKeysIn;
var objectProto$2 = Object.prototype;
var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
function baseKeysIn$1(object) {
  if (!isObject$4(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype$1(object), result = [];
  for (var key in object) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty$2.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}
var _baseKeysIn = baseKeysIn$1;
var arrayLikeKeys = _arrayLikeKeys, baseKeysIn = _baseKeysIn, isArrayLike$1 = isArrayLike_1;
function keysIn$3(object) {
  return isArrayLike$1(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}
var keysIn_1 = keysIn$3;
var copyObject$3 = _copyObject, keysIn$2 = keysIn_1;
function baseAssignIn$1(object, source) {
  return object && copyObject$3(source, keysIn$2(source), object);
}
var _baseAssignIn = baseAssignIn$1;
var _cloneBuffer = { exports: {} };
_cloneBuffer.exports;
(function(module, exports) {
  var root3 = _root;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer2 = moduleExports ? root3.Buffer : void 0, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
  function cloneBuffer2(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
    buffer.copy(result);
    return result;
  }
  module.exports = cloneBuffer2;
})(_cloneBuffer, _cloneBuffer.exports);
var _cloneBufferExports = _cloneBuffer.exports;
function copyArray$1(source, array) {
  var index2 = -1, length = source.length;
  array || (array = Array(length));
  while (++index2 < length) {
    array[index2] = source[index2];
  }
  return array;
}
var _copyArray = copyArray$1;
var copyObject$2 = _copyObject, getSymbols$1 = _getSymbols;
function copySymbols$1(source, object) {
  return copyObject$2(source, getSymbols$1(source), object);
}
var _copySymbols = copySymbols$1;
var overArg = _overArg;
var getPrototype$3 = overArg(Object.getPrototypeOf, Object);
var _getPrototype = getPrototype$3;
var arrayPush = _arrayPush, getPrototype$2 = _getPrototype, getSymbols = _getSymbols, stubArray = stubArray_1;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbolsIn$2 = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype$2(object);
  }
  return result;
};
var _getSymbolsIn = getSymbolsIn$2;
var copyObject$1 = _copyObject, getSymbolsIn$1 = _getSymbolsIn;
function copySymbolsIn$1(source, object) {
  return copyObject$1(source, getSymbolsIn$1(source), object);
}
var _copySymbolsIn = copySymbolsIn$1;
var baseGetAllKeys = _baseGetAllKeys, getSymbolsIn = _getSymbolsIn, keysIn$1 = keysIn_1;
function getAllKeysIn$3(object) {
  return baseGetAllKeys(object, keysIn$1, getSymbolsIn);
}
var _getAllKeysIn = getAllKeysIn$3;
var objectProto$1 = Object.prototype;
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
function initCloneArray$1(array) {
  var length = array.length, result = new array.constructor(length);
  if (length && typeof array[0] == "string" && hasOwnProperty$1.call(array, "index")) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}
var _initCloneArray = initCloneArray$1;
var Uint8Array$1 = _Uint8Array;
function cloneArrayBuffer$3(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
  return result;
}
var _cloneArrayBuffer = cloneArrayBuffer$3;
var cloneArrayBuffer$2 = _cloneArrayBuffer;
function cloneDataView$1(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer$2(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
var _cloneDataView = cloneDataView$1;
var reFlags = /\w*$/;
function cloneRegExp$1(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}
var _cloneRegExp = cloneRegExp$1;
var Symbol$1 = _Symbol;
var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function cloneSymbol$1(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}
var _cloneSymbol = cloneSymbol$1;
var cloneArrayBuffer$1 = _cloneArrayBuffer;
function cloneTypedArray$1(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer$1(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var _cloneTypedArray = cloneTypedArray$1;
var cloneArrayBuffer = _cloneArrayBuffer, cloneDataView = _cloneDataView, cloneRegExp = _cloneRegExp, cloneSymbol = _cloneSymbol, cloneTypedArray = _cloneTypedArray;
var boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", symbolTag$1 = "[object Symbol]";
var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
function initCloneByTag$1(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag$1:
      return cloneArrayBuffer(object);
    case boolTag$1:
    case dateTag$1:
      return new Ctor(+object);
    case dataViewTag$1:
      return cloneDataView(object, isDeep);
    case float32Tag$1:
    case float64Tag$1:
    case int8Tag$1:
    case int16Tag$1:
    case int32Tag$1:
    case uint8Tag$1:
    case uint8ClampedTag$1:
    case uint16Tag$1:
    case uint32Tag$1:
      return cloneTypedArray(object, isDeep);
    case mapTag$2:
      return new Ctor();
    case numberTag$1:
    case stringTag$1:
      return new Ctor(object);
    case regexpTag$1:
      return cloneRegExp(object);
    case setTag$2:
      return new Ctor();
    case symbolTag$1:
      return cloneSymbol(object);
  }
}
var _initCloneByTag = initCloneByTag$1;
var isObject$3 = isObject_1;
var objectCreate = Object.create;
var baseCreate$1 = /* @__PURE__ */ function() {
  function object() {
  }
  return function(proto2) {
    if (!isObject$3(proto2)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto2);
    }
    object.prototype = proto2;
    var result = new object();
    object.prototype = void 0;
    return result;
  };
}();
var _baseCreate = baseCreate$1;
var baseCreate = _baseCreate, getPrototype$1 = _getPrototype, isPrototype = _isPrototype;
function initCloneObject$1(object) {
  return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype$1(object)) : {};
}
var _initCloneObject = initCloneObject$1;
var getTag$2 = _getTag, isObjectLike$2 = isObjectLike_1;
var mapTag$1 = "[object Map]";
function baseIsMap$1(value) {
  return isObjectLike$2(value) && getTag$2(value) == mapTag$1;
}
var _baseIsMap = baseIsMap$1;
var baseIsMap = _baseIsMap, baseUnary$2 = _baseUnary, nodeUtil$1 = _nodeUtilExports;
var nodeIsMap = nodeUtil$1 && nodeUtil$1.isMap;
var isMap$1 = nodeIsMap ? baseUnary$2(nodeIsMap) : baseIsMap;
var isMap_1 = isMap$1;
var getTag$1 = _getTag, isObjectLike$1 = isObjectLike_1;
var setTag$1 = "[object Set]";
function baseIsSet$1(value) {
  return isObjectLike$1(value) && getTag$1(value) == setTag$1;
}
var _baseIsSet = baseIsSet$1;
var baseIsSet = _baseIsSet, baseUnary$1 = _baseUnary, nodeUtil = _nodeUtilExports;
var nodeIsSet = nodeUtil && nodeUtil.isSet;
var isSet$1 = nodeIsSet ? baseUnary$1(nodeIsSet) : baseIsSet;
var isSet_1 = isSet$1;
var Stack = _Stack, arrayEach = _arrayEach, assignValue$1 = _assignValue, baseAssign = _baseAssign, baseAssignIn = _baseAssignIn, cloneBuffer = _cloneBufferExports, copyArray = _copyArray, copySymbols = _copySymbols, copySymbolsIn = _copySymbolsIn, getAllKeys = _getAllKeys, getAllKeysIn$2 = _getAllKeysIn, getTag = _getTag, initCloneArray = _initCloneArray, initCloneByTag = _initCloneByTag, initCloneObject = _initCloneObject, isArray$2 = isArray_1, isBuffer = isBufferExports, isMap = isMap_1, isObject$2 = isObject_1, isSet = isSet_1, keys$1 = keys_1, keysIn = keysIn_1;
var CLONE_DEEP_FLAG$1 = 1, CLONE_FLAT_FLAG$1 = 2, CLONE_SYMBOLS_FLAG$1 = 4;
var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag$1 = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag$1] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
function baseClone$1(value, bitmask, customizer, key, object, stack) {
  var result, isDeep = bitmask & CLONE_DEEP_FLAG$1, isFlat = bitmask & CLONE_FLAT_FLAG$1, isFull = bitmask & CLONE_SYMBOLS_FLAG$1;
  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== void 0) {
    return result;
  }
  if (!isObject$2(value)) {
    return value;
  }
  var isArr = isArray$2(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag$1 || tag == argsTag || isFunc && !object) {
      result = isFlat || isFunc ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  stack || (stack = new Stack());
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);
  if (isSet(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone$1(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap(value)) {
    value.forEach(function(subValue, key2) {
      result.set(key2, baseClone$1(subValue, bitmask, customizer, key2, value, stack));
    });
  }
  var keysFunc = isFull ? isFlat ? getAllKeysIn$2 : getAllKeys : isFlat ? keysIn : keys$1;
  var props = isArr ? void 0 : keysFunc(value);
  arrayEach(props || value, function(subValue, key2) {
    if (props) {
      key2 = subValue;
      subValue = value[key2];
    }
    assignValue$1(result, key2, baseClone$1(subValue, bitmask, customizer, key2, value, stack));
  });
  return result;
}
var _baseClone = baseClone$1;
function last$1(array) {
  var length = array == null ? 0 : array.length;
  return length ? array[length - 1] : void 0;
}
var last_1 = last$1;
function baseSlice$1(array, start, end) {
  var index2 = -1, length = array.length;
  if (start < 0) {
    start = -start > length ? 0 : length + start;
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : end - start >>> 0;
  start >>>= 0;
  var result = Array(length);
  while (++index2 < length) {
    result[index2] = array[index2 + start];
  }
  return result;
}
var _baseSlice = baseSlice$1;
var baseGet$2 = _baseGet, baseSlice = _baseSlice;
function parent$1(object, path3) {
  return path3.length < 2 ? object : baseGet$2(object, baseSlice(path3, 0, -1));
}
var _parent = parent$1;
var castPath$3 = _castPath, last = last_1, parent = _parent, toKey$1 = _toKey;
function baseUnset$2(object, path3) {
  path3 = castPath$3(path3, object);
  object = parent(object, path3);
  return object == null || delete object[toKey$1(last(path3))];
}
var _baseUnset = baseUnset$2;
var baseGetTag = _baseGetTag, getPrototype = _getPrototype, isObjectLike = isObjectLike_1;
var objectTag = "[object Object]";
var funcProto = Function.prototype, objectProto = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty = objectProto.hasOwnProperty;
var objectCtorString = funcToString.call(Object);
function isPlainObject$1(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto2 = getPrototype(value);
  if (proto2 === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto2, "constructor") && proto2.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}
var isPlainObject_1 = isPlainObject$1;
var isPlainObject = isPlainObject_1;
function customOmitClone$1(value) {
  return isPlainObject(value) ? void 0 : value;
}
var _customOmitClone = customOmitClone$1;
function apply$1(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
var _apply = apply$1;
var apply = _apply;
var nativeMax = Math.max;
function overRest$2(func, start, transform) {
  start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
  return function() {
    var args = arguments, index2 = -1, length = nativeMax(args.length - start, 0), array = Array(length);
    while (++index2 < length) {
      array[index2] = args[start + index2];
    }
    index2 = -1;
    var otherArgs = Array(start + 1);
    while (++index2 < start) {
      otherArgs[index2] = args[index2];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}
var _overRest = overRest$2;
function constant$1(value) {
  return function() {
    return value;
  };
}
var constant_1 = constant$1;
var constant = constant_1, defineProperty = _defineProperty, identity$2 = identity_1;
var baseSetToString$1 = !defineProperty ? identity$2 : function(func, string) {
  return defineProperty(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant(string),
    "writable": true
  });
};
var _baseSetToString = baseSetToString$1;
var HOT_COUNT = 800, HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut$1(func) {
  var count = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(void 0, arguments);
  };
}
var _shortOut = shortOut$1;
var baseSetToString = _baseSetToString, shortOut = _shortOut;
var setToString$2 = shortOut(baseSetToString);
var _setToString = setToString$2;
var flatten = flatten_1, overRest$1 = _overRest, setToString$1 = _setToString;
function flatRest$1(func) {
  return setToString$1(overRest$1(func, void 0, flatten), func + "");
}
var _flatRest = flatRest$1;
var arrayMap$3 = _arrayMap, baseClone = _baseClone, baseUnset$1 = _baseUnset, castPath$2 = _castPath, copyObject = _copyObject, customOmitClone = _customOmitClone, flatRest = _flatRest, getAllKeysIn$1 = _getAllKeysIn;
var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
var omit = flatRest(function(object, paths) {
  var result = {};
  if (object == null) {
    return result;
  }
  var isDeep = false;
  paths = arrayMap$3(paths, function(path3) {
    path3 = castPath$2(path3, object);
    isDeep || (isDeep = path3.length > 1);
    return path3;
  });
  copyObject(object, getAllKeysIn$1(object), result);
  if (isDeep) {
    result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
  }
  var length = paths.length;
  while (length--) {
    baseUnset$1(result, paths[length]);
  }
  return result;
});
var omit_1 = omit;
const z = /* @__PURE__ */ getDefaultExportFromCjs(omit_1);
var assignValue = _assignValue, castPath$1 = _castPath, isIndex$1 = _isIndex, isObject$1 = isObject_1, toKey = _toKey;
function baseSet$2(object, path3, value, customizer) {
  if (!isObject$1(object)) {
    return object;
  }
  path3 = castPath$1(path3, object);
  var index2 = -1, length = path3.length, lastIndex = length - 1, nested = object;
  while (nested != null && ++index2 < length) {
    var key = toKey(path3[index2]), newValue = value;
    if (key === "__proto__" || key === "constructor" || key === "prototype") {
      return object;
    }
    if (index2 != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : void 0;
      if (newValue === void 0) {
        newValue = isObject$1(objValue) ? objValue : isIndex$1(path3[index2 + 1]) ? [] : {};
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}
var _baseSet = baseSet$2;
var baseGet$1 = _baseGet, baseSet$1 = _baseSet, castPath = _castPath;
function basePickBy$1(object, paths, predicate) {
  var index2 = -1, length = paths.length, result = {};
  while (++index2 < length) {
    var path3 = paths[index2], value = baseGet$1(object, path3);
    if (predicate(value, path3)) {
      baseSet$1(result, castPath(path3, object), value);
    }
  }
  return result;
}
var _basePickBy = basePickBy$1;
var arrayMap$2 = _arrayMap, baseIteratee$2 = _baseIteratee, basePickBy = _basePickBy, getAllKeysIn = _getAllKeysIn;
function pickBy(object, predicate) {
  if (object == null) {
    return {};
  }
  var props = arrayMap$2(getAllKeysIn(object), function(prop) {
    return [prop];
  });
  predicate = baseIteratee$2(predicate);
  return basePickBy(object, props, function(value, path3) {
    return predicate(value, path3[0]);
  });
}
var pickBy_1 = pickBy;
const W = /* @__PURE__ */ getDefaultExportFromCjs(pickBy_1);
var baseSet = _baseSet;
function set(object, path3, value) {
  return object == null ? object : baseSet(object, path3, value);
}
var set_1 = set;
const H = /* @__PURE__ */ getDefaultExportFromCjs(set_1);
var baseEach = _baseEach;
function baseSome$1(collection, predicate) {
  var result;
  baseEach(collection, function(value, index2, collection2) {
    result = predicate(value, index2, collection2);
    return !result;
  });
  return !!result;
}
var _baseSome = baseSome$1;
var eq = eq_1, isArrayLike = isArrayLike_1, isIndex = _isIndex, isObject = isObject_1;
function isIterateeCall$2(value, index2, object) {
  if (!isObject(object)) {
    return false;
  }
  var type3 = typeof index2;
  if (type3 == "number" ? isArrayLike(object) && isIndex(index2, object.length) : type3 == "string" && index2 in object) {
    return eq(object[index2], value);
  }
  return false;
}
var _isIterateeCall = isIterateeCall$2;
var arraySome = _arraySome, baseIteratee$1 = _baseIteratee, baseSome = _baseSome, isArray$1 = isArray_1, isIterateeCall$1 = _isIterateeCall;
function some(collection, predicate, guard) {
  var func = isArray$1(collection) ? arraySome : baseSome;
  if (guard && isIterateeCall$1(collection, predicate, guard)) {
    predicate = void 0;
  }
  return func(collection, baseIteratee$1(predicate));
}
var some_1 = some;
const K = /* @__PURE__ */ getDefaultExportFromCjs(some_1);
function baseSortBy$1(array, comparer) {
  var length = array.length;
  array.sort(comparer);
  while (length--) {
    array[length] = array[length].value;
  }
  return array;
}
var _baseSortBy = baseSortBy$1;
var isSymbol = isSymbol_1;
function compareAscending$1(value, other) {
  if (value !== other) {
    var valIsDefined = value !== void 0, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
    var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
    if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
      return 1;
    }
    if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
      return -1;
    }
  }
  return 0;
}
var _compareAscending = compareAscending$1;
var compareAscending = _compareAscending;
function compareMultiple$1(object, other, orders) {
  var index2 = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
  while (++index2 < length) {
    var result = compareAscending(objCriteria[index2], othCriteria[index2]);
    if (result) {
      if (index2 >= ordersLength) {
        return result;
      }
      var order = orders[index2];
      return result * (order == "desc" ? -1 : 1);
    }
  }
  return object.index - other.index;
}
var _compareMultiple = compareMultiple$1;
var arrayMap$1 = _arrayMap, baseGet = _baseGet, baseIteratee = _baseIteratee, baseMap = _baseMap, baseSortBy = _baseSortBy, baseUnary = _baseUnary, compareMultiple = _compareMultiple, identity$1 = identity_1, isArray = isArray_1;
function baseOrderBy$1(collection, iteratees, orders) {
  if (iteratees.length) {
    iteratees = arrayMap$1(iteratees, function(iteratee) {
      if (isArray(iteratee)) {
        return function(value) {
          return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
        };
      }
      return iteratee;
    });
  } else {
    iteratees = [identity$1];
  }
  var index2 = -1;
  iteratees = arrayMap$1(iteratees, baseUnary(baseIteratee));
  var result = baseMap(collection, function(value, key, collection2) {
    var criteria = arrayMap$1(iteratees, function(iteratee) {
      return iteratee(value);
    });
    return { "criteria": criteria, "index": ++index2, "value": value };
  });
  return baseSortBy(result, function(object, other) {
    return compareMultiple(object, other, orders);
  });
}
var _baseOrderBy = baseOrderBy$1;
var identity = identity_1, overRest = _overRest, setToString = _setToString;
function baseRest$1(func, start) {
  return setToString(overRest(func, start, identity), func + "");
}
var _baseRest = baseRest$1;
var baseFlatten = _baseFlatten, baseOrderBy = _baseOrderBy, baseRest = _baseRest, isIterateeCall = _isIterateeCall;
var sortBy = baseRest(function(collection, iteratees) {
  if (collection == null) {
    return [];
  }
  var length = iteratees.length;
  if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
    iteratees = [];
  } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
    iteratees = [iteratees[0]];
  }
  return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
});
var sortBy_1 = sortBy;
const Y = /* @__PURE__ */ getDefaultExportFromCjs(sortBy_1);
var baseTimes = _baseTimes, castFunction = _castFunction, toInteger = toInteger_1;
var MAX_SAFE_INTEGER = 9007199254740991;
var MAX_ARRAY_LENGTH = 4294967295;
var nativeMin = Math.min;
function times(n, iteratee) {
  n = toInteger(n);
  if (n < 1 || n > MAX_SAFE_INTEGER) {
    return [];
  }
  var index2 = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
  iteratee = castFunction(iteratee);
  n -= MAX_ARRAY_LENGTH;
  var result = baseTimes(length, iteratee);
  while (++index2 < n) {
    iteratee(index2);
  }
  return result;
}
var times_1 = times;
const Z = /* @__PURE__ */ getDefaultExportFromCjs(times_1);
var baseUnset = _baseUnset;
function unset(object, path3) {
  return object == null ? true : baseUnset(object, path3);
}
var unset_1 = unset;
const X = /* @__PURE__ */ getDefaultExportFromCjs(unset_1);
var arrayMap = _arrayMap;
function baseValues$1(object, props) {
  return arrayMap(props, function(key) {
    return object[key];
  });
}
var _baseValues = baseValues$1;
var baseValues = _baseValues, keys = keys_1;
function values(object) {
  return object == null ? [] : baseValues(object, keys(object));
}
var values_1 = values;
const k = /* @__PURE__ */ getDefaultExportFromCjs(values_1);
function v(s2) {
  return Object.keys(s2).join(",");
}
function I(s2) {
  let e, t = "", r = s2;
  for (; r > 0; )
    e = (r - 1) % 26, t = String.fromCharCode(e + 65) + t, r = (r - e - 1) / 26;
  return t;
}
function J(s2) {
  let e = 0;
  const { length: t } = s2;
  for (let r = 0; r < t; r++)
    e += (s2.charCodeAt(r) - 64) * 26 ** (t - r - 1);
  return e;
}
function S(s2) {
  let e = "";
  return Object.keys(s2).forEach((t) => {
    const r = typeof s2[t] == "object", a = r && s2[t].length >= 0;
    if (r || (e += `${t}=${encodeURIComponent(s2[t])}&`), r && a)
      for (const o of s2[t])
        e += `${t}=${encodeURIComponent(o)}&`;
  }), e && e.slice(0, -1);
}
function F(s2) {
  const e = L(s2);
  u(e, (t, r) => {
    if (r && t.length > 1)
      throw new Error(`Duplicate header detected: "${r}". Please make sure all non-empty headers are unique`);
  });
}
class E {
  constructor(e, t, r) {
    this._worksheet = e, this._rowNumber = t, this._rawData = r, this._deleted = false;
  }
  get deleted() {
    return this._deleted;
  }
  get rowNumber() {
    return this._rowNumber;
  }
  _updateRowNumber(e) {
    this._rowNumber = e;
  }
  get a1Range() {
    return [this._worksheet.a1SheetName, "!", `A${this._rowNumber}`, ":", `${I(this._worksheet.headerValues.length)}${this._rowNumber}`].join("");
  }
  get(e) {
    const t = this._worksheet.headerValues.indexOf(e);
    return this._rawData[t];
  }
  set(e, t) {
    const r = this._worksheet.headerValues.indexOf(e);
    this._rawData[r] = t;
  }
  assign(e) {
    for (const t in e)
      this.set(t, e[t]);
  }
  toObject() {
    const e = {};
    for (let t = 0; t < this._worksheet.headerValues.length; t++) {
      const r = this._worksheet.headerValues[t];
      r && (e[r] = this._rawData[t]);
    }
    return e;
  }
  async save(e) {
    if (this._deleted)
      throw new Error("This row has been deleted - call getRows again before making updates.");
    const t = await this._worksheet._spreadsheet.sheetsApi.request({ method: "put", url: `/values/${encodeURIComponent(this.a1Range)}`, params: { valueInputOption: e?.raw ? "RAW" : "USER_ENTERED", includeValuesInResponse: true }, data: { range: this.a1Range, majorDimension: "ROWS", values: [this._rawData] } });
    this._rawData = t.data.updatedData.values[0];
  }
  async delete() {
    if (this._deleted)
      throw new Error("This row has been deleted - call getRows again before making updates.");
    const e = await this._worksheet._makeSingleUpdateRequest("deleteRange", { range: { sheetId: this._worksheet.sheetId, startRowIndex: this._rowNumber - 1, endRowIndex: this._rowNumber }, shiftDimension: "ROWS" });
    return this._deleted = true, this._worksheet._shiftRowCache(this.rowNumber), e;
  }
  _clearRowData() {
    for (let e = 0; e < this._rawData.length; e++)
      this._rawData[e] = "";
  }
}
class b {
  constructor(e) {
    this.type = e.type, this.message = e.message;
  }
}
class V {
  constructor(e, t, r, a) {
    this._sheet = e, this._rowIndex = t, this._columnIndex = r, this._draftData = {}, this._updateRawData(a), this._rawData = a;
  }
  _updateRawData(e) {
    this._rawData = e, this._draftData = {}, this._rawData?.effectiveValue && "errorValue" in this._rawData.effectiveValue ? this._error = new b(this._rawData.effectiveValue.errorValue) : this._error = void 0;
  }
  get rowIndex() {
    return this._rowIndex;
  }
  get columnIndex() {
    return this._columnIndex;
  }
  get a1Column() {
    return I(this._columnIndex + 1);
  }
  get a1Row() {
    return this._rowIndex + 1;
  }
  get a1Address() {
    return `${this.a1Column}${this.a1Row}`;
  }
  get value() {
    if (this._draftData.value !== void 0)
      throw new Error("Value has been changed");
    return this._error ? this._error : this._rawData?.effectiveValue ? k(this._rawData.effectiveValue)[0] : null;
  }
  set value(e) {
    if (e instanceof b)
      throw new Error("You can't manually set a value to an error");
    if (O(e))
      this._draftData.valueType = "boolValue";
    else if (w(e))
      e.substring(0, 1) === "=" ? this._draftData.valueType = "formulaValue" : this._draftData.valueType = "stringValue";
    else if (M(e))
      this._draftData.valueType = "numberValue";
    else if (B(e))
      this._draftData.valueType = "stringValue", e = "";
    else
      throw new Error("Set value to boolean, string, or number");
    this._draftData.value = e;
  }
  get valueType() {
    return this._error ? "errorValue" : this._rawData?.effectiveValue ? R(this._rawData.effectiveValue)[0] : null;
  }
  get formattedValue() {
    return this._rawData?.formattedValue || null;
  }
  get formula() {
    return p(this._rawData, "userEnteredValue.formulaValue", null);
  }
  set formula(e) {
    if (!e)
      throw new Error("To clear a formula, set `cell.value = null`");
    if (e.substring(0, 1) !== "=")
      throw new Error('formula must begin with "="');
    this.value = e;
  }
  get formulaError() {
    return this._error;
  }
  get errorValue() {
    return this._error;
  }
  get numberValue() {
    if (this.valueType === "numberValue")
      return this.value;
  }
  set numberValue(e) {
    this.value = e;
  }
  get boolValue() {
    if (this.valueType === "boolValue")
      return this.value;
  }
  set boolValue(e) {
    this.value = e;
  }
  get stringValue() {
    if (this.valueType === "stringValue")
      return this.value;
  }
  set stringValue(e) {
    if (e?.startsWith("="))
      throw new Error("Use cell.formula to set formula values");
    this.value = e;
  }
  get hyperlink() {
    if (this._draftData.value)
      throw new Error("Save cell to be able to read hyperlink");
    return this._rawData?.hyperlink;
  }
  get note() {
    return this._draftData.note !== void 0 ? this._draftData.note : this._rawData?.note;
  }
  set note(e) {
    if ((e == null || e === false) && (e = ""), !w(e))
      throw new Error("Note must be a string");
    e === this._rawData?.note ? delete this._draftData.note : this._draftData.note = e;
  }
  get userEnteredFormat() {
    return Object.freeze(this._rawData?.userEnteredFormat);
  }
  get effectiveFormat() {
    return Object.freeze(this._rawData?.effectiveFormat);
  }
  _getFormatParam(e) {
    if (p(this._draftData, `userEnteredFormat.${e}`))
      throw new Error("User format is unsaved - save the cell to be able to read it again");
    return Object.freeze(this._rawData.userEnteredFormat[e]);
  }
  _setFormatParam(e, t) {
    q(t, p(this._rawData, `userEnteredFormat.${e}`)) ? X(this._draftData, `userEnteredFormat.${e}`) : (H(this._draftData, `userEnteredFormat.${e}`, t), this._draftData.clearFormat = false);
  }
  get numberFormat() {
    return this._getFormatParam("numberFormat");
  }
  get backgroundColor() {
    return this._getFormatParam("backgroundColor");
  }
  get backgroundColorStyle() {
    return this._getFormatParam("backgroundColorStyle");
  }
  get borders() {
    return this._getFormatParam("borders");
  }
  get padding() {
    return this._getFormatParam("padding");
  }
  get horizontalAlignment() {
    return this._getFormatParam("horizontalAlignment");
  }
  get verticalAlignment() {
    return this._getFormatParam("verticalAlignment");
  }
  get wrapStrategy() {
    return this._getFormatParam("wrapStrategy");
  }
  get textDirection() {
    return this._getFormatParam("textDirection");
  }
  get textFormat() {
    return this._getFormatParam("textFormat");
  }
  get hyperlinkDisplayType() {
    return this._getFormatParam("hyperlinkDisplayType");
  }
  get textRotation() {
    return this._getFormatParam("textRotation");
  }
  set numberFormat(e) {
    this._setFormatParam("numberFormat", e);
  }
  set backgroundColor(e) {
    this._setFormatParam("backgroundColor", e);
  }
  set backgroundColorStyle(e) {
    this._setFormatParam("backgroundColorStyle", e);
  }
  set borders(e) {
    this._setFormatParam("borders", e);
  }
  set padding(e) {
    this._setFormatParam("padding", e);
  }
  set horizontalAlignment(e) {
    this._setFormatParam("horizontalAlignment", e);
  }
  set verticalAlignment(e) {
    this._setFormatParam("verticalAlignment", e);
  }
  set wrapStrategy(e) {
    this._setFormatParam("wrapStrategy", e);
  }
  set textDirection(e) {
    this._setFormatParam("textDirection", e);
  }
  set textFormat(e) {
    this._setFormatParam("textFormat", e);
  }
  set hyperlinkDisplayType(e) {
    this._setFormatParam("hyperlinkDisplayType", e);
  }
  set textRotation(e) {
    this._setFormatParam("textRotation", e);
  }
  clearAllFormatting() {
    this._draftData.clearFormat = true, delete this._draftData.userEnteredFormat;
  }
  get _isDirty() {
    return !!(this._draftData.note !== void 0 || R(this._draftData.userEnteredFormat).length || this._draftData.clearFormat || this._draftData.value !== void 0);
  }
  discardUnsavedChanges() {
    this._draftData = {};
  }
  async save() {
    await this._sheet.saveCells([this]);
  }
  _getUpdateRequest() {
    const e = this._draftData.value !== void 0, t = this._draftData.note !== void 0, r = !!R(this._draftData.userEnteredFormat || {}).length, a = this._draftData.clearFormat;
    if (!K([e, t, r, a]))
      return null;
    const o = { ...this._rawData?.userEnteredFormat, ...this._draftData.userEnteredFormat };
    return p(this._draftData, "userEnteredFormat.backgroundColor") && delete o.backgroundColorStyle, { updateCells: { rows: [{ values: [{ ...e && { userEnteredValue: { [this._draftData.valueType]: this._draftData.value } }, ...t && { note: this._draftData.note }, ...r && { userEnteredFormat: o }, ...a && { userEnteredFormat: {} } }] }], fields: R(W({ userEnteredValue: e, note: t, userEnteredFormat: r || a })).join(","), start: { sheetId: this._sheet.sheetId, rowIndex: this.rowIndex, columnIndex: this.columnIndex } } };
  }
}
class $ {
  constructor(e, t, r) {
    this._spreadsheet = e, this._headerRowIndex = 1, this._rawProperties = null, this._cells = [], this._rowMetadata = [], this._columnMetadata = [], this._rowCache = [], this._headerRowIndex = 1, this._rawProperties = t, this._cells = [], this._rowMetadata = [], this._columnMetadata = [], r && this._fillCellData(r);
  }
  get headerValues() {
    if (!this._headerValues)
      throw new Error("Header values are not yet loaded");
    return this._headerValues;
  }
  updateRawData(e, t) {
    this._rawProperties = e, this._fillCellData(t);
  }
  async _makeSingleUpdateRequest(e, t) {
    return this._spreadsheet._makeSingleUpdateRequest(e, { ...t });
  }
  _ensureInfoLoaded() {
    if (!this._rawProperties)
      throw new Error("You must call `doc.loadInfo()` again before accessing this property");
  }
  resetLocalCache(e) {
    e || (this._rawProperties = null), this._headerValues = void 0, this._headerRowIndex = 1, this._cells = [];
  }
  _fillCellData(e) {
    u(e, (t) => {
      const r = t.startRow || 0, a = t.startColumn || 0, o = t.rowMetadata.length, h2 = t.columnMetadata.length;
      for (let i = 0; i < o; i++) {
        const n = r + i;
        for (let d2 = 0; d2 < h2; d2++) {
          const l = a + d2;
          this._cells[n] || (this._cells[n] = []);
          const m2 = p(t, `rowData[${i}].values[${d2}]`);
          this._cells[n][l] ? this._cells[n][l]._updateRawData(m2) : this._cells[n][l] = new V(this, n, l, m2);
        }
      }
      for (let i = 0; i < t.rowMetadata.length; i++)
        this._rowMetadata[r + i] = t.rowMetadata[i];
      for (let i = 0; i < t.columnMetadata.length; i++)
        this._columnMetadata[a + i] = t.columnMetadata[i];
    });
  }
  _addSheetIdToRange(e) {
    if (e.sheetId && e.sheetId !== this.sheetId)
      throw new Error("Leave sheet ID blank or set to matching ID of this sheet");
    return { ...e, sheetId: this.sheetId };
  }
  _getProp(e) {
    return this._ensureInfoLoaded(), this._rawProperties[e];
  }
  _setProp(e, t) {
    throw new Error("Do not update directly - use `updateProperties()`");
  }
  get sheetId() {
    return this._getProp("sheetId");
  }
  get title() {
    return this._getProp("title");
  }
  get index() {
    return this._getProp("index");
  }
  get sheetType() {
    return this._getProp("sheetType");
  }
  get gridProperties() {
    return this._getProp("gridProperties");
  }
  get hidden() {
    return this._getProp("hidden");
  }
  get tabColor() {
    return this._getProp("tabColor");
  }
  get rightToLeft() {
    return this._getProp("rightToLeft");
  }
  set sheetId(e) {
    this._setProp("sheetId", e);
  }
  set title(e) {
    this._setProp("title", e);
  }
  set index(e) {
    this._setProp("index", e);
  }
  set sheetType(e) {
    this._setProp("sheetType", e);
  }
  set gridProperties(e) {
    this._setProp("gridProperties", e);
  }
  set hidden(e) {
    this._setProp("hidden", e);
  }
  set tabColor(e) {
    this._setProp("tabColor", e);
  }
  set rightToLeft(e) {
    this._setProp("rightToLeft", e);
  }
  get rowCount() {
    return this._ensureInfoLoaded(), this.gridProperties.rowCount;
  }
  get columnCount() {
    return this._ensureInfoLoaded(), this.gridProperties.columnCount;
  }
  get a1SheetName() {
    return `'${this.title.replace(/'/g, "''")}'`;
  }
  get encodedA1SheetName() {
    return encodeURIComponent(this.a1SheetName);
  }
  get lastColumnLetter() {
    return this.columnCount ? I(this.columnCount) : "";
  }
  get cellStats() {
    let e = A(this._cells);
    return e = g(e), { nonEmpty: P(e, (t) => t.value).length, loaded: e.length, total: this.rowCount * this.columnCount };
  }
  getCellByA1(e) {
    const t = e.match(/([A-Z]+)([0-9]+)/);
    if (!t)
      throw new Error(`Cell address "${e}" not valid`);
    const r = J(t[1]), a = parseInt(t[2]);
    return this.getCell(a - 1, r - 1);
  }
  getCell(e, t) {
    if (e < 0 || t < 0)
      throw new Error("Min coordinate is 0, 0");
    if (e >= this.rowCount || t >= this.columnCount)
      throw new Error(`Out of bounds, sheet is ${this.rowCount} by ${this.columnCount}`);
    if (!p(this._cells, `[${e}][${t}]`))
      throw new Error("This cell has not been loaded yet");
    return this._cells[e][t];
  }
  async loadCells(e) {
    if (!e)
      return this._spreadsheet.loadCells(this.a1SheetName);
    const t = f(e) ? e : [e], r = c(t, (a) => {
      if (w(a))
        return a.startsWith(this.a1SheetName) ? a : `${this.a1SheetName}!${a}`;
      if (y(a)) {
        const o = a;
        if (o.sheetId && o.sheetId !== this.sheetId)
          throw new Error("Leave sheet ID blank or set to matching ID of this sheet");
        return { sheetId: this.sheetId, ...a };
      }
      throw new Error("Each filter must be a A1 range string or gridrange object");
    });
    return this._spreadsheet.loadCells(r);
  }
  async saveUpdatedCells() {
    const e = P(A(this._cells), { _isDirty: true });
    e.length && await this.saveCells(e);
  }
  async saveCells(e) {
    const t = c(e, (a) => a._getUpdateRequest()), r = c(e, (a) => `${this.a1SheetName}!${a.a1Address}`);
    if (!g(t).length)
      throw new Error("At least one cell must have something to update");
    await this._spreadsheet._makeBatchUpdateRequest(t, r);
  }
  async _ensureHeaderRowLoaded() {
    this._headerValues || await this.loadHeaderRow();
  }
  async loadHeaderRow(e) {
    e !== void 0 && (this._headerRowIndex = e);
    const t = await this.getCellsInRange(`A${this._headerRowIndex}:${this.lastColumnLetter}${this._headerRowIndex}`);
    if (!t)
      throw new Error("No values in the header row - fill the first row with header values before trying to interact with rows");
    if (this._headerValues = c(t[0], (r) => r?.trim()), !g(this.headerValues).length)
      throw new Error("All your header cells are blank - fill the first row with header values before trying to interact with rows");
    F(this.headerValues);
  }
  async setHeaderRow(e, t) {
    if (!e)
      return;
    if (e.length > this.columnCount)
      throw new Error(`Sheet is not large enough to fit ${e.length} columns. Resize the sheet first.`);
    const r = c(e, (o) => o?.trim());
    if (F(r), !g(r).length)
      throw new Error("All your header cells are blank -");
    t && (this._headerRowIndex = t);
    const a = await this._spreadsheet.sheetsApi.request({ method: "put", url: `/values/${this.encodedA1SheetName}!${this._headerRowIndex}:${this._headerRowIndex}`, params: { valueInputOption: "USER_ENTERED", includeValuesInResponse: true }, data: { range: `${this.a1SheetName}!${this._headerRowIndex}:${this._headerRowIndex}`, majorDimension: "ROWS", values: [[...r, ...Z(this.columnCount - r.length, () => "")]] } });
    this._headerValues = a.data.updatedData.values[0];
  }
  async addRows(e, t = {}) {
    if (this.title.includes(":"))
      throw new Error('Please remove the ":" from your sheet title. There is a bug with the google API which breaks appending rows if any colons are in the sheet title.');
    if (!f(e))
      throw new Error("You must pass in an array of row values to append");
    await this._ensureHeaderRowLoaded();
    const r = [];
    u(e, (i) => {
      let n;
      if (f(i))
        n = i;
      else if (y(i)) {
        n = [];
        for (let d2 = 0; d2 < this.headerValues.length; d2++) {
          const l = this.headerValues[d2];
          n[d2] = i[l];
        }
      } else
        throw new Error("Each row must be an object or an array");
      r.push(n);
    });
    const a = await this._spreadsheet.sheetsApi.request({ method: "post", url: `/values/${this.encodedA1SheetName}!A${this._headerRowIndex}:append`, params: { valueInputOption: t.raw ? "RAW" : "USER_ENTERED", insertDataOption: t.insert ? "INSERT_ROWS" : "OVERWRITE", includeValuesInResponse: true }, data: { values: r } }), { updatedRange: o } = a.data.updates;
    let h2 = o.match(/![A-Z]+([0-9]+):?/)[1];
    return h2 = parseInt(h2), this._ensureInfoLoaded(), t.insert ? this._rawProperties.gridProperties.rowCount += e.length : h2 + e.length > this.rowCount && (this._rawProperties.gridProperties.rowCount = h2 + e.length - 1), c(a.data.updates.updatedData.values, (i) => new E(this, h2++, i));
  }
  async addRow(e, t) {
    return (await this.addRows([e], t))[0];
  }
  async getRows(e) {
    const t = e?.offset || 0, r = e?.limit || this.rowCount - 1;
    await this._ensureHeaderRowLoaded();
    const a = 1 + this._headerRowIndex + t, o = a + r - 1, h2 = I(this.headerValues.length), i = await this.getCellsInRange(`A${a}:${h2}${o}`);
    if (!i)
      return [];
    const n = [];
    let d2 = a;
    for (let l = 0; l < i.length; l++) {
      const m2 = new E(this, d2++, i[l]);
      this._rowCache[m2.rowNumber] = m2, n.push(m2);
    }
    return n;
  }
  _shiftRowCache(e) {
    delete this._rowCache[e], this._rowCache.forEach((t) => {
      t.rowNumber > e && t._updateRowNumber(t.rowNumber - 1);
    });
  }
  async clearRows(e) {
    const t = e?.start || this._headerRowIndex + 1, r = e?.end || this.rowCount;
    await this._spreadsheet.sheetsApi.post(`/values/${this.encodedA1SheetName}!${t}:${r}:clear`), this._rowCache.forEach((a) => {
      a.rowNumber >= t && a.rowNumber <= r && a._clearRowData();
    });
  }
  async updateProperties(e) {
    return this._makeSingleUpdateRequest("updateSheetProperties", { properties: { sheetId: this.sheetId, ...e }, fields: v(e) });
  }
  async updateGridProperties(e) {
    return this.updateProperties({ gridProperties: e });
  }
  async resize(e) {
    return this.updateGridProperties(e);
  }
  async updateDimensionProperties(e, t, r) {
    return this._makeSingleUpdateRequest("updateDimensionProperties", { range: { sheetId: this.sheetId, dimension: e, ...r }, properties: t, fields: v(t) });
  }
  async getCellsInRange(e, t) {
    return (await this._spreadsheet.sheetsApi.get(`/values/${this.encodedA1SheetName}!${e}`, { params: t })).data.values;
  }
  async updateNamedRange() {
  }
  async addNamedRange() {
  }
  async deleteNamedRange() {
  }
  async repeatCell() {
  }
  async autoFill() {
  }
  async cutPaste() {
  }
  async copyPaste() {
  }
  async mergeCells(e, t = "MERGE_ALL") {
    await this._makeSingleUpdateRequest("mergeCells", { mergeType: t, range: this._addSheetIdToRange(e) });
  }
  async unmergeCells(e) {
    await this._makeSingleUpdateRequest("unmergeCells", { range: this._addSheetIdToRange(e) });
  }
  async updateBorders() {
  }
  async addFilterView() {
  }
  async appendCells() {
  }
  async clearBasicFilter() {
  }
  async deleteDimension() {
  }
  async deleteEmbeddedObject() {
  }
  async deleteFilterView() {
  }
  async duplicateFilterView() {
  }
  async duplicate(e) {
    const t = (await this._makeSingleUpdateRequest("duplicateSheet", { sourceSheetId: this.sheetId, ...e?.index !== void 0 && { insertSheetIndex: e.index }, ...e?.id && { newSheetId: e.id }, ...e?.title && { newSheetName: e.title } })).properties.sheetId;
    return this._spreadsheet.sheetsById[t];
  }
  async findReplace() {
  }
  async insertDimension(e, t, r) {
    if (!e)
      throw new Error("You need to specify a dimension. i.e. COLUMNS|ROWS");
    if (!y(t))
      throw new Error("`range` must be an object containing `startIndex` and `endIndex`");
    if (!x(t.startIndex) || t.startIndex < 0)
      throw new Error("range.startIndex must be an integer >=0");
    if (!x(t.endIndex) || t.endIndex < 0)
      throw new Error("range.endIndex must be an integer >=0");
    if (t.endIndex <= t.startIndex)
      throw new Error("range.endIndex must be greater than range.startIndex");
    if (r === void 0 && (r = t.startIndex > 0), r && t.startIndex === 0)
      throw new Error("Cannot set inheritFromBefore to true if inserting in first row/column");
    return this._makeSingleUpdateRequest("insertDimension", { range: { sheetId: this.sheetId, dimension: e, startIndex: t.startIndex, endIndex: t.endIndex }, inheritFromBefore: r });
  }
  async insertRange() {
  }
  async moveDimension() {
  }
  async updateEmbeddedObjectPosition() {
  }
  async pasteData() {
  }
  async textToColumns() {
  }
  async updateFilterView() {
  }
  async deleteRange() {
  }
  async appendDimension() {
  }
  async addConditionalFormatRule() {
  }
  async updateConditionalFormatRule() {
  }
  async deleteConditionalFormatRule() {
  }
  async sortRange() {
  }
  async setDataValidation() {
  }
  async setBasicFilter() {
  }
  async addProtectedRange() {
  }
  async updateProtectedRange() {
  }
  async deleteProtectedRange() {
  }
  async autoResizeDimensions() {
  }
  async addChart() {
  }
  async updateChartSpec() {
  }
  async updateBanding() {
  }
  async addBanding() {
  }
  async deleteBanding() {
  }
  async createDeveloperMetadata() {
  }
  async updateDeveloperMetadata() {
  }
  async deleteDeveloperMetadata() {
  }
  async randomizeRange() {
  }
  async addDimensionGroup() {
  }
  async deleteDimensionGroup() {
  }
  async updateDimensionGroup() {
  }
  async trimWhitespace() {
  }
  async deleteDuplicates() {
  }
  async addSlicer() {
  }
  async updateSlicerSpec() {
  }
  async delete() {
    return this._spreadsheet.deleteSheet(this.sheetId);
  }
  async copyToSpreadsheet(e) {
    return this._spreadsheet.sheetsApi.post(`/sheets/${this.sheetId}:copyTo`, { destinationSpreadsheetId: e });
  }
  async clear(e) {
    const t = e ? `!${e}` : "";
    await this._spreadsheet.sheetsApi.post(`/values/${this.encodedA1SheetName}${t}:clear`), this.resetLocalCache(true);
  }
  async downloadAsCSV(e = false) {
    return this._spreadsheet._downloadAs("csv", this.sheetId, e);
  }
  async downloadAsTSV(e = false) {
    return this._spreadsheet._downloadAs("tsv", this.sheetId, e);
  }
  async downloadAsPDF(e = false) {
    return this._spreadsheet._downloadAs("pdf", this.sheetId, e);
  }
}
var _ = ((s2) => (s2.GOOGLE_AUTH_CLIENT = "google_auth", s2.RAW_ACCESS_TOKEN = "raw_access_token", s2.API_KEY = "api_key", s2))(_ || {});
const T = "https://sheets.googleapis.com/v4/spreadsheets", Q = "https://www.googleapis.com/drive/v3/files", N = { html: {}, zip: {}, xlsx: {}, ods: {}, csv: { singleWorksheet: true }, tsv: { singleWorksheet: true }, pdf: { singleWorksheet: true } };
function ee(s2) {
  if ("getRequestHeaders" in s2)
    return _.GOOGLE_AUTH_CLIENT;
  if ("token" in s2)
    return _.RAW_ACCESS_TOKEN;
  if ("apiKey" in s2)
    return _.API_KEY;
  throw new Error("Invalid auth");
}
async function U(s2) {
  if ("getRequestHeaders" in s2)
    return { headers: await s2.getRequestHeaders() };
  if ("apiKey" in s2)
    return { params: { key: s2.apiKey } };
  if ("token" in s2)
    return { headers: { Authorization: `Bearer ${s2.token}` } };
  throw new Error("Invalid auth");
}
class C {
  constructor(e, t) {
    this._rawProperties = null, this._spreadsheetUrl = null, this._deleted = false, this.spreadsheetId = e, this.auth = t, this._rawSheets = {}, this._spreadsheetUrl = null, this.sheetsApi = axios.create({ baseURL: `${T}/${e}`, paramsSerializer: S, maxContentLength: 1 / 0, maxBodyLength: 1 / 0 }), this.driveApi = axios.create({ baseURL: `${Q}/${e}`, paramsSerializer: S }), this.sheetsApi.interceptors.request.use(this._setAxiosRequestAuth.bind(this)), this.sheetsApi.interceptors.response.use(this._handleAxiosResponse.bind(this), this._handleAxiosErrors.bind(this)), this.driveApi.interceptors.request.use(this._setAxiosRequestAuth.bind(this)), this.driveApi.interceptors.response.use(this._handleAxiosResponse.bind(this), this._handleAxiosErrors.bind(this));
  }
  get authMode() {
    return ee(this.auth);
  }
  async _setAxiosRequestAuth(e) {
    const t = await U(this.auth);
    return u(t.headers, (r, a) => {
      e.headers.set(a, r);
    }), e.params = { ...e.params, ...t.params }, e;
  }
  async _handleAxiosResponse(e) {
    return e;
  }
  async _handleAxiosErrors(e) {
    const t = e.response?.data;
    if (t) {
      if (!t.error)
        throw e;
      const { code: r, message: a } = t.error;
      throw e.message = `Google API error - [${r}] ${a}`, e;
    }
    throw p(e, "response.status") === 403 && "apiKey" in this.auth ? new Error("Sheet is private. Use authentication or make public. (see https://github.com/theoephraim/node-google-spreadsheet#a-note-on-authentication for details)") : e;
  }
  async _makeSingleUpdateRequest(e, t) {
    const r = await this.sheetsApi.post(":batchUpdate", { requests: [{ [e]: t }], includeSpreadsheetInResponse: true });
    return this._updateRawProperties(r.data.updatedSpreadsheet.properties), u(r.data.updatedSpreadsheet.sheets, (a) => this._updateOrCreateSheet(a)), r.data.replies[0][e];
  }
  async _makeBatchUpdateRequest(e, t) {
    const r = await this.sheetsApi.post(":batchUpdate", { requests: e, includeSpreadsheetInResponse: true, ...t && { responseIncludeGridData: true, ...t !== "*" && { responseRanges: t } } });
    this._updateRawProperties(r.data.updatedSpreadsheet.properties), u(r.data.updatedSpreadsheet.sheets, (a) => this._updateOrCreateSheet(a));
  }
  _ensureInfoLoaded() {
    if (!this._rawProperties)
      throw new Error("You must call `doc.loadInfo()` before accessing this property");
  }
  _updateRawProperties(e) {
    this._rawProperties = e;
  }
  _updateOrCreateSheet(e) {
    const { properties: t, data: r } = e, { sheetId: a } = t;
    this._rawSheets[a] ? this._rawSheets[a].updateRawData(t, r) : this._rawSheets[a] = new $(this, t, r);
  }
  _getProp(e) {
    return this._ensureInfoLoaded(), this._rawProperties[e];
  }
  get title() {
    return this._getProp("title");
  }
  get locale() {
    return this._getProp("locale");
  }
  get timeZone() {
    return this._getProp("timeZone");
  }
  get autoRecalc() {
    return this._getProp("autoRecalc");
  }
  get defaultFormat() {
    return this._getProp("defaultFormat");
  }
  get spreadsheetTheme() {
    return this._getProp("spreadsheetTheme");
  }
  get iterativeCalculationSettings() {
    return this._getProp("iterativeCalculationSettings");
  }
  async updateProperties(e) {
    await this._makeSingleUpdateRequest("updateSpreadsheetProperties", { properties: e, fields: v(e) });
  }
  async loadInfo(e = false) {
    const t = await this.sheetsApi.get("/", { params: { ...e && { includeGridData: true } } });
    this._spreadsheetUrl = t.data.spreadsheetUrl, this._rawProperties = t.data.properties, u(t.data.sheets, (r) => this._updateOrCreateSheet(r));
  }
  resetLocalCache() {
    this._rawProperties = null, this._rawSheets = {};
  }
  get sheetCount() {
    return this._ensureInfoLoaded(), k(this._rawSheets).length;
  }
  get sheetsById() {
    return this._ensureInfoLoaded(), this._rawSheets;
  }
  get sheetsByIndex() {
    return this._ensureInfoLoaded(), Y(this._rawSheets, "index");
  }
  get sheetsByTitle() {
    return this._ensureInfoLoaded(), G(this._rawSheets, "title");
  }
  async addSheet(e = {}) {
    const t = (await this._makeSingleUpdateRequest("addSheet", { properties: z(e, "headerValues", "headerRowIndex") })).properties.sheetId, r = this.sheetsById[t];
    return e.headerValues && await r.setHeaderRow(e.headerValues, e.headerRowIndex), r;
  }
  async deleteSheet(e) {
    await this._makeSingleUpdateRequest("deleteSheet", { sheetId: e }), delete this._rawSheets[e];
  }
  async addNamedRange(e, t, r) {
    return this._makeSingleUpdateRequest("addNamedRange", { name: e, namedRangeId: r, range: t });
  }
  async deleteNamedRange(e) {
    return this._makeSingleUpdateRequest("deleteNamedRange", { namedRangeId: e });
  }
  async loadCells(e) {
    const t = this.authMode === _.API_KEY, r = f(e) ? e : [e], a = c(r, (i) => {
      if (w(i))
        return t ? i : { a1Range: i };
      if (y(i)) {
        if (t)
          throw new Error("Only A1 ranges are supported when fetching cells with read-only access (using only an API key)");
        return { gridRange: i };
      }
      throw new Error("Each filter must be an A1 range string or a gridrange object");
    });
    let o;
    this.authMode === _.API_KEY ? o = await this.sheetsApi.get("/", { params: { includeGridData: true, ranges: a } }) : o = await this.sheetsApi.post(":getByDataFilter", { includeGridData: true, dataFilters: a });
    const { sheets: h2 } = o.data;
    u(h2, (i) => {
      this._updateOrCreateSheet(i);
    });
  }
  async _downloadAs(e, t, r) {
    if (!N[e])
      throw new Error(`unsupported export fileType - ${e}`);
    if (N[e].singleWorksheet) {
      if (t === void 0)
        throw new Error(`Must specify worksheetId when exporting as ${e}`);
    } else if (t)
      throw new Error(`Cannot specify worksheetId when exporting as ${e}`);
    if (e === "html" && (e = "zip"), !this._spreadsheetUrl)
      throw new Error("Cannot export sheet that is not fully loaded");
    const a = this._spreadsheetUrl.replace("/edit", "/export");
    return (await this.sheetsApi.get(a, { baseURL: "", params: { id: this.spreadsheetId, format: e, ...t && { gid: t } }, responseType: r ? "stream" : "arraybuffer" })).data;
  }
  async downloadAsZippedHTML(e) {
    return this._downloadAs("html", void 0, e);
  }
  async downloadAsHTML(e) {
    return this._downloadAs("html", void 0, e);
  }
  async downloadAsXLSX(e = false) {
    return this._downloadAs("xlsx", void 0, e);
  }
  async downloadAsODS(e = false) {
    return this._downloadAs("ods", void 0, e);
  }
  async delete() {
    const e = await this.driveApi.delete("");
    return this._deleted = true, e.data;
  }
  async listPermissions() {
    return (await this.driveApi.request({ method: "GET", url: "/permissions", params: { fields: "permissions(id,type,emailAddress,domain,role,displayName,photoLink,deleted)" } })).data.permissions;
  }
  async setPublicAccessLevel(e) {
    const t = await this.listPermissions(), r = j(t, (a) => a.type === "anyone");
    if (e === false) {
      if (!r)
        return;
      await this.driveApi.request({ method: "DELETE", url: `/permissions/${r.id}` });
    } else
      await this.driveApi.request({ method: "POST", url: "/permissions", params: {}, data: { role: e || "viewer", type: "anyone" } });
  }
  async share(e, t) {
    let r, a;
    return e.includes("@") ? r = e : a = e, (await this.driveApi.request({ method: "POST", url: "/permissions", params: { ...t?.emailMessage === false && { sendNotificationEmail: false }, ...w(t?.emailMessage) && { emailMessage: t?.emailMessage }, ...t?.role === "owner" && { transferOwnership: true } }, data: { role: t?.role || "writer", ...r && { type: t?.isGroup ? "group" : "user", emailAddress: r }, ...a && { type: "domain", domain: a } } })).data;
  }
  static async createNewSpreadsheetDocument(e, t) {
    if ("apiKey" in e)
      throw new Error("Cannot use api key only to create a new spreadsheet - it is only usable for read-only access of public docs");
    const r = await U(e), a = await axios.request({ method: "POST", url: T, paramsSerializer: S, ...r, data: { properties: t } }), o = new C(a.data.spreadsheetId, e);
    return o._spreadsheetUrl = a.data.spreadsheetUrl, o._rawProperties = a.data.properties, u(a.data.sheets, (h2) => o._updateOrCreateSheet(h2)), o;
  }
}
const { JWT } = require("google-auth-library");
async function getPages(credentials, sheetID) {
  const document2 = createDocument(credentials, sheetID);
  await document2.loadInfo();
  const pages = Object.entries(document2.sheetsByTitle).map(([key, content]) => {
    return {
      pageName: key,
      pageID: content.sheetId
    };
  });
  return Promise.resolve(pages);
}
async function insertRecord(payload, config) {
  const { credentials, sheetID, pageName } = config;
  const { date, startTime, endTime, durationInS, duration } = payload;
  const document2 = createDocument(credentials, sheetID);
  await document2.loadInfo();
  const sheetPage = document2.sheetsById[+pageName];
  try {
    if (sheetPage.headerValues.length >= 0) {
      console.log("Headers Are set");
    }
  } catch (e) {
    sheetPage.setHeaderRow(
      [
        "Date",
        "Duration on App",
        "Starting Time",
        "Ending Time",
        "Duration Computed",
        "Duration in Seconds"
      ],
      0
    );
    await sheetPage.loadCells("A1:F1");
    for (let index2 = 0; index2 < 6; index2++) {
      const cell = sheetPage.getCell(0, index2);
      Object.entries(cellStyle).forEach(([key, _cellStyle]) => {
        cell[key] = _cellStyle;
      });
    }
    await sheetPage.saveUpdatedCells();
  }
  const rowsCount = (await sheetPage.getRows()).length + 2;
  await sheetPage.addRow(
    [
      date,
      duration,
      startTime,
      endTime,
      `=D${rowsCount} - C${rowsCount}`,
      durationInS
    ],
    { raw: false, insert: true }
  );
  Promise.resolve(true);
}
async function getPageRows(config) {
  const { credentials, sheetID, pageName } = config;
  const document2 = createDocument(credentials, sheetID);
  await document2.loadInfo();
  const sheetPage = document2.sheetsById[+pageName];
  const rows = (await sheetPage.getRows()).map((row, index2) => {
    const _row = row._rawData;
    return {
      id: index2,
      date: _row[0],
      // _row["Date"],
      durationComputed: _row[4],
      // _row["Duration Computed"],
      durationInSeconds: +_row[5],
      // _row["Duration in Seconds"],
      durationOnApp: _row[1],
      // _row["Duration on App"],
      startTime: _row[2],
      // _row["Starting Time"],
      endingTime: _row[3]
      // _row["Ending Time"],
    };
  });
  return Promise.resolve(rows);
}
function createDocument(credentials, sheetID) {
  const auth = new JWT({
    email: credentials.client_email,
    key: credentials.private_key,
    scopes: ["https://www.googleapis.com/auth/spreadsheets"]
  });
  const document2 = new C(sheetID, auth);
  return document2;
}
const cellStyle = {
  backgroundColor: {
    red: 0.23921569,
    green: 0.52156866,
    blue: 0.7764706
  },
  horizontalAlignment: "CENTER",
  verticalAlignment: "MIDDLE",
  textFormat: {
    foregroundColor: {
      red: 1,
      green: 1,
      blue: 1
    },
    fontFamily: "Merriweather",
    fontSize: 13,
    bold: true,
    italic: false,
    strikethrough: false,
    underline: false,
    foregroundColorStyle: {
      rgbColor: {
        red: 1,
        green: 1,
        blue: 1
      }
    }
  }
};
const router = express$1.Router();
router.post("/addRecord", async function(req2, res2) {
  const { date, startTime, endTime, durationInS, duration } = req2.body;
  const { credentials, sheetID, pageName } = req2;
  const payload = {
    date,
    startTime: new Date(startTime).toLocaleTimeString("en-US", {
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    }),
    endTime: new Date(endTime).toLocaleTimeString("en-US", {
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    }),
    durationInS,
    duration
  };
  await insertRecord(payload, { credentials, sheetID, pageName });
  return res2.send({
    success: true
  });
});
router.get("/setView", (req2, res2) => {
  const { view: view2 } = req2.query;
  switch (view2) {
    case "expanded": {
      req2.resizeWindow(true);
      break;
    }
    case "small": {
      req2.resizeWindow(false);
      break;
    }
    default: {
      return res2.send({ ok: false, message: `unknown view ${view2}` });
    }
  }
  return res2.send({ ok: true, message: "View Updated" });
});
router.get("/getPages", async (req2, res2) => {
  const { credentials, sheetID } = req2;
  const pages = await getPages(credentials, sheetID);
  return res2.send({
    pages,
    length: pages.length
  });
});
router.get("/getRows", async (req2, res2) => {
  const { credentials, sheetID, pageName } = req2;
  const rows = await getPageRows({ credentials, sheetID, pageName });
  return res2.send({ rows, length: rows.length });
});
router.get("/exit", async (req2, res2) => {
  res2.send({ code: 200 });
  return req2.electronApp.exit();
});
router.get("/setBadge", async (req2, res2) => {
  req2.electronApp.setBadgeCount("-");
  return res2.send({ code: 200 });
});
router.get("/unsetBadge", async (req2, res2) => {
  req2.electronApp.setBadgeCount(0);
  return res2.send({ code: 200 });
});
const Logo = "data:image/png;base64,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";
let mainWindow;
const smallVersion = {
  height: 128,
  width: 530
};
const expandedVersion = {
  width: 530,
  height: 500
};
const onPort = 8080;
async function handleFileOpen() {
  const { canceled, filePaths } = await electron.dialog.showOpenDialog({});
  if (!canceled) {
    return filePaths[0];
  }
}
function createWindow() {
  const primaryDisplay = electron.screen.getPrimaryDisplay();
  const { width, height } = primaryDisplay.workAreaSize;
  const { width: w2, height: h2 } = smallVersion;
  mainWindow = new electron.BrowserWindow({
    width: w2,
    height: h2,
    title: "Shiftify - Time Tracker",
    x: width - w2,
    y: height - h2 + 25,
    transparent: false,
    roundedCorners: true,
    resizable: true,
    icon: path__namespace.join(__dirname, "../../app-assets/logo-main.png"),
    webPreferences: {
      preload: path__namespace.join(__dirname, "../preload/preload.js"),
      webSecurity: false,
      nodeIntegration: true
    }
  });
  const port = process.env.NODE_ENV !== "production" ? 5173 : onPort;
  mainWindow.loadURL(`http://localhost:${port}`);
  mainWindow.on("closed", () => mainWindow = null);
}
function resizeWindow(expand = false) {
  const primaryDisplay = electron.screen.getPrimaryDisplay();
  const { width, height } = primaryDisplay.workAreaSize;
  const [x2, y2] = mainWindow.getPosition();
  const [_w, _h] = mainWindow.getSize();
  const { width: w2, height: h2 } = expand ? expandedVersion : smallVersion;
  if (_w === w2 && _h === h2) {
    return;
  }
  mainWindow.setSize(w2, h2);
  if (x2 + w2 > width || y2 + h2 > height) {
    mainWindow.setPosition(width - w2, height - h2 + 25);
  }
  if (!expand) {
    mainWindow.setPosition(width - w2, height - h2 + 25);
  }
}
electron.app.whenReady().then(() => {
  path__namespace.join(__dirname, "./app-assets/logo-main-bg.png");
  const dockIcon = electron.nativeImage.createFromDataURL(Logo);
  electron.app.dock.setIcon(dockIcon);
  electron.ipcMain.handle("dialog:openFile", handleFileOpen);
  createWindow();
});
electron.app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    electron.app.quit();
  }
});
electron.app.on("activate", () => {
  if (mainWindow == null) {
    createWindow();
  }
});
const application = express$1();
application.use(express$1.json());
application.use(extractBasics);
application.use((req2, res2, next) => {
  req2.electronApp = electron.app;
  req2.mainWindow = mainWindow;
  req2.resizeWindow = resizeWindow;
  return next();
});
application.use("/api", router);
application.use(express$1.static(path__namespace.join(__dirname, "../renderer")));
application.get("/", (req2, res2) => {
  return res2.sendFile(path__namespace.join(__dirname, "../renderer/index.html"));
});
application.listen(onPort, () => {
  console.log("Listening", onPort);
  console.log("Environment", process.env.NODE_ENV);
});
